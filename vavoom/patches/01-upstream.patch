diff -Nur orig/basev/common/actors/constants.txt mod/basev/common/actors/constants.txt
--- orig/basev/common/actors/constants.txt	2010-09-01 20:26:03.000000000 +0200
+++ mod/basev/common/actors/constants.txt	2022-08-12 08:34:34.000000000 +0200
@@ -92,3 +92,12 @@
 const int CPF_USEAMMO				= 1;
 const int CPF_DAGGER				= 2;
 const int CPF_PULLIN				= 4;
+
+// Render Style constants
+const int STYLE_None				= 0;	// Do not draw
+const int STYLE_Normal				= 1;	// Normal; just copy the image to the screen
+const int STYLE_Fuzzy				= 2;	// Draw silhouette using "fuzz" effect
+const int STYLE_SoulTrans			= 3;	// Draw translucent with amount in r_transsouls
+const int STYLE_OptFuzzy			= 4;	// Draw as fuzzy or translucent, based on user preference
+const int STYLE_Translucent			= 64;	// Draw translucent
+const int STYLE_Add				= 65;	// Draw additive
diff -Nur orig/basev/common/actors/doom/doomartifacts.txt mod/basev/common/actors/doom/doomartifacts.txt
--- orig/basev/common/actors/doom/doomartifacts.txt	2008-03-09 10:20:06.000000000 +0100
+++ mod/basev/common/actors/doom/doomartifacts.txt	2022-08-12 08:34:34.000000000 +0200
@@ -52,6 +52,7 @@
 	Inventory.PickupMessage "$gotinvis"
 	Inventory.MaxAmount 0
 	Powerup.Type Invisibility
+	+VisibilityPulse
 	+CountItem
 	+Inventory.BigPowerup
 	+Inventory.AutoActivate
diff -Nur orig/basev/common/actors/doom/doommisc.txt mod/basev/common/actors/doom/doommisc.txt
--- orig/basev/common/actors/doom/doommisc.txt	2008-03-25 14:48:43.000000000 +0100
+++ mod/basev/common/actors/doom/doommisc.txt	2022-08-12 08:34:34.000000000 +0200
@@ -21,18 +21,11 @@
 	Death:
 		BEXP A 5 Bright
 		BEXP B 5 Bright A_Scream
-		BEXP C 5 Bright
+		BEXP C 5 Bright A_PreExplode(STYLE_Translucent, 0.5)
 		BEXP D 10 Bright A_Explode
 		BEXP E 10 Bright
 		Stop
 	}
-
-	//FIXME I had translucent explosions.
-	//void PreExplode()
-	//{
-	//	RenderStyle = STYLE_Translucent;
-	//	Alpha = 0.5;
-	//}
 }
 
 //------------------------------------------------------------------------------
diff -Nur orig/basev/common/actors/nativeclasses.txt mod/basev/common/actors/nativeclasses.txt
--- orig/basev/common/actors/nativeclasses.txt	2010-09-01 20:26:03.000000000 +0200
+++ mod/basev/common/actors/nativeclasses.txt	2022-08-12 08:34:34.000000000 +0200
@@ -52,12 +52,14 @@
 	action native A_BulletAttack();
 	action native A_MonsterRail();
 	action native A_Explode(optional eval int damage, optional eval int distance,
-		optional evanot bool hurtsource, optional eval bool alert);
+		optional evalnot bool hurtsource, optional eval bool alert,
+		optional eval int dmgdistance, optional eval int nails, optional eval int naildamage);
 	action native A_RadiusThrust(optional eval int force, optional eval int distance,
 		optional evanot bool affectsource);
 	action native A_Detonate();
 	action native A_ThrowGrenade(class<Actor> itemtype, optional eval float spawnheight,
 		optional eval float xyvel, optional eval float zvel, optional evalnot bool useammo);
+	action native A_MonsterRefire(int prob, state jump);
 
 	//
 	//	Freeze death functions
@@ -114,7 +116,7 @@
 	action native A_SpawnItemEx(class<Actor> itemtype, optional eval float xoffs,
 		optional eval float yoffs, optional eval float zoffs, optional eval float xmom,
 		optional eval float ymom, optional eval float zmom, optional eval float angle,
-		optional eval int flags, optional eval int chance);
+		optional eval int flags, optional eval int chance, optional eval bool ApplyTranslation);
 
 	//
 	//	State jumps
@@ -163,6 +165,7 @@
 	action native A_DeQueueCorpse();
 	action native A_ChangeVelocity(float x, float y, float z, int flags);
   	action native A_ScaleVelocity(float scale);
+	action native A_PreExplode(int RenderStyle, float A);
 
 	//
 	//  Misc. Stuff
@@ -258,9 +261,9 @@
 	//	Not documented
 	//
 	action native A_SetGravity(eval float gravity);
-	//action native A_PlayerSkinCheck(state label);
+	action native A_PlayerSkinCheck(state label);
 	action native A_Respawn(optional eval int flags);
-	//action native A_BarrelDestroy();
+	action native A_BarrelDestroy();
 	action native A_Feathers();
 	action native A_ShootGun();
 	action native A_RocketInFlight();
diff -Nur orig/basev/common/actors/strife/strifeweapons.txt mod/basev/common/actors/strife/strifeweapons.txt
--- orig/basev/common/actors/strife/strifeweapons.txt	2008-09-19 19:28:57.000000000 +0200
+++ mod/basev/common/actors/strife/strifeweapons.txt	2022-08-12 08:34:34.000000000 +0200
@@ -531,7 +531,7 @@
 	states
 	{
 	Ready:
-		FLMT AB 3 A_WeaponReady
+		FLMT AAABBB 1 A_WeaponReady
 		Loop
 	Deselect:
 		FLMT A 1 A_Lower
@@ -600,7 +600,7 @@
 	states
 	{
 	Ready:
-		MAUL FGHA 6 A_WeaponReady
+		MAUL FFFFFFGGGGGGHHHHHHAAAAA 1 A_WeaponReady
 		Loop
 	Deselect:
 		MAUL A 1 A_Lower
@@ -637,7 +637,7 @@
 	states
 	{
 	Ready:
-		MAUL IJKL 7 A_WeaponReady
+		MAUL IIIIIIIJJJJJJJKKKKKKKLLLLLLL 1 A_WeaponReady
 		Loop
 	Deselect:
 		MAUL I 1 A_Lower
diff -Nur orig/basev/common/basepak.ls.in mod/basev/common/basepak.ls.in
--- orig/basev/common/basepak.ls.in	2010-11-30 12:36:14.000000000 +0100
+++ mod/basev/common/basepak.ls.in	2022-08-12 08:34:34.000000000 +0200
@@ -188,9 +188,11 @@
 progs/linespec/Pottery1.vc					@CMAKE_SOURCE_DIR@/progs/common/linespec/Pottery1.vc
 progs/linespec/PowerCoupling.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerCoupling.vc
 progs/linespec/PowerDamage.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerDamage.vc
+progs/linespec/PowerDoubleFiringSpeed.vc	@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerDoubleFiringSpeed.vc
 progs/linespec/PowerFlight.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerFlight.vc
 progs/linespec/PowerFrightener.vc			@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerFrightener.vc
 progs/linespec/PowerGhost.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerGhost.vc
+progs/linespec/PowerHighJump.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerHighJump.vc
 progs/linespec/PowerInfiniteAmmo.vc			@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerInfiniteAmmo.vc
 progs/linespec/PowerInvisibility.vc			@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerInvisibility.vc
 progs/linespec/PowerInvulnerable.vc			@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerInvulnerable.vc
@@ -206,6 +208,7 @@
 progs/linespec/PowerSpeed.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerSpeed.vc
 progs/linespec/PowerStrength.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerStrength.vc
 progs/linespec/PowerTargeter.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerTargeter.vc
+progs/linespec/PowerTimeFreeze.vc			@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerTimeFreeze.vc
 progs/linespec/PowerTorch.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerTorch.vc
 progs/linespec/Powerup.vc					@CMAKE_SOURCE_DIR@/progs/common/linespec/Powerup.vc
 progs/linespec/PowerupGiver.vc				@CMAKE_SOURCE_DIR@/progs/common/linespec/PowerupGiver.vc
@@ -324,6 +327,7 @@
 progs/uibase/MenuScreenJoinGame.vc				@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenJoinGame.vc
 progs/uibase/MenuScreenLoadGame.vc				@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenLoadGame.vc
 progs/uibase/MenuScreenMasterList.vc			@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenMasterList.vc
+progs/uibase/MenuScreenMODOptions.vc			@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenMODOptions.vc
 progs/uibase/MenuScreenMouseOptions.vc			@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenMouseOptions.vc
 progs/uibase/MenuScreenSaveGame.vc				@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenSaveGame.vc
 progs/uibase/MenuScreenScreenResolution.vc		@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenScreenResolution.vc
@@ -331,6 +335,7 @@
 progs/uibase/MenuScreenSkill.vc					@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenSkill.vc
 progs/uibase/MenuScreenSList.vc					@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenSList.vc
 progs/uibase/MenuScreenSoundOptions.vc			@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenSoundOptions.vc
+progs/uibase/MenuScreenSpecialControls.vc		@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenSpecialControls.vc
 progs/uibase/MenuScreenVideoOptions.vc			@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuScreenVideoOptions.vc
 progs/uibase/MenuSelector_Big.vc				@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuSelector_Big.vc
 progs/uibase/MenuSelector_SmallLeft.vc			@CMAKE_SOURCE_DIR@/progs/common/uibase/MenuSelector_SmallLeft.vc
diff -Nur orig/basev/common/fxdefs/doom/decorations.txt mod/basev/common/fxdefs/doom/decorations.txt
--- orig/basev/common/fxdefs/doom/decorations.txt	2008-03-10 14:28:20.000000000 +0100
+++ mod/basev/common/fxdefs/doom/decorations.txt	2022-08-12 08:34:34.000000000 +0200
@@ -3,7 +3,7 @@
 {
 	colour 1 0 0
 	radius 160
-	offset 0 0 16
+	offset 0 0 35
 }
 
 class ShortRedTorch
@@ -17,7 +17,7 @@
 {
 	colour 0 1 0
 	radius 160
-	offset 0 0 16
+	offset 0 0 35
 }
 
 class ShortGreenTorch
@@ -31,7 +31,7 @@
 {
 	colour 0 0 1
 	radius 160
-	offset 0 0 16
+	offset 0 0 35
 }
 
 class ShortBlueTorch
@@ -45,7 +45,7 @@
 {
 	colour 1 0 0
 	radius 160
-	offset 0 0 32
+	offset 0 0 55
 }
 
 class RedTorch
@@ -59,7 +59,7 @@
 {
 	colour 0 1 0
 	radius 160
-	offset 0 0 32
+	offset 0 0 55
 }
 
 class GreenTorch
@@ -73,7 +73,7 @@
 {
 	colour 0 0 1
 	radius 160
-	offset 0 0 32
+	offset 0 0 55
 }
 
 class BlueTorch
@@ -87,7 +87,7 @@
 {
 	colour 1 1 1
 	radius 160
-	offset 0 0 32
+	offset 0 0 40
 }
 
 class Column
@@ -129,7 +129,7 @@
 {
 	colour 1 1 0
 	radius 140
-	offset 0 0 24
+	offset 0 0 16
 }
 
 class BurningBarrel
@@ -156,7 +156,7 @@
 {
 	colour 1 0.5 0.3
 	radius 140
-	offset 0 0 32
+	offset 0 0 40
 }
 
 class HeadCandles
@@ -170,7 +170,7 @@
 {
 	colour 1 1 0.5
 	radius 128
-	offset 0 0 32
+	offset 0 0 48
 }
 
 class Candelabra
@@ -184,7 +184,7 @@
 {
 	colour 1 0.5 0.1
 	radius 140
-	offset 0 0 32
+	offset 0 0 40
 }
 
 class FloatingSkull
@@ -198,7 +198,7 @@
 {
 	colour 1 1 0.5
 	radius 128
-	offset 0 0 32
+	offset 0 0 46
 }
 
 class EvilEye
diff -Nur orig/basev/common/fxdefs/doom/pickups.txt mod/basev/common/fxdefs/doom/pickups.txt
--- orig/basev/common/fxdefs/doom/pickups.txt	2008-02-16 14:25:45.000000000 +0100
+++ mod/basev/common/fxdefs/doom/pickups.txt	2022-08-12 08:34:34.000000000 +0200
@@ -3,6 +3,7 @@
 {
 	colour 0 0 0.7
 	radius 86
+	offset 0 0 1
 }
 
 class HealthBonus
@@ -15,6 +16,7 @@
 {
 	colour 0 1 0
 	radius 86
+	offset 0 0 1
 }
 
 class GreenArmor
@@ -27,6 +29,7 @@
 {
 	colour 0 0 1
 	radius 86
+	offset 0 0 1
 }
 
 class BlueArmor
@@ -39,6 +42,7 @@
 {
 	colour 0.2 0.4 0.2
 	radius 86
+	offset 0 0 1
 }
 
 class ArmorBonus
@@ -51,6 +55,7 @@
 {
 	colour 0 0 1
 	radius 86
+	offset 0 0 1
 }
 
 class Soulsphere
@@ -63,6 +68,7 @@
 {
 	colour 0.65 0 0
 	radius 86
+	offset 0 0 1
 }
 
 class BlurSphere
@@ -75,6 +81,7 @@
 {
 	colour 0 0.7 0
 	radius 86
+	offset 0 0 1
 }
 
 class InvulnerabilitySphere
@@ -87,6 +94,7 @@
 {
 	colour 0.55 0.45 0.35
 	radius 86
+	offset 0 0 1
 }
 
 class Megasphere
diff -Nur orig/basev/common/fxdefs/heretic/decorations.txt mod/basev/common/fxdefs/heretic/decorations.txt
--- orig/basev/common/fxdefs/heretic/decorations.txt	2008-02-21 22:02:41.000000000 +0100
+++ mod/basev/common/fxdefs/heretic/decorations.txt	2022-08-12 08:34:34.000000000 +0200
@@ -3,7 +3,7 @@
 {
 	colour 1 1 0
 	radius 118
-	offset 0 0 68
+	offset 0 0 69
 }
 
 class KeyGizmoYellow
@@ -17,7 +17,7 @@
 {
 	colour 0 1 0
 	radius 118
-	offset 0 0 68
+	offset 0 0 69
 }
 
 class KeyGizmoGreen
@@ -31,7 +31,7 @@
 {
 	colour 0 0 1
 	radius 118
-	offset 0 0 68
+	offset 0 0 69
 }
 
 class KeyGizmoBlue
@@ -73,7 +73,7 @@
 {
 	colour 1 1 0.5
 	radius 160
-	offset 0 0 52
+	offset 0 0 56
 }
 
 class Chandelier
@@ -87,7 +87,7 @@
 {
 	colour 1 1 0
 	radius 160
-	offset 0 0 52
+	offset 0 0 55
 }
 
 class FireBrazier
diff -Nur orig/basev/common/fxdefs/heretic/pickups.txt mod/basev/common/fxdefs/heretic/pickups.txt
--- orig/basev/common/fxdefs/heretic/pickups.txt	2008-02-17 17:28:01.000000000 +0100
+++ mod/basev/common/fxdefs/heretic/pickups.txt	2022-08-12 08:34:34.000000000 +0200
@@ -3,6 +3,7 @@
 {
 	colour 1 1 0
 	radius 66
+	offset 0 0 1
 }
 
 class KeyYellow
@@ -15,6 +16,7 @@
 {
 	colour 0 1 0
 	radius 66
+	offset 0 0 1
 }
 
 class KeyGreen
@@ -27,6 +29,7 @@
 {
 	colour 0 0 1
 	radius 66
+	offset 0 0 1
 }
 
 class KeyBlue
@@ -39,6 +42,7 @@
 {
 	colour 0.4 0.5 0.4
 	radius 86
+	offset 0 0 1
 }
 
 class ArtiInvisibility
diff -Nur orig/basev/common/fxdefs/hexen/decorations.txt mod/basev/common/fxdefs/hexen/decorations.txt
--- orig/basev/common/fxdefs/hexen/decorations.txt	2008-02-21 20:33:00.000000000 +0100
+++ mod/basev/common/fxdefs/hexen/decorations.txt	2022-08-12 08:34:34.000000000 +0200
@@ -72,7 +72,7 @@
 {
 	colour 1 1 0.5
 	radius 128
-	offset 0 0 52
+	offset 0 0 56
 }
 
 class ZChandelier
@@ -86,7 +86,7 @@
 {
 	colour 1 1 0
 	radius 160
-	offset 0 0 48
+	offset 0 0 55
 }
 
 class BrassTorch
@@ -113,7 +113,7 @@
 {
 	colour 0.4 0.4 1
 	radius 128
-	offset 0 0 8
+	offset 0 0 10
 }
 
 class ZBlueCandle
@@ -127,7 +127,7 @@
 {
 	colour 1 1 0
 	radius 160
-	offset 0 0 64
+	offset 0 0 66
 }
 
 class ZTwinedTorch
@@ -160,7 +160,7 @@
 {
 	colour 1 1 0
 	radius 128
-	offset 0 0 48
+	offset 0 0 38
 }
 
 class ZWallTorch
@@ -224,7 +224,7 @@
 {
 	colour 1 1 0
 	radius 170
-	offset 0 0 72
+	offset 0 5 74
 }
 
 class ZFireBull
@@ -257,7 +257,7 @@
 {
 	colour 1 1 0
 	radius 128
-	offset 0 0 64
+	offset 0 0 8
 }
 
 class FlameSmall
@@ -277,7 +277,7 @@
 {
 	colour 1 1 0
 	radius 128
-	offset 0 0 0
+	offset 0 0 16
 }
 
 class FlameLarge
diff -Nur orig/basev/common/fxdefs/hexen/pickups.txt mod/basev/common/fxdefs/hexen/pickups.txt
--- orig/basev/common/fxdefs/hexen/pickups.txt	2008-02-17 17:34:17.000000000 +0100
+++ mod/basev/common/fxdefs/hexen/pickups.txt	2022-08-12 08:34:34.000000000 +0200
@@ -3,6 +3,7 @@
 {
 	colour 0.3 0.3 0.75
 	radius 100
+	offset 0 0 1
 }
 
 class Mana1
@@ -15,6 +16,7 @@
 {
 	colour 0.2 0.4 0.15
 	radius 100
+	offset 0 0 1
 }
 
 class Mana2
@@ -27,6 +29,7 @@
 {
 	colour 1 0 0
 	radius 100
+	offset 0 0 1
 }
 
 class Mana3
@@ -39,6 +42,7 @@
 {
 	colour 0.3 0.3 0.75
 	radius 86
+	offset 0 0 1
 }
 
 class ArtiSpeedBoots
@@ -51,6 +55,7 @@
 {
 	colour 0.6 0 0.7
 	radius 86
+	offset 0 0 1
 }
 
 class ArtiBoostArmor
@@ -63,6 +68,7 @@
 {
 	colour 0.3 0.3 0.75
 	radius 86
+	offset 0 0 1
 }
 
 class MWeapLightning
@@ -75,6 +81,7 @@
 {
 	colour 0.2 0.4 0.2
 	radius 86
+	offset 0 0 1
 }
 
 class FWeaponPiece1
@@ -97,6 +104,7 @@
 {
 	colour 0.3 0.3 0.75
 	radius 86
+	offset 0 0 1
 }
 
 class CWeaponPiece1
@@ -119,6 +127,7 @@
 {
 	colour 1 0 0
 	radius 86
+	offset 0 0 1
 }
 
 class MWeaponPiece1
diff -Nur orig/basev/common/fxdefs/raven/pickups.txt mod/basev/common/fxdefs/raven/pickups.txt
--- orig/basev/common/fxdefs/raven/pickups.txt	2008-02-17 17:28:00.000000000 +0100
+++ mod/basev/common/fxdefs/raven/pickups.txt	2022-08-12 08:34:34.000000000 +0200
@@ -3,6 +3,7 @@
 {
 	colour 1 0.5 0
 	radius 86
+	offset 0 0 1
 }
 
 class ArtiTorch
@@ -15,6 +16,7 @@
 {
 	colour 1 1 1
 	radius 86
+	offset 0 0 1
 }
 
 class ArtiInvulnerability
diff -Nur orig/basev/common/glshaders/draw_automap.fs mod/basev/common/glshaders/draw_automap.fs
--- orig/basev/common/glshaders/draw_automap.fs	2010-05-31 23:23:05.000000000 +0200
+++ mod/basev/common/glshaders/draw_automap.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,8 +1,8 @@
 #version 110
+
+varying vec4 Colour;
 
-varying vec4		Colour;
-
-void main()
-{
+void main ()
+{
 	gl_FragColor = Colour;
 }
diff -Nur orig/basev/common/glshaders/draw_automap.vs mod/basev/common/glshaders/draw_automap.vs
--- orig/basev/common/glshaders/draw_automap.vs	2010-05-31 23:23:42.000000000 +0200
+++ mod/basev/common/glshaders/draw_automap.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,12 +1,12 @@
 #version 110
-
-varying vec4		Colour;
-
-void main()
-{
+
+varying vec4 Colour;
+
+void main ()
+{
 	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
+
 	//	Pass colour.
 	Colour = gl_Color;
 }
diff -Nur orig/basev/common/glshaders/draw_fixed_col.fs mod/basev/common/glshaders/draw_fixed_col.fs
--- orig/basev/common/glshaders/draw_fixed_col.fs	2010-05-31 23:23:46.000000000 +0200
+++ mod/basev/common/glshaders/draw_fixed_col.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,8 +1,8 @@
 #version 110
-
-uniform vec4		Colour;
-
-void main()
-{
-	gl_FragColor = Colour;
-}
+
+uniform vec4 Colour;
+
+void main ()
+{
+	gl_FragColor = Colour;
+}
diff -Nur orig/basev/common/glshaders/draw_fixed_col.vs mod/basev/common/glshaders/draw_fixed_col.vs
--- orig/basev/common/glshaders/draw_fixed_col.vs	2010-05-31 23:23:50.000000000 +0200
+++ mod/basev/common/glshaders/draw_fixed_col.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,7 +1,7 @@
-#version 110
+#version 110
 
-void main()
-{
+void main ()
+{
 	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 }
diff -Nur orig/basev/common/glshaders/draw_shadow.fs mod/basev/common/glshaders/draw_shadow.fs
--- orig/basev/common/glshaders/draw_shadow.fs	2010-05-31 23:23:53.000000000 +0200
+++ mod/basev/common/glshaders/draw_shadow.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,12 +1,23 @@
 #version 110
+
+uniform sampler2D Texture;
+uniform float Alpha;
+
+varying vec2 TextureCoordinate;
+
+void main ()
+{
+	float Transp;
 
-uniform sampler2D	Texture;
-uniform float		Alpha;
+	Transp = clamp (((
+		(texture2D (Texture, TextureCoordinate).w * Alpha)
+		- 0.1) / 0.9), 0.0, 1.0);
 
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	vec4 TexColour = texture2D(Texture, TextureCoordinate);
-	gl_FragColor = vec4(0.0, 0.0, 0.0, TexColour.a * Alpha);
+	vec4 FinalColour;
+	FinalColour.xyz = vec3(0.0, 0.0, 0.0);
+	FinalColour.w = (Transp * (Transp * (3.0 - 
+		(2.0 * Transp)
+		)));
+
+	gl_FragColor = FinalColour;
 }
diff -Nur orig/basev/common/glshaders/draw_simple.fs mod/basev/common/glshaders/draw_simple.fs
--- orig/basev/common/glshaders/draw_simple.fs	2010-05-31 23:23:57.000000000 +0200
+++ mod/basev/common/glshaders/draw_simple.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,17 +1,29 @@
 #version 110
+
+uniform sampler2D Texture;
+uniform float Alpha;
+
+varying vec2 TextureCoordinate;
 
-uniform sampler2D	Texture;
-uniform float		Alpha;
-
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	vec4 FinalColour = texture2D(Texture, TextureCoordinate);
-	if (FinalColour.a < 0.666)
+void main ()
+{
+	vec4 FinalColour;
+	vec4 TexCol;
+
+	TexCol = texture2D (Texture, TextureCoordinate);
+	FinalColour.xyz = TexCol.xyz;
+
+	if ((TexCol.w < 0.4))
 	{
 		discard;
-	}
-	FinalColour.a *= Alpha;
-	gl_FragColor = FinalColour;
+	};
+	float Transp;
+
+	Transp = clamp (((Alpha - 0.4) / 0.6), 0.0, 1.0);
+
+	FinalColour.w = (TexCol.w * (Transp * (Transp * 
+		(3.0 - (2.0 * Transp))
+		)));
+
+	gl_FragColor = FinalColour;
 }
diff -Nur orig/basev/common/glshaders/draw_simple.vs mod/basev/common/glshaders/draw_simple.vs
--- orig/basev/common/glshaders/draw_simple.vs	2010-05-31 23:24:01.000000000 +0200
+++ mod/basev/common/glshaders/draw_simple.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,12 +1,12 @@
 #version 110
 
-varying vec2		TextureCoordinate;
-
-void main()
-{
+varying vec2 TextureCoordinate;
+
+void main ()
+{
 	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 
 	//	Pass texture coordinates.
-	TextureCoordinate = vec2(gl_MultiTexCoord0);
+	TextureCoordinate = gl_MultiTexCoord0.xy;
 }
diff -Nur orig/basev/common/glshaders/shadows_ambient.fs mod/basev/common/glshaders/shadows_ambient.fs
--- orig/basev/common/glshaders/shadows_ambient.fs	2010-05-31 23:24:03.000000000 +0200
+++ mod/basev/common/glshaders/shadows_ambient.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,8 +1,20 @@
 #version 110
+
+uniform vec4 Light;
+uniform sampler2D Texture;
+
+varying vec2 TextureCoordinate;
+
+void main ()
+{
+	vec4 TexColour;
 
-uniform vec4		Light;
+	TexColour = texture2D (Texture, TextureCoordinate);
 
-void main()
-{
+	if ((TexColour.w <= 0.1))
+	{
+		discard;
+	};
+
 	gl_FragColor = Light;
-}
+}
diff -Nur orig/basev/common/glshaders/shadows_ambient.vs mod/basev/common/glshaders/shadows_ambient.vs
--- orig/basev/common/glshaders/shadows_ambient.vs	2010-05-31 23:24:06.000000000 +0200
+++ mod/basev/common/glshaders/shadows_ambient.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,7 +1,24 @@
 #version 110
+
+uniform vec3 SAxis;
+uniform vec3 TAxis;
+uniform float SOffs;
+uniform float TOffs;
+uniform float TexIW;
+uniform float TexIH;
+
+varying vec2 TextureCoordinate;
 
-void main()
-{
-	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-}
+void main ()
+{
+	//	Transforming The Vertex
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
+
+	//	Calculate texture coordinates.
+	vec2 ts;
+
+	ts.x = ((dot (gl_Vertex.xyz, SAxis) + SOffs) * TexIW);
+	ts.y = ((dot (gl_Vertex.xyz, TAxis) + TOffs) * TexIH);
+
+	TextureCoordinate = ts;
+}
diff -Nur orig/basev/common/glshaders/shadows_fog.fs mod/basev/common/glshaders/shadows_fog.fs
--- orig/basev/common/glshaders/shadows_fog.fs	2010-05-31 23:24:10.000000000 +0200
+++ mod/basev/common/glshaders/shadows_fog.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,28 +1,51 @@
 #version 110
 
-uniform int			FogType;
-uniform vec4		FogColour;
-uniform float		FogDensity;
-uniform float		FogStart;
-uniform float		FogEnd;
+uniform int FogType;
+uniform vec4 FogColour;
+uniform float FogDensity;
+uniform float FogStart;
+uniform float FogEnd;
 
-void main()
+void main ()
 {
-	float z = gl_FragCoord.z / gl_FragCoord.w;
-	const float LOG2 = 1.442695;
 	float FogFactor;
-	if (FogType == 3)
-	{
-		FogFactor = exp2(-FogDensity * FogDensity * z * z * LOG2);
-	}
-	else if (FogType == 2)
+	float z;
+
+	z = (gl_FragCoord.z / gl_FragCoord.w);
+
+	if ((FogType == 3))
 	{
-		FogFactor = exp2(-FogDensity * z * LOG2);
+		FogFactor = exp2(((
+			((-(FogDensity) * FogDensity) * z)
+			* z) * 1.442695));
 	}
 	else
 	{
-		FogFactor = (FogEnd - z) / (FogEnd - FogStart);
-	}
-	FogFactor = clamp(1.0 - FogFactor, 0.0, 1.0);
-	gl_FragColor = vec4(FogColour.xyz, FogFactor);
+		if ((FogType == 2))
+		{
+			FogFactor = exp2(((
+				-(FogDensity)
+				* z) * 1.442695));
+		}
+		else
+		{
+			FogFactor = ((FogEnd - z) / (FogEnd - FogStart));
+		};
+	};
+	float ClampFogFactor;
+
+	ClampFogFactor = clamp ((1.0 - FogFactor), 0.0, 1.0);
+	FogFactor = ClampFogFactor;
+
+	float SmoothFactor;
+
+	SmoothFactor = clamp (((ClampFogFactor - 0.1) / 0.9), 0.0, 1.0);
+	vec4 FinalFogColour;
+
+	FinalFogColour.xyz = FogColour.xyz;
+	FinalFogColour.w = (SmoothFactor * (SmoothFactor * (3.0 - 
+					(2.0 * SmoothFactor)
+					)));
+
+	gl_FragColor = FinalFogColour;
 }
diff -Nur orig/basev/common/glshaders/shadows_fog.vs mod/basev/common/glshaders/shadows_fog.vs
--- orig/basev/common/glshaders/shadows_fog.vs	2010-05-31 23:24:14.000000000 +0200
+++ mod/basev/common/glshaders/shadows_fog.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,7 +1,8 @@
 #version 110
 
-void main()
+void main ()
 {
 	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 }
+
diff -Nur orig/basev/common/glshaders/shadows_light.fs mod/basev/common/glshaders/shadows_light.fs
--- orig/basev/common/glshaders/shadows_light.fs	2010-05-31 23:24:17.000000000 +0200
+++ mod/basev/common/glshaders/shadows_light.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,30 +1,78 @@
-#version 110
+#version 110
 
-uniform vec3		LightColour;
-uniform float		LightRadius;
+uniform vec3 LightColour;
+uniform float LightRadius;
+uniform sampler2D Texture;
 
-varying vec3		Normal;
-varying float		Dist;
-varying vec3		VertToLight;
-
-void main()
-{
-	float DistToLight = length(VertToLight);
-	if (DistToLight >= LightRadius)
-	{
-		discard;
-	}
-	vec3 Incoming = normalize(VertToLight);
-	float Angle = dot(Incoming, Normal);
-	Angle = 0.5 + 0.5 * Angle;
-	//float Add = LightRadius - Dist;
-	float Add = LightRadius - DistToLight;
-	Add *= Angle;
-	//if (Add <= 0.0)
-	//{
-	//	discard;
-	//}
-	Add = clamp(Add / 255.0, 0.0, 1.0);
+varying vec3 Normal;
+varying vec3 VertToLight;
+varying vec3 VertToView;
+varying float Dist;
+varying float VDist;
+varying vec2 TextureCoordinate;
+
+void main ()
+{
+	float Add_1;
+	float DistToView;
+
+	DistToView = sqrt(dot (VertToView, VertToView));
+
+	if ((DistToView <= 0.0))
+	{
+		discard;
+	};
+	if ((VDist <= 0.0))
+	{
+		discard;
+	};
+
+	if ((Dist <= 0.0))
+	{
+		discard;
+	};
+	float DistToLight;
+
+	DistToLight = sqrt(dot (VertToLight, VertToLight));
+	if ((DistToLight <= 0.0))
+	{
+		discard;
+	};
+
+	if ((DistToLight > LightRadius))
+	{
+		discard;
+	};
+	vec4 TexColour;
+
+	TexColour = texture2D (Texture, TextureCoordinate);
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
+	Add_1 = ((LightRadius - DistToLight) * (0.5 + (0.5 * 
+			dot (normalize(VertToLight), Normal)
+			)));
+
+	if ((Add_1 <= 0.0))
+	{
+		discard;
+	};
+	float ClampAdd;
+
+	ClampAdd = clamp ((Add_1 / 255.0), 0.0, 1.0);
+	Add_1 = ClampAdd;
+	float Transp;
+
+	Transp = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+	vec4 FinalColour;
+
+	FinalColour.xyz = LightColour;
+	FinalColour.w = (ClampAdd * (Transp * (Transp * 
+					(3.0 - (2.0 * Transp))
+					)));
+
+	gl_FragColor = FinalColour;
+}
 
-	gl_FragColor = vec4(LightColour.r, LightColour.g, LightColour.b, Add);
-}
diff -Nur orig/basev/common/glshaders/shadows_light.vs mod/basev/common/glshaders/shadows_light.vs
--- orig/basev/common/glshaders/shadows_light.vs	2010-05-31 23:24:21.000000000 +0200
+++ mod/basev/common/glshaders/shadows_light.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,20 +1,46 @@
 #version 110
 
-uniform vec3		LightPos;
-uniform float		LightRadius;
+uniform vec3 ViewOrigin;
+uniform vec3 LightPos;
+uniform vec3 SAxis;
+uniform vec3 TAxis;
+uniform float SOffs;
+uniform float TOffs;
+uniform float TexIW;
+uniform float TexIH;
+
+attribute vec3 SurfNormal;
+attribute float SurfDist;
 
-attribute vec3		SurfNormal;
-attribute float		SurfDist;
+varying vec3 Normal;
+varying vec3 VertToLight;
+varying vec3 VertToView;
+varying float Dist;
+varying float VDist;
+varying vec2 TextureCoordinate;
+
+void main ()
+{
+	//	Transforming The Vertex
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 
-varying vec3		Normal;
-varying float		Dist;
-varying vec3		VertToLight;
-
-void main()
-{
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-
-	Normal = SurfNormal; 
-	Dist = dot(LightPos, SurfNormal) - SurfDist;
-	VertToLight.xyz = LightPos.xyz - gl_Vertex.xyz;
-}
+	//	Calculate texture coordinates.
+	vec2 ts;
+
+	ts.x = ((dot (gl_Vertex.xyz, SAxis) + SOffs) * TexIW);
+	ts.y = ((dot (gl_Vertex.xyz, TAxis) + TOffs) * TexIH);
+	
+	TextureCoordinate = ts;
+
+	Normal = SurfNormal;
+	float LightDist;
+	float ViewDist;
+
+	LightDist = dot (LightPos, SurfNormal);
+	ViewDist = dot(ViewOrigin, SurfNormal);
+	Dist = (LightDist - SurfDist);
+	VDist = (ViewDist - SurfDist);
+
+	VertToLight = (LightPos - gl_Vertex.xyz);
+	VertToView = (ViewOrigin - gl_Vertex.xyz);
+}
diff -Nur orig/basev/common/glshaders/shadows_model_ambient.fs mod/basev/common/glshaders/shadows_model_ambient.fs
--- orig/basev/common/glshaders/shadows_model_ambient.fs	2010-05-31 23:24:31.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_ambient.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,16 +1,159 @@
 #version 110
 
-uniform sampler2D	Texture;
-uniform vec4		Light;
+uniform vec4 Light;
+uniform sampler2D Texture;
+uniform float InAlpha;
+uniform bool AllowTransparency;
 
-varying vec2		TextureCoordinate;
+varying vec2 TextureCoordinate;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying float Dist;
 
-void main()
+void main ()
 {
-	vec4 TexColour = texture2D(Texture, TextureCoordinate);
-	if (TexColour.a <= 0.666)
+	vec4 FinalColour;
+	float DistVPos;
+
+	DistVPos = sqrt(dot (VPos, VPos));
+
+	if (((Dist > 0.0) && (DistVPos < 0.0)))
 	{
 		discard;
+	};
+	float DistToView;
+
+	DistToView = sqrt(dot (VertToView, VertToView));
+	vec4 TexColour;
+
+	TexColour = texture2D (Texture, TextureCoordinate);
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
+
+	if ((Dist >= 0.0))
+	{
+		if ((DistToView < 0.0))
+		{
+			vec4 DarkColour;
+			float ClampTransp;
+
+			ClampTransp = clamp (((
+			(Light.w * TexColour.w)
+			- 0.1) / 0.9), 0.0, 1.0);
+			DarkColour.xyz = (Light.xyz * 0.75);
+			DarkColour.w = (InAlpha * (ClampTransp * (ClampTransp * 
+			(3.0 - (2.0 * ClampTransp))
+			)));
+
+			if ((AllowTransparency == bool(0)))
+			{
+				if (((InAlpha == 1.0) && (ClampTransp < 0.666)))
+				{
+					discard;
+				};
+			}
+			else
+			{
+				if ((ClampTransp < 0.1))
+				{
+					discard;
+				};
+			};
+			FinalColour = DarkColour;
+		}
+		else
+		{
+			vec4 BrightColour;
+			float ClampTransp;
+
+			ClampTransp = clamp (((
+			(Light.w * TexColour.w)
+			- 0.1) / 0.9), 0.0, 1.0);
+			BrightColour.xyz = Light.xyz;
+			BrightColour.w = (InAlpha * (ClampTransp * (ClampTransp * 
+			(3.0 - (2.0 * ClampTransp))
+			)));
+
+			if ((AllowTransparency == bool(0)))
+			{
+				if (((InAlpha == 1.0) && (ClampTransp < 0.666)))
+				{
+					discard;
+				};
+			}
+			else
+			{
+				if ((ClampTransp < 0.1))
+				{
+					discard;
+				};
+			};
+			FinalColour = BrightColour;
+		};
 	}
-	gl_FragColor = Light;
-}
+	else
+	{
+		if ((DistToView > 0.0))
+		{
+			vec4 DarkColour;
+			float ClampTransp;
+
+			ClampTransp = clamp (((
+			(Light.w * TexColour.w)
+			- 0.1) / 0.9), 0.0, 1.0);
+			DarkColour.xyz = (Light.xyz * 0.75);
+			DarkColour.w = (InAlpha * (ClampTransp * (ClampTransp * 
+			(3.0 - (2.0 * ClampTransp))
+			)));
+
+			if ((AllowTransparency == bool(0)))
+			{
+				if (((InAlpha == 1.0) && (ClampTransp < 0.666)))
+				{
+					discard;
+				};
+			}
+			else
+			{
+				if ((ClampTransp < 0.1))
+				{
+					discard;
+				};
+			};
+			FinalColour = DarkColour;
+		}
+		else
+		{
+			vec4 BrightColour;
+			float ClampTransp;
+
+			ClampTransp = clamp (((
+			(Light.w * TexColour.w)
+			- 0.1) / 0.9), 0.0, 1.0);
+			BrightColour.xyz = Light.xyz;
+			BrightColour.w = (InAlpha * (ClampTransp * (ClampTransp * 
+			(3.0 - (2.0 * ClampTransp))
+			)));
+
+			if ((AllowTransparency == bool(0)))
+			{
+				if (((InAlpha == 1.0) && (ClampTransp < 0.666)))
+				{
+					discard;
+				};
+			}
+			else
+			{
+				if ((ClampTransp < 0.1))
+				{
+					discard;
+				};
+			};
+			FinalColour = BrightColour;
+		};
+	};
+	gl_FragColor = FinalColour;
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_ambient.vs mod/basev/common/glshaders/shadows_model_ambient.vs
--- orig/basev/common/glshaders/shadows_model_ambient.vs	2010-05-31 23:24:35.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_ambient.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,21 +1,34 @@
 #version 110
+uniform mat4 ModelToWorldMat;
+uniform mat3 NormalToWorldMat;
+uniform vec3 ViewOrigin;
+uniform float Inter;
 
-uniform float		Inter;
-uniform mat4		ModelToWorldMat;
+attribute vec4 Vert2;
+attribute vec3 VertNormal;
+attribute vec3 Vert2Normal;
+attribute vec2 TexCoord;
 
-attribute vec4		Vert2;
-attribute vec2		TexCoord;
+varying vec3 Normal;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec2 TextureCoordinate;
+varying float PlaneDist;
+varying float Dist;
 
-varying vec2		TextureCoordinate;
-
-void main()
+void main ()
 {
-	//	Transforming The Vertex
-	vec4 Vert = mix(gl_Vertex, Vert2, Inter);
-	//Vert = ModelToWorldMat * Vert;
-	Vert = Vert * ModelToWorldMat;
-	gl_Position = gl_ModelViewProjectionMatrix * Vert;
+	vec4 Vert;
+
+	Vert = (mix (gl_Vertex, Vert2, Inter) * ModelToWorldMat);
+	gl_Position = (gl_ModelViewProjectionMatrix * Vert);
+	Normal = (NormalToWorldMat * mix (VertNormal, Vert2Normal, Inter));
+	float SurfDist;
 
-	//	Pass texture coordinates.
+	SurfDist = dot (Normal, Vert.xyz);
+	PlaneDist = SurfDist;
+	Dist = (dot (ViewOrigin, Normal) - SurfDist);
+	VertToView = (ViewOrigin - Vert.xyz);
+	VPos = (ViewOrigin - gl_Position.xyz);
 	TextureCoordinate = TexCoord;
-}
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_fog.fs mod/basev/common/glshaders/shadows_model_fog.fs
--- orig/basev/common/glshaders/shadows_model_fog.fs	2010-05-31 23:24:38.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_fog.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,37 +1,152 @@
 #version 110
 
-uniform sampler2D	Texture;
-uniform int			FogType;
-uniform vec4		FogColour;
-uniform float		FogDensity;
-uniform float		FogStart;
-uniform float		FogEnd;
+uniform vec4 FogColour;
+uniform sampler2D Texture;
+uniform float FogDensity;
+uniform float FogStart;
+uniform float FogEnd;
+uniform int FogType;
+uniform bool AllowTransparency;
 
-varying vec2		TextureCoordinate;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec2 TextureCoordinate;
+varying float Dist;
+uniform float InAlpha;
 
-void main()
+void main ()
 {
-	vec4 FinalColour = texture2D(Texture, TextureCoordinate);
-	if (FinalColour.a <= 0.0)
+	float z;
+	float FogFactor;
+	vec4 FinalColour;
+	float DistVPos;
+
+	DistVPos = sqrt(dot (VPos, VPos));
+
+	if ((Dist > 0.0))
 	{
-		discard;
+		if ((DistVPos < 0.0))
+		{
+			discard;
+		};
 	}
+	else
+	{
+		if ((DistVPos > 0.0))
+		{
+			discard;
+		};
+	};
+	float DistToView;
 
-	float z = gl_FragCoord.z / gl_FragCoord.w;
-	const float LOG2 = 1.442695;
-	float FogFactor;
-	if (FogType == 3)
+	DistToView = sqrt(dot (VertToView, VertToView));
+
+	vec4 TexColour;
+
+	TexColour = texture2D (Texture, TextureCoordinate);
+
+	if ((TexColour.w < 0.1))
 	{
-		FogFactor = exp2(-FogDensity * FogDensity * z * z * LOG2);
+		discard;
+	};
+	z = (gl_FragCoord.z / gl_FragCoord.w);
+
+	if ((FogType == 3))
+	{
+		FogFactor = exp2(((
+		  ((-(FogDensity) * FogDensity) * z)
+		 * z) * 1.442695));
 	}
-	else if (FogType == 2)
+	else
 	{
-		FogFactor = exp2(-FogDensity * z * LOG2);
+		if ((FogType == 2))
+		{
+			FogFactor = exp2(((
+			-(FogDensity)
+			* z) * 1.442695));
+		}
+		else
+		{
+			FogFactor = ((FogEnd - z) / (FogEnd - FogStart));
+		};
+	};
+
+	if ((Dist >= 0.0))
+	{
+		if ((DistToView <= 0.0))
+		{
+			vec4 DarkColour;
+
+			FogFactor = (clamp ((1.0 - FogFactor), 0.0, 1.0) * InAlpha);
+			float ClampTrans;
+
+			ClampTrans = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+			DarkColour.xyz = FogColour.xyz;
+			DarkColour.w = ((FogFactor * InAlpha) * (ClampTrans * (ClampTrans * 
+			(3.0 - (2.0 * ClampTrans))
+			)));
+			FinalColour = DarkColour;
+		}
+		else
+		{
+			vec4 BrightColour;
+
+			FogFactor = (clamp ((0.75 - FogFactor), 0.0, 0.75) * InAlpha);
+			float ClampTrans;
+
+			ClampTrans = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+			BrightColour.xyz = (FogColour.xyz * 0.75);
+			BrightColour.w = ((FogFactor * InAlpha) * (ClampTrans * (ClampTrans * 
+			(3.0 - (2.0 * ClampTrans))
+			)));
+			FinalColour = BrightColour;
+		};
 	}
 	else
 	{
-		FogFactor = (FogEnd - z) / (FogEnd - FogStart);
+		if ((DistToView >= 0.0))
+		{
+			vec4 DarkColour;
+
+			FogFactor = (clamp ((1.0 - FogFactor), 0.0, 1.0) * InAlpha);
+			float ClampTrans;
+
+			ClampTrans = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+			DarkColour.xyz = FogColour.xyz;
+			DarkColour.w = ((FogFactor * InAlpha) * (ClampTrans * (ClampTrans * 
+			(3.0 - (2.0 * ClampTrans))
+			)));
+			FinalColour = DarkColour;
+		}
+		else
+		{
+			vec4 BrighColour;
+
+			FogFactor = (clamp ((0.75 - FogFactor), 0.0, 0.75) * InAlpha);
+			float ClampTrans;
+
+			ClampTrans = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+			BrighColour.xyz = (FogColour.xyz * 0.75);
+			BrighColour.w = ((FogFactor * InAlpha) * (ClampTrans * (ClampTrans * 
+			(3.0 - (2.0 * ClampTrans))
+			)));
+			FinalColour = BrighColour;
+		};
+	};
+
+	if ((AllowTransparency == bool(0)))
+	{
+		if (((InAlpha == 1.0) && (FinalColour.w < 0.666)))
+		{
+			discard;
+		};
 	}
-	FogFactor = clamp(1.0 - FogFactor, 0.0, 1.0);
-	gl_FragColor = vec4(FogColour.xyz, FogFactor);
-}
+	else
+	{
+		if ((FinalColour.w < 0.1))
+		{
+			discard;
+		};
+	};
+	gl_FragColor = FinalColour;
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_fog.vs mod/basev/common/glshaders/shadows_model_fog.vs
--- orig/basev/common/glshaders/shadows_model_fog.vs	2010-05-31 23:24:42.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_fog.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,22 +1,36 @@
 #version 110
 
-uniform float		Inter;
-uniform mat4		ModelToWorldMat;
+uniform mat4 ModelToWorldMat;
+uniform mat3 NormalToWorldMat;
+uniform vec3 ViewOrigin;
+uniform float Inter;
 
-attribute vec4		Vert2;
-attribute vec2		TexCoord;
+attribute vec4 Vert2;
+attribute vec3 VertNormal;
+attribute vec3 Vert2Normal;
+attribute vec2 TexCoord;
 
-varying vec2		TextureCoordinate;
+varying vec3 Normal;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec2 TextureCoordinate;
+varying float PlaneDist;
+varying float Dist;
 
-void main()
+void main ()
 {
-	//	Transforming The Vertex
-	vec4 Vert = mix(gl_Vertex, Vert2, Inter);
-	//Vert = ModelToWorldMat * Vert;
-	Vert = Vert * ModelToWorldMat;
+	vec4 Vert;
+
+	Vert.xyz = (mix (gl_Vertex, Vert2, Inter) * ModelToWorldMat).xyz;
 	Vert.w = 1.0;
-	gl_Position = gl_ModelViewProjectionMatrix * Vert;
+	gl_Position = (gl_ModelViewProjectionMatrix * Vert);
+	Normal = (NormalToWorldMat * mix (VertNormal, Vert2Normal, Inter));
+	float SurfDist;
 
-	//	Pass texture coordinates.
+	SurfDist = dot (Normal, Vert.xyz);
+	PlaneDist = SurfDist;
+	Dist = (dot (ViewOrigin, Normal) - SurfDist);
+	VertToView = (ViewOrigin - Vert.xyz);
+	VPos = (ViewOrigin - gl_Position.xyz);
 	TextureCoordinate = TexCoord;
-}
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_light.fs mod/basev/common/glshaders/shadows_model_light.fs
--- orig/basev/common/glshaders/shadows_model_light.fs	2010-05-31 23:24:45.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_light.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,40 +1,139 @@
-#version 110
-
-uniform sampler2D	Texture;
-uniform vec3		LightColour;
-uniform float		LightRadius;
-
-varying vec3		Normal;
-//varying float		Dist;
-varying vec3		VertToLight;
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	vec4 TexColour = texture2D(Texture, TextureCoordinate);
-	if (TexColour.a <= 0.666)
-	{
-		discard;
-	}
-
-	float DistToLight = length(VertToLight); //* 100.0;
-	if (DistToLight >= LightRadius)
-	{
-		discard;
-	}
-	vec3 Incoming = normalize(VertToLight);
-	vec3 Norm = normalize(Normal);
-	float Angle = dot(Incoming, Norm);
-//	Angle = 0.5 + 0.5 * Angle;
-//	float Add = LightRadius - Dist;
-	float Add = LightRadius - DistToLight;
-	Add *= Angle;
-//	if (Add <= 0.0)
-//	{
-//		discard;
-//	}
-	Add = clamp(Add / 255.0, 0.0, 1.0);
-
-	gl_FragColor = vec4(LightColour.r, LightColour.g, LightColour.b, Add);
-//	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
-}
+#version 110
+uniform sampler2D Texture;
+uniform vec3 LightColour;
+uniform float LightRadius;
+uniform float InAlpha;
+uniform bool AllowTransparency;
+
+varying vec3 Normal;
+varying vec3 VertToLight;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec3 VPosL;
+varying vec2 TextureCoordinate;
+varying float Dist;
+varying float VDist;
+
+void main ()
+{
+	vec4 FinalColour;
+	float Add;
+	float DistVPosL;
+
+	DistVPosL = sqrt(dot (VPosL, VPosL));
+	float DistVPos;
+
+	DistVPos = sqrt(dot (VPos, VPos));
+
+	if ((Dist > 0.0))
+	{
+		if ((DistVPosL < -(LightRadius)))
+		{
+			discard;
+		};
+
+		if ((DistVPos < 0.0))
+		{
+			discard;
+		};
+	}
+	else
+	{
+		if ((DistVPosL > LightRadius))
+		{
+			discard;
+		};
+
+		if ((DistVPos > 0.0))
+		{
+			discard;
+		};
+	};
+	float DistToView;
+
+	DistToView = sqrt(dot (VertToView, VertToView));
+
+	if ((Dist > 0.0))
+	{
+		if ((VDist < 0.0))
+		{
+			discard;
+		};
+		if ((DistToView < 0.0))
+		{
+			discard;
+		};
+	}
+	else
+	{
+		if ((VDist > 0.0))
+		{
+			discard;
+		};
+		if ((DistToView > 0.0))
+		{
+			discard;
+		};
+	};
+	float DistToLight;
+
+	DistToLight = sqrt(dot (VertToLight, VertToLight));
+
+	if ((Dist > 0.0))
+	{
+		if ((DistToLight > LightRadius))
+		{
+			discard;
+		};
+	}
+	else
+	{
+		if ((DistToLight < -(LightRadius)))
+		{
+			discard;
+		};
+	};
+	vec4 TexColour;
+
+	TexColour = texture2D (Texture, TextureCoordinate);
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
+	Add = ((LightRadius - DistToLight) * (0.5 + (0.5 * 
+	dot (normalize(VertToLight), Normal)
+	)));
+
+	if ((Add <= 0.0))
+	{
+		discard;
+	};
+	float ClampAdd;
+
+	ClampAdd = clamp ((Add / 255.0), 0.0, 1.0);
+	Add = ClampAdd;
+	float ClampTrans;
+
+	ClampTrans = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+	FinalColour.xyz = LightColour;
+	FinalColour.w = ((ClampAdd * TexColour.w) * (ClampTrans * (ClampTrans * 
+	(3.0 - (2.0 * ClampTrans))
+	)));
+
+	if ((AllowTransparency == bool(0)))
+	{
+		if (((InAlpha == 1.0) && (ClampTrans < 0.666)))
+		{
+			discard;
+		};
+	}
+	else
+	{
+		if ((ClampTrans < 0.1))
+		{
+			discard;
+		};
+	};
+	gl_FragColor = FinalColour;
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_light.vs mod/basev/common/glshaders/shadows_model_light.vs
--- orig/basev/common/glshaders/shadows_model_light.vs	2010-05-31 23:24:48.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_light.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,29 +1,41 @@
-#version 110
-
-uniform float		Inter;
-uniform vec3		LightPos;
-uniform float		LightRadius;
-uniform mat4		ModelToWorldMat;
-uniform mat3		NormalToWorldMat;
-
-attribute vec4		Vert2;
-attribute vec3		VertNormal;
-attribute vec3		Vert2Normal;
-attribute vec2		TexCoord;
-
-varying vec3		Normal;
-//varying float		Dist;
-varying vec3		VertToLight;
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	vec4 Vert = mix(gl_Vertex, Vert2, Inter);
-	//Vert = ModelToWorldMat * Vert;
-	Vert = Vert * ModelToWorldMat;
-	gl_Position = gl_ModelViewProjectionMatrix * Vert;
-
-	Normal = NormalToWorldMat * mix(VertNormal, Vert2Normal, Inter); 
-	VertToLight.xyz = LightPos.xyz - Vert.xyz;
-	TextureCoordinate = TexCoord;
-}
+#version 110
+
+uniform mat4 ModelToWorldMat;
+uniform mat3 NormalToWorldMat;
+uniform vec3 LightPos;
+uniform vec3 ViewOrigin;
+uniform float Inter;
+
+attribute vec4 Vert2;
+attribute vec3 VertNormal;
+attribute vec3 Vert2Normal;
+attribute vec2 TexCoord;
+
+varying vec3 Normal;
+varying vec3 VertToLight;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec3 VPosL;
+varying vec2 TextureCoordinate;
+varying float PlaneDist;
+varying float Dist;
+varying float VDist;
+
+void main ()
+{
+  vec4 Vert;
+  Vert = (mix (gl_Vertex, Vert2, Inter) * ModelToWorldMat);
+  gl_Position = (gl_ModelViewProjectionMatrix * Vert);
+  Normal = (NormalToWorldMat * mix (VertNormal, Vert2Normal, Inter));
+  float SurfDist;
+
+  SurfDist = dot (Normal, Vert.xyz);
+  PlaneDist = SurfDist;
+  Dist = (dot (LightPos, Normal) - SurfDist);
+  VDist = (dot (ViewOrigin, Normal) - SurfDist);
+  VertToLight = (LightPos - Vert.xyz);
+  VertToView = (ViewOrigin - Vert.xyz);
+  VPosL = (LightPos - gl_Position.xyz);
+  VPos = (ViewOrigin - gl_Position.xyz);
+  TextureCoordinate = TexCoord;
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_shadow.fs mod/basev/common/glshaders/shadows_model_shadow.fs
--- orig/basev/common/glshaders/shadows_model_shadow.fs	2010-05-31 23:24:51.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_shadow.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,6 +1,36 @@
-#version 110
-
-void main()
-{
-	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
-}
+#version 110
+
+uniform float LightRadius;
+
+varying vec3 VertToView;
+varying vec3 VPosL;
+varying vec3 VPos;
+
+void main ()
+{
+	float DistToView;
+
+	DistToView = sqrt(dot (VertToView, VertToView));
+
+	if ((DistToView < 0.0))
+	{
+		discard;
+	};
+	float DistVPosL;
+
+	DistVPosL = sqrt(dot (VPosL, VPosL));
+
+	if ((DistVPosL < -(LightRadius)))
+	{
+		discard;
+	};
+	float DistVPos;
+
+	DistVPos = sqrt(dot (VPos, VPos));
+
+	if ((DistVPos < 0.0))
+	{
+		discard;
+	};
+	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_shadow.vs mod/basev/common/glshaders/shadows_model_shadow.vs
--- orig/basev/common/glshaders/shadows_model_shadow.vs	2010-05-31 23:24:55.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_shadow.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,21 +1,32 @@
-#version 110
-
-uniform float		Inter;
-uniform vec3		LightPos;
-uniform mat4		ModelToWorldMat;
-
-attribute vec4		Vert2;
-attribute float		Offset;
-
-void main()
-{
-	vec4 Vert = mix(gl_Vertex, Vert2, Inter);
-	Vert = Vert * ModelToWorldMat;
-	if (Offset > 0.0)
-	{
-		vec3 Dir = normalize(Vert.xyz - LightPos);
-//		Vert += Offset * vec4(Dir, 0.0);
-		Vert.xyz = LightPos + Offset * Dir;
-	}
-	gl_Position = gl_ModelViewProjectionMatrix * Vert;
-}
+#version 110
+
+uniform mat4 ModelToWorldMat;
+uniform vec3 LightPos;
+uniform vec3 ViewOrigin;
+uniform float Inter;
+
+attribute vec4 Vert2;
+attribute float Offset;
+
+varying vec3 VertToView;
+varying vec3 VPosL;
+varying vec3 VPos;
+varying float Offs;
+
+void main ()
+{
+	vec4 Vert;
+	Vert = (mix (gl_Vertex, Vert2, Inter) * ModelToWorldMat);
+
+	if ((Offset > 0.0))
+	{
+		Vert.xyz = (LightPos + (Offset * normalize(
+		  (Vert.xyz - LightPos)
+		)));
+	};
+	gl_Position = (gl_ModelViewProjectionMatrix * Vert);
+	VertToView = (ViewOrigin - Vert.xyz);
+	VPosL = (LightPos - gl_Position.xyz);
+	VPos = (ViewOrigin - gl_Position.xyz);
+	Offs = Offset;
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_model_textures.fs mod/basev/common/glshaders/shadows_model_textures.fs
--- orig/basev/common/glshaders/shadows_model_textures.fs	2010-05-31 23:24:59.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_textures.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,16 +1,68 @@
-#version 110
+#version 110
 
-uniform sampler2D	Texture;
+uniform sampler2D Texture;
+uniform float InAlpha;
+uniform bool AllowTransparency;
 
-varying vec2		TextureCoordinate;
+varying vec2 TextureCoordinate;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying float PlaneDist;
+varying float Dist;
+
+void main ()
+{
+	float DistVPos;
+
+	DistVPos = sqrt(dot (VPos, VPos));
+
+	if ((DistVPos < 0.0))
+	{
+		discard;
+	};
+	float DistToView;
+
+	DistToView = sqrt(dot (VertToView, VertToView));
 
-void main()
-{
-	vec4 FinalColour = texture2D(Texture, TextureCoordinate);
-	if (FinalColour.a <= 0.666)
-	{
-		discard;
-	}
+	if ((DistToView < 0.0))
+	{
+		discard;
+	};
+	vec4 TexColour;
 
-	gl_FragColor = FinalColour;
-}
+	TexColour = texture2D (Texture, TextureCoordinate);
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
+	float ClampTransp;
+
+	ClampTransp = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+	vec4 FinalColour;
+
+	FinalColour.xyz = TexColour.xyz;
+	FinalColour.w = (InAlpha * (ClampTransp * (ClampTransp * 
+		(3.0 - (2.0 * ClampTransp))
+		)));
+
+	if ((AllowTransparency == false))
+	{
+		if ((InAlpha == 1.0))
+		{
+			if ((ClampTransp < 0.666))
+			{
+				discard;
+			};
+		};
+	}
+	else
+	{
+		if ((ClampTransp < 0.1))
+		{
+			discard;
+		};
+	};
+
+	gl_FragColor = FinalColour;
+}
diff -Nur orig/basev/common/glshaders/shadows_model_textures.vs mod/basev/common/glshaders/shadows_model_textures.vs
--- orig/basev/common/glshaders/shadows_model_textures.vs	2010-05-31 23:25:03.000000000 +0200
+++ mod/basev/common/glshaders/shadows_model_textures.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,21 +1,35 @@
 #version 110
 
-uniform float		Inter;
-uniform mat4		ModelToWorldMat;
+uniform mat4 ModelToWorldMat;
+uniform mat3 NormalToWorldMat;
+uniform vec3 ViewOrigin;
+uniform float Inter;
 
-attribute vec4		Vert2;
-attribute vec2		TexCoord;
+attribute vec4 Vert2;
+attribute vec3 VertNormal;
+attribute vec3 Vert2Normal;
+attribute vec2 TexCoord;
 
-varying vec2		TextureCoordinate;
+varying vec3 Normal;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec2 TextureCoordinate;
+varying float PlaneDist;
+varying float Dist;
 
-void main()
+void main ()
 {
-	//	Transforming The Vertex
-	vec4 Vert = mix(gl_Vertex, Vert2, Inter);
-	//Vert = ModelToWorldMat * Vert;
-	Vert = Vert * ModelToWorldMat;
-	gl_Position = gl_ModelViewProjectionMatrix * Vert;
+	vec4 Vert;
 
-	//	Pass texture coordinates.
+	Vert = (mix (gl_Vertex, Vert2, Inter) * ModelToWorldMat);
+	gl_Position = (gl_ModelViewProjectionMatrix * Vert);
+	Normal = (NormalToWorldMat * mix (VertNormal, Vert2Normal, Inter));
+	float SurfDist;
+
+	SurfDist = dot (Normal, Vert.xyz);
+	PlaneDist = SurfDist;
+	Dist = (dot (ViewOrigin, Normal) - SurfDist);
+	VertToView = (ViewOrigin - Vert.xyz);
+	VPos = (ViewOrigin - gl_Position.xyz);
 	TextureCoordinate = TexCoord;
-}
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/shadows_texture.fs mod/basev/common/glshaders/shadows_texture.fs
--- orig/basev/common/glshaders/shadows_texture.fs	2010-05-31 23:25:06.000000000 +0200
+++ mod/basev/common/glshaders/shadows_texture.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,10 +1,27 @@
 #version 110
+
+uniform sampler2D Texture;
 
-uniform sampler2D	Texture;
-
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	gl_FragColor = texture2D(Texture, TextureCoordinate);
-}
+varying vec2 TextureCoordinate;
+
+void main ()
+{
+	vec4 FinalColour_1;
+	vec4 TexColour;
+
+	TexColour = texture2D (Texture, TextureCoordinate);
+	FinalColour_1.xyz = TexColour.xyz;
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
+	float ClampTransp;
+
+	ClampTransp = clamp (((TexColour.w - 0.1) / 0.9), 0.0, 1.0);
+	FinalColour_1.w = (TexColour.w * (ClampTransp * (ClampTransp * 
+		(3.0 - (2.0 * ClampTransp))
+		)));
+
+	gl_FragColor = FinalColour_1;
+}
diff -Nur orig/basev/common/glshaders/shadows_texture.vs mod/basev/common/glshaders/shadows_texture.vs
--- orig/basev/common/glshaders/shadows_texture.vs	2010-05-31 23:25:09.000000000 +0200
+++ mod/basev/common/glshaders/shadows_texture.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,14 +1,14 @@
-#version 110
+#version 110
 
-attribute vec2		TexCoord;
+attribute vec2 TexCoord;
 
-varying vec2		TextureCoordinate;
+varying vec2 TextureCoordinate;
 
-void main()
-{
-	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-
-	//	Pass texture coordinates.
+void main ()
+{
+	//	Transforming The Vertex
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
+
+	//	Pass texture coordinates.
 	TextureCoordinate = TexCoord;
-}
+}
diff -Nur orig/basev/common/glshaders/surf_dsky.fs mod/basev/common/glshaders/surf_dsky.fs
--- orig/basev/common/glshaders/surf_dsky.fs	2010-05-31 23:25:13.000000000 +0200
+++ mod/basev/common/glshaders/surf_dsky.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,15 +1,28 @@
 #version 110
+
+uniform sampler2D Texture;
+uniform sampler2D Texture2;
+uniform float Brightness;
 
-uniform sampler2D	Texture;
-uniform sampler2D	Texture2;
-uniform float		Brightness;
+varying vec2 TextureCoordinate;
+varying vec2 Texture2Coordinate;
 
-varying vec2		TextureCoordinate;
-varying vec2		Texture2Coordinate;
+void main ()
+{
+	vec4 Tex2;
+
+	Tex2 = texture2D (Texture, Texture2Coordinate);
+	float ClampTransp2;
 
-void main()
-{
-	vec4 Tex1 = texture2D(Texture, TextureCoordinate);
-	vec4 Tex2 = texture2D(Texture2, Texture2Coordinate);
-	gl_FragColor = mix(Tex1, Tex2, Tex2.a) * vec4(Brightness, Brightness, Brightness, 1.0);
-}
+	ClampTransp2 = clamp (((Tex2.w - 0.1) / 0.9), 0.0, 1.0);
+	vec4 BrightFactor;
+
+	BrightFactor.w = 1.0;
+	BrightFactor.x = Brightness;
+	BrightFactor.y = Brightness;
+	BrightFactor.z = Brightness;
+
+	gl_FragColor = (mix (texture2D (Texture2, TextureCoordinate), Tex2, (ClampTransp2 * 
+		(ClampTransp2 * (3.0 - (2.0 * ClampTransp2)))
+		)) * BrightFactor);
+}
diff -Nur orig/basev/common/glshaders/surf_dsky.vs mod/basev/common/glshaders/surf_dsky.vs
--- orig/basev/common/glshaders/surf_dsky.vs	2010-05-31 23:25:16.000000000 +0200
+++ mod/basev/common/glshaders/surf_dsky.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,17 +1,17 @@
 #version 110
+
+attribute vec2 TexCoord;
+attribute vec2 TexCoord2;
+
+varying vec2 TextureCoordinate;
+varying vec2 Texture2Coordinate;
+
+void main ()
+{
+	//	Transforming The Vertex
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 
-attribute vec2		TexCoord;
-attribute vec2		TexCoord2;
-
-varying vec2		TextureCoordinate;
-varying vec2		Texture2Coordinate;
-
-void main()
-{
-	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-
-	//	Pass texture coordinates.
-	TextureCoordinate = TexCoord;
-	Texture2Coordinate = TexCoord2;
-}
+	//	Pass texture coordinates.
+	TextureCoordinate = TexCoord;
+	Texture2Coordinate = TexCoord2;
+}
diff -Nur orig/basev/common/glshaders/surf_lightmap.fs mod/basev/common/glshaders/surf_lightmap.fs
--- orig/basev/common/glshaders/surf_lightmap.fs	2010-05-31 23:25:21.000000000 +0200
+++ mod/basev/common/glshaders/surf_lightmap.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,43 +1,68 @@
 #version 110
 
-uniform sampler2D	Texture;
-uniform sampler2D	LightMap;
-uniform sampler2D	SpecularMap;
-uniform bool		FogEnabled;
-uniform int			FogType;
-uniform vec4		FogColour;
-uniform float		FogDensity;
-uniform float		FogStart;
-uniform float		FogEnd;
+uniform sampler2D Texture;
+uniform sampler2D LightMap;
+uniform sampler2D SpecularMap;
+uniform bool FogEnabled;
+uniform int FogType;
+uniform vec4 FogColour;
+uniform float FogDensity;
+uniform float FogStart;
+uniform float FogEnd;
 
-varying vec2		TextureCoordinate;
-varying vec2		LightmapCoordinate;
+varying vec2 TextureCoordinate;
+varying vec2 LightmapCoordinate;
 
-void main()
+void main ()
 {
-	vec4 FinalColour = texture2D(Texture, TextureCoordinate) * texture2D(LightMap, LightmapCoordinate) +
-		 texture2D(SpecularMap, LightmapCoordinate);
+	vec4 FinalColour_1;
+	vec4 TexColour;
+
+	TexColour = ((texture2D (Texture, TextureCoordinate) * texture2D (LightMap, LightmapCoordinate)) + texture2D (SpecularMap, LightmapCoordinate));
+	FinalColour_1 = TexColour;
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
 
 	if (FogEnabled)
 	{
-		float z = gl_FragCoord.z / gl_FragCoord.w;
-		const float LOG2 = 1.442695;
-		float FogFactor;
-		if (FogType == 3)
-		{
-			FogFactor = exp2(-FogDensity * FogDensity * z * z * LOG2);
-		}
-		else if (FogType == 2)
+		float FogFactor_3;
+		float z;
+
+		z = (gl_FragCoord.z / gl_FragCoord.w);
+
+		if ((FogType == 3))
 		{
-			FogFactor = exp2(-FogDensity * z * LOG2);
+			FogFactor_3 = exp2(((
+				((-(FogDensity) * FogDensity) * z)
+				* z) * 1.442695));
 		}
 		else
 		{
-			FogFactor = (FogEnd - z) / (FogEnd - FogStart);
-		}
-		FogFactor = clamp(FogFactor, 0.0, 1.0);
-		FinalColour = mix(FogColour, FinalColour, FogFactor);
-	}
+			if ((FogType == 2))
+			{
+				FogFactor_3 = exp2(((
+					-(FogDensity)
+					* z) * 1.442695));
+			}
+			else
+			{
+				FogFactor_3 = ((FogEnd - z) / (FogEnd - FogStart));
+			};
+		};
+		float SmoothFactor;
+
+		SmoothFactor = clamp (FogFactor_3, 0.0, 1.0);
+		FogFactor_3 = SmoothFactor;
+		float FogFactor;
+
+		FogFactor = clamp (((SmoothFactor - 0.1) / 0.9), 0.0, 1.0);
+		FinalColour_1 = mix (FogColour, TexColour, (FogFactor * (FogFactor * 
+			(3.0 - (2.0 * FogFactor))
+			)));
+	};
 
-	gl_FragColor = FinalColour;
+	gl_FragColor = FinalColour_1;
 }
diff -Nur orig/basev/common/glshaders/surf_lightmap.vs mod/basev/common/glshaders/surf_lightmap.vs
--- orig/basev/common/glshaders/surf_lightmap.vs	2010-05-31 23:32:14.000000000 +0200
+++ mod/basev/common/glshaders/surf_lightmap.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,32 +1,46 @@
 #version 110
 
-uniform vec3		SAxis;
-uniform vec3		TAxis;
-uniform float		SOffs;
-uniform float		TOffs;
-uniform float		TexIW;
-uniform float		TexIH;
-uniform float		TexMinS;
-uniform float		TexMinT;
-uniform float		CacheS;
-uniform float		CacheT;
+uniform vec3 SAxis;
+uniform vec3 TAxis;
+uniform float SOffs;
+uniform float TOffs;
+uniform float TexIW;
+uniform float TexIH;
+uniform float TexMinS;
+uniform float TexMinT;
+uniform float CacheS;
+uniform float CacheT;
 
-varying vec2		TextureCoordinate;
-varying vec2		LightmapCoordinate;
+varying vec2 TextureCoordinate;
+varying vec2 LightmapCoordinate;
 
-void main()
+void main ()
 {
-	const float BLOCK_WIDTH = 128.0;
-	const float BLOCK_HEIGHT = 128.0;
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
+	float s;
 
-	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+	s = (dot (gl_Vertex.xyz, SAxis) + SOffs);
+	float t;
 
-	//	Calculate texture coordinates.
-	float s = (dot(gl_Vertex.xyz, SAxis) + SOffs);
-	float t = (dot(gl_Vertex.xyz, TAxis) + TOffs);
-	float lights = (s - TexMinS + CacheS * 16.0 + 8.0) / (BLOCK_WIDTH * 16.0);
-	float lightt = (t - TexMinT + CacheT * 16.0 + 8.0) / (BLOCK_HEIGHT * 16.0);
-	TextureCoordinate = vec2(s * TexIW, t * TexIH);
-	LightmapCoordinate = vec2(lights, lightt);
+	t = (dot (gl_Vertex.xyz, TAxis) + TOffs);
+	vec2 st;
+
+	st.x = (s * TexIW);
+	st.y = (t * TexIH);
+
+	TextureCoordinate = st;
+	vec2 lightst;
+
+	lightst.x = (((
+		(s - TexMinS)
+		+ 
+		(CacheS * 16.0)
+		) + 8.0) / 2048.0);
+	lightst.y = (((
+		(t - TexMinT)
+		+ 
+		(CacheT * 16.0)
+		) + 8.0) / 2048.0);
+
+	LightmapCoordinate = lightst;
 }
diff -Nur orig/basev/common/glshaders/surf_masked.fs mod/basev/common/glshaders/surf_masked.fs
--- orig/basev/common/glshaders/surf_masked.fs	2010-05-31 23:25:28.000000000 +0200
+++ mod/basev/common/glshaders/surf_masked.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,45 +1,67 @@
 #version 110
+
+uniform sampler2D Texture;
+uniform vec4 Light;
+uniform bool FogEnabled;
+uniform int FogType;
+uniform vec4 FogColour;
+uniform float FogDensity;
+uniform float FogStart;
+uniform float FogEnd;
+uniform float AlphaRef;
+
+varying vec2 TextureCoordinate;
 
-uniform sampler2D	Texture;
-uniform vec4		Light;
-uniform bool		FogEnabled;
-uniform int			FogType;
-uniform vec4		FogColour;
-uniform float		FogDensity;
-uniform float		FogStart;
-uniform float		FogEnd;
-uniform float		AlphaRef;
-
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	vec4 FinalColour = texture2D(Texture, TextureCoordinate) * Light;
-	if (FinalColour.a <= AlphaRef)
+void main ()
+{
+	vec4 FinalColour_1;
+	vec4 TexColour;
+
+	TexColour = (texture2D (Texture, TextureCoordinate) * Light);
+	FinalColour_1 = TexColour;
+
+	if ((TexColour.w < AlphaRef))
 	{
-		discard;
-	}
-
+		discard;
+	};
+
 	if (FogEnabled)
-	{
-		float z = gl_FragCoord.z / gl_FragCoord.w;
-		const float LOG2 = 1.442695;
-		float FogFactor;
-		if (FogType == 3)
-		{
-			FogFactor = exp2(-FogDensity * FogDensity * z * z * LOG2);
-		}
-		else if (FogType == 2)
-		{
-			FogFactor = exp2(-FogDensity * z * LOG2);
+	{
+		float FogFactor_3;
+		float z;
+
+		z = (gl_FragCoord.z / gl_FragCoord.w);
+
+		if ((FogType == 3))
+		{
+			FogFactor_3 = exp2(((
+				((-(FogDensity) * FogDensity) * z)
+				* z) * 1.442695));
 		}
 		else
-		{
-			FogFactor = (FogEnd - z) / (FogEnd - FogStart);
-		}
-		FogFactor = clamp(FogFactor, 0.0, 1.0);
-		FinalColour = mix(FogColour, FinalColour, FogFactor);
-	}
+		{
+			if ((FogType == 2))
+			{
+				FogFactor_3 = exp2(((
+					-(FogDensity)
+					* z) * 1.442695));
+			}
+			else
+			{
+				FogFactor_3 = ((FogEnd - z) / (FogEnd - FogStart));
+			};
+		};
+		float ClampFactor;
+
+		ClampFactor = clamp (FogFactor_3, 0.0, 1.0);
+		FogFactor_3 = ClampFactor;
+		float FogFactor;
 
-	gl_FragColor = FinalColour;
-}
+		FogFactor = clamp (((ClampFactor - AlphaRef) / (1.0 - AlphaRef)), 0.0, 1.0);
+		FinalColour_1 = mix (FogColour, TexColour, (FogFactor * (FogFactor * 
+			(3.0 - (2.0 * FogFactor))
+			)));
+	};
+
+	gl_FragColor = FinalColour_1;
+}
diff -Nur orig/basev/common/glshaders/surf_masked.vs mod/basev/common/glshaders/surf_masked.vs
--- orig/basev/common/glshaders/surf_masked.vs	2010-05-31 23:25:31.000000000 +0200
+++ mod/basev/common/glshaders/surf_masked.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,14 +1,14 @@
-#version 110
+#version 110
 
-attribute vec2		TexCoord;
+attribute vec2 TexCoord;
+
+varying vec2 TextureCoordinate;
 
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-
-	//	Pass texture coordinates.
-	TextureCoordinate = TexCoord;
-}
+void main ()
+{
+	//	Transforming The Vertex
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
+
+	//	Pass texture coordinates.
+	TextureCoordinate = TexCoord;
+}
diff -Nur orig/basev/common/glshaders/surf_model.fs mod/basev/common/glshaders/surf_model.fs
--- orig/basev/common/glshaders/surf_model.fs	2010-05-31 23:25:34.000000000 +0200
+++ mod/basev/common/glshaders/surf_model.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,44 +1,104 @@
 #version 110
 
-uniform sampler2D	Texture;
-uniform bool		FogEnabled;
-uniform int			FogType;
-uniform vec4		FogColour;
-uniform float		FogDensity;
-uniform float		FogStart;
-uniform float		FogEnd;
+uniform sampler2D Texture;
+uniform vec4 FogColour;
+uniform float FogDensity;
+uniform float FogStart;
+uniform float FogEnd;
+uniform float InAlpha;
+uniform int FogType;
+uniform bool FogEnabled;
+uniform bool AllowTransparency;
 
-varying vec4		Light;
-varying vec2		TextureCoordinate;
+varying vec4 Light;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec2 TextureCoordinate;
 
-void main()
+void main ()
 {
-	vec4 FinalColour = texture2D(Texture, TextureCoordinate) * Light;
-	if (FinalColour.a <= 0.0)
+	vec4 FinalColour;
+	vec4 TexColour;
+	float DistVPos;
+	
+	DistVPos = sqrt(dot (VPos, VPos));
+	
+	if ((DistVPos < 0.0))
 	{
 		discard;
-	}
+	};
+	float DistToView;
+
+	DistToView = sqrt(dot (VertToView, VertToView));
+
+	if ((DistToView < 0.0))
+	{
+		discard;
+	};
+	TexColour = (texture2D (Texture, TextureCoordinate) * Light);
+	FinalColour.xyz = TexColour.xyz;
+	FinalColour.w = TexColour.w;
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
 
 	if (FogEnabled)
 	{
-		float z = gl_FragCoord.z / gl_FragCoord.w;
-		const float LOG2 = 1.442695;
+		float z;
 		float FogFactor;
-		if (FogType == 3)
-		{
-			FogFactor = exp2(-FogDensity * FogDensity * z * z * LOG2);
-		}
-		else if (FogType == 2)
+
+		z = (gl_FragCoord.z / gl_FragCoord.w);
+
+		if ((FogType == 3))
 		{
-			FogFactor = exp2(-FogDensity * z * LOG2);
+			FogFactor = exp2(((
+			((-(FogDensity) * FogDensity) * z)
+			* z) * 1.442695));
 		}
 		else
 		{
-			FogFactor = (FogEnd - z) / (FogEnd - FogStart);
-		}
-		FogFactor = clamp(FogFactor, 0.0, 1.0);
-		FinalColour = mix(FogColour, FinalColour, FogFactor);
-	}
+			if ((FogType == 2))
+			{
+				FogFactor = exp2(((
+				  -(FogDensity)
+				 * z) * 1.442695));
+			}
+			else
+			{
+				FogFactor = ((FogEnd - z) / (FogEnd - FogStart));
+			};
+		};
+		float ClampFogFactor;
+
+		ClampFogFactor = clamp (FogFactor, 0.0, 1.0);
+		FogFactor = ClampFogFactor;
+
+		float ClampTransp;
+
+		ClampTransp = clamp (((ClampFogFactor - 0.1) / 0.9), 0.0, 1.0);
+		FinalColour.xyz = mix (FogColour.xyz, TexColour.xyz, (ClampTransp * (ClampTransp * 
+		  (3.0 - (2.0 * ClampTransp))
+		)));
+		FinalColour.w = mix (FogColour.w, TexColour.w, (ClampTransp * (ClampTransp * 
+		  (3.0 - (2.0 * ClampTransp))
+		)));
+	};
 
+	if ((AllowTransparency == bool(0)))
+	{
+		if (((InAlpha == 1.0) && (FinalColour.w < 0.666)))
+		{
+			discard;
+		};
+	}
+	else
+	{
+		if ((FinalColour.w < 0.1))
+		{
+			discard;
+		};
+	};
 	gl_FragColor = FinalColour;
-}
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/surf_model.vs mod/basev/common/glshaders/surf_model.vs
--- orig/basev/common/glshaders/surf_model.vs	2010-05-31 23:25:38.000000000 +0200
+++ mod/basev/common/glshaders/surf_model.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,22 +1,25 @@
 #version 110
 
-uniform float		Inter;
+uniform vec3 ViewOrigin;
+uniform float Inter;
 
-attribute vec4		Vert2;
-attribute vec4		LightVal;
-attribute vec2		TexCoord;
+attribute vec4 Vert2;
+attribute vec4 LightVal;
+attribute vec2 TexCoord;
+
+varying vec4 Light;
+varying vec3 VertToView;
+varying vec3 VPos;
+varying vec2 TextureCoordinate;
 
-varying vec4		Light;
-varying vec2		TextureCoordinate;
-
-void main()
+void main ()
 {
-	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * mix(gl_Vertex, Vert2, Inter);
+	vec4 Vert;
 
-	//	Pass light
+	Vert = mix (gl_Vertex, Vert2, Inter);
+	gl_Position = (gl_ModelViewProjectionMatrix * Vert);
+	VertToView = (ViewOrigin - Vert.xyz);
+	VPos = (ViewOrigin - gl_Position.xyz);
 	Light = LightVal;
-
-	//	Pass texture coordinates.
 	TextureCoordinate = TexCoord;
-}
+}
\ Nincs új sor a fájl végén
diff -Nur orig/basev/common/glshaders/surf_part.fs mod/basev/common/glshaders/surf_part.fs
--- orig/basev/common/glshaders/surf_part.fs	2010-05-31 23:25:41.000000000 +0200
+++ mod/basev/common/glshaders/surf_part.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,14 +1,24 @@
-#version 110
+#version 110
 
-varying vec4		Light;
-varying vec2		TextureCoordinate;
+varying vec4 Light;
+varying vec2 TextureCoordinate;
 
-void main()
-{
-	float a = clamp((1.0 - length(TextureCoordinate)) * 2.0, 0.0, 1.0);
-	if (a <= 0.0)
-	{
-		discard;
-	}
-	gl_FragColor = Light * (1.0, 1.0, 1.0, a);
-}
+void main ()
+{
+	float a;
+
+	a = clamp (((1.0 - 
+		sqrt(dot (TextureCoordinate, TextureCoordinate))
+		) * 2.0), 0.0, 1.0);
+
+	if ((a < 0.1))
+	{
+		discard;
+	};
+	float Transp;
+
+	Transp = clamp (((a - 0.1) / 0.9), 0.0, 1.0);
+	gl_FragColor = (Light * (Transp * (Transp * 
+		(3.0 - (2.0 * Transp))
+		)));
+}
diff -Nur orig/basev/common/glshaders/surf_part.vs mod/basev/common/glshaders/surf_part.vs
--- orig/basev/common/glshaders/surf_part.vs	2010-05-31 23:25:51.000000000 +0200
+++ mod/basev/common/glshaders/surf_part.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,19 +1,19 @@
 #version 110
+
+attribute vec4 LightVal;
+attribute vec2 TexCoord;
+
+varying vec4 Light;
+varying vec2 TextureCoordinate;
+
+void main ()
+{
+	//	Transforming The Vertex
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 
-attribute vec4		LightVal;
-attribute vec2		TexCoord;
-
-varying vec4		Light;
-varying vec2		TextureCoordinate;
-
-void main()
-{
-	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-
-	//	Pass light
-	Light = LightVal;
-
-	//	Pass texture coordinates.
+	//	Pass light
+	Light = LightVal;
+
+	//	Pass texture coordinates.
 	TextureCoordinate = TexCoord;
-}
+}
diff -Nur orig/basev/common/glshaders/surf_simple.fs mod/basev/common/glshaders/surf_simple.fs
--- orig/basev/common/glshaders/surf_simple.fs	2010-05-31 23:25:56.000000000 +0200
+++ mod/basev/common/glshaders/surf_simple.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,40 +1,66 @@
 #version 110
 
-uniform sampler2D	Texture;
-uniform vec4		Light;
-uniform bool		FogEnabled;
-uniform int			FogType;
-uniform vec4		FogColour;
-uniform float		FogDensity;
-uniform float		FogStart;
-uniform float		FogEnd;
+uniform sampler2D Texture;
+uniform vec4 Light;
+uniform bool FogEnabled;
+uniform int FogType;
+uniform vec4 FogColour;
+uniform float FogDensity;
+uniform float FogStart;
+uniform float FogEnd;
 
-varying vec2		TextureCoordinate;
+varying vec2 TextureCoordinate;
 
-void main()
+void main ()
 {
-	vec4 FinalColour = texture2D(Texture, TextureCoordinate) * Light;
+	vec4 FinalColour_1;
+	vec4 TexColour;
+
+	TexColour = (texture2D (Texture, TextureCoordinate) * Light);
+	FinalColour_1 = TexColour;
+
+	if ((TexColour.w < 0.1))
+	{
+		discard;
+	};
 
 	if (FogEnabled)
 	{
-		float z = gl_FragCoord.z / gl_FragCoord.w;
-		const float LOG2 = 1.442695;
-		float FogFactor;
-		if (FogType == 3)
-		{
-			FogFactor = exp2(-FogDensity * FogDensity * z * z * LOG2);
-		}
-		else if (FogType == 2)
+		float FogFactor_3;
+		float z;
+
+		z = (gl_FragCoord.z / gl_FragCoord.w);
+
+		if ((FogType == 3))
 		{
-			FogFactor = exp2(-FogDensity * z * LOG2);
+			FogFactor_3 = exp2(((
+				((-(FogDensity) * FogDensity) * z)
+				* z) * 1.442695));
 		}
 		else
 		{
-			FogFactor = (FogEnd - z) / (FogEnd - FogStart);
-		}
-		FogFactor = clamp(FogFactor, 0.0, 1.0);
-		FinalColour = mix(FogColour, FinalColour, FogFactor);
-	}
+			if ((FogType == 2))
+			{
+				FogFactor_3 = exp2(((
+					-(FogDensity)
+					* z) * 1.442695));
+			}
+			else
+			{
+				FogFactor_3 = ((FogEnd - z) / (FogEnd - FogStart));
+			};
+		};
+		float ClampFactor;
+
+		ClampFactor = clamp (FogFactor_3, 0.0, 1.0);
+		FogFactor_3 = ClampFactor;
+
+		float FogFactor;
+		FogFactor = clamp (((ClampFactor - 0.1) / 0.9), 0.0, 1.0);
+		FinalColour_1 = mix (FogColour, TexColour, (FogFactor * (FogFactor * 
+			(3.0 - (2.0 * FogFactor))
+			)));
+	};
 
-	gl_FragColor = FinalColour;
+	gl_FragColor = FinalColour_1;
 }
diff -Nur orig/basev/common/glshaders/surf_simple.vs mod/basev/common/glshaders/surf_simple.vs
--- orig/basev/common/glshaders/surf_simple.vs	2010-05-31 23:25:59.000000000 +0200
+++ mod/basev/common/glshaders/surf_simple.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,21 +1,24 @@
 #version 110
 
-uniform vec3		SAxis;
-uniform vec3		TAxis;
-uniform float		SOffs;
-uniform float		TOffs;
-uniform float		TexIW;
-uniform float		TexIH;
+uniform vec3 SAxis;
+uniform vec3 TAxis;
+uniform float SOffs;
+uniform float TOffs;
+uniform float TexIW;
+uniform float TexIH;
 
-varying vec2		TextureCoordinate;
+varying vec2 TextureCoordinate;
 
-void main()
+void main ()
 {
 	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 
 	//	Calculate texture coordinates.
-	float s = (dot(gl_Vertex.xyz, SAxis) + SOffs) * TexIW;
-	float t = (dot(gl_Vertex.xyz, TAxis) + TOffs) * TexIH;
-	TextureCoordinate = vec2(s, t);
+	vec2 st;
+
+	st.x = ((dot (gl_Vertex.xyz, SAxis) + SOffs) * TexIW);
+	st.y = ((dot (gl_Vertex.xyz, TAxis) + TOffs) * TexIH);
+
+	TextureCoordinate = st;
 }
diff -Nur orig/basev/common/glshaders/surf_sky.fs mod/basev/common/glshaders/surf_sky.fs
--- orig/basev/common/glshaders/surf_sky.fs	2010-05-31 23:26:03.000000000 +0200
+++ mod/basev/common/glshaders/surf_sky.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,11 +1,18 @@
-#version 110
+#version 110
 
-uniform sampler2D	Texture;
-uniform float		Brightness;
+uniform sampler2D Texture;
+uniform float Brightness;
 
-varying vec2		TextureCoordinate;
+varying vec2 TextureCoordinate;
+
+void main ()
+{
+	vec4 BrightFactor;
 
-void main()
-{
-	gl_FragColor = texture2D(Texture, TextureCoordinate) * vec4(Brightness, Brightness, Brightness, 1.0);
-}
+	BrightFactor.w = 1.0;
+	BrightFactor.x = Brightness;
+	BrightFactor.y = Brightness;
+	BrightFactor.z = Brightness;
+
+	gl_FragColor = (texture2D (Texture, TextureCoordinate) * BrightFactor);
+}
diff -Nur orig/basev/common/glshaders/surf_sky.vs mod/basev/common/glshaders/surf_sky.vs
--- orig/basev/common/glshaders/surf_sky.vs	2010-05-31 23:26:06.000000000 +0200
+++ mod/basev/common/glshaders/surf_sky.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,14 +1,14 @@
 #version 110
-
-attribute vec2		TexCoord;
-
-varying vec2		TextureCoordinate;
-
-void main()
-{
+
+attribute vec2 TexCoord;
+
+varying vec2 TextureCoordinate;
+
+void main ()
+{
 	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
-
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
+
 	//	Pass texture coordinates.
 	TextureCoordinate = TexCoord;
-}
+}
diff -Nur orig/basev/common/glshaders/surf_zbuf.fs mod/basev/common/glshaders/surf_zbuf.fs
--- orig/basev/common/glshaders/surf_zbuf.fs	2010-05-31 23:26:08.000000000 +0200
+++ mod/basev/common/glshaders/surf_zbuf.fs	2022-08-12 08:34:34.000000000 +0200
@@ -1,6 +1,6 @@
 #version 110
 
-void main()
+void main ()
 {
 	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
 }
diff -Nur orig/basev/common/glshaders/surf_zbuf.vs mod/basev/common/glshaders/surf_zbuf.vs
--- orig/basev/common/glshaders/surf_zbuf.vs	2010-05-31 23:26:13.000000000 +0200
+++ mod/basev/common/glshaders/surf_zbuf.vs	2022-08-12 08:34:34.000000000 +0200
@@ -1,7 +1,7 @@
 #version 110
 
-void main()
+void main ()
 {
 	//	Transforming The Vertex
-	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
+	gl_Position = (gl_ModelViewProjectionMatrix * gl_Vertex);
 }
diff -Nur orig/basev/common/vavoom_decorate_defs.xml mod/basev/common/vavoom_decorate_defs.xml
--- orig/basev/common/vavoom_decorate_defs.xml	2010-12-23 20:47:55.000000000 +0100
+++ mod/basev/common/vavoom_decorate_defs.xml	2022-08-12 08:34:34.000000000 +0200
@@ -172,6 +172,7 @@
 		<flag name="NoDamage" property="bNoDamage" />
 		<flag name="DontRip" property="bDontRip" />
 		<flag name="NoTelefrag" property="bNoTeleFrag" />
+		<flag name="NoTimeFreeze" property="bNoTimeFreeze" />
 		<!-- Appearance and sound -->
 		<flag name="Bright" property="bBright" />
 		<flag name="Invisible" property="bInvisible" />
@@ -344,6 +345,7 @@
 		<flag name="KeepDepleted" property="bKeepDepleted" />
 		<flag name="IgnoreSkill" property="bIgnoreSkill" />
 		<flag name="AdditiveTime" property="bAdditiveTime" />
+		<flag_unsupported name="AlwaysActivate" /> <!-- From SkulTag ? -->
 	</class>
 
 	<class name="Ammo">
@@ -404,6 +406,7 @@
 		<prop_class name="Weapon.SisterWeapon" property="SisterWeaponType" />
 		<prop_name name="Weapon.UpSound" property="UpSound" />
 		<prop_float name="Weapon.YAdjust" property="PSpriteSY" />
+		<prop_int_unsupported name="Weapon.SlotNumber" />
 		<!-- Vavoom specific -->
 		<prop_float name="Weapon.BotCombatDist" property="BotCombatDist" />
 		<prop_int name="Weapon.PlayerModelVersion" property="PlayerModelVersion" />
diff -Nur orig/basev/doom/sndinfo.txt mod/basev/doom/sndinfo.txt
--- orig/basev/doom/sndinfo.txt	2009-01-04 14:59:10.000000000 +0100
+++ mod/basev/doom/sndinfo.txt	2022-08-12 08:34:34.000000000 +0200
@@ -123,6 +123,7 @@
 imp/pain						dspopain
 imp/death1						dsbgdth1
 imp/death2						dsbgdth2
+$limit imp/active 6
 
 //  Demon
 demon/sight						dssgtsit
@@ -130,6 +131,7 @@
 demon/melee						dssgtatk
 demon/pain						dsdmpain
 demon/death						dssgtdth
+$limit demon/melee 4
 
 //  Spectre
 spectre/sight					dssgtsit
diff -Nur orig/basev/heretic/sndinfo.txt mod/basev/heretic/sndinfo.txt
--- orig/basev/heretic/sndinfo.txt	2008-03-30 15:40:34.000000000 +0200
+++ mod/basev/heretic/sndinfo.txt	2022-08-12 08:34:34.000000000 +0200
@@ -59,6 +59,7 @@
 //  Crossbow
 weapons/bowshoot				bowsht
 weapons/bowhit					hrnhit
+$limit weapons/bowhit 0
 
 //  Blaster
 weapons/blastershoot			blssht
@@ -88,6 +89,7 @@
 weapons/maceexplode				phohit
 weapons/macestop				pstop
 $limit weapons/maceshoot 0
+$limit weapons/maceexplode 0
 
 //==========================================================================
 //
@@ -266,7 +268,7 @@
 $limit world/amb8 1
 $limit world/amb9 1
 $limit world/amb10 1
-$limit world/amb11 1
+$limit world/amb11 0
 
 //	Sparks
 world/spark1					spark1
diff -Nur orig/basev/hexen/sndinfo.txt mod/basev/hexen/sndinfo.txt
--- orig/basev/hexen/sndinfo.txt	2010-09-01 20:26:03.000000000 +0200
+++ mod/basev/hexen/sndinfo.txt	2022-08-12 08:34:34.000000000 +0200
@@ -238,12 +238,12 @@
 $MAP    59              Simonr
 $MAP    60              Crucibr
 
-$MAP    33              Grover
-$MAP    34              Fortr
-$MAP    35              Swampr
-$MAP    36              Wobabyr
-$MAP    37              Blechr
-$MAP    38              Falconr
+//$MAP    33              Grover
+//$MAP    34              Fortr
+//$MAP    35              Swampr
+//$MAP    36              Wobabyr
+//$MAP    37              Blechr
+//$MAP    38              Falconr
 
 $MAP    0               hexen
 $MAP    0               hub
diff -Nur orig/basev/strife/CMakeLists.txt mod/basev/strife/CMakeLists.txt
--- orig/basev/strife/CMakeLists.txt	2008-09-11 00:20:58.000000000 +0200
+++ mod/basev/strife/CMakeLists.txt	2022-08-12 08:34:34.000000000 +0200
@@ -2,7 +2,7 @@
 
 add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/strfhelp.o
 	COMMAND ${ACC} ARGS ${CMAKE_CURRENT_SOURCE_DIR}/../../utils/editing/acs/strfhelp.acs strfhelp.o
-	DEPENDS ../../utils/editing/acs/*.acs acc
+	DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/../../utils/editing/acs/*.acs acc
 	)
 add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/basepak.pk3
 	COMMAND ${VLUMPY} ARGS basepak.ls
A(z) orig/docs/About.pdf és a(z) mod/docs/About.pdf bináris fájlok különböznek
diff -Nur orig/docs/changes3.log mod/docs/changes3.log
--- orig/docs/changes3.log	2010-12-31 14:20:39.000000000 +0100
+++ mod/docs/changes3.log	2022-08-12 08:34:34.000000000 +0200
@@ -4391,3 +4391,217 @@
 ******************************************************************************
                             VERSION 1.33
 ******************************************************************************
+
+07.02.2011
+  Firebrand removed limits on some more Heretic sounds.
+  Firebrand added various checks for avoiding floating monsters with bobbing
+ motions to get stuck inside other  enemies momentarily.
+  Firebrand fixed the Strife's Inquisitor could get stuck in other actors
+ when jumping.
+  Firebrand doubled the speed at which floating monsters go up when "sliding"
+ along walls vertically to make it more consistent to original behaviour.
+  Firebrand fixed some problems with MBF bounce flags physics in floors and ceilings.
+  Firebrand tweaked the way wall bounce physics work.
+  Firebrand applied patch supplied by Blzut3 to fix performance of dedicated and
+ master server on Linux.
+10.02.2011
+  Firebrand made some more tweaks to the wall bouncing code.
+  Firebrand added missing include files to the previous linux dedicated server and
+ master server patch.
+  Firebrand changed the checks for Hexen's floating monsters with bobbing motions.
+  Firebrand added a way to handle the case of actors on top of other actors when they
+ stand in moving platforms or floors.
+  Firebrand fixed actor bounces wouldn't check or change BounceCount.
+  Firebrand made sliding polyobject doors to crush ice corpses.
+  Firebrand made normal doom doors to crush ice corpses.
+11.02.2011
+  Firebrand fixed the problem that made the player don't enter it's pain state when walking on
+ lava or nukage pools.
+  Firebrand adjusted Z Velocity for Fighter's flechettes, since the old value was a bit too high.
+  Firebrand added some checks inside of StepMove method for better handling of certain conditions that
+ could cause monsters to get stuck inside of each other when falling down.
+13.02.2011
+  Firebrand commented out Hexen Deathking's music assigments inside the Hexen's SNDINFO lump that were
+ overlapping with the original ones, this isn't much trouble, these maps were deathmatch only in Deathkings
+ so people won't care what music files are player where.
+  Firebrand added B0rsuk's patch provided for changing Hexen's Bishops and Stalker boss's behaviout of shooting
+ even when the player wasn't around, it was added as a gameplay compatibility option that it's turned off by
+ default.
+  Firebrand fixed the logic of the HitCeiling method, since it was modifying the origin of objects and this was
+ affecting bouncing objects.
+  Firebrand fixing how the Mobj thrust done by polyobjects was being calculated, since the effects weren't
+ correct sometimes making monsters remain stuck with rotating polyobjects, he also fixed the logic of the
+ function for crushing corpses and ice corpses.
+  Firebrand removed the one sound per mobj limit from GetChannel, since it was making the sounds for the
+ Heretic's Gauntlet weapon to be cut off when replayed, it also made the game reproduce sounds way better.
+  Firebrand fixed the option's text of the gameplay options screen to fit on screen for all the games.
+14.02.2011
+  Firebrand fixed the bPulseVisibility flag logic, since it didn't worked correctly.
+  Firebrand restored the PulseVisibility flag to Doom's BlurSphere.
+  Firebrand made actors with Crash state to Crash only on Solid objects, since this could trigger the effect
+ indefinitely under specific conditions.
+  Firebrand enabled drawing of light shadows for player model.
+27.02.2011
+  Firebrand added and implemented time freeze powerup class.
+  Firebrand added and implemented double firing speed powerup class.
+  Firebrand added and implemented high jump powerup class.
+  Firebrand added some more parameters for RadiusAttack method (dmgdistance, nails and naildamage).
+  Firebrand added A_MonsterRefire method, for generalized ReFire action for monsters.
+  Firebrand added some stub methods for allowing DECORATE mods to work correctly.
+  Firebrand fixed a crash in InitSpawnedItem method, caused when the player spawned friendly monsters.
+  Firebrand added some checks for making sure that Pain state exists when forcing pain in monsters.
+  Firebrand made Ceiling bouncing objects to take into account a couple more flags to avoid bouncing on skies.
+  Firebrand fixed durations and flags for most of the powerup classes.
+  Firebrand added a code patch for fixing SDL_Quit method wasn't properly called when exiting with error in
+ Linux.
+  Firebrand made 'altdeath.com' the default master server for looking for Vavoom games on Internet, thanks go to
+ Blzut3 and AlexMax for hosting it and giving information on this.
+03.03.2011
+  Firebrand applied code patch file provided by mnk at the forums that adds ModPlug for MOD type music output,
+ but added some more configurable options to it as CVars.
+  Firebrand added CVars for allowing selection of output device to use for playing MIDI, MUS and MOD type music.
+  Firebrand added more configurable options for MikMod.
+  Firebrand updated the common progs MSVC project file to add the new source files.
+  Firebrand fixed a crash inside the AutoUseHealthStrife that had to do with incorrect logic with dynamic arrays.
+  Firebrand improved the layout of the sound options screen, he also added a new screen for setting new MikMod
+ and ModPlug options and a slider for setting the amount of sound channels.
+  Firebrand made layout improvements on the advanced video options, so that it displays correctly on all games.
+  Firebrand added calls to methods to stop all sounds when entering to intermission and text screens.
+  Firebrand fixed an error on the gameplay options screen, which was setting an incorrect CVar when changing
+ the 'monsters can dropoff' option.
+  Firebrand fixed a crash when taking screenshots on Direct3D that had to do with trying to lock a surface that
+ was being used by the renderer, instead a new surface with the exact same contents as the screen should be
+ created and copied to the data pointers that generate screenshots.
+07.03.2011
+  Firebrand added Game Music Emu codec, to play emulation music in various formats (NSF, GBS, AY, HES, GYM, VGM).
+  Firebrand made fixes to the basepak projects to avoid generating too many intermediate directories.
+  Firebrand fixed compilation errors on Linux.
+  Firebrand updated readme file with locations for the new libraries used by Vavoom.
+08.03.2011
+  Firebrand added a new control options screen that shows KEYCONF script generated controls for MODs.
+  Firebrand added a special flag to mark monsters as "crashed" to avoid execution of Crash method infinitely,
+ this was specially noted on sloped surfaces, where monsters that could "crash" did this infinitely.
+  Firebrand fixed a problem with 'addslotdefault' KEYCONF command wouldn't work because it wasn't expecting
+ lowercased class names for it.
+  Firebrand commented 'check(Level->TIDHash[HashIndex] == this)' inside of p_entity.cpp, he thinks that there's
+ no reason for this line there, he will uncomment it if something breaks up with this change.
+09.03.2011
+  Firebrand fixed a crash in TestMobjZ method, which was exposed after adding this method for checking for
+ collisions when setting actors Z origin inside of FloatBobbing motion moves (and other cases), the crash
+ happened because we weren't checking if both actors collided with things, so sometimes actors which didn't
+ collide with things (like the player with NoClip cheat), could cause things to cosider them as "being there".
+  Firebrand Standardized how the setslot methods work, they did work if class names were EXACTLY as they
+ should be, but if the names were provided without proper casing, then they wouldn't work, now Vavoom transforms
+ the names to lower case and then looks for the class name when setting weapons to a weapon slot.
+  Firebrand improved the code to "create" a new special controls screen when KEYCONF lumps are used.
+11.03.2011
+  Firebrand made ModPlug check the filetype before starting playback, to avoid using it for MIDI playback,
+ since it sounds really bad.
+  Firebrand fixed pig and invulnerable players coughed when poisoned.
+  Firebrand changed the height for Chicken and Pig players and monsters to be higher than the default
+ MaxStepHeight (24), because things could pass and be "stepped up" by monsters and static decorations,
+ this seems to be a problem with Doom's physics code, but he doesn't have the time or desire to investigate
+ this as of now, so this will be fixed later.
+  Firebrand fixed that projectiles with bForceDamage that did 0 damage didn't forced actor to enter to their
+ pain state.
+13.03.2011
+  Firebrand doubled TID_HASH_SIZE, since there were maps that could cause assertions because of the old size
+ limit.
+  Firebrand fixed that projectiles with bForcePain didn't make monsters to go into their pain state all the
+ time because of a logic error in the check.
+  Firebrand fixed the logic inside of PolyThrustMobj method to make polyobjects able to crush corpses.
+  Firebrand fixed a problem where platforms which didn't had any Wait time to go up (or down) did so anyways,
+ this fixes the problem with Hexen's MAP31 script where some platforms would go up and immediately go down,
+ which wasn't the expected behavior.
+  Firebrand improved some checks for polyobjects blocked by things.
+  Firebrand fixed a problem where active scripts wouldn't be checked when loading savegames, causing a problem
+ when the player was reborn from a reborn state save, where scripts wouldn't be executed properly.
+19.03.2011
+  Firebrand fixed the keys checked for several Strife line specials, thanks go to Crimson Wizard and appelzin3
+ for providing information for fixing this bug.
+  Firebrand implemented the patch provided by b0rsuk to fix TeleportOther1 projectile to work on players too.
+  Firebrand made player to reset buttons after ending a strife conversation, to avoid a problem where the player
+ could kill NPCs when ending conversation screens with the mouse because it triggered the player's weapon fire.
+20.03.2011
+  Firebrand fixed the problem where actors that had low height could make static decorations "step up" on them
+ because of flawed problems in the physics checks done on these cases.
+  Firebrand fixed the checks done for using ice death frames or generic ice death frames if these aren't found
+ inside WAD files.
+27.03.2011
+  Firebrand changed that only things marked with bSpecial flag are spawned with bDropped flag in many places of
+ progs source.
+  Firebrand changed the checks inside of DoThingCount to check for health of anything instead of only things with
+ bMonster flag.
+  Firebrand fixed some small issues when rendering models and levels using advanced level renderer in OpenGL.
+  Firebrand fixed the logic of the checks done for crushing bodies with polyobjects.
+  Firebrand fixed a problem with GME Codec with OpenAL sound driver which could crash because it was using a
+ different buffer size than needed.
+  Firebrand added extra checks to ModPlug when opening MOD type files, because he found that some GME type files
+ would be treated as MOD files and played with ModPlug, which would make it produce garbage sound.
+  Firebrand added some CVars to DirectSound driver to select the type of speakers and mixing frequency (which
+ are still experimental).
+  Firebrand made small improvements to parsing of old DECORATE definitions.
+28.03.2011
+  Firebrand made lines with ML_BLOCKEVERYTHING flag to block everything as expected, this revision only fixes
+ the game logic, the rendering problem will be fixed in another revision.
+30.03.2011
+  Firebrand updated GME library to version 0.6, which makes sound overall better and adds a couple of fixes.
+  Firebrand fixed GME playback as suggested by Mnk in the forums.
+  Firebrand made all sound CVars to begin with "snd_" for standardization.
+04.04.2011
+  Firebrand fixed the checks for determining if a monster should jump or not.
+06.04.2011
+  Firebrand made quake focus things to limit the intensity of Quakes to avoid problems in player view and thrust
+ of actors.
+  Firebrand fixed for good the polyobject mobj thrust force.
+  Firebrand made TextureChangeDoor to add a ML_NOTBOTPEG flag, so that lines display their texture correctly.
+21.04.2011
+  Firebrand changed the way in which PointInSubsector method determines the node number for a more accurate
+ method.
+  Firebrand improved the calculations in CheckThing method to be similar to the ones done in CheckRelThing, this
+ seems to improve physics in many other checks in-game.
+  Firebrand fixed the calculations done in CheckRelThing method to use tmtrace structure instead of the entity's
+ Origin, since it's more precise this way, this also improves physics checks among the game too.
+  Firebrand changed the RenderBSP methods so that they check for visibility of the node's BBox that are going to
+ be subdivided behind the camera, this had a positive hit in performance with advanced and regular renderers,
+ the game still slows down when rendering complex structures, but the improvement in general is good.
+25.04.2011
+  Firebrand continued improving the performance of the renderer by adding checks to avoid rendering of stuff that
+ is not on the camera, this had a substantial improvement in performance even when using the advanced renderer
+ with model shadows.
+26.04.2011
+  Firebrand revised the checks and corrected a few mistakes on them.
+07.05.2011
+  Firebrand fixed some typos on GME library CMakeList.txt file, which caused compilation on Linux to fail.
+08.05.2011
+  Firebrand applied a patch file provided by inode64 that fixes more compilation errors of GME library under
+Linux.
+09.05.2011
+  Firebrand removed duplicated files from trunk and CMakeLists.txt.
+  Firebrand removed use of specific MSVC methods from blargg_source.h file.
+10.05.2011
+  Firebrand improved rendering of fake floors.
+11.05.2011
+  Firebrand fixed some compilation errors in common.h and enabled using typedefs for vint types.
+  Firebrand added a HAVE_STDINT_H define in blargg_common.h, to allow the use of stdint.h file when compiling.
+12.05.2011
+  Firebrand fixed a crash when Direct3D renderer updated camera textures.
+  Firebrand ran the code analysis tool from MSVC on Vavoom project and fixed some warnings, which seem to
+ improve performance.
+13.05.2011
+  Firebrand continues fixing some more warnings from the code analysis tool.
+16.05.2011
+  Firebrand fixed the remaining warnings from the code analysis tool.
+  Firebrand made the engine use srand method to seed a value to further randomize the random number generator.
+19.05.2011
+  Firebrand fixed a few GCC warnings that were reported on the forum.
+  Firebrand fixed a few possible memory leaks in some parts of the code.
+  Firebrand fixed the drawing of translucent model ambient, light and fog passes in advanced OpenGL renderer,
+ the problem was due to the shaders not taking into account an actor alpha value to apply it to the model.
+26.05.2011
+  Firebrand added some checks to the clipper to properly clip away segs behind closed doors and elevator/plats.
+27.05.2011
+  Firebrand fixed a problem reported on the forums, where the renderer would mark polyobject segs on the
+ frontsectors linecount to 0 to skip rendering them, this made some maps to crash when entering such sectors.
+01.06.2011
+  Firebrand began improving how Timidity uses DLS files, since they sounded crappy, this isn't finished yet.
\ Nincs új sor a fájl végén
A(z) orig/docs/glVIS.pdf és a(z) mod/docs/glVIS.pdf bináris fájlok különböznek
A(z) orig/docs/tutorials/AddingaWeapon.pdf és a(z) mod/docs/tutorials/AddingaWeapon.pdf bináris fájlok különböznek
A(z) orig/docs/tutorials/MultipagedIntermission.pdf és a(z) mod/docs/tutorials/MultipagedIntermission.pdf bináris fájlok különböznek
A(z) orig/docs/tutorials/RepeaterCannon.pdf és a(z) mod/docs/tutorials/RepeaterCannon.pdf bináris fájlok különböznek
A(z) orig/docs/tutorials/Skyboxes.pdf és a(z) mod/docs/tutorials/Skyboxes.pdf bináris fájlok különböznek
A(z) orig/docs/tutorials/SpriteStates.pdf és a(z) mod/docs/tutorials/SpriteStates.pdf bináris fájlok különböznek
A(z) orig/docs/tutorials/SwimmableWater.pdf és a(z) mod/docs/tutorials/SwimmableWater.pdf bináris fájlok különböznek
diff -Nur orig/docs/vavoom.txt mod/docs/vavoom.txt
--- orig/docs/vavoom.txt	2010-12-31 15:23:58.000000000 +0100
+++ mod/docs/vavoom.txt	2022-08-12 08:34:35.000000000 +0200
@@ -10,7 +10,7 @@
             ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
              #    ##    ##    #      ####     ####   ##       ##
 
-                                                    Version 1.33
+                                                    Version 1.34
 
 Contents:
     0. Disclaimer
@@ -56,8 +56,9 @@
      - Optional: CD-ROM
      - Windows version: DirectX 9 (http://www.microsoft.com/directx)
 
-*** IMPORTANT! Vavoom requires a floating point processor.
-Systems that do not have an FPU installed will not run Vavoom -- at all.
+*** IMPORTANT! ***
+ Vavoom requires a floating point processor.
+ Systems that do not have an FPU installed will not run Vavoom -- at all.
 
   To play Vavoom you need the main wad file from one of the following games:
      - Doom shareware
@@ -117,6 +118,7 @@
     * libmad (http://www.underbit.com/products/mad/)
     * mikmod (http://mikmod.raphnet.net/)
     * FLAC (http://flac.sourceforge.net/)
+    * libmodplug (http://modplug-xmms.sourceforge.net/)
 
   And of course the Vavoom sources.
 
@@ -192,16 +194,39 @@
       * libmad (http://www.underbit.com/products/mad/)
       * mikmod (http://mikmod.raphnet.net/)
       * FLAC (http://flac.sourceforge.net/)
+      * libmodplug (http://modplug-xmms.sourceforge.net/)
 
   You can also compile with MSVC 2008, you will find the workspace and project
- files in the 'msvc' subdirectory. You will still need MinGW to compile asm
- files.
+ files in the 'msvc' subdirectory.
+
+==============================================================================
+3.4 Timidity patches
+==============================================================================
+
+ You can get Timidity patches to use with Vavoom from here:
+
+	http://www.doomworld.com/idgames/index.php?id=13928
+
+ or from here:
+
+	http://www.doomworld.com/idgames/index.php?id=12527
+
+ To allow Vavoom to use the patch files, you need to edit the timidity.cfg,
+look for and replace the
+
+	dir d:\doom\misc\patches
+
+line to point to the directory where you unarchived the pack, then move the
+timidity.cfg file to the same directory where Vavoom executable is located.
+
+ Then make sure to enable Timidity playback in the launher or inside the
+sound options menu in-game.
 
 *****************************************************************************
 4. Starting a net game
 *****************************************************************************
 
-  The Vavoom supports only TCP/IP.
+  Vavoom supports only TCP/IP.
 
   The default socket port is 26000. It can be changed in the console with
 the command "port <port>".
@@ -397,6 +422,7 @@
         - Tab to complete a command, press it again for the next matching command;
         - Shift + Tab for reverse order;
         - PageUp/PageDown to scroll lines up/down;
+        - Separate multiple commands by separating them with semi-colon ';';
         - Up/Down for the last 16 commands history.
     - CD audio.
     - 3 crosshairs.
@@ -410,9 +436,10 @@
     - glBSP plugin.
     - glVIS plugin.
     - Support for Skyboxes
-    - WAV and FLAC sounds, MP3, OGG and mod-style music.
+    - WAV and FLAC sounds, MP3, OGG, mod-style and game emulation music.
     - Possibility of using Timidity for MIDI and MUS playback.
-    - High Resolution textures
+    - High Resolution textures.
+    - Definition of new in-game controls using KEYCONF script.
     - Custom object and weapon definitions using DECORATE script.
     - Stencil shadows.
     - A lots more.
@@ -1177,6 +1204,12 @@
 * Improvements to DECORATE.
 * Multiple bug fixes
 
+==============================================================================
+Version 1.34
+==============================================================================
+
+* Bug fixes
+
 *****************************************************************************
 8. Licensing
 *****************************************************************************
A(z) orig/docs/wiki/ActionSpecials.pdf és a(z) mod/docs/wiki/ActionSpecials.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/ACS.pdf és a(z) mod/docs/wiki/ACS.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/CommandLineArguments.pdf és a(z) mod/docs/wiki/CommandLineArguments.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/ConsoleCommands.pdf és a(z) mod/docs/wiki/ConsoleCommands.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/Decorate.pdf és a(z) mod/docs/wiki/Decorate.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/DefinitionScripts.pdf és a(z) mod/docs/wiki/DefinitionScripts.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/MakingaMod.pdf és a(z) mod/docs/wiki/MakingaMod.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/ModelDefinitions.pdf és a(z) mod/docs/wiki/ModelDefinitions.pdf bináris fájlok különböznek
A(z) orig/docs/wiki/VavoomC.pdf és a(z) mod/docs/wiki/VavoomC.pdf bináris fájlok különböznek
diff -Nur orig/libs/core/args.cpp mod/libs/core/args.cpp
--- orig/libs/core/args.cpp	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/args.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: args.cpp 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -95,7 +95,7 @@
 		fseek(handle, 0, SEEK_END);
 		int size = ftell(handle);
 		fseek(handle, 0, SEEK_SET);
-		char *file = (char*)malloc(size + 1);
+		char *file = (char*)Z_Malloc(size + 1);
 		fread(file, size, 1, handle);
 		fclose(handle);
 		file[size] = 0;
@@ -103,7 +103,7 @@
 		//	Keep all other cmdline args
 		char** oldargv = Argv;
 
-		Argv = (char**)malloc(sizeof(char*) * MAXARGVS);
+		Argv = (char**)Z_Malloc(sizeof(char*) * MAXARGVS);
 		memset(Argv, 0, sizeof(char*) * MAXARGVS);
 
 		//	Keep args before response file
diff -Nur orig/libs/core/args.h mod/libs/core/args.h
--- orig/libs/core/args.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/args.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: args.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/array.h mod/libs/core/array.h
--- orig/libs/core/array.h	2010-04-03 21:55:10.000000000 +0200
+++ mod/libs/core/array.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: array.h 4211 2010-04-03 19:59:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/arraystream.cpp mod/libs/core/arraystream.cpp
--- orig/libs/core/arraystream.cpp	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/arraystream.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: arraystream.cpp 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/arraystream.h mod/libs/core/arraystream.h
--- orig/libs/core/arraystream.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/arraystream.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: arraystream.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/bitstream.cpp mod/libs/core/bitstream.cpp
--- orig/libs/core/bitstream.cpp	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/bitstream.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: bitstream.cpp 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/bitstream.h mod/libs/core/bitstream.h
--- orig/libs/core/bitstream.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/bitstream.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: bitstream.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/common.cpp mod/libs/core/common.cpp
--- orig/libs/core/common.cpp	2010-04-03 16:16:11.000000000 +0200
+++ mod/libs/core/common.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: common.cpp 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/common.h mod/libs/core/common.h
--- orig/libs/core/common.h	2010-04-03 21:55:10.000000000 +0200
+++ mod/libs/core/common.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: common.h 4211 2010-04-03 19:59:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -65,6 +65,8 @@
 
 typedef unsigned char 		byte;
 
+//#define HAVE_INTTYPES_H
+
 #ifdef HAVE_INTTYPES_H
 #include <inttypes.h>
 typedef int8_t				vint8;
@@ -73,7 +75,6 @@
 typedef uint16_t			vuint16;
 typedef int32_t				vint32;
 typedef uint32_t			vuint32;
-/* Needs more changes to compile with MSVC
 #elif defined _WIN32
 typedef __int8				vint8;
 typedef unsigned __int8		vuint8;
@@ -81,7 +82,6 @@
 typedef unsigned __int16	vuint16;
 typedef __int32				vint32;
 typedef unsigned __int32	vuint32;
-*/
 #else
 typedef char				vint8;
 typedef unsigned char		vuint8;
@@ -144,8 +144,8 @@
 //
 //==========================================================================
 
-#define clock(var)		var -= Sys_Cycles()
-#define unclock(var)	var += Sys_Cycles() - 34
+#define clock_cycle(var)		var -= Sys_Cycles()
+#define unclock_cycle(var)		var += Sys_Cycles() - 34
 
 //==========================================================================
 //
diff -Nur orig/libs/core/core.h mod/libs/core/core.h
--- orig/libs/core/core.h	2010-05-20 20:32:13.000000000 +0200
+++ mod/libs/core/core.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: core.h 4251 2010-05-20 18:39:48Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/crc.cpp mod/libs/core/crc.cpp
--- orig/libs/core/crc.cpp	2010-04-03 21:55:10.000000000 +0200
+++ mod/libs/core/crc.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: crc.cpp 4211 2010-04-03 19:59:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/crc.h mod/libs/core/crc.h
--- orig/libs/core/crc.h	2010-04-03 21:55:10.000000000 +0200
+++ mod/libs/core/crc.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: crc.h 4211 2010-04-03 19:59:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/endian.cpp mod/libs/core/endian.cpp
--- orig/libs/core/endian.cpp	2010-04-03 20:12:55.000000000 +0200
+++ mod/libs/core/endian.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: endian.cpp 4207 2010-04-03 18:17:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/endian.h mod/libs/core/endian.h
--- orig/libs/core/endian.h	2010-04-03 20:12:55.000000000 +0200
+++ mod/libs/core/endian.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: endian.h 4207 2010-04-03 18:17:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/exception.cpp mod/libs/core/exception.cpp
--- orig/libs/core/exception.cpp	2010-04-21 15:15:40.000000000 +0200
+++ mod/libs/core/exception.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: exception.cpp 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -109,7 +109,7 @@
 	else
 		strcat(new_string, " <- ");
 	strcat(new_string, string);
-	delete host_error_string;
+	delete[] host_error_string;
 	host_error_string = NULL;
 	host_error_string = new_string;
 }
diff -Nur orig/libs/core/exception.h mod/libs/core/exception.h
--- orig/libs/core/exception.h	2010-04-03 18:27:57.000000000 +0200
+++ mod/libs/core/exception.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: exception.h 4206 2010-04-03 16:32:33Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/log.cpp mod/libs/core/log.cpp
--- orig/libs/core/log.cpp	2010-04-03 17:18:59.000000000 +0200
+++ mod/libs/core/log.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: log.cpp 4204 2010-04-03 15:23:34Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/log.h mod/libs/core/log.h
--- orig/libs/core/log.h	2010-04-03 17:18:59.000000000 +0200
+++ mod/libs/core/log.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: log.h 4204 2010-04-03 15:23:34Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/map.h mod/libs/core/map.h
--- orig/libs/core/map.h	2010-04-21 15:15:40.000000000 +0200
+++ mod/libs/core/map.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: map.h 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/matrix.cpp mod/libs/core/matrix.cpp
--- orig/libs/core/matrix.cpp	2010-05-28 19:06:49.000000000 +0200
+++ mod/libs/core/matrix.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: matrix.cpp 4279 2010-05-28 17:13:12Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/matrix.h mod/libs/core/matrix.h
--- orig/libs/core/matrix.h	2010-05-28 19:06:49.000000000 +0200
+++ mod/libs/core/matrix.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: matrix.h 4279 2010-05-28 17:13:12Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/memorystream.cpp mod/libs/core/memorystream.cpp
--- orig/libs/core/memorystream.cpp	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/memorystream.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: memorystream.cpp 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/memorystream.h mod/libs/core/memorystream.h
--- orig/libs/core/memorystream.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/memorystream.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: memorystream.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/name.cpp mod/libs/core/name.cpp
--- orig/libs/core/name.cpp	2010-12-23 20:47:55.000000000 +0100
+++ mod/libs/core/name.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: name.cpp 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/name.h mod/libs/core/name.h
--- orig/libs/core/name.h	2010-04-03 21:55:10.000000000 +0200
+++ mod/libs/core/name.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: name.h 4211 2010-04-03 19:59:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -118,7 +118,7 @@
 	}
 };
 
-inline vuint32 GetTypeHash(const VName N)
+inline vuint32 GetTypeHash(const VName& N)
 {
 	return N.GetIndex();
 }
diff -Nur orig/libs/core/names.h mod/libs/core/names.h
--- orig/libs/core/names.h	2010-11-30 12:36:15.000000000 +0100
+++ mod/libs/core/names.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: names.h 4336 2010-09-17 21:54:34Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -120,6 +120,7 @@
 REGISTER_NAME(AfterUnarchiveThinkers)
 REGISTER_NAME(FindLine)
 REGISTER_NAME(PolyThrustMobj)
+REGISTER_NAME(PolyCrushMobj)
 REGISTER_NAME(TagBusy)
 REGISTER_NAME(PolyBusy)
 REGISTER_NAME(ThingCount)
@@ -150,6 +151,7 @@
 REGISTER_NAME(SetViewPos)
 REGISTER_NAME(PreTravel)
 REGISTER_NAME(UseInventory)
+REGISTER_NAME(CheckDoubleFiringSpeed)
 REGISTER_NAME(Cheat_God)
 REGISTER_NAME(Cheat_NoClip)
 REGISTER_NAME(Cheat_Gimme)
@@ -160,6 +162,7 @@
 REGISTER_NAME(Cheat_Fly)
 REGISTER_NAME(Cheat_NoTarget)
 REGISTER_NAME(Cheat_Anubis)
+REGISTER_NAME(Cheat_Freeze)
 REGISTER_NAME(ClientStartSound)
 REGISTER_NAME(ClientStopSound)
 REGISTER_NAME(ClientStartSequence)
diff -Nur orig/libs/core/str.cpp mod/libs/core/str.cpp
--- orig/libs/core/str.cpp	2010-12-23 20:47:55.000000000 +0100
+++ mod/libs/core/str.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: str.cpp 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/stream.cpp mod/libs/core/stream.cpp
--- orig/libs/core/stream.cpp	2010-04-03 21:00:12.000000000 +0200
+++ mod/libs/core/stream.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: stream.cpp 4208 2010-04-03 19:04:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/stream.h mod/libs/core/stream.h
--- orig/libs/core/stream.h	2010-04-03 21:00:12.000000000 +0200
+++ mod/libs/core/stream.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: stream.h 4208 2010-04-03 19:04:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/str.h mod/libs/core/str.h
--- orig/libs/core/str.h	2010-12-31 14:34:43.000000000 +0100
+++ mod/libs/core/str.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: str.h 4362 2010-12-31 13:29:30Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/vector.h mod/libs/core/vector.h
--- orig/libs/core/vector.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/vector.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vector.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/xml.cpp mod/libs/core/xml.cpp
--- orig/libs/core/xml.cpp	2010-12-23 20:47:55.000000000 +0100
+++ mod/libs/core/xml.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: xml.cpp 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/xml.h mod/libs/core/xml.h
--- orig/libs/core/xml.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/libs/core/xml.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: xml.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/libs/core/zone.cpp mod/libs/core/zone.cpp
--- orig/libs/core/zone.cpp	2010-04-21 15:15:40.000000000 +0200
+++ mod/libs/core/zone.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: zone.cpp 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -38,6 +38,8 @@
 #define SMALLID				0x22
 #define LARGEID				0x33
 
+//#define ZONE_DEBUG
+
 // TYPES -------------------------------------------------------------------
 
 enum
diff -Nur orig/libs/core/zone.h mod/libs/core/zone.h
--- orig/libs/core/zone.h	2010-12-23 20:47:55.000000000 +0100
+++ mod/libs/core/zone.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: zone.h 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -101,6 +101,11 @@
 	Z_Free(Ptr);
 }
 
+inline void operator delete(void* Ptr, size_t)
+{
+	Z_Free(Ptr);
+}
+
 inline void* operator new[](size_t Size)
 {
 	return Z_Malloc(int(Size));
@@ -110,5 +115,10 @@
 {
 	Z_Free(Ptr);
 }
+
+inline void operator delete[](void* Ptr, size_t)
+{
+	Z_Free(Ptr);
+}
 
 #endif
diff -Nur orig/msvc/acc.vcproj mod/msvc/acc.vcproj
--- orig/msvc/acc.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/acc.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,262 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="acc"
-	ProjectGUID="{023239F2-F1D1-43FB-9B2C-604727C13BC5}"
-	RootNamespace="acc"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				LinkIncremental="2"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				WholeProgramOptimization="false"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				RuntimeTypeInfo="false"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="1"
-				CallingConvention="0"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				LinkIncremental="1"
-				GenerateDebugInformation="false"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				LinkTimeCodeGeneration="0"
-				SetChecksum="true"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath="..\utils\acc\acc.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\error.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\misc.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\parse.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\pcode.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\strlist.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\symbol.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\token.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath="..\utils\acc\common.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\error.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\misc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\parse.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\pcode.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\strlist.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\symbol.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\acc\token.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/acc.vcxproj mod/msvc/acc.vcxproj
--- orig/msvc/acc.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/acc.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,237 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{023239F2-F1D1-43FB-9B2C-604727C13BC5}</ProjectGuid>
+    <RootNamespace>acc</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>None</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <SetChecksum>true</SetChecksum>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <SetChecksum>true</SetChecksum>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\acc\acc.c" />
+    <ClCompile Include="..\utils\acc\error.c" />
+    <ClCompile Include="..\utils\acc\misc.c" />
+    <ClCompile Include="..\utils\acc\parse.c" />
+    <ClCompile Include="..\utils\acc\pcode.c" />
+    <ClCompile Include="..\utils\acc\strlist.c" />
+    <ClCompile Include="..\utils\acc\symbol.c" />
+    <ClCompile Include="..\utils\acc\token.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\acc\common.h" />
+    <ClInclude Include="..\utils\acc\error.h" />
+    <ClInclude Include="..\utils\acc\misc.h" />
+    <ClInclude Include="..\utils\acc\parse.h" />
+    <ClInclude Include="..\utils\acc\pcode.h" />
+    <ClInclude Include="..\utils\acc\strlist.h" />
+    <ClInclude Include="..\utils\acc\symbol.h" />
+    <ClInclude Include="..\utils\acc\token.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/acc.vcxproj.filters mod/msvc/acc.vcxproj.filters
--- orig/msvc/acc.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/acc.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,65 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\acc\acc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\acc\error.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\acc\misc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\acc\parse.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\acc\pcode.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\acc\strlist.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\acc\symbol.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\acc\token.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\acc\common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\acc\error.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\acc\misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\acc\parse.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\acc\pcode.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\acc\strlist.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\acc\symbol.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\acc\token.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_common.vcproj mod/msvc/basepak_common.vcproj
--- orig/msvc/basepak_common.vcproj	2010-11-30 12:36:12.000000000 +0100
+++ mod/msvc/basepak_common.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,1377 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="basepak_common"
-	ProjectGUID="{EE79378F-9689-40B8-99F4-B0E5872A6337}"
-	RootNamespace="progs_common_engine"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\common\basepak.ls &#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\common\basepak.ls &#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\common\basepak.ls &#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\common\basepak.ls &#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="engine"
-			>
-			<File
-				RelativePath="..\progs\common\engine\ActorDisplayWindow.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\BasePlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\ClientGameBase.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\Entity.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\GameInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\GameObject.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\Level.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\LevelInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\Object.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\PlayerReplicationInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\RootWidget.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\ScriptsParser.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\Thinker.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\Widget.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\engine\WorldInfo.vc"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="linespec"
-			>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.DoomAttack.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.DoomSpecific.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.FlagsAndAppearance.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.FreezeDeath.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.GenericAttacks.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Heretic.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Hexen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.HexenWeapons.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Inventory.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Misc.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.MissileMovement.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.MonsterAi.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Sound.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Spawn.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Special.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.StateJump.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.States.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Actor.Strife.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ActorMover.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\AimingCamera.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\AmbientSound.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Ammo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\AmmoFillup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Armor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiBlastRadius.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiBoostArmor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiDarkServant.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiHealingRadius.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiPoisonBag.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiTeleport.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiTeleportOther.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiTimeBomb.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ArtiTomeOfPower.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BackpackItem.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BasicArmor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BasicArmorBonus.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BasicArmorPickup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BlasterFX1.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BossSpot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BrainState.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Bridge.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\BridgeBall.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\CeilingMover.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\CeilingWaggle.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\CFlameMissile.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ChickenPlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ClericWeapon.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ClericWeaponPiece.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\CloseDoor222.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Coin.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\CustomInventory.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\CWeapWraithverge.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\DegninOre.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\DoomBuilderCamera.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\DummyStrifeItem.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\DynamicLight.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Elevator.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.AiUtils.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.Damage.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.Defaults.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.Head.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.Inventory.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.LineAttack.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.Misc.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.Physics.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\EntityEx.SpawnMissile.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FakeInventory.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FighterWeapon.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FighterWeaponPiece.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FireFlicker.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FlashFader.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FloorMover.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FloorWaggle.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ForceFieldGuard.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FourthWeaponHolder.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FourthWeaponPiece.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FrostMissile.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FSwordMissile.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\FWeapAxe.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\GlassShard.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\GlowingLight.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HateTarget.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Health.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HealthFillup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HealthPickup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HealthTraining.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Heresiarch.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HereticWeapon.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HexenArmor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HexenWeapon.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HolySpirit.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\HornRodFX2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\IceChunk.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\IceChunkHead.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\InterpolationPoint.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\InterpolationSpecial.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Inventory.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\InvisibleBridge.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\InvisibleBridge16.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\InvisibleBridge32.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\InvisibleBridge8.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Key.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LightEffect.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LightFlash.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Lighting.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Lightning.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LightningThinker.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LightningZap.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LineSpecialClientGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LineSpecialGameInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LineSpecialLevelInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LookAtCamera.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LoreShot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\LowerStackLookOnly.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Mace.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MaceFX4.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Macil1.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MageStaffFX2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MageWandMissile.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MageWeapon.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MageWeaponPiece.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MapRevealer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Meat.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Minotaur.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MinotaurFriend.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MorphedMonster.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MorphProjectile.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\MWeapBloodscourge.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\OpenDoor222.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\OpenDoor224.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Oracle.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ParticleFountain.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PathFollower.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PatrolSpecial.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PhasedLight.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PhoenixFX1.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PhoenixFX2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PhoenixRod.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PhoenixRodPowered.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PhosphorousFire.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PickupFlash.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PigPlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Pillar.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PlaneWatcher.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Platform.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PlayerChunk.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PlayerEx.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PlayerPawn.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PointLight.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PointLightFlicker.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PointLightFlickerRandom.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PointLightPulse.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PointPuller.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PointPusher.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PoisonBolt.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PoisonCloud.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PolyobjDoor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PolyobjMover.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PolyobjRotator.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PolyobjThinker.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Pottery1.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerCoupling.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerFlight.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerGhost.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerInvisibility.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerInvulnerable.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerIronFeet.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerLightAmp.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerMask.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerMinotaur.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerScanner.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerShadow.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerSpeed.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerStrength.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerTargeter.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerTorch.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Powerup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerupGiver.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PowerWeaponLevel2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PrisonPass.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Pusher.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\PuzzleItem.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\QuakeFocus.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\RainPillar.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\RainPlayer2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\RainPlayer3.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\RainPlayer4.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\RaiseAlarm.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Ripper.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Scanner.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ScriptedMarine.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Scroller.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActEnter.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActExit.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActEyesAboveC.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActEyesBelowC.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActEyesDive.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActEyesSurface.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActHitCeiling.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActHitFakeFloor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActHitFloor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActUse.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecActUseWall.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecretTrigger.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SectorAction.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SectorMover.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SectorPointLight.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SectorSilencer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SectorThinker.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SecurityCamera.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Sigil.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SkyPicker.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SkyViewpoint.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SlideshowStarter.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SorcBall.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SorcBall1.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SorcBall2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SorcBall3.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Sorcerer2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SoundEnvironment.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SoundSequence.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SoundSequenceSlot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Spark.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SpecialSpot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SpectralMonster.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\StackPoint.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\StairStepMover.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\StaticLightSource.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\StaticRGBLightSource.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Strobe.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SwitchableDecoration.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\SwitchingDecoration.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\TeleportDest.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\TeleportDest2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\TeleportDest3.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\TeleporterBeacon.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\TeleportFog.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\TelOtherFX1.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\TextureChangeDoor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ThrustFloorDown.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\UpgradeAccuracy.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\UpgradeStamina.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\UpperStackLookOnly.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\VerticalDoor.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\WallLightTransfer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\WaterZone.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Weapon.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\WeaponGiver.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\WeaponHolder.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\WeaponPiece.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\Whirlwind.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\WorldInfoEx.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ZBell.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ZBridge.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\linespec\ZCorpseLynchedNoHeart.vc"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="uibase"
-			>
-			<File
-				RelativePath="..\progs\common\uibase\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\ClientGameShared.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\ConDialog.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\ConDlgChoice.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\FinaleBackground.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\FinaleScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\HUDMessage.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\HUDMessageFadeInOut.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\HUDMessageFadeOut.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\HUDMessageTypeOnFadeOut.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\IntermissionBackground.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuBigTextButton.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoice.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoice_BackButton.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoice_LoadSlot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoice_OnOff.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoice_SaveSlot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoiceEnum.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoiceEpisode.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoicePClass.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoiceSkill.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoiceSlider.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuChoiceSlot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuControlKey.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuInputLine.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuModel.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuSaveSlot.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenAdvancedVideoOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenClass.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenControls.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenEpisode.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenJoinGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenLoadGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenMouseOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenSaveGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenScreenResolution.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenSinglePlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenSkill.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenSList.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenSoundOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuScreenVideoOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuSelector_Big.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuSelector_SmallLeft.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuSelector_SmallRight.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuSList.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuSmallTextButton.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuSpriteAnim.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuStaticAnim.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuStaticBitmap.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuTextButton.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\MenuTitleText.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\common\uibase\StatusBarShared.vc"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_common.vcxproj mod/msvc/basepak_common.vcxproj
--- orig/msvc/basepak_common.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_common.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,514 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{EE79378F-9689-40B8-99F4-B0E5872A6337}</ProjectGuid>
+    <RootNamespace>progs_common_engine</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\common\basepak.ls 
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\common\engine\ActorDisplayWindow.vc" />
+    <None Include="..\progs\common\engine\BasePlayer.vc" />
+    <None Include="..\progs\common\engine\classes.vc" />
+    <None Include="..\progs\common\engine\ClientGameBase.vc" />
+    <None Include="..\progs\common\engine\Entity.vc" />
+    <None Include="..\progs\common\engine\GameInfo.vc" />
+    <None Include="..\progs\common\engine\GameObject.vc" />
+    <None Include="..\progs\common\engine\Level.vc" />
+    <None Include="..\progs\common\engine\LevelInfo.vc" />
+    <None Include="..\progs\common\engine\Object.vc" />
+    <None Include="..\progs\common\engine\PlayerReplicationInfo.vc" />
+    <None Include="..\progs\common\engine\RootWidget.vc" />
+    <None Include="..\progs\common\engine\ScriptsParser.vc" />
+    <None Include="..\progs\common\engine\Thinker.vc" />
+    <None Include="..\progs\common\engine\Widget.vc" />
+    <None Include="..\progs\common\engine\WorldInfo.vc" />
+    <None Include="..\progs\common\linespec\Actor.DoomAttack.vc" />
+    <None Include="..\progs\common\linespec\Actor.DoomSpecific.vc" />
+    <None Include="..\progs\common\linespec\Actor.FlagsAndAppearance.vc" />
+    <None Include="..\progs\common\linespec\Actor.FreezeDeath.vc" />
+    <None Include="..\progs\common\linespec\Actor.GenericAttacks.vc" />
+    <None Include="..\progs\common\linespec\Actor.Heretic.vc" />
+    <None Include="..\progs\common\linespec\Actor.Hexen.vc" />
+    <None Include="..\progs\common\linespec\Actor.HexenWeapons.vc" />
+    <None Include="..\progs\common\linespec\Actor.Inventory.vc" />
+    <None Include="..\progs\common\linespec\Actor.Misc.vc" />
+    <None Include="..\progs\common\linespec\Actor.MissileMovement.vc" />
+    <None Include="..\progs\common\linespec\Actor.MonsterAi.vc" />
+    <None Include="..\progs\common\linespec\Actor.Sound.vc" />
+    <None Include="..\progs\common\linespec\Actor.Spawn.vc" />
+    <None Include="..\progs\common\linespec\Actor.Special.vc" />
+    <None Include="..\progs\common\linespec\Actor.StateJump.vc" />
+    <None Include="..\progs\common\linespec\Actor.States.vc" />
+    <None Include="..\progs\common\linespec\Actor.Strife.vc" />
+    <None Include="..\progs\common\linespec\ActorMover.vc" />
+    <None Include="..\progs\common\linespec\AimingCamera.vc" />
+    <None Include="..\progs\common\linespec\AmbientSound.vc" />
+    <None Include="..\progs\common\linespec\Ammo.vc" />
+    <None Include="..\progs\common\linespec\AmmoFillup.vc" />
+    <None Include="..\progs\common\linespec\Armor.vc" />
+    <None Include="..\progs\common\linespec\ArtiBlastRadius.vc" />
+    <None Include="..\progs\common\linespec\ArtiBoostArmor.vc" />
+    <None Include="..\progs\common\linespec\ArtiDarkServant.vc" />
+    <None Include="..\progs\common\linespec\ArtiHealingRadius.vc" />
+    <None Include="..\progs\common\linespec\ArtiPoisonBag.vc" />
+    <None Include="..\progs\common\linespec\ArtiTeleport.vc" />
+    <None Include="..\progs\common\linespec\ArtiTeleportOther.vc" />
+    <None Include="..\progs\common\linespec\ArtiTimeBomb.vc" />
+    <None Include="..\progs\common\linespec\ArtiTomeOfPower.vc" />
+    <None Include="..\progs\common\linespec\BackpackItem.vc" />
+    <None Include="..\progs\common\linespec\BasicArmor.vc" />
+    <None Include="..\progs\common\linespec\BasicArmorBonus.vc" />
+    <None Include="..\progs\common\linespec\BasicArmorPickup.vc" />
+    <None Include="..\progs\common\linespec\BlasterFX1.vc" />
+    <None Include="..\progs\common\linespec\BossSpot.vc" />
+    <None Include="..\progs\common\linespec\BrainState.vc" />
+    <None Include="..\progs\common\linespec\Bridge.vc" />
+    <None Include="..\progs\common\linespec\BridgeBall.vc" />
+    <None Include="..\progs\common\linespec\CeilingMover.vc" />
+    <None Include="..\progs\common\linespec\CeilingWaggle.vc" />
+    <None Include="..\progs\common\linespec\CFlameMissile.vc" />
+    <None Include="..\progs\common\linespec\ChickenPlayer.vc" />
+    <None Include="..\progs\common\linespec\classes.vc" />
+    <None Include="..\progs\common\linespec\ClericWeapon.vc" />
+    <None Include="..\progs\common\linespec\ClericWeaponPiece.vc" />
+    <None Include="..\progs\common\linespec\CloseDoor222.vc" />
+    <None Include="..\progs\common\linespec\Coin.vc" />
+    <None Include="..\progs\common\linespec\CustomInventory.vc" />
+    <None Include="..\progs\common\linespec\CWeapWraithverge.vc" />
+    <None Include="..\progs\common\linespec\DegninOre.vc" />
+    <None Include="..\progs\common\linespec\DoomBuilderCamera.vc" />
+    <None Include="..\progs\common\linespec\DummyStrifeItem.vc" />
+    <None Include="..\progs\common\linespec\DynamicLight.vc" />
+    <None Include="..\progs\common\linespec\Elevator.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.AiUtils.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.Damage.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.Defaults.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.Head.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.Inventory.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.LineAttack.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.Misc.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.Morph.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.Physics.vc" />
+    <None Include="..\progs\common\linespec\EntityEx.SpawnMissile.vc" />
+    <None Include="..\progs\common\linespec\FakeInventory.vc" />
+    <None Include="..\progs\common\linespec\FastProjectile.vc" />
+    <None Include="..\progs\common\linespec\FighterWeapon.vc" />
+    <None Include="..\progs\common\linespec\FighterWeaponPiece.vc" />
+    <None Include="..\progs\common\linespec\FireFlicker.vc" />
+    <None Include="..\progs\common\linespec\FlashFader.vc" />
+    <None Include="..\progs\common\linespec\FloorMover.vc" />
+    <None Include="..\progs\common\linespec\FloorWaggle.vc" />
+    <None Include="..\progs\common\linespec\ForceFieldGuard.vc" />
+    <None Include="..\progs\common\linespec\FourthWeaponHolder.vc" />
+    <None Include="..\progs\common\linespec\FourthWeaponPiece.vc" />
+    <None Include="..\progs\common\linespec\FrostMissile.vc" />
+    <None Include="..\progs\common\linespec\FSwordMissile.vc" />
+    <None Include="..\progs\common\linespec\FWeapAxe.vc" />
+    <None Include="..\progs\common\linespec\GlassShard.vc" />
+    <None Include="..\progs\common\linespec\GlowingLight.vc" />
+    <None Include="..\progs\common\linespec\HateTarget.vc" />
+    <None Include="..\progs\common\linespec\Health.vc" />
+    <None Include="..\progs\common\linespec\HealthFillup.vc" />
+    <None Include="..\progs\common\linespec\HealthPickup.vc" />
+    <None Include="..\progs\common\linespec\HealthTraining.vc" />
+    <None Include="..\progs\common\linespec\Heresiarch.vc" />
+    <None Include="..\progs\common\linespec\HereticWeapon.vc" />
+    <None Include="..\progs\common\linespec\HexenArmor.vc" />
+    <None Include="..\progs\common\linespec\HexenWeapon.vc" />
+    <None Include="..\progs\common\linespec\HolySpirit.vc" />
+    <None Include="..\progs\common\linespec\HornRodFX2.vc" />
+    <None Include="..\progs\common\linespec\IceChunk.vc" />
+    <None Include="..\progs\common\linespec\IceChunkHead.vc" />
+    <None Include="..\progs\common\linespec\InterpolationPoint.vc" />
+    <None Include="..\progs\common\linespec\InterpolationSpecial.vc" />
+    <None Include="..\progs\common\linespec\Inventory.vc" />
+    <None Include="..\progs\common\linespec\InvisibleBridge.vc" />
+    <None Include="..\progs\common\linespec\InvisibleBridge16.vc" />
+    <None Include="..\progs\common\linespec\InvisibleBridge32.vc" />
+    <None Include="..\progs\common\linespec\InvisibleBridge8.vc" />
+    <None Include="..\progs\common\linespec\Key.vc" />
+    <None Include="..\progs\common\linespec\LightEffect.vc" />
+    <None Include="..\progs\common\linespec\LightFlash.vc" />
+    <None Include="..\progs\common\linespec\Lighting.vc" />
+    <None Include="..\progs\common\linespec\Lightning.vc" />
+    <None Include="..\progs\common\linespec\LightningThinker.vc" />
+    <None Include="..\progs\common\linespec\LightningZap.vc" />
+    <None Include="..\progs\common\linespec\LineSpecialClientGame.vc" />
+    <None Include="..\progs\common\linespec\LineSpecialGameInfo.vc" />
+    <None Include="..\progs\common\linespec\LineSpecialLevelInfo.vc" />
+    <None Include="..\progs\common\linespec\LookAtCamera.vc" />
+    <None Include="..\progs\common\linespec\LoreShot.vc" />
+    <None Include="..\progs\common\linespec\LowerStackLookOnly.vc" />
+    <None Include="..\progs\common\linespec\Mace.vc" />
+    <None Include="..\progs\common\linespec\MaceFX4.vc" />
+    <None Include="..\progs\common\linespec\Macil1.vc" />
+    <None Include="..\progs\common\linespec\MageStaffFX2.vc" />
+    <None Include="..\progs\common\linespec\MageWandMissile.vc" />
+    <None Include="..\progs\common\linespec\MageWeapon.vc" />
+    <None Include="..\progs\common\linespec\MageWeaponPiece.vc" />
+    <None Include="..\progs\common\linespec\MapRevealer.vc" />
+    <None Include="..\progs\common\linespec\Meat.vc" />
+    <None Include="..\progs\common\linespec\Minotaur.vc" />
+    <None Include="..\progs\common\linespec\MinotaurFriend.vc" />
+    <None Include="..\progs\common\linespec\MorphedMonster.vc" />
+    <None Include="..\progs\common\linespec\MorphProjectile.vc" />
+    <None Include="..\progs\common\linespec\MWeapBloodscourge.vc" />
+    <None Include="..\progs\common\linespec\OpenDoor222.vc" />
+    <None Include="..\progs\common\linespec\OpenDoor224.vc" />
+    <None Include="..\progs\common\linespec\Oracle.vc" />
+    <None Include="..\progs\common\linespec\ParticleFountain.vc" />
+    <None Include="..\progs\common\linespec\PathFollower.vc" />
+    <None Include="..\progs\common\linespec\PatrolSpecial.vc" />
+    <None Include="..\progs\common\linespec\PhasedLight.vc" />
+    <None Include="..\progs\common\linespec\PhoenixFX1.vc" />
+    <None Include="..\progs\common\linespec\PhoenixFX2.vc" />
+    <None Include="..\progs\common\linespec\PhoenixRod.vc" />
+    <None Include="..\progs\common\linespec\PhoenixRodPowered.vc" />
+    <None Include="..\progs\common\linespec\PhosphorousFire.vc" />
+    <None Include="..\progs\common\linespec\PickupFlash.vc" />
+    <None Include="..\progs\common\linespec\PigPlayer.vc" />
+    <None Include="..\progs\common\linespec\Pillar.vc" />
+    <None Include="..\progs\common\linespec\PlaneWatcher.vc" />
+    <None Include="..\progs\common\linespec\Platform.vc" />
+    <None Include="..\progs\common\linespec\PlayerChunk.vc" />
+    <None Include="..\progs\common\linespec\PlayerEx.vc" />
+    <None Include="..\progs\common\linespec\PlayerPawn.vc" />
+    <None Include="..\progs\common\linespec\PointLight.vc" />
+    <None Include="..\progs\common\linespec\PointLightFlicker.vc" />
+    <None Include="..\progs\common\linespec\PointLightFlickerRandom.vc" />
+    <None Include="..\progs\common\linespec\PointLightPulse.vc" />
+    <None Include="..\progs\common\linespec\PointPuller.vc" />
+    <None Include="..\progs\common\linespec\PointPusher.vc" />
+    <None Include="..\progs\common\linespec\PoisonBolt.vc" />
+    <None Include="..\progs\common\linespec\PoisonCloud.vc" />
+    <None Include="..\progs\common\linespec\PolyobjDoor.vc" />
+    <None Include="..\progs\common\linespec\PolyobjMover.vc" />
+    <None Include="..\progs\common\linespec\PolyobjRotator.vc" />
+    <None Include="..\progs\common\linespec\PolyobjThinker.vc" />
+    <None Include="..\progs\common\linespec\Pottery1.vc" />
+    <None Include="..\progs\common\linespec\PowerCoupling.vc" />
+    <None Include="..\progs\common\linespec\PowerDamage.vc" />
+    <None Include="..\progs\common\linespec\PowerDoubleFiringSpeed.vc" />
+    <None Include="..\progs\common\linespec\PowerFlight.vc" />
+    <None Include="..\progs\common\linespec\PowerFrightener.vc" />
+    <None Include="..\progs\common\linespec\PowerGhost.vc" />
+    <None Include="..\progs\common\linespec\PowerHighJump.vc" />
+    <None Include="..\progs\common\linespec\PowerInfiniteAmmo.vc" />
+    <None Include="..\progs\common\linespec\PowerInvisibility.vc" />
+    <None Include="..\progs\common\linespec\PowerInvulnerable.vc" />
+    <None Include="..\progs\common\linespec\PowerIronFeet.vc" />
+    <None Include="..\progs\common\linespec\PowerLightAmp.vc" />
+    <None Include="..\progs\common\linespec\PowerMask.vc" />
+    <None Include="..\progs\common\linespec\PowerMinotaur.vc" />
+    <None Include="..\progs\common\linespec\PowerMorph.vc" />
+    <None Include="..\progs\common\linespec\PowerProtection.vc" />
+    <None Include="..\progs\common\linespec\PowerRegeneration.vc" />
+    <None Include="..\progs\common\linespec\PowerScanner.vc" />
+    <None Include="..\progs\common\linespec\PowerShadow.vc" />
+    <None Include="..\progs\common\linespec\PowerSpeed.vc" />
+    <None Include="..\progs\common\linespec\PowerStrength.vc" />
+    <None Include="..\progs\common\linespec\PowerTargeter.vc" />
+    <None Include="..\progs\common\linespec\PowerTimeFreeze.vc" />
+    <None Include="..\progs\common\linespec\PowerTorch.vc" />
+    <None Include="..\progs\common\linespec\Powerup.vc" />
+    <None Include="..\progs\common\linespec\PowerupGiver.vc" />
+    <None Include="..\progs\common\linespec\PowerWeaponLevel2.vc" />
+    <None Include="..\progs\common\linespec\PrisonPass.vc" />
+    <None Include="..\progs\common\linespec\Pusher.vc" />
+    <None Include="..\progs\common\linespec\PuzzleItem.vc" />
+    <None Include="..\progs\common\linespec\QuakeFocus.vc" />
+    <None Include="..\progs\common\linespec\RainPillar.vc" />
+    <None Include="..\progs\common\linespec\RainPlayer2.vc" />
+    <None Include="..\progs\common\linespec\RainPlayer3.vc" />
+    <None Include="..\progs\common\linespec\RainPlayer4.vc" />
+    <None Include="..\progs\common\linespec\RaiseAlarm.vc" />
+    <None Include="..\progs\common\linespec\RandomSpawner.vc" />
+    <None Include="..\progs\common\linespec\Ripper.vc" />
+    <None Include="..\progs\common\linespec\Scanner.vc" />
+    <None Include="..\progs\common\linespec\ScriptedMarine.vc" />
+    <None Include="..\progs\common\linespec\Scroller.vc" />
+    <None Include="..\progs\common\linespec\SecActEnter.vc" />
+    <None Include="..\progs\common\linespec\SecActExit.vc" />
+    <None Include="..\progs\common\linespec\SecActEyesAboveC.vc" />
+    <None Include="..\progs\common\linespec\SecActEyesBelowC.vc" />
+    <None Include="..\progs\common\linespec\SecActEyesDive.vc" />
+    <None Include="..\progs\common\linespec\SecActEyesSurface.vc" />
+    <None Include="..\progs\common\linespec\SecActHitCeiling.vc" />
+    <None Include="..\progs\common\linespec\SecActHitFakeFloor.vc" />
+    <None Include="..\progs\common\linespec\SecActHitFloor.vc" />
+    <None Include="..\progs\common\linespec\SecActUse.vc" />
+    <None Include="..\progs\common\linespec\SecActUseWall.vc" />
+    <None Include="..\progs\common\linespec\SecretTrigger.vc" />
+    <None Include="..\progs\common\linespec\SectorAction.vc" />
+    <None Include="..\progs\common\linespec\SectorMover.vc" />
+    <None Include="..\progs\common\linespec\SectorPointLight.vc" />
+    <None Include="..\progs\common\linespec\SectorSilencer.vc" />
+    <None Include="..\progs\common\linespec\SectorThinker.vc" />
+    <None Include="..\progs\common\linespec\SecurityCamera.vc" />
+    <None Include="..\progs\common\linespec\Sigil.vc" />
+    <None Include="..\progs\common\linespec\SkyPicker.vc" />
+    <None Include="..\progs\common\linespec\SkyViewpoint.vc" />
+    <None Include="..\progs\common\linespec\SlideshowStarter.vc" />
+    <None Include="..\progs\common\linespec\SorcBall.vc" />
+    <None Include="..\progs\common\linespec\SorcBall1.vc" />
+    <None Include="..\progs\common\linespec\SorcBall2.vc" />
+    <None Include="..\progs\common\linespec\SorcBall3.vc" />
+    <None Include="..\progs\common\linespec\Sorcerer2.vc" />
+    <None Include="..\progs\common\linespec\SoundEnvironment.vc" />
+    <None Include="..\progs\common\linespec\SoundSequence.vc" />
+    <None Include="..\progs\common\linespec\SoundSequenceSlot.vc" />
+    <None Include="..\progs\common\linespec\Spark.vc" />
+    <None Include="..\progs\common\linespec\SpecialSpot.vc" />
+    <None Include="..\progs\common\linespec\SpectralMonster.vc" />
+    <None Include="..\progs\common\linespec\StackPoint.vc" />
+    <None Include="..\progs\common\linespec\StairStepMover.vc" />
+    <None Include="..\progs\common\linespec\StaticLightSource.vc" />
+    <None Include="..\progs\common\linespec\StaticRGBLightSource.vc" />
+    <None Include="..\progs\common\linespec\Strobe.vc" />
+    <None Include="..\progs\common\linespec\SwitchableDecoration.vc" />
+    <None Include="..\progs\common\linespec\SwitchingDecoration.vc" />
+    <None Include="..\progs\common\linespec\TeleportDest.vc" />
+    <None Include="..\progs\common\linespec\TeleportDest2.vc" />
+    <None Include="..\progs\common\linespec\TeleportDest3.vc" />
+    <None Include="..\progs\common\linespec\TeleporterBeacon.vc" />
+    <None Include="..\progs\common\linespec\TeleportFog.vc" />
+    <None Include="..\progs\common\linespec\TelOtherFX1.vc" />
+    <None Include="..\progs\common\linespec\TextureChangeDoor.vc" />
+    <None Include="..\progs\common\linespec\ThrustFloorDown.vc" />
+    <None Include="..\progs\common\linespec\UpgradeAccuracy.vc" />
+    <None Include="..\progs\common\linespec\UpgradeStamina.vc" />
+    <None Include="..\progs\common\linespec\UpperStackLookOnly.vc" />
+    <None Include="..\progs\common\linespec\VerticalDoor.vc" />
+    <None Include="..\progs\common\linespec\WallLightTransfer.vc" />
+    <None Include="..\progs\common\linespec\WaterZone.vc" />
+    <None Include="..\progs\common\linespec\Weapon.vc" />
+    <None Include="..\progs\common\linespec\WeaponGiver.vc" />
+    <None Include="..\progs\common\linespec\WeaponHolder.vc" />
+    <None Include="..\progs\common\linespec\WeaponPiece.vc" />
+    <None Include="..\progs\common\linespec\Whirlwind.vc" />
+    <None Include="..\progs\common\linespec\WorldInfoEx.vc" />
+    <None Include="..\progs\common\linespec\ZBell.vc" />
+    <None Include="..\progs\common\linespec\ZBridge.vc" />
+    <None Include="..\progs\common\linespec\ZCorpseLynchedNoHeart.vc" />
+    <None Include="..\progs\common\uibase\classes.vc" />
+    <None Include="..\progs\common\uibase\ClientGameShared.vc" />
+    <None Include="..\progs\common\uibase\ConDialog.vc" />
+    <None Include="..\progs\common\uibase\ConDlgChoice.vc" />
+    <None Include="..\progs\common\uibase\FinaleBackground.vc" />
+    <None Include="..\progs\common\uibase\FinaleScreen.vc" />
+    <None Include="..\progs\common\uibase\HUDMessage.vc" />
+    <None Include="..\progs\common\uibase\HUDMessageFadeInOut.vc" />
+    <None Include="..\progs\common\uibase\HUDMessageFadeOut.vc" />
+    <None Include="..\progs\common\uibase\HUDMessageTypeOnFadeOut.vc" />
+    <None Include="..\progs\common\uibase\IntermissionBackground.vc" />
+    <None Include="..\progs\common\uibase\MenuBigTextButton.vc" />
+    <None Include="..\progs\common\uibase\MenuChoice.vc" />
+    <None Include="..\progs\common\uibase\MenuChoice_BackButton.vc" />
+    <None Include="..\progs\common\uibase\MenuChoice_LoadSlot.vc" />
+    <None Include="..\progs\common\uibase\MenuChoice_OnOff.vc" />
+    <None Include="..\progs\common\uibase\MenuChoice_SaveSlot.vc" />
+    <None Include="..\progs\common\uibase\MenuChoiceEnum.vc" />
+    <None Include="..\progs\common\uibase\MenuChoiceEpisode.vc" />
+    <None Include="..\progs\common\uibase\MenuChoicePClass.vc" />
+    <None Include="..\progs\common\uibase\MenuChoiceSkill.vc" />
+    <None Include="..\progs\common\uibase\MenuChoiceSlider.vc" />
+    <None Include="..\progs\common\uibase\MenuChoiceSlot.vc" />
+    <None Include="..\progs\common\uibase\MenuControlKey.vc" />
+    <None Include="..\progs\common\uibase\MenuInputLine.vc" />
+    <None Include="..\progs\common\uibase\MenuModel.vc" />
+    <None Include="..\progs\common\uibase\MenuSaveSlot.vc" />
+    <None Include="..\progs\common\uibase\MenuScreen.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenAdvancedVideoOptions.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenClass.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenControls.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenEpisode.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenJoinGame.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenLoadGame.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenMasterList.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenMODOptions.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenMouseOptions.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenSaveGame.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenScreenResolution.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenSinglePlayer.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenSkill.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenSList.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenSoundOptions.vc" />
+    <None Include="..\progs\common\uibase\MenuScreenVideoOptions.vc" />
+    <None Include="..\progs\common\uibase\MenuSelector_Big.vc" />
+    <None Include="..\progs\common\uibase\MenuSelector_SmallLeft.vc" />
+    <None Include="..\progs\common\uibase\MenuSelector_SmallRight.vc" />
+    <None Include="..\progs\common\uibase\MenuSList.vc" />
+    <None Include="..\progs\common\uibase\MenuSmallTextButton.vc" />
+    <None Include="..\progs\common\uibase\MenuSpriteAnim.vc" />
+    <None Include="..\progs\common\uibase\MenuStaticAnim.vc" />
+    <None Include="..\progs\common\uibase\MenuStaticBitmap.vc" />
+    <None Include="..\progs\common\uibase\MenuTextButton.vc" />
+    <None Include="..\progs\common\uibase\MenuTitleText.vc" />
+    <None Include="..\progs\common\uibase\StatusBarShared.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_common.vcxproj.filters mod/msvc/basepak_common.vcxproj.filters
--- orig/msvc/basepak_common.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_common.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1033 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="engine">
+      <UniqueIdentifier>{f237c5c2-fe60-4598-8e72-4f9f0e903a5e}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="linespec">
+      <UniqueIdentifier>{b4249f95-93b7-46f7-84f7-e20ff0ce7fed}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="uibase">
+      <UniqueIdentifier>{043d67e3-c954-402f-858b-a8a3317abffc}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\progs\common\engine\ActorDisplayWindow.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\BasePlayer.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\classes.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\ClientGameBase.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\Entity.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\GameInfo.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\GameObject.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\Level.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\LevelInfo.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\Object.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\PlayerReplicationInfo.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\RootWidget.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\ScriptsParser.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\Thinker.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\Widget.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\engine\WorldInfo.vc">
+      <Filter>engine</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.DoomAttack.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.DoomSpecific.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.FlagsAndAppearance.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.FreezeDeath.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.GenericAttacks.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Heretic.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Hexen.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.HexenWeapons.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Inventory.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Misc.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.MissileMovement.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.MonsterAi.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Sound.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Spawn.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Special.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.StateJump.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.States.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Actor.Strife.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ActorMover.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\AimingCamera.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\AmbientSound.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Ammo.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\AmmoFillup.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Armor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiBlastRadius.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiBoostArmor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiDarkServant.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiHealingRadius.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiPoisonBag.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiTeleport.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiTeleportOther.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiTimeBomb.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ArtiTomeOfPower.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BackpackItem.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BasicArmor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BasicArmorBonus.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BasicArmorPickup.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BlasterFX1.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BossSpot.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BrainState.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Bridge.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\BridgeBall.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\CeilingMover.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\CeilingWaggle.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\CFlameMissile.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ChickenPlayer.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\classes.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ClericWeapon.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ClericWeaponPiece.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\CloseDoor222.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Coin.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\CustomInventory.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\CWeapWraithverge.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\DegninOre.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\DoomBuilderCamera.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\DummyStrifeItem.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\DynamicLight.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Elevator.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.AiUtils.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.Damage.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.Defaults.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.Head.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.Inventory.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.LineAttack.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.Misc.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.Morph.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.Physics.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\EntityEx.SpawnMissile.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FakeInventory.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FastProjectile.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FighterWeapon.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FighterWeaponPiece.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FireFlicker.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FlashFader.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FloorMover.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FloorWaggle.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ForceFieldGuard.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FourthWeaponHolder.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FourthWeaponPiece.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FrostMissile.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FSwordMissile.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\FWeapAxe.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\GlassShard.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\GlowingLight.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HateTarget.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Health.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HealthFillup.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HealthPickup.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HealthTraining.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Heresiarch.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HereticWeapon.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HexenArmor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HexenWeapon.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HolySpirit.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\HornRodFX2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\IceChunk.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\IceChunkHead.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\InterpolationPoint.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\InterpolationSpecial.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Inventory.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\InvisibleBridge.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\InvisibleBridge16.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\InvisibleBridge32.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\InvisibleBridge8.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Key.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LightEffect.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LightFlash.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Lighting.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Lightning.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LightningThinker.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LightningZap.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LineSpecialClientGame.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LineSpecialGameInfo.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LineSpecialLevelInfo.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LookAtCamera.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LoreShot.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\LowerStackLookOnly.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Mace.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MaceFX4.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Macil1.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MageStaffFX2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MageWandMissile.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MageWeapon.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MageWeaponPiece.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MapRevealer.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Meat.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Minotaur.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MinotaurFriend.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MorphedMonster.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MorphProjectile.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\MWeapBloodscourge.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\OpenDoor222.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\OpenDoor224.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Oracle.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ParticleFountain.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PathFollower.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PatrolSpecial.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PhasedLight.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PhoenixFX1.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PhoenixFX2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PhoenixRod.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PhoenixRodPowered.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PhosphorousFire.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PickupFlash.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PigPlayer.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Pillar.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PlaneWatcher.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Platform.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PlayerChunk.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PlayerEx.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PlayerPawn.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PointLight.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PointLightFlicker.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PointLightFlickerRandom.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PointLightPulse.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PointPuller.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PointPusher.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PoisonBolt.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PoisonCloud.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PolyobjDoor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PolyobjMover.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PolyobjRotator.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PolyobjThinker.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Pottery1.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerCoupling.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerDamage.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerDoubleFiringSpeed.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerFlight.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerFrightener.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerGhost.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerHighJump.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerInfiniteAmmo.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerInvisibility.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerInvulnerable.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerIronFeet.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerLightAmp.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerMask.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerMinotaur.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerMorph.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerProtection.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerRegeneration.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerScanner.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerShadow.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerSpeed.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerStrength.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerTargeter.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerTimeFreeze.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerTorch.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Powerup.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerupGiver.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PowerWeaponLevel2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PrisonPass.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Pusher.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\PuzzleItem.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\QuakeFocus.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\RainPillar.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\RainPlayer2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\RainPlayer3.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\RainPlayer4.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\RaiseAlarm.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\RandomSpawner.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Ripper.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Scanner.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ScriptedMarine.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Scroller.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActEnter.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActExit.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActEyesAboveC.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActEyesBelowC.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActEyesDive.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActEyesSurface.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActHitCeiling.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActHitFakeFloor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActHitFloor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActUse.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecActUseWall.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecretTrigger.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SectorAction.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SectorMover.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SectorPointLight.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SectorSilencer.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SectorThinker.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SecurityCamera.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Sigil.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SkyPicker.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SkyViewpoint.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SlideshowStarter.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SorcBall.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SorcBall1.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SorcBall2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SorcBall3.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Sorcerer2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SoundEnvironment.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SoundSequence.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SoundSequenceSlot.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Spark.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SpecialSpot.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SpectralMonster.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\StackPoint.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\StairStepMover.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\StaticLightSource.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\StaticRGBLightSource.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Strobe.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SwitchableDecoration.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\SwitchingDecoration.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\TeleportDest.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\TeleportDest2.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\TeleportDest3.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\TeleporterBeacon.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\TeleportFog.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\TelOtherFX1.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\TextureChangeDoor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ThrustFloorDown.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\UpgradeAccuracy.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\UpgradeStamina.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\UpperStackLookOnly.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\VerticalDoor.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\WallLightTransfer.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\WaterZone.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Weapon.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\WeaponGiver.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\WeaponHolder.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\WeaponPiece.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\Whirlwind.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\WorldInfoEx.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ZBell.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ZBridge.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\linespec\ZCorpseLynchedNoHeart.vc">
+      <Filter>linespec</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\classes.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\ClientGameShared.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\ConDialog.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\ConDlgChoice.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\FinaleBackground.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\FinaleScreen.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\HUDMessage.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\HUDMessageFadeInOut.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\HUDMessageFadeOut.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\HUDMessageTypeOnFadeOut.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\IntermissionBackground.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuBigTextButton.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoice.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoice_BackButton.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoice_LoadSlot.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoice_OnOff.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoice_SaveSlot.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoiceEnum.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoiceEpisode.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoicePClass.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoiceSkill.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoiceSlider.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuChoiceSlot.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuControlKey.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuInputLine.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuModel.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuSaveSlot.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreen.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenAdvancedVideoOptions.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenClass.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenControls.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenEpisode.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenJoinGame.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenLoadGame.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenMasterList.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenMODOptions.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenMouseOptions.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenSaveGame.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenScreenResolution.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenSinglePlayer.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenSkill.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenSList.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenSoundOptions.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuScreenVideoOptions.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuSelector_Big.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuSelector_SmallLeft.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuSelector_SmallRight.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuSList.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuSmallTextButton.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuSpriteAnim.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuStaticAnim.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuStaticBitmap.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuTextButton.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\MenuTitleText.vc">
+      <Filter>uibase</Filter>
+    </None>
+    <None Include="..\progs\common\uibase\StatusBarShared.vc">
+      <Filter>uibase</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_doom1.vcproj mod/msvc/basepak_doom1.vcproj
--- orig/msvc/basepak_doom1.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_doom1.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,149 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_doom1"
-	ProjectGUID="{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}"
-	RootNamespace="basepak_doom1"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="196613"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom1\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom1\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output=""
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			CharacterSet="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom1\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom1\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="cgame"
-			>
-			<File
-				RelativePath="..\progs\doom\cgame\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\ClientGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\IntermissionScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenControls2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenGameplayOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenHelp.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenMain.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenMultiplayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenNewNetGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenPlayerSetup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\StatusBarScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\TitleScreen.vc"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="game"
-			>
-			<File
-				RelativePath="..\progs\doom\game\BotPlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\DoomLevelInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\MainGameInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\Player.vc"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_doom1.vcxproj mod/msvc/basepak_doom1.vcxproj
--- orig/msvc/basepak_doom1.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_doom1.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,203 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}</ProjectGuid>
+    <RootNamespace>basepak_doom1</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom1\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\doom\cgame\classes.vc" />
+    <None Include="..\progs\doom\cgame\ClientGame.vc" />
+    <None Include="..\progs\doom\cgame\IntermissionScreen.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenControls2.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenGameplayOptions.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenHelp.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenMain.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenMultiplayer.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenNewNetGame.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenOptions.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenPlayerSetup.vc" />
+    <None Include="..\progs\doom\cgame\StatusBarScreen.vc" />
+    <None Include="..\progs\doom\cgame\TitleScreen.vc" />
+    <None Include="..\progs\doom\game\BotPlayer.vc" />
+    <None Include="..\progs\doom\game\classes.vc" />
+    <None Include="..\progs\doom\game\DoomLevelInfo.vc" />
+    <None Include="..\progs\doom\game\MainGameInfo.vc" />
+    <None Include="..\progs\doom\game\Player.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_doom1.vcxproj.filters mod/msvc/basepak_doom1.vcxproj.filters
--- orig/msvc/basepak_doom1.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_doom1.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,67 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="cgame">
+      <UniqueIdentifier>{b531b711-28c8-4995-96a9-3f123a68a800}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="game">
+      <UniqueIdentifier>{a9f6370e-1b42-47c0-97cb-c8e1240bcee2}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\progs\doom\cgame\classes.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\ClientGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\IntermissionScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenControls2.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenGameplayOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenHelp.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenMain.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenMultiplayer.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenNewNetGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenPlayerSetup.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\StatusBarScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\TitleScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\game\BotPlayer.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\classes.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\DoomLevelInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\MainGameInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\Player.vc">
+      <Filter>game</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_doom2.vcproj mod/msvc/basepak_doom2.vcproj
--- orig/msvc/basepak_doom2.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_doom2.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_doom2"
-	ProjectGUID="{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}"
-	RootNamespace="progs_doom2"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom2\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom2\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom2\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom2\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<File
-			RelativePath="..\progs\doom2\cgame.vc"
-			>
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_doom2.vcxproj mod/msvc/basepak_doom2.vcxproj
--- orig/msvc/basepak_doom2.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_doom2.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,180 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}</ProjectGuid>
+    <RootNamespace>progs_doom2</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom2\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\doom2\cgame.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_doom.vcproj mod/msvc/basepak_doom.vcproj
--- orig/msvc/basepak_doom.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_doom.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,145 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_doom"
-	ProjectGUID="{607F2422-5660-4D06-B604-C975A30E5CD5}"
-	RootNamespace="progs_common_linespec"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\doom\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="game"
-			>
-			<File
-				RelativePath="..\progs\doom\game\BotPlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\DoomLevelInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\MainGameInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\game\Player.vc"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="cgame"
-			>
-			<File
-				RelativePath="..\progs\doom\cgame\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\ClientGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\IntermissionScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenControls2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenGameplayOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenHelp.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenMain.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenMultiplayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenNewNetGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\MenuScreenPlayerSetup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\StatusBarScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\doom\cgame\TitleScreen.vc"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_doom.vcxproj mod/msvc/basepak_doom.vcxproj
--- orig/msvc/basepak_doom.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_doom.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,197 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{607F2422-5660-4D06-B604-C975A30E5CD5}</ProjectGuid>
+    <RootNamespace>progs_common_linespec</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\doom\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\doom\game\BotPlayer.vc" />
+    <None Include="..\progs\doom\game\classes.vc" />
+    <None Include="..\progs\doom\game\DoomLevelInfo.vc" />
+    <None Include="..\progs\doom\game\MainGameInfo.vc" />
+    <None Include="..\progs\doom\game\Player.vc" />
+    <None Include="..\progs\doom\cgame\classes.vc" />
+    <None Include="..\progs\doom\cgame\ClientGame.vc" />
+    <None Include="..\progs\doom\cgame\IntermissionScreen.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenControls2.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenGameplayOptions.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenHelp.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenMain.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenMultiplayer.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenNewNetGame.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenOptions.vc" />
+    <None Include="..\progs\doom\cgame\MenuScreenPlayerSetup.vc" />
+    <None Include="..\progs\doom\cgame\StatusBarScreen.vc" />
+    <None Include="..\progs\doom\cgame\TitleScreen.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_doom.vcxproj.filters mod/msvc/basepak_doom.vcxproj.filters
--- orig/msvc/basepak_doom.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_doom.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,67 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="game">
+      <UniqueIdentifier>{14a59967-a8cf-451c-b9fa-d06a86499b2c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="cgame">
+      <UniqueIdentifier>{e351619d-674f-4b89-b1e2-97f2f0ce6855}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\progs\doom\game\BotPlayer.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\classes.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\DoomLevelInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\MainGameInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\game\Player.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\classes.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\ClientGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\IntermissionScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenControls2.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenGameplayOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenHelp.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenMain.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenMultiplayer.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenNewNetGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\MenuScreenPlayerSetup.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\StatusBarScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\doom\cgame\TitleScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_heretic.vcproj mod/msvc/basepak_heretic.vcproj
--- orig/msvc/basepak_heretic.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_heretic.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,145 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_heretic"
-	ProjectGUID="{AEDD4819-EE4F-4A94-9776-10C430A9D291}"
-	RootNamespace="progs_doom_cgame"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\heretic\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\heretic\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\heretic\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\heretic\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="cgame"
-			>
-			<File
-				RelativePath="..\progs\heretic\cgame\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\ClientGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\IntermissionScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenControls2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenGameplayOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenHelp.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenMain.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenMultiplayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenNewNetGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\MenuScreenPlayerSetup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\StatusBarScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\cgame\TitleScreen.vc"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="game"
-			>
-			<File
-				RelativePath="..\progs\heretic\game\BotPlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\game\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\game\HereticLevelInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\game\MainGameInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\heretic\game\Player.vc"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_heretic.vcxproj mod/msvc/basepak_heretic.vcxproj
--- orig/msvc/basepak_heretic.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_heretic.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,197 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{AEDD4819-EE4F-4A94-9776-10C430A9D291}</ProjectGuid>
+    <RootNamespace>progs_doom_cgame</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\heretic\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\heretic\cgame\classes.vc" />
+    <None Include="..\progs\heretic\cgame\ClientGame.vc" />
+    <None Include="..\progs\heretic\cgame\IntermissionScreen.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenControls2.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenGameplayOptions.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenHelp.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenMain.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenMultiplayer.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenNewNetGame.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenOptions.vc" />
+    <None Include="..\progs\heretic\cgame\MenuScreenPlayerSetup.vc" />
+    <None Include="..\progs\heretic\cgame\StatusBarScreen.vc" />
+    <None Include="..\progs\heretic\cgame\TitleScreen.vc" />
+    <None Include="..\progs\heretic\game\BotPlayer.vc" />
+    <None Include="..\progs\heretic\game\classes.vc" />
+    <None Include="..\progs\heretic\game\HereticLevelInfo.vc" />
+    <None Include="..\progs\heretic\game\MainGameInfo.vc" />
+    <None Include="..\progs\heretic\game\Player.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_heretic.vcxproj.filters mod/msvc/basepak_heretic.vcxproj.filters
--- orig/msvc/basepak_heretic.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_heretic.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,67 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="cgame">
+      <UniqueIdentifier>{ca027b68-e591-407d-bba0-430edae21671}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="game">
+      <UniqueIdentifier>{9d58371c-2862-4551-b199-31daec969195}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\progs\heretic\cgame\classes.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\ClientGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\IntermissionScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenControls2.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenGameplayOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenHelp.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenMain.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenMultiplayer.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenNewNetGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\MenuScreenPlayerSetup.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\StatusBarScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\cgame\TitleScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\heretic\game\BotPlayer.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\heretic\game\classes.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\heretic\game\HereticLevelInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\heretic\game\MainGameInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\heretic\game\Player.vc">
+      <Filter>game</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_hexen.vcproj mod/msvc/basepak_hexen.vcproj
--- orig/msvc/basepak_hexen.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_hexen.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,153 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_hexen"
-	ProjectGUID="{DD00F5CF-9520-44D2-BDC4-45130B5024FA}"
-	RootNamespace="progs_doom_game"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\hexen\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\hexen\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\hexen\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\hexen\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="cgame"
-			>
-			<File
-				RelativePath="..\progs\hexen\cgame\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\ClientGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\IntermissionScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenControls2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenGameplayOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenHelp.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenMain.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenMultiplayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenNewNetGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\MenuScreenPlayerSetup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\StatusBarScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\cgame\TitleScreen.vc"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="game"
-			>
-			<File
-				RelativePath="..\progs\hexen\game\BotPlayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\game\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\game\HexenDefs.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\game\HexenLevelInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\game\MainGameInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\game\Player.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\hexen\game\PlayerSpeed.vc"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_hexen.vcxproj mod/msvc/basepak_hexen.vcxproj
--- orig/msvc/basepak_hexen.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_hexen.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,199 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{DD00F5CF-9520-44D2-BDC4-45130B5024FA}</ProjectGuid>
+    <RootNamespace>progs_doom_game</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\hexen\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\hexen\cgame\classes.vc" />
+    <None Include="..\progs\hexen\cgame\ClientGame.vc" />
+    <None Include="..\progs\hexen\cgame\IntermissionScreen.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenControls2.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenGameplayOptions.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenHelp.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenMain.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenMultiplayer.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenNewNetGame.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenOptions.vc" />
+    <None Include="..\progs\hexen\cgame\MenuScreenPlayerSetup.vc" />
+    <None Include="..\progs\hexen\cgame\StatusBarScreen.vc" />
+    <None Include="..\progs\hexen\cgame\TitleScreen.vc" />
+    <None Include="..\progs\hexen\game\BotPlayer.vc" />
+    <None Include="..\progs\hexen\game\classes.vc" />
+    <None Include="..\progs\hexen\game\HexenDefs.vc" />
+    <None Include="..\progs\hexen\game\HexenLevelInfo.vc" />
+    <None Include="..\progs\hexen\game\MainGameInfo.vc" />
+    <None Include="..\progs\hexen\game\Player.vc" />
+    <None Include="..\progs\hexen\game\PlayerSpeed.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_hexen.vcxproj.filters mod/msvc/basepak_hexen.vcxproj.filters
--- orig/msvc/basepak_hexen.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_hexen.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,73 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="cgame">
+      <UniqueIdentifier>{8e488fbe-f08c-4caa-b687-965f66a9ff7b}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="game">
+      <UniqueIdentifier>{b7da3484-4570-4e07-b413-b762545fdeef}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\progs\hexen\cgame\classes.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\ClientGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\IntermissionScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenControls2.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenGameplayOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenHelp.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenMain.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenMultiplayer.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenNewNetGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\MenuScreenPlayerSetup.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\StatusBarScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\cgame\TitleScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\hexen\game\BotPlayer.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\hexen\game\classes.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\hexen\game\HexenDefs.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\hexen\game\HexenLevelInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\hexen\game\MainGameInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\hexen\game\Player.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\hexen\game\PlayerSpeed.vc">
+      <Filter>game</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_plutonia.vcproj mod/msvc/basepak_plutonia.vcproj
--- orig/msvc/basepak_plutonia.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_plutonia.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_plutonia"
-	ProjectGUID="{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}"
-	RootNamespace="progs_plutonia"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\plutonia\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\plutonia\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\plutonia\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\plutonia\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<File
-			RelativePath="..\progs\plutonia\cgame.vc"
-			>
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_plutonia.vcxproj mod/msvc/basepak_plutonia.vcxproj
--- orig/msvc/basepak_plutonia.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_plutonia.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,180 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}</ProjectGuid>
+    <RootNamespace>progs_plutonia</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\plutonia\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\plutonia\cgame.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_strife.vcproj mod/msvc/basepak_strife.vcproj
--- orig/msvc/basepak_strife.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_strife.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,153 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_strife"
-	ProjectGUID="{1CD88557-1039-4B0C-9DF6-AB181E799536}"
-	RootNamespace="progs_doom_shared"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\strife\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\strife\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\strife\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\strife\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="cgame"
-			>
-			<File
-				RelativePath="..\progs\strife\cgame\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\ClientGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\ConSlideshow1.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\ConSlideshow2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\IntermissionScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenControls2.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenGameplayOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenHelp.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenMain.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenMultiplayer.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenNewNetGame.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenOptions.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenPlayerSetup.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\MenuScreenQuit.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\StatusBarScreen.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\cgame\TitleScreen.vc"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="game"
-			>
-			<File
-				RelativePath="..\progs\strife\game\classes.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\game\MainGameInfo.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\game\Player.vc"
-				>
-			</File>
-			<File
-				RelativePath="..\progs\strife\game\StrifeLevelInfo.vc"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_strife.vcxproj mod/msvc/basepak_strife.vcxproj
--- orig/msvc/basepak_strife.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_strife.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,199 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{1CD88557-1039-4B0C-9DF6-AB181E799536}</ProjectGuid>
+    <RootNamespace>progs_doom_shared</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\strife\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\strife\cgame\classes.vc" />
+    <None Include="..\progs\strife\cgame\ClientGame.vc" />
+    <None Include="..\progs\strife\cgame\ConSlideshow1.vc" />
+    <None Include="..\progs\strife\cgame\ConSlideshow2.vc" />
+    <None Include="..\progs\strife\cgame\IntermissionScreen.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenControls2.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenGameplayOptions.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenHelp.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenMain.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenMultiplayer.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenNewNetGame.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenOptions.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenPlayerSetup.vc" />
+    <None Include="..\progs\strife\cgame\MenuScreenQuit.vc" />
+    <None Include="..\progs\strife\cgame\StatusBarScreen.vc" />
+    <None Include="..\progs\strife\cgame\TitleScreen.vc" />
+    <None Include="..\progs\strife\game\classes.vc" />
+    <None Include="..\progs\strife\game\MainGameInfo.vc" />
+    <None Include="..\progs\strife\game\Player.vc" />
+    <None Include="..\progs\strife\game\StrifeLevelInfo.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_strife.vcxproj.filters mod/msvc/basepak_strife.vcxproj.filters
--- orig/msvc/basepak_strife.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_strife.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,73 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="cgame">
+      <UniqueIdentifier>{02791ae3-1c7e-4dbe-9081-e221e9bd74fe}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="game">
+      <UniqueIdentifier>{afc1f536-be56-4ef1-a9db-f12b074a1524}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\progs\strife\cgame\classes.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\ClientGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\ConSlideshow1.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\ConSlideshow2.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\IntermissionScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenControls2.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenGameplayOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenHelp.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenMain.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenMultiplayer.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenNewNetGame.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenOptions.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenPlayerSetup.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\MenuScreenQuit.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\StatusBarScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\cgame\TitleScreen.vc">
+      <Filter>cgame</Filter>
+    </None>
+    <None Include="..\progs\strife\game\classes.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\strife\game\MainGameInfo.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\strife\game\Player.vc">
+      <Filter>game</Filter>
+    </None>
+    <None Include="..\progs\strife\game\StrifeLevelInfo.vc">
+      <Filter>game</Filter>
+    </None>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/basepak_tnt.vcproj mod/msvc/basepak_tnt.vcproj
--- orig/msvc/basepak_tnt.vcproj	2010-03-14 20:25:50.000000000 +0100
+++ mod/msvc/basepak_tnt.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="basepak_tnt"
-	ProjectGUID="{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}"
-	RootNamespace="progs_tnt"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\tnt\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\tnt\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(ProjectDir)$(InputName)_$(ConfigurationName)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)\basepak\$(InputName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="0"
-			>
-			<Tool
-				Name="VCNMakeTool"
-				BuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\tnt\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				ReBuildCommandLine="$(SolutionDir)$(ConfigurationName)\vlumpy.exe ..\basev\tnt\basepak.ls&#x0D;&#x0A;if exist $(OutDir) goto end&#x0D;&#x0A;goto no &#x0D;&#x0A;:no &#x0D;&#x0A;md $(OutDir)&#x0D;&#x0A;goto end &#x0D;&#x0A;:end &#x0D;&#x0A;move basepak.pk3 $(OutDir)&#x0D;&#x0A;"
-				CleanCommandLine=""
-				Output="basepak.pk3"
-				PreprocessorDefinitions=""
-				IncludeSearchPath=""
-				ForcedIncludes=""
-				AssemblySearchPath=""
-				ForcedUsingAssemblies=""
-				CompileAsManaged=""
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<File
-			RelativePath="..\progs\tnt\cgame.vc"
-			>
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/basepak_tnt.vcxproj mod/msvc/basepak_tnt.vcxproj
--- orig/msvc/basepak_tnt.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/basepak_tnt.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,180 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}</ProjectGuid>
+    <RootNamespace>progs_tnt</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Makefile</ConfigurationType>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(ProjectDir)$(ProjectName)_$(Configuration)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)\basepak\$(ProjectName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)\</IntDir>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeReBuildCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)\vlumpy.exe ..\basev\tnt\basepak.ls
+if exist $(OutDir) goto end
+goto no 
+:no 
+md $(OutDir)
+goto end 
+:end 
+move basepak.pk3 $(OutDir)
+</NMakeReBuildCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">del $(OutDir)\basepak.pk3</NMakeCleanCommandLine>
+    <NMakeCleanCommandLine Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">basepak.pk3</NMakeOutput>
+    <NMakeOutput Condition="'$(Configuration)|$(Platform)'=='Release|x64'">basepak.pk3</NMakeOutput>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakePreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakePreprocessorDefinitions)</NMakePreprocessorDefinitions>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeIncludeSearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeIncludeSearchPath)</NMakeIncludeSearchPath>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeForcedIncludes Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedIncludes)</NMakeForcedIncludes>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeAssemblySearchPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeAssemblySearchPath)</NMakeAssemblySearchPath>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <NMakeForcedUsingAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(NMakeForcedUsingAssemblies)</NMakeForcedUsingAssemblies>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\progs\tnt\cgame.vc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="vlumpy.vcxproj">
+      <Project>{f65ac2b2-1632-4584-bda1-dac149fc9bdd}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/core.vcproj mod/msvc/core.vcproj
--- orig/msvc/core.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/core.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,312 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="core"
-	ProjectGUID="{D509CF19-F957-4F58-8F05-3AA6AA520B2F}"
-	RootNamespace="core"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="196613"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="true"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath="..\libs\core\args.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\arraystream.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\bitstream.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\common.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\crc.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\endian.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\exception.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\log.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\matrix.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\memorystream.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\name.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\str.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\stream.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\xml.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\zone.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath="..\libs\core\args.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\array.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\arraystream.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\bitstream.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\common.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\core.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\crc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\endian.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\exception.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\log.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\map.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\matrix.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\memorystream.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\name.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\names.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\str.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\stream.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\vector.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\xml.h"
-				>
-			</File>
-			<File
-				RelativePath="..\libs\core\zone.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/core.vcxproj mod/msvc/core.vcxproj
--- orig/msvc/core.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/core.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,214 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{D509CF19-F957-4F58-8F05-3AA6AA520B2F}</ProjectGuid>
+    <RootNamespace>core</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Configuration)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Configuration)_$(PlatformName)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\boost_1_49_0;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.11\include;F:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>None</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <CallingConvention>Cdecl</CallingConvention>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Lib>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\libs\core\args.cpp" />
+    <ClCompile Include="..\libs\core\arraystream.cpp" />
+    <ClCompile Include="..\libs\core\bitstream.cpp" />
+    <ClCompile Include="..\libs\core\common.cpp" />
+    <ClCompile Include="..\libs\core\crc.cpp" />
+    <ClCompile Include="..\libs\core\endian.cpp" />
+    <ClCompile Include="..\libs\core\exception.cpp" />
+    <ClCompile Include="..\libs\core\log.cpp" />
+    <ClCompile Include="..\libs\core\matrix.cpp" />
+    <ClCompile Include="..\libs\core\memorystream.cpp" />
+    <ClCompile Include="..\libs\core\name.cpp" />
+    <ClCompile Include="..\libs\core\str.cpp" />
+    <ClCompile Include="..\libs\core\stream.cpp" />
+    <ClCompile Include="..\libs\core\xml.cpp" />
+    <ClCompile Include="..\libs\core\zone.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\libs\core\args.h" />
+    <ClInclude Include="..\libs\core\array.h" />
+    <ClInclude Include="..\libs\core\arraystream.h" />
+    <ClInclude Include="..\libs\core\bitstream.h" />
+    <ClInclude Include="..\libs\core\common.h" />
+    <ClInclude Include="..\libs\core\core.h" />
+    <ClInclude Include="..\libs\core\crc.h" />
+    <ClInclude Include="..\libs\core\endian.h" />
+    <ClInclude Include="..\libs\core\exception.h" />
+    <ClInclude Include="..\libs\core\log.h" />
+    <ClInclude Include="..\libs\core\map.h" />
+    <ClInclude Include="..\libs\core\matrix.h" />
+    <ClInclude Include="..\libs\core\memorystream.h" />
+    <ClInclude Include="..\libs\core\name.h" />
+    <ClInclude Include="..\libs\core\names.h" />
+    <ClInclude Include="..\libs\core\str.h" />
+    <ClInclude Include="..\libs\core\stream.h" />
+    <ClInclude Include="..\libs\core\vector.h" />
+    <ClInclude Include="..\libs\core\xml.h" />
+    <ClInclude Include="..\libs\core\zone.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/core.vcxproj.filters mod/msvc/core.vcxproj.filters
--- orig/msvc/core.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/core.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,126 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\libs\core\args.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\arraystream.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\bitstream.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\common.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\crc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\endian.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\exception.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\log.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\matrix.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\memorystream.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\name.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\str.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\stream.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\xml.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\libs\core\zone.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\libs\core\args.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\array.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\arraystream.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\bitstream.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\crc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\endian.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\exception.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\log.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\map.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\matrix.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\memorystream.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\name.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\names.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\str.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\stream.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\vector.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\xml.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\libs\core\zone.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/fixmd2.vcproj mod/msvc/fixmd2.vcproj
--- orig/msvc/fixmd2.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/fixmd2.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="fixmd2"
-	ProjectGUID="{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}"
-	RootNamespace="fixmd2"
-	TargetFrameworkVersion="196613"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;"
-				MinimalRebuild="true"
-				ExceptionHandling="1"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				WarningLevel="3"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				LinkIncremental="2"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				WholeProgramOptimization="true"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				GenerateDebugInformation="false"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				LinkTimeCodeGeneration="1"
-				RandomizedBaseAddress="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\fixmd2\fixmd2.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/fixmd2.vcxproj mod/msvc/fixmd2.vcxproj
--- orig/msvc/fixmd2.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/fixmd2.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,224 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}</ProjectGuid>
+    <RootNamespace>fixmd2</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\boost_1_49_0\;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\boost_1_49_0\stage\lib\x64;$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <CallingConvention>Cdecl</CallingConvention>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+      <SubSystem>Console</SubSystem>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <TargetMachine>MachineX64</TargetMachine>
+      <SubSystem>Console</SubSystem>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp" />
+    <ClCompile Include="..\utils\fixmd2\fixmd2.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/fixmd2.vcxproj.filters mod/msvc/fixmd2.vcxproj.filters
--- orig/msvc/fixmd2.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/fixmd2.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,30 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\fixmd2\fixmd2.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/glvis.vcproj mod/msvc/glvis.vcproj
--- orig/msvc/glvis.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/glvis.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,237 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="glvis"
-	ProjectGUID="{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}"
-	RootNamespace="glvis"
-	TargetFrameworkVersion="196613"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				WarningLevel="3"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				LinkIncremental="2"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				GenerateDebugInformation="false"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				LinkTimeCodeGeneration="1"
-				RandomizedBaseAddress="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\flow.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\glvis.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\level.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\wadlib.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\fmapdefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\fwaddefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\glvis.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\vector.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\wadlib.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/glvis.vcxproj mod/msvc/glvis.vcxproj
--- orig/msvc/glvis.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/glvis.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,225 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}</ProjectGuid>
+    <RootNamespace>glvis</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\boost_1_49_0\;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\boost_1_49_0\stage\lib\x64;$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <CallingConvention>Cdecl</CallingConvention>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp" />
+    <ClCompile Include="..\utils\glvis\flow.cpp" />
+    <ClCompile Include="..\utils\glvis\glvis.cpp" />
+    <ClCompile Include="..\utils\glvis\level.cpp" />
+    <ClCompile Include="..\utils\common\wadlib.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h" />
+    <ClInclude Include="..\utils\common\fmapdefs.h" />
+    <ClInclude Include="..\utils\common\fwaddefs.h" />
+    <ClInclude Include="..\utils\glvis\glvis.h" />
+    <ClInclude Include="..\utils\glvis\vector.h" />
+    <ClInclude Include="..\utils\common\wadlib.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="libglvis.vcxproj">
+      <Project>{0292d20b-0826-40e7-b713-a9b512505155}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/glvis.vcxproj.filters mod/msvc/glvis.vcxproj.filters
--- orig/msvc/glvis.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/glvis.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,54 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glvis\flow.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glvis\glvis.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glvis\level.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\common\wadlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\fmapdefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\fwaddefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glvis\glvis.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glvis\vector.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\wadlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/gme.vcxproj mod/msvc/gme.vcxproj
--- orig/msvc/gme.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/gme.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,348 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\gme\src\Ay_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Ay_Core.h" />
+    <ClInclude Include="..\source\gme\src\Ay_Emu.h" />
+    <ClInclude Include="..\source\gme\src\blargg_common.h" />
+    <ClInclude Include="..\source\gme\src\blargg_config.h" />
+    <ClInclude Include="..\source\gme\src\blargg_endian.h" />
+    <ClInclude Include="..\source\gme\src\blargg_errors.h" />
+    <ClInclude Include="..\source\gme\src\blargg_source.h" />
+    <ClInclude Include="..\source\gme\src\Blip_Buffer.h" />
+    <ClInclude Include="..\source\gme\src\Blip_Buffer_impl.h" />
+    <ClInclude Include="..\source\gme\src\Blip_Buffer_impl2.h" />
+    <ClInclude Include="..\source\gme\src\Classic_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Data_Reader.h" />
+    <ClInclude Include="..\source\gme\src\divfix.h" />
+    <ClInclude Include="..\source\gme\src\Downsampler.h" />
+    <ClInclude Include="..\source\gme\src\Dual_Resampler.h" />
+    <ClInclude Include="..\source\gme\src\Effects_Buffer.h" />
+    <ClInclude Include="..\source\gme\src\emu2413.h" />
+    <ClInclude Include="..\source\gme\src\Fir_Resampler.h" />
+    <ClInclude Include="..\source\gme\src\fmopl.h" />
+    <ClInclude Include="..\source\gme\src\Gbs_Core.h" />
+    <ClInclude Include="..\source\gme\src\Gbs_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Gb_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Gb_Cpu.h" />
+    <ClInclude Include="..\source\gme\src\Gb_Cpu_run.h" />
+    <ClInclude Include="..\source\gme\src\Gb_Oscs.h" />
+    <ClInclude Include="..\source\gme\src\gme.h" />
+    <ClInclude Include="..\source\gme\src\Gme_File.h" />
+    <ClInclude Include="..\source\gme\src\Gme_Loader.h" />
+    <ClInclude Include="..\source\gme\src\Gym_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Hes_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Hes_Apu_Adpcm.h" />
+    <ClInclude Include="..\source\gme\src\Hes_Core.h" />
+    <ClInclude Include="..\source\gme\src\Hes_Cpu.h" />
+    <ClInclude Include="..\source\gme\src\Hes_Cpu_run.h" />
+    <ClInclude Include="..\source\gme\src\Hes_Emu.h" />
+    <ClInclude Include="..\source\gme\src\i_fmpac.h" />
+    <ClInclude Include="..\source\gme\src\i_fmunit.h" />
+    <ClInclude Include="..\source\gme\src\i_vrc7.h" />
+    <ClInclude Include="..\source\gme\src\kmsnddev.h" />
+    <ClInclude Include="..\source\gme\src\Kss_Core.h" />
+    <ClInclude Include="..\source\gme\src\Kss_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Kss_Scc_Apu.h" />
+    <ClInclude Include="..\source\gme\src\M3u_Playlist.h" />
+    <ClInclude Include="..\source\gme\src\Multi_Buffer.h" />
+    <ClInclude Include="..\source\gme\src\Music_Emu.h" />
+    <ClInclude Include="..\source\gme\src\nestypes.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Cpu.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Cpu_run.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Fds_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Fme7_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Mmc5_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Namco_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Oscs.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Vrc6_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Nes_Vrc7_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Nsfe_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Nsf_Core.h" />
+    <ClInclude Include="..\source\gme\src\Nsf_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Nsf_Impl.h" />
+    <ClInclude Include="..\source\gme\src\Opl_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Resampler.h" />
+    <ClInclude Include="..\source\gme\src\Rom_Data.h" />
+    <ClInclude Include="..\source\gme\src\Sap_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Sap_Core.h" />
+    <ClInclude Include="..\source\gme\src\Sap_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Sgc_Core.h" />
+    <ClInclude Include="..\source\gme\src\Sgc_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Sgc_Impl.h" />
+    <ClInclude Include="..\source\gme\src\Sms_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Sms_Fm_Apu.h" />
+    <ClInclude Include="..\source\gme\src\Snes_Spc.h" />
+    <ClInclude Include="..\source\gme\src\Spc_Cpu.h" />
+    <ClInclude Include="..\source\gme\src\Spc_Dsp.h" />
+    <ClInclude Include="..\source\gme\src\Spc_Emu.h" />
+    <ClInclude Include="..\source\gme\src\SPC_Filter.h" />
+    <ClInclude Include="..\source\gme\src\s_deltat.h" />
+    <ClInclude Include="..\source\gme\src\s_logtbl.h" />
+    <ClInclude Include="..\source\gme\src\s_opl.h" />
+    <ClInclude Include="..\source\gme\src\s_opltbl.h" />
+    <ClInclude Include="..\source\gme\src\Track_Filter.h" />
+    <ClInclude Include="..\source\gme\src\Upsampler.h" />
+    <ClInclude Include="..\source\gme\src\Vgm_Core.h" />
+    <ClInclude Include="..\source\gme\src\Vgm_Emu.h" />
+    <ClInclude Include="..\source\gme\src\ym2413.h" />
+    <ClInclude Include="..\source\gme\src\Ym2413_Emu.h" />
+    <ClInclude Include="..\source\gme\src\Ym2612_Emu.h" />
+    <ClInclude Include="..\source\gme\src\ymdeltat.h" />
+    <ClInclude Include="..\source\gme\src\Z80_Cpu.h" />
+    <ClInclude Include="..\source\gme\src\Z80_Cpu_run.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\gme\src\Ay_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Ay_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Ay_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Ay_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\blargg_common.cpp" />
+    <ClCompile Include="..\source\gme\src\blargg_errors.cpp" />
+    <ClCompile Include="..\source\gme\src\Blip_Buffer.cpp" />
+    <ClCompile Include="..\source\gme\src\Classic_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Data_Reader.cpp" />
+    <ClCompile Include="..\source\gme\src\Downsampler.cpp" />
+    <ClCompile Include="..\source\gme\src\Dual_Resampler.cpp" />
+    <ClCompile Include="..\source\gme\src\Effects_Buffer.cpp" />
+    <ClCompile Include="..\source\gme\src\emu2413.cpp" />
+    <ClCompile Include="..\source\gme\src\Fir_Resampler.cpp" />
+    <ClCompile Include="..\source\gme\src\fmopl.cpp" />
+    <ClCompile Include="..\source\gme\src\Gbs_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Gbs_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Gbs_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Gb_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Gb_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Gb_Oscs.cpp" />
+    <ClCompile Include="..\source\gme\src\gme.cpp" />
+    <ClCompile Include="..\source\gme\src\Gme_File.cpp" />
+    <ClCompile Include="..\source\gme\src\Gme_Loader.cpp" />
+    <ClCompile Include="..\source\gme\src\Gym_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Hes_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Hes_Apu_Adpcm.cpp" />
+    <ClCompile Include="..\source\gme\src\Hes_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Hes_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Hes_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Kss_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Kss_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Kss_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Kss_Scc_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\M3u_Playlist.cpp" />
+    <ClCompile Include="..\source\gme\src\Multi_Buffer.cpp" />
+    <ClCompile Include="..\source\gme\src\Music_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Fds_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Fme7_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Namco_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Oscs.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Vrc6_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nes_Vrc7_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nsfe_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nsf_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Nsf_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nsf_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Nsf_Impl.cpp" />
+    <ClCompile Include="..\source\gme\src\Opl_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Resampler.cpp" />
+    <ClCompile Include="..\source\gme\src\Rom_Data.cpp" />
+    <ClCompile Include="..\source\gme\src\Sap_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Sap_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Sap_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Sap_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Sgc_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Sgc_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Sgc_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Sgc_Impl.cpp" />
+    <ClCompile Include="..\source\gme\src\Sms_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Sms_Fm_Apu.cpp" />
+    <ClCompile Include="..\source\gme\src\Snes_Spc.cpp" />
+    <ClCompile Include="..\source\gme\src\Spc_Cpu.cpp" />
+    <ClCompile Include="..\source\gme\src\Spc_Dsp.cpp" />
+    <ClCompile Include="..\source\gme\src\Spc_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\SPC_Filter.cpp" />
+    <ClCompile Include="..\source\gme\src\s_deltat.c" />
+    <ClCompile Include="..\source\gme\src\s_logtbl.c" />
+    <ClCompile Include="..\source\gme\src\s_opl.c" />
+    <ClCompile Include="..\source\gme\src\s_opltbl.c" />
+    <ClCompile Include="..\source\gme\src\Track_Filter.cpp" />
+    <ClCompile Include="..\source\gme\src\Upsampler.cpp" />
+    <ClCompile Include="..\source\gme\src\Vgm_Core.cpp" />
+    <ClCompile Include="..\source\gme\src\Vgm_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\ym2413.c" />
+    <ClCompile Include="..\source\gme\src\Ym2413_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\Ym2612_Emu.cpp" />
+    <ClCompile Include="..\source\gme\src\ymdeltat.cpp" />
+    <ClCompile Include="..\source\gme\src\Z80_Cpu.cpp" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}</ProjectGuid>
+    <RootNamespace>gme</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.11\include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <Lib>
+      <OutputFile>$(OutDir)$(ProjectName)_d.lib</OutputFile>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Lib>
+      <OutputFile>$(OutDir)$(ProjectName)_d.lib</OutputFile>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <CallingConvention>Cdecl</CallingConvention>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Lib>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Lib>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/gme.vcxproj.filters mod/msvc/gme.vcxproj.filters
--- orig/msvc/gme.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/gme.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,537 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\gme\src\Ay_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Ay_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Ay_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\blargg_common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\blargg_config.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\blargg_endian.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\blargg_errors.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\blargg_source.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Blip_Buffer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Blip_Buffer_impl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Blip_Buffer_impl2.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Classic_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\divfix.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Downsampler.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Dual_Resampler.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Effects_Buffer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\emu2413.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Fir_Resampler.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\fmopl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gb_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gb_Cpu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gb_Cpu_run.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gb_Oscs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gbs_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gbs_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\gme.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gme_File.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gme_Loader.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Gym_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Hes_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Hes_Apu_Adpcm.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Hes_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Hes_Cpu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Hes_Cpu_run.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Hes_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\i_fmpac.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\i_fmunit.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\i_vrc7.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\kmsnddev.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Kss_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Kss_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Kss_Scc_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\M3u_Playlist.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Multi_Buffer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Music_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Cpu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Cpu_run.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Fds_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Fme7_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Mmc5_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Namco_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Oscs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Vrc6_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nes_Vrc7_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\nestypes.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nsf_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nsf_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nsf_Impl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Nsfe_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Opl_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Resampler.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Rom_Data.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\s_deltat.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\s_logtbl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\s_opl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\s_opltbl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sap_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sap_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sap_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sgc_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sgc_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sgc_Impl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sms_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Sms_Fm_Apu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Snes_Spc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Spc_Cpu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Spc_Dsp.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Spc_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\SPC_Filter.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Track_Filter.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Upsampler.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Vgm_Core.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Vgm_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\ym2413.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Ym2413_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Ym2612_Emu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\ymdeltat.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Z80_Cpu.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Z80_Cpu_run.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gme\src\Data_Reader.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\gme\src\s_deltat.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\s_logtbl.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\s_opl.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\s_opltbl.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\ym2413.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Ay_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Ay_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Ay_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Ay_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\blargg_common.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\blargg_errors.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Blip_Buffer.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Classic_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Downsampler.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Dual_Resampler.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Effects_Buffer.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\emu2413.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Fir_Resampler.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\fmopl.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gb_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gb_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gb_Oscs.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gbs_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gbs_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gbs_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\gme.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gme_File.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gme_Loader.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Gym_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Hes_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Hes_Apu_Adpcm.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Hes_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Hes_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Hes_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Kss_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Kss_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Kss_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Kss_Scc_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\M3u_Playlist.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Multi_Buffer.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Music_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Fds_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Fme7_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Namco_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Oscs.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Vrc6_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nes_Vrc7_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nsf_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nsf_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nsf_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nsf_Impl.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Nsfe_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Opl_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Resampler.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Rom_Data.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sap_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sap_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sap_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sap_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sgc_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sgc_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sgc_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sgc_Impl.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sms_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Sms_Fm_Apu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Snes_Spc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Spc_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Spc_Dsp.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Spc_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\SPC_Filter.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Track_Filter.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Upsampler.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Vgm_Core.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Vgm_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Ym2413_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Ym2612_Emu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\ymdeltat.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Z80_Cpu.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gme\src\Data_Reader.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/libglbsp.vcproj mod/msvc/libglbsp.vcproj
--- orig/msvc/libglbsp.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/libglbsp.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,263 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="libglbsp"
-	ProjectGUID="{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}"
-	RootNamespace="libglbsp"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				PreprocessorDefinitions="GLBSP_PLUGIN;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				PreprocessorDefinitions="GLBSP_PLUGIN;WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CallingConvention="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-				OutputFile=".\Release/libglbsp.bsc"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="..\utils\glbsp\analyze.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\blockmap.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\glbsp.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\level.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\node.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\reject.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\seg.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\system.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\util.c"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\wad.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="..\utils\glbsp\analyze.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\blockmap.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\glbsp.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\level.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\node.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\reject.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\seg.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\structs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\system.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\util.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glbsp\wad.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/libglbsp.vcxproj mod/msvc/libglbsp.vcxproj
--- orig/msvc/libglbsp.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/libglbsp.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,242 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}</ProjectGuid>
+    <RootNamespace>libglbsp</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>GLBSP_PLUGIN;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>GLBSP_PLUGIN;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <PreprocessorDefinitions>GLBSP_PLUGIN;WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>.\Release/libglbsp.bsc</OutputFile>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>GLBSP_PLUGIN;WIN32;_WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <OutputFile>.\Release/libglbsp.bsc</OutputFile>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\glbsp\analyze.c" />
+    <ClCompile Include="..\utils\glbsp\blockmap.c" />
+    <ClCompile Include="..\utils\glbsp\glbsp.c" />
+    <ClCompile Include="..\utils\glbsp\level.c" />
+    <ClCompile Include="..\utils\glbsp\node.c" />
+    <ClCompile Include="..\utils\glbsp\reject.c" />
+    <ClCompile Include="..\utils\glbsp\seg.c" />
+    <ClCompile Include="..\utils\glbsp\system.c" />
+    <ClCompile Include="..\utils\glbsp\util.c" />
+    <ClCompile Include="..\utils\glbsp\wad.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\glbsp\analyze.h" />
+    <ClInclude Include="..\utils\glbsp\blockmap.h" />
+    <ClInclude Include="..\utils\glbsp\glbsp.h" />
+    <ClInclude Include="..\utils\glbsp\level.h" />
+    <ClInclude Include="..\utils\glbsp\node.h" />
+    <ClInclude Include="..\utils\glbsp\reject.h" />
+    <ClInclude Include="..\utils\glbsp\seg.h" />
+    <ClInclude Include="..\utils\glbsp\structs.h" />
+    <ClInclude Include="..\utils\glbsp\system.h" />
+    <ClInclude Include="..\utils\glbsp\util.h" />
+    <ClInclude Include="..\utils\glbsp\wad.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/libglbsp.vcxproj.filters mod/msvc/libglbsp.vcxproj.filters
--- orig/msvc/libglbsp.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/libglbsp.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,80 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{a5510e00-83b9-485e-aef1-3ea6154e48c2}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{c6919223-e601-4e71-9497-c12938763cad}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\glbsp\analyze.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\blockmap.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\glbsp.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\level.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\node.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\reject.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\seg.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\system.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\util.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glbsp\wad.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\glbsp\analyze.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\blockmap.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\glbsp.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\level.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\node.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\reject.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\seg.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\structs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\system.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\util.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glbsp\wad.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/libglvis.vcproj mod/msvc/libglvis.vcproj
--- orig/msvc/libglvis.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/libglvis.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,223 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="libglvis"
-	ProjectGUID="{0292D20B-0826-40E7-B713-A9B512505155}"
-	RootNamespace="libglvis"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="4"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\flow.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\level.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\wadlib.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\fmapdefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\fwaddefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\glvis.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\glvisint.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\glvis\vector.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\wadlib.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/libglvis.vcxproj mod/msvc/libglvis.vcxproj
--- orig/msvc/libglvis.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/libglvis.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,243 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0292D20B-0826-40E7-B713-A9B512505155}</ProjectGuid>
+    <RootNamespace>libglvis</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\Libraries\boost_1_49_0\;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <CallingConvention>Cdecl</CallingConvention>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_WIN23;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp" />
+    <ClCompile Include="..\utils\glvis\flow.cpp" />
+    <ClCompile Include="..\utils\glvis\level.cpp" />
+    <ClCompile Include="..\utils\common\wadlib.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h" />
+    <ClInclude Include="..\utils\common\fmapdefs.h" />
+    <ClInclude Include="..\utils\common\fwaddefs.h" />
+    <ClInclude Include="..\utils\glvis\glvis.h" />
+    <ClInclude Include="..\utils\glvis\glvisint.h" />
+    <ClInclude Include="..\utils\glvis\vector.h" />
+    <ClInclude Include="..\utils\common\wadlib.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/libglvis.vcxproj.filters mod/msvc/libglvis.vcxproj.filters
--- orig/msvc/libglvis.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/libglvis.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,50 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{fd08ca9a-7334-411b-a38e-9f0d199f40a6}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{34ecceae-18d4-44c1-8adf-07069e7e7715}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glvis\flow.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\glvis\level.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\common\wadlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\fmapdefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\fwaddefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glvis\glvis.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glvis\glvisint.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\glvis\vector.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\wadlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/timidity.vcproj mod/msvc/timidity.vcproj
--- orig/msvc/timidity.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/timidity.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,239 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="timidity"
-	ProjectGUID="{A5E43684-5BC7-4DEE-965B-F2E20C360793}"
-	RootNamespace="timidity"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="false"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				RuntimeTypeInfo="false"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CompileAs="2"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="2057"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="4"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="2057"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="..\source\timidity\common.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\instrum.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\instrum_dls.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\instrum_sf2.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\mix.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\playmidi.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\readmidi.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\resample.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\tables.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\timidity.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="..\source\timidity\dls1.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\dls2.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\gf1.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\sf2.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\timidity\timidity.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/timidity.vcxproj mod/msvc/timidity.vcxproj
--- orig/msvc/timidity.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/timidity.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,237 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{A5E43684-5BC7-4DEE-965B-F2E20C360793}</ProjectGuid>
+    <RootNamespace>timidity</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\Libraries\FMOD Programmers API Win32\api\inc;C:\Libraries\include;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;C:\Libraries\wxWidgets-2.8.12\include\msvc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <CallingConvention>Cdecl</CallingConvention>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0809</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <FloatingPointModel>Fast</FloatingPointModel>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0809</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0809</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0809</Culture>
+    </ResourceCompile>
+    <Lib>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Lib>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\timidity\common.cpp" />
+    <ClCompile Include="..\source\timidity\instrum.cpp" />
+    <ClCompile Include="..\source\timidity\instrum_dls.cpp" />
+    <ClCompile Include="..\source\timidity\instrum_sf2.cpp" />
+    <ClCompile Include="..\source\timidity\mix.cpp" />
+    <ClCompile Include="..\source\timidity\playmidi.cpp" />
+    <ClCompile Include="..\source\timidity\readmidi.cpp" />
+    <ClCompile Include="..\source\timidity\resample.cpp" />
+    <ClCompile Include="..\source\timidity\tables.cpp" />
+    <ClCompile Include="..\source\timidity\timidity.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\timidity\dls1.h" />
+    <ClInclude Include="..\source\timidity\dls2.h" />
+    <ClInclude Include="..\source\timidity\gf1.h" />
+    <ClInclude Include="..\source\timidity\sf2.h" />
+    <ClInclude Include="..\source\timidity\timidity.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/timidity.vcxproj.filters mod/msvc/timidity.vcxproj.filters
--- orig/msvc/timidity.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/timidity.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,62 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{93d5b4dc-9029-4816-be0d-1ff8cdec1f80}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{6267835c-b11d-49a4-8037-aea0ddc239cb}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\timidity\common.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\instrum.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\instrum_dls.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\instrum_sf2.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\mix.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\playmidi.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\readmidi.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\resample.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\tables.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\timidity\timidity.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\timidity\dls1.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\timidity\dls2.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\timidity\gf1.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\timidity\sf2.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\timidity\timidity.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/updaterevision.vcxproj mod/msvc/updaterevision.vcxproj
--- orig/msvc/updaterevision.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/updaterevision.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,206 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <Text Include="..\utils\updaterevision\CMakeLists.txt" />
+    <Text Include="..\utils\updaterevision\trustinfo.txt" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\updaterevision\updaterevision.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{6077B7D6-349F-4077-B552-3BC302EF5859}</ProjectGuid>
+    <RootNamespace>updaterevision</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>14.0.25431.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <ExecutablePath>E:\Libraries\Git\bin;$(ExecutablePath)</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir>$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PreBuildEvent>
+      <Command />
+    </PreBuildEvent>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <StringPooling>true</StringPooling>
+      <ExceptionHandling />
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <CompileAs>CompileAsC</CompileAs>
+      <DisableSpecificWarnings>4996</DisableSpecificWarnings>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention />
+      <TargetMachine>MachineX86</TargetMachine>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader />
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PreBuildEvent>
+      <Command />
+    </PreBuildEvent>
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader />
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention />
+      <TargetMachine>MachineX86</TargetMachine>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>WIN64;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader />
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention />
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vavoom-dedicated.vcxproj mod/msvc/vavoom-dedicated.vcxproj
--- orig/msvc/vavoom-dedicated.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vavoom-dedicated.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,601 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{45D28600-E993-49D7-97F1-B08D3A490244}</ProjectGuid>
+    <RootNamespace>vavoom</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msv;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\lib;E:\Libraries\OpenAL 1.1 SDK\libs\Win32;E:\Libraries\Release;E:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;E:\Libraries\wxWidgets-2.8.12\lib\vc_lib;E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\lib;F:\Libraries\OpenAL 1.1 SDK\libs\Win64;F:\Libraries\Release64;F:\Libraries\Release;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64;F:\Libraries\wxWidgets-2.8.12\lib\vc_lib;F:\Libraries\boost_1_49_0\stage\lib\x64;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\include;E:\Libraries\OpenAL 1.1 SDK\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\Debug;E:\Libraries\OpenAL 1.1 SDK\libs\Win32;$(LibraryPath)</LibraryPath>
+    <ExecutablePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\bin;$(ExecutablePath)</ExecutablePath>
+    <ExecutablePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\bin;$(ExecutablePath)</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ExecutablePath>E:\Libraries\bin;E:\Libraries\Git\bin;$(ExecutablePath)</ExecutablePath>
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <RunCodeAnalysis>false</RunCodeAnalysis>
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Release/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <PreprocessorDefinitions>SERVER;NDEBUG;WIN32;_WINDOWS;MIKMOD_STATIC;MODPLUG_STATIC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>None</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <EnablePREfast>false</EnablePREfast>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalDependencies>winmm.lib;wsock32.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries);</IgnoreSpecificDefaultLibraries>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <GenerateMapFile>false</GenerateMapFile>
+      <MapExports>false</MapExports>
+      <SubSystem>Console</SubSystem>
+      <TerminalServerAware>
+      </TerminalServerAware>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <SetChecksum>true</SetChecksum>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <StackReserveSize>
+      </StackReserveSize>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+    <ProjectReference />
+    <ProjectReference />
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TypeLibraryName>.\Release/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>SERVER;NDEBUG;WIN32;_WIN32;_WINDOWS;MIKMOD_STATIC;MODPLUG_STATIC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=0;FPM_64BIT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <UndefinePreprocessorDefinitions>
+      </UndefinePreprocessorDefinitions>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalDependencies>winmm.lib;wsock32.lib;zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)vavoom-dedicated.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <GenerateMapFile>false</GenerateMapFile>
+      <MapExports>false</MapExports>
+      <SubSystem>Console</SubSystem>
+      <TerminalServerAware>
+      </TerminalServerAware>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <SetChecksum>true</SetChecksum>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <StackReserveSize>
+      </StackReserveSize>
+      <TargetMachine>MachineX64</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Debug/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>SERVER;_DEBUG;WIN32;_WINDOWS;_WIN32;_CRTDBG_MAP_ALLOC;MIKMOD_STATIC;MODPLUG_STATIC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>winmm.lib;opengl32.lib;openal32.lib;wsock32.lib;libpngd.lib;libjpeg_d.lib;zlibd.lib;libmad_d.lib;libmikmod_d.lib;libmodplug_d.lib;libvorbis_static_d.lib;libogg_static_d.lib;libFLAC_static_d.lib;libFLAC++_static_d.lib;win_utf8_io_static_d.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)vavoom-dedicated.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <IgnoreSpecificDefaultLibraries>
+      </IgnoreSpecificDefaultLibraries>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TypeLibraryName>.\Debug/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>SERVER;_DEBUG;WIN32;_WINDOWS;_WIN32;_CRTDBG_MAP_ALLOC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAs>Default</CompileAs>
+      <MultiProcessorCompilation>false</MultiProcessorCompilation>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>user32.lib;ole32.lib;gdi32.lib;winmm.lib;opengl32.lib;openal32.lib;wsock32.lib;libpngd.lib;libjpeg_d.lib;zlibd.lib;libmad_d.lib;libmikmod_d.lib;libvorbis_static_d.lib;libogg_static_d.lib;libmikmod_d.lib;libmodplug_d.lib;libFLAC_static_d.lib;libFLAC++_static_d.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)vavoom-dedicated.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\cheats.cpp" />
+    <ClCompile Include="..\source\cmd.cpp" />
+    <ClCompile Include="..\source\cvar.cpp" />
+    <ClCompile Include="..\source\debug.cpp" />
+    <ClCompile Include="..\source\files.cpp" />
+    <ClCompile Include="..\source\fs_dir.cpp" />
+    <ClCompile Include="..\source\fs_wad.cpp" />
+    <ClCompile Include="..\source\fs_zip.cpp" />
+    <ClCompile Include="..\source\host.cpp" />
+    <ClCompile Include="..\source\infostr.cpp" />
+    <ClCompile Include="..\source\language.cpp" />
+    <ClCompile Include="..\source\level.cpp" />
+    <ClCompile Include="..\source\lockdefs.cpp" />
+    <ClCompile Include="..\source\mapinfo.cpp" />
+    <ClCompile Include="..\source\maths.cpp" />
+    <ClCompile Include="..\source\misc.cpp" />
+    <ClCompile Include="..\source\pr_cmds.cpp" />
+    <ClCompile Include="..\source\pr_exec.cpp" />
+    <ClCompile Include="..\source\sc_man.cpp" />
+    <ClCompile Include="..\source\template.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_class.cpp" />
+    <ClCompile Include="..\source\vc_constant.cpp" />
+    <ClCompile Include="..\source\vc_decorate.cpp" />
+    <ClCompile Include="..\source\vc_dehacked.cpp" />
+    <ClCompile Include="..\source\vc_emit_context.cpp" />
+    <ClCompile Include="..\source\vc_error.cpp" />
+    <ClCompile Include="..\source\vc_expr_array.cpp" />
+    <ClCompile Include="..\source\vc_expr_assign.cpp" />
+    <ClCompile Include="..\source\vc_expr_base.cpp" />
+    <ClCompile Include="..\source\vc_expr_cast.cpp" />
+    <ClCompile Include="..\source\vc_expr_field.cpp" />
+    <ClCompile Include="..\source\vc_expr_invoke.cpp" />
+    <ClCompile Include="..\source\vc_expr_literal.cpp" />
+    <ClCompile Include="..\source\vc_expr_local.cpp" />
+    <ClCompile Include="..\source\vc_expr_misc.cpp" />
+    <ClCompile Include="..\source\vc_expr_type.cpp" />
+    <ClCompile Include="..\source\vc_expr_unary_binary.cpp" />
+    <ClCompile Include="..\source\vc_field.cpp" />
+    <ClCompile Include="..\source\vc_lexer.cpp" />
+    <ClCompile Include="..\source\vc_location.cpp" />
+    <ClCompile Include="..\source\vc_member.cpp" />
+    <ClCompile Include="..\source\vc_method.cpp" />
+    <ClCompile Include="..\source\vc_modifiers.cpp" />
+    <ClCompile Include="..\source\vc_object.cpp" />
+    <ClCompile Include="..\source\vc_package.cpp" />
+    <ClCompile Include="..\source\vc_parser.cpp" />
+    <ClCompile Include="..\source\vc_property.cpp" />
+    <ClCompile Include="..\source\vc_state.cpp" />
+    <ClCompile Include="..\source\vc_statement.cpp" />
+    <ClCompile Include="..\source\vc_struct.cpp" />
+    <ClCompile Include="..\source\vc_type.cpp" />
+    <ClCompile Include="..\source\wad.cpp" />
+    <ClCompile Include="..\source\zipstream.cpp" />
+    <ClCompile Include="..\source\r_data.cpp" />
+    <ClCompile Include="..\source\r_tex.cpp" />
+    <ClCompile Include="..\source\r_tex_automap.cpp" />
+    <ClCompile Include="..\source\r_tex_base.cpp" />
+    <ClCompile Include="..\source\r_tex_camera.cpp" />
+    <ClCompile Include="..\source\r_tex_flat.cpp" />
+    <ClCompile Include="..\source\r_tex_imgz.cpp" />
+    <ClCompile Include="..\source\r_tex_jpeg.cpp" />
+    <ClCompile Include="..\source\r_tex_multipatch.cpp" />
+    <ClCompile Include="..\source\r_tex_patch.cpp" />
+    <ClCompile Include="..\source\r_tex_pcx.cpp" />
+    <ClCompile Include="..\source\r_tex_png.cpp" />
+    <ClCompile Include="..\source\r_tex_raw.cpp" />
+    <ClCompile Include="..\source\r_tex_tga.cpp" />
+    <ClCompile Include="..\source\r_tex_warp.cpp" />
+    <ClCompile Include="..\source\net_channel.cpp" />
+    <ClCompile Include="..\source\net_channel_control.cpp" />
+    <ClCompile Include="..\source\net_channel_level.cpp" />
+    <ClCompile Include="..\source\net_channel_object_map.cpp" />
+    <ClCompile Include="..\source\net_channel_player.cpp" />
+    <ClCompile Include="..\source\net_channel_thinker.cpp" />
+    <ClCompile Include="..\source\net_connection.cpp" />
+    <ClCompile Include="..\source\net_context.cpp" />
+    <ClCompile Include="..\source\net_datagram.cpp" />
+    <ClCompile Include="..\source\net_demo.cpp" />
+    <ClCompile Include="..\source\net_loopback.cpp" />
+    <ClCompile Include="..\source\net_main.cpp" />
+    <ClCompile Include="..\source\net_message.cpp" />
+    <ClCompile Include="..\source\net_object_map.cpp" />
+    <ClCompile Include="..\source\net_udp.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\net_winsock.cpp" />
+    <ClCompile Include="..\source\snd_data.cpp" />
+    <ClCompile Include="..\source\snd_reverbs.cpp" />
+    <ClCompile Include="..\source\p_acs.cpp" />
+    <ClCompile Include="..\source\p_clip.cpp" />
+    <ClCompile Include="..\source\p_entity.cpp" />
+    <ClCompile Include="..\source\p_entity_sight.cpp" />
+    <ClCompile Include="..\source\p_entity_world.cpp" />
+    <ClCompile Include="..\source\p_gameinfo.cpp" />
+    <ClCompile Include="..\source\p_gameobject.cpp" />
+    <ClCompile Include="..\source\p_level_think.cpp" />
+    <ClCompile Include="..\source\p_levelinfo.cpp" />
+    <ClCompile Include="..\source\p_nodebuild.cpp" />
+    <ClCompile Include="..\source\p_player.cpp" />
+    <ClCompile Include="..\source\p_player_input.cpp" />
+    <ClCompile Include="..\source\p_playerreplicationinfo.cpp" />
+    <ClCompile Include="..\source\p_polyobj.cpp" />
+    <ClCompile Include="..\source\p_setup.cpp" />
+    <ClCompile Include="..\source\p_setup_udmf.cpp" />
+    <ClCompile Include="..\source\p_switch.cpp" />
+    <ClCompile Include="..\source\p_terrain.cpp" />
+    <ClCompile Include="..\source\p_thinker.cpp" />
+    <ClCompile Include="..\source\p_trace.cpp" />
+    <ClCompile Include="..\source\p_world.cpp" />
+    <ClCompile Include="..\source\p_worldinfo.cpp" />
+    <ClCompile Include="..\source\sv_main.cpp" />
+    <ClCompile Include="..\source\sv_save.cpp" />
+    <ClCompile Include="..\source\sv_world.cpp" />
+    <ClCompile Include="..\source\sys_wind.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\build.h" />
+    <ClInclude Include="..\source\cmd.h" />
+    <ClInclude Include="..\source\common.h" />
+    <ClInclude Include="..\source\cvar.h" />
+    <ClInclude Include="..\source\debug.h" />
+    <ClInclude Include="..\source\files.h" />
+    <ClInclude Include="..\source\fs_local.h" />
+    <ClInclude Include="..\source\fwaddefs.h" />
+    <ClInclude Include="..\source\gamedefs.h" />
+    <ClInclude Include="..\source\host.h" />
+    <ClInclude Include="..\source\infostr.h" />
+    <ClInclude Include="..\source\language.h" />
+    <ClInclude Include="..\source\level.h" />
+    <ClInclude Include="..\source\lockdefs.h" />
+    <ClInclude Include="..\source\mapinfo.h" />
+    <ClInclude Include="..\source\maths.h" />
+    <ClInclude Include="..\source\misc.h" />
+    <ClInclude Include="..\source\progdefs.h" />
+    <ClInclude Include="..\source\progs.h" />
+    <ClInclude Include="..\source\protocol.h" />
+    <ClInclude Include="..\source\resource.h" />
+    <ClInclude Include="..\source\save.h" />
+    <ClInclude Include="..\source\scripts.h" />
+    <ClInclude Include="..\source\template.h" />
+    <ClInclude Include="..\source\vc_class.h" />
+    <ClInclude Include="..\source\vc_constant.h" />
+    <ClInclude Include="..\source\vc_decorate.h" />
+    <ClInclude Include="..\source\vc_dehacked.h" />
+    <ClInclude Include="..\source\vc_emit_context.h" />
+    <ClInclude Include="..\source\vc_error.h" />
+    <ClInclude Include="..\source\vc_expr_array.h" />
+    <ClInclude Include="..\source\vc_expr_assign.h" />
+    <ClInclude Include="..\source\vc_expr_base.h" />
+    <ClInclude Include="..\source\vc_expr_cast.h" />
+    <ClInclude Include="..\source\vc_expr_field.h" />
+    <ClInclude Include="..\source\vc_expr_invoke.h" />
+    <ClInclude Include="..\source\vc_expr_literal.h" />
+    <ClInclude Include="..\source\vc_expr_local.h" />
+    <ClInclude Include="..\source\vc_expr_misc.h" />
+    <ClInclude Include="..\source\vc_expr_type.h" />
+    <ClInclude Include="..\source\vc_expr_unary_binary.h" />
+    <ClInclude Include="..\source\vc_field.h" />
+    <ClInclude Include="..\source\vc_lexer.h" />
+    <ClInclude Include="..\source\vc_location.h" />
+    <ClInclude Include="..\source\vc_member.h" />
+    <ClInclude Include="..\source\vc_method.h" />
+    <ClInclude Include="..\source\vc_modifiers.h" />
+    <ClInclude Include="..\source\vc_object.h" />
+    <ClInclude Include="..\source\vc_package.h" />
+    <ClInclude Include="..\source\vc_parser.h" />
+    <ClInclude Include="..\source\vc_property.h" />
+    <ClInclude Include="..\source\vc_state.h" />
+    <ClInclude Include="..\source\vc_statement.h" />
+    <ClInclude Include="..\source\vc_struct.h" />
+    <ClInclude Include="..\source\vc_type.h" />
+    <ClInclude Include="..\source\wad.h" />
+    <ClInclude Include="..\source\zipstream.h" />
+    <ClInclude Include="..\source\r_local.h" />
+    <ClInclude Include="..\source\r_public.h" />
+    <ClInclude Include="..\source\r_shared.h" />
+    <ClInclude Include="..\source\r_tex.h" />
+    <ClInclude Include="..\source\net_local.h" />
+    <ClInclude Include="..\source\net_message.h" />
+    <ClInclude Include="..\source\network.h" />
+    <ClInclude Include="..\source\sound.h" />
+    <ClInclude Include="..\source\p_acs.h" />
+    <ClInclude Include="..\source\p_clip.h" />
+    <ClInclude Include="..\source\p_entity.h" />
+    <ClInclude Include="..\source\p_gameinfo.h" />
+    <ClInclude Include="..\source\p_gameobject.h" />
+    <ClInclude Include="..\source\p_levelinfo.h" />
+    <ClInclude Include="..\source\p_player.h" />
+    <ClInclude Include="..\source\p_playerreplicationinfo.h" />
+    <ClInclude Include="..\source\p_thinker.h" />
+    <ClInclude Include="..\source\p_world.h" />
+    <ClInclude Include="..\source\p_worldinfo.h" />
+    <ClInclude Include="..\source\server.h" />
+    <ClInclude Include="..\source\sv_local.h" />
+    <ClInclude Include="..\source\system.h" />
+    <ClInclude Include="..\source\winlocal.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\source\vavoom.ico" />
+    <None Include="..\source\vavoom_2.ico" />
+    <None Include="..\source\vavoom_3.ico" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\source\vavoom.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="gme.vcxproj">
+      <Project>{142a5d48-ed8d-4c77-a7c2-a983375d4a9b}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="libglbsp.vcxproj">
+      <Project>{3dc4fb0f-24b7-4051-9faa-b2215cf73554}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="libglvis.vcxproj">
+      <Project>{0292d20b-0826-40e7-b713-a9b512505155}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="timidity.vcxproj">
+      <Project>{a5e43684-5bc7-4dee-965b-f2e20c360793}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vavoom-dedicated.vcxproj.filters mod/msvc/vavoom-dedicated.vcxproj.filters
--- orig/msvc/vavoom-dedicated.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vavoom-dedicated.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,634 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{964861da-fd72-416f-9246-a80b713cf137}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{f347612a-0001-46f0-b6e1-aa9887e42476}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{0174d417-4e5b-458a-8baa-6595929a75ec}</UniqueIdentifier>
+      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
+    </Filter>
+    <Filter Include="Rendering">
+      <UniqueIdentifier>{b4bee56d-0916-4dd9-a6cd-caa5c85178c1}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Rendering\Textures">
+      <UniqueIdentifier>{8a6ef6e2-d938-4ee3-b831-10f5d98395ea}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Networking">
+      <UniqueIdentifier>{b45397d6-7d11-4f1a-a892-6f9a34d151d8}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Sound">
+      <UniqueIdentifier>{5a09dd73-f9ca-4beb-8302-829e3e120925}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Play">
+      <UniqueIdentifier>{cb5c6b6e-573e-4acd-8d1c-330a955f6d41}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Server">
+      <UniqueIdentifier>{850ec370-ba61-4311-bffe-e63010755f78}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="System">
+      <UniqueIdentifier>{326326c3-2ff4-4e67-a46e-4a170e38d181}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\cheats.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\cmd.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\cvar.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\debug.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\files.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\fs_dir.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\fs_wad.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\fs_zip.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\host.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\infostr.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\language.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\level.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\lockdefs.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\mapinfo.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\maths.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\misc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\pr_cmds.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\pr_exec.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sc_man.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\template.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_class.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_constant.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_decorate.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_dehacked.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_emit_context.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_error.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_array.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_assign.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_base.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_cast.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_field.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_invoke.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_literal.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_local.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_misc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_type.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_unary_binary.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_field.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_lexer.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_location.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_member.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_method.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_modifiers.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_object.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_package.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_parser.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_property.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_state.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_statement.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_struct.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_type.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\wad.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\zipstream.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_data.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_automap.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_base.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_camera.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_flat.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_imgz.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_jpeg.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_multipatch.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_patch.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_pcx.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_png.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_raw.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_tga.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_warp.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_control.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_level.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_object_map.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_player.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_thinker.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_connection.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_context.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_datagram.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_demo.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_loopback.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_main.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_message.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_object_map.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_udp.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_winsock.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_data.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_reverbs.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_acs.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_clip.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_entity.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_entity_sight.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_entity_world.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_gameinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_gameobject.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_level_think.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_levelinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_nodebuild.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_player.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_player_input.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_playerreplicationinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_polyobj.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_setup.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_setup_udmf.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_switch.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_terrain.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_thinker.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_trace.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_world.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_worldinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sv_main.cpp">
+      <Filter>Server</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sv_save.cpp">
+      <Filter>Server</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sv_world.cpp">
+      <Filter>Server</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_wind.cpp">
+      <Filter>System</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\build.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\cmd.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\cvar.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\debug.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\files.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\fs_local.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\fwaddefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gamedefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\host.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\infostr.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\language.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\level.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\lockdefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\mapinfo.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\maths.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\progdefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\progs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\protocol.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\save.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\scripts.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\template.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_class.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_constant.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_decorate.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_dehacked.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_emit_context.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_error.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_array.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_assign.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_cast.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_field.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_invoke.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_literal.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_local.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_unary_binary.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_field.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_lexer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_location.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_member.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_method.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_modifiers.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_object.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_package.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_parser.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_property.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_state.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_statement.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_struct.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\wad.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\zipstream.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_local.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_public.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_shared.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_tex.h">
+      <Filter>Rendering\Textures</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\net_local.h">
+      <Filter>Networking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\net_message.h">
+      <Filter>Networking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\network.h">
+      <Filter>Networking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\sound.h">
+      <Filter>Sound</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_acs.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_clip.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_entity.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_gameinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_gameobject.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_levelinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_player.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_playerreplicationinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_thinker.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_world.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_worldinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\server.h">
+      <Filter>Server</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\sv_local.h">
+      <Filter>Server</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\system.h">
+      <Filter>System</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\winlocal.h">
+      <Filter>System</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\resource.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\source\vavoom.ico">
+      <Filter>Resource Files</Filter>
+    </None>
+    <None Include="..\source\vavoom_2.ico">
+      <Filter>Resource Files</Filter>
+    </None>
+    <None Include="..\source\vavoom_3.ico">
+      <Filter>Resource Files</Filter>
+    </None>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\source\vavoom.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vavoom-master.vcproj mod/msvc/vavoom-master.vcproj
--- orig/msvc/vavoom-master.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/vavoom-master.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,207 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="vavoom-master"
-	ProjectGUID="{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}"
-	RootNamespace="vavoommaster"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="wsock32.lib"
-				LinkIncremental="2"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			CharacterSet="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				DebugInformationFormat="1"
-				CompileAs="2"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="wsock32.lib"
-				LinkIncremental="1"
-				GenerateDebugInformation="false"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath="..\utils\master\main.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/vavoom-master.vcxproj mod/msvc/vavoom-master.vcxproj
--- orig/msvc/vavoom-master.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vavoom-master.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,230 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}</ProjectGuid>
+    <RootNamespace>vavoommaster</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\Libraries\boost_1_49_0\;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\boost_1_49_0\stage\lib\x64;$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>wsock32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>wsock32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <CallingConvention>Cdecl</CallingConvention>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>wsock32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>wsock32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\master\main.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vavoom-master.vcxproj.filters mod/msvc/vavoom-master.vcxproj.filters
--- orig/msvc/vavoom-master.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vavoom-master.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\master\main.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/Vavoom.sln mod/msvc/Vavoom.sln
--- orig/msvc/Vavoom.sln	2010-04-04 10:19:19.000000000 +0200
+++ mod/msvc/Vavoom.sln	2022-08-12 08:34:35.000000000 +0200
@@ -1,97 +1,109 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual Studio 2008
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vavoom", "vavoom.vcproj", "{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0292D20B-0826-40E7-B713-A9B512505155} = {0292D20B-0826-40E7-B713-A9B512505155}
-		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554} = {3DC4FB0F-24B7-4051-9FAA-B2215CF73554}
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F} = {D509CF19-F957-4F58-8F05-3AA6AA520B2F}
-		{A5E43684-5BC7-4DEE-965B-F2E20C360793} = {A5E43684-5BC7-4DEE-965B-F2E20C360793}
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vavoom", "vavoom.vcxproj", "{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}"
+	ProjectSection(ProjectDependencies) = postProject
 		{6077B7D6-349F-4077-B552-3BC302EF5859} = {6077B7D6-349F-4077-B552-3BC302EF5859}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libglbsp", "libglbsp.vcproj", "{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libglbsp", "libglbsp.vcxproj", "{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libglvis", "libglvis.vcproj", "{0292D20B-0826-40E7-B713-A9B512505155}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F} = {D509CF19-F957-4F58-8F05-3AA6AA520B2F}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libglvis", "libglvis.vcxproj", "{0292D20B-0826-40E7-B713-A9B512505155}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "timidity", "timidity.vcproj", "{A5E43684-5BC7-4DEE-965B-F2E20C360793}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "timidity", "timidity.vcxproj", "{A5E43684-5BC7-4DEE-965B-F2E20C360793}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vcc", "vcc.vcproj", "{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F} = {D509CF19-F957-4F58-8F05-3AA6AA520B2F}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vcc", "vcc.vcxproj", "{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vlumpy", "vlumpy.vcproj", "{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F} = {D509CF19-F957-4F58-8F05-3AA6AA520B2F}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vlumpy", "vlumpy.vcxproj", "{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "acc", "acc.vcproj", "{023239F2-F1D1-43FB-9B2C-604727C13BC5}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "acc", "acc.vcxproj", "{023239F2-F1D1-43FB-9B2C-604727C13BC5}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vavoom-master", "vavoom-master.vcproj", "{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F} = {D509CF19-F957-4F58-8F05-3AA6AA520B2F}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vavoom-master", "vavoom-master.vcxproj", "{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "glvis", "glvis.vcproj", "{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}"
-	ProjectSection(ProjectDependencies) = postProject
-		{0292D20B-0826-40E7-B713-A9B512505155} = {0292D20B-0826-40E7-B713-A9B512505155}
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F} = {D509CF19-F957-4F58-8F05-3AA6AA520B2F}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "glvis", "glvis.vcxproj", "{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "fixmd2", "fixmd2.vcproj", "{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F} = {D509CF19-F957-4F58-8F05-3AA6AA520B2F}
-	EndProjectSection
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "fixmd2", "fixmd2.vcxproj", "{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "updaterevision", "..\utils\updaterevision\updaterevision.vcproj", "{6077B7D6-349F-4077-B552-3BC302EF5859}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_common", "basepak_common.vcxproj", "{EE79378F-9689-40B8-99F4-B0E5872A6337}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_common", "basepak_common.vcproj", "{EE79378F-9689-40B8-99F4-B0E5872A6337}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_doom", "basepak_doom.vcxproj", "{607F2422-5660-4D06-B604-C975A30E5CD5}"
 	ProjectSection(ProjectDependencies) = postProject
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_doom", "basepak_doom.vcproj", "{607F2422-5660-4D06-B604-C975A30E5CD5}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_doom2", "basepak_doom2.vcxproj", "{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}"
 	ProjectSection(ProjectDependencies) = postProject
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
+		{607F2422-5660-4D06-B604-C975A30E5CD5} = {607F2422-5660-4D06-B604-C975A30E5CD5}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4} = {8BF28A9B-EB60-4C1F-84B2-D133718C21A4}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_doom2", "basepak_doom2.vcproj", "{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_heretic", "basepak_heretic.vcxproj", "{AEDD4819-EE4F-4A94-9776-10C430A9D291}"
 	ProjectSection(ProjectDependencies) = postProject
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
+		{607F2422-5660-4D06-B604-C975A30E5CD5} = {607F2422-5660-4D06-B604-C975A30E5CD5}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4} = {8BF28A9B-EB60-4C1F-84B2-D133718C21A4}
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533} = {DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_heretic", "basepak_heretic.vcproj", "{AEDD4819-EE4F-4A94-9776-10C430A9D291}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_hexen", "basepak_hexen.vcxproj", "{DD00F5CF-9520-44D2-BDC4-45130B5024FA}"
 	ProjectSection(ProjectDependencies) = postProject
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291} = {AEDD4819-EE4F-4A94-9776-10C430A9D291}
+		{607F2422-5660-4D06-B604-C975A30E5CD5} = {607F2422-5660-4D06-B604-C975A30E5CD5}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4} = {8BF28A9B-EB60-4C1F-84B2-D133718C21A4}
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533} = {DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_hexen", "basepak_hexen.vcproj", "{DD00F5CF-9520-44D2-BDC4-45130B5024FA}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_strife", "basepak_strife.vcxproj", "{1CD88557-1039-4B0C-9DF6-AB181E799536}"
 	ProjectSection(ProjectDependencies) = postProject
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291} = {AEDD4819-EE4F-4A94-9776-10C430A9D291}
+		{607F2422-5660-4D06-B604-C975A30E5CD5} = {607F2422-5660-4D06-B604-C975A30E5CD5}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4} = {8BF28A9B-EB60-4C1F-84B2-D133718C21A4}
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533} = {DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}
+		{DD00F5CF-9520-44D2-BDC4-45130B5024FA} = {DD00F5CF-9520-44D2-BDC4-45130B5024FA}
+		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A} = {FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_strife", "basepak_strife.vcproj", "{1CD88557-1039-4B0C-9DF6-AB181E799536}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_plutonia", "basepak_plutonia.vcxproj", "{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}"
 	ProjectSection(ProjectDependencies) = postProject
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291} = {AEDD4819-EE4F-4A94-9776-10C430A9D291}
+		{607F2422-5660-4D06-B604-C975A30E5CD5} = {607F2422-5660-4D06-B604-C975A30E5CD5}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4} = {8BF28A9B-EB60-4C1F-84B2-D133718C21A4}
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533} = {DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}
+		{DD00F5CF-9520-44D2-BDC4-45130B5024FA} = {DD00F5CF-9520-44D2-BDC4-45130B5024FA}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_plutonia", "basepak_plutonia.vcproj", "{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_tnt", "basepak_tnt.vcxproj", "{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}"
 	ProjectSection(ProjectDependencies) = postProject
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291} = {AEDD4819-EE4F-4A94-9776-10C430A9D291}
+		{607F2422-5660-4D06-B604-C975A30E5CD5} = {607F2422-5660-4D06-B604-C975A30E5CD5}
+		{1CD88557-1039-4B0C-9DF6-AB181E799536} = {1CD88557-1039-4B0C-9DF6-AB181E799536}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4} = {8BF28A9B-EB60-4C1F-84B2-D133718C21A4}
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533} = {DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}
+		{DD00F5CF-9520-44D2-BDC4-45130B5024FA} = {DD00F5CF-9520-44D2-BDC4-45130B5024FA}
+		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A} = {FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_tnt", "basepak_tnt.vcproj", "{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_doom1", "basepak_doom1.vcxproj", "{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}"
 	ProjectSection(ProjectDependencies) = postProject
+		{607F2422-5660-4D06-B604-C975A30E5CD5} = {607F2422-5660-4D06-B604-C975A30E5CD5}
+		{EE79378F-9689-40B8-99F4-B0E5872A6337} = {EE79378F-9689-40B8-99F4-B0E5872A6337}
 		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD} = {F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}
 	EndProjectSection
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "basepak_doom1", "basepak_doom1.vcproj", "{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "core", "core.vcxproj", "{D509CF19-F957-4F58-8F05-3AA6AA520B2F}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gme", "gme.vcxproj", "{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "updaterevision", "updaterevision.vcxproj", "{6077B7D6-349F-4077-B552-3BC302EF5859}"
 EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "core", "core.vcproj", "{D509CF19-F957-4F58-8F05-3AA6AA520B2F}"
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "vavoom-dedicated", "vavoom-dedicated.vcxproj", "{45D28600-E993-49D7-97F1-B08D3A490244}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -103,132 +115,188 @@
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Debug|Win32.ActiveCfg = Debug|Win32
 		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Debug|Win32.Build.0 = Debug|Win32
-		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Debug|x64.ActiveCfg = Debug|Win32
+		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Debug|x64.ActiveCfg = Debug|x64
+		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Debug|x64.Build.0 = Debug|x64
 		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Release|Win32.ActiveCfg = Release|Win32
 		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Release|Win32.Build.0 = Release|Win32
-		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Release|x64.ActiveCfg = Release|Win32
+		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Release|x64.ActiveCfg = Release|x64
+		{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}.Release|x64.Build.0 = Release|x64
 		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Debug|Win32.ActiveCfg = Debug|Win32
 		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Debug|Win32.Build.0 = Debug|Win32
-		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Debug|x64.ActiveCfg = Debug|Win32
+		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Debug|x64.ActiveCfg = Debug|x64
+		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Debug|x64.Build.0 = Debug|x64
 		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Release|Win32.ActiveCfg = Release|Win32
 		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Release|Win32.Build.0 = Release|Win32
-		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Release|x64.ActiveCfg = Release|Win32
+		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Release|x64.ActiveCfg = Release|x64
+		{3DC4FB0F-24B7-4051-9FAA-B2215CF73554}.Release|x64.Build.0 = Release|x64
 		{0292D20B-0826-40E7-B713-A9B512505155}.Debug|Win32.ActiveCfg = Debug|Win32
 		{0292D20B-0826-40E7-B713-A9B512505155}.Debug|Win32.Build.0 = Debug|Win32
-		{0292D20B-0826-40E7-B713-A9B512505155}.Debug|x64.ActiveCfg = Debug|Win32
+		{0292D20B-0826-40E7-B713-A9B512505155}.Debug|x64.ActiveCfg = Debug|x64
+		{0292D20B-0826-40E7-B713-A9B512505155}.Debug|x64.Build.0 = Debug|x64
 		{0292D20B-0826-40E7-B713-A9B512505155}.Release|Win32.ActiveCfg = Release|Win32
 		{0292D20B-0826-40E7-B713-A9B512505155}.Release|Win32.Build.0 = Release|Win32
-		{0292D20B-0826-40E7-B713-A9B512505155}.Release|x64.ActiveCfg = Release|Win32
+		{0292D20B-0826-40E7-B713-A9B512505155}.Release|x64.ActiveCfg = Release|x64
+		{0292D20B-0826-40E7-B713-A9B512505155}.Release|x64.Build.0 = Release|x64
 		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Debug|Win32.ActiveCfg = Debug|Win32
 		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Debug|Win32.Build.0 = Debug|Win32
-		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Debug|x64.ActiveCfg = Debug|Win32
+		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Debug|x64.ActiveCfg = Debug|x64
+		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Debug|x64.Build.0 = Debug|x64
 		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Release|Win32.ActiveCfg = Release|Win32
 		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Release|Win32.Build.0 = Release|Win32
-		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Release|x64.ActiveCfg = Release|Win32
+		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Release|x64.ActiveCfg = Release|x64
+		{A5E43684-5BC7-4DEE-965B-F2E20C360793}.Release|x64.Build.0 = Release|x64
 		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Debug|Win32.ActiveCfg = Debug|Win32
 		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Debug|Win32.Build.0 = Debug|Win32
-		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Debug|x64.ActiveCfg = Debug|Win32
+		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Debug|x64.ActiveCfg = Debug|x64
+		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Debug|x64.Build.0 = Debug|x64
 		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Release|Win32.ActiveCfg = Release|Win32
 		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Release|Win32.Build.0 = Release|Win32
-		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Release|x64.ActiveCfg = Release|Win32
+		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Release|x64.ActiveCfg = Release|x64
+		{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}.Release|x64.Build.0 = Release|x64
 		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Debug|Win32.ActiveCfg = Debug|Win32
 		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Debug|Win32.Build.0 = Debug|Win32
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Debug|x64.ActiveCfg = Debug|Win32
+		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Debug|x64.ActiveCfg = Debug|x64
+		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Debug|x64.Build.0 = Debug|x64
 		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Release|Win32.ActiveCfg = Release|Win32
 		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Release|Win32.Build.0 = Release|Win32
-		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Release|x64.ActiveCfg = Release|Win32
+		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Release|x64.ActiveCfg = Release|x64
+		{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}.Release|x64.Build.0 = Release|x64
 		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Debug|Win32.ActiveCfg = Debug|Win32
 		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Debug|Win32.Build.0 = Debug|Win32
-		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Debug|x64.ActiveCfg = Debug|Win32
+		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Debug|x64.ActiveCfg = Debug|x64
+		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Debug|x64.Build.0 = Debug|x64
 		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Release|Win32.ActiveCfg = Release|Win32
 		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Release|Win32.Build.0 = Release|Win32
-		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Release|x64.ActiveCfg = Release|Win32
+		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Release|x64.ActiveCfg = Release|x64
+		{023239F2-F1D1-43FB-9B2C-604727C13BC5}.Release|x64.Build.0 = Release|x64
 		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Debug|Win32.ActiveCfg = Debug|Win32
 		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Debug|Win32.Build.0 = Debug|Win32
-		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Debug|x64.ActiveCfg = Debug|Win32
+		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Debug|x64.ActiveCfg = Debug|x64
+		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Debug|x64.Build.0 = Debug|x64
 		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Release|Win32.ActiveCfg = Release|Win32
 		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Release|Win32.Build.0 = Release|Win32
-		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Release|x64.ActiveCfg = Release|Win32
+		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Release|x64.ActiveCfg = Release|x64
+		{6CE404BD-51D1-4DA4-BE5F-827226C6A1CD}.Release|x64.Build.0 = Release|x64
 		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Debug|Win32.ActiveCfg = Debug|Win32
 		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Debug|Win32.Build.0 = Debug|Win32
-		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Debug|x64.ActiveCfg = Debug|Win32
+		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Debug|x64.ActiveCfg = Debug|x64
+		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Debug|x64.Build.0 = Debug|x64
 		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Release|Win32.ActiveCfg = Release|Win32
 		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Release|Win32.Build.0 = Release|Win32
-		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Release|x64.ActiveCfg = Release|Win32
+		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Release|x64.ActiveCfg = Release|x64
+		{F424FB4F-2341-4CA6-A13F-71E4A8C696DC}.Release|x64.Build.0 = Release|x64
 		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Debug|Win32.ActiveCfg = Debug|Win32
 		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Debug|Win32.Build.0 = Debug|Win32
-		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Debug|x64.ActiveCfg = Debug|Win32
+		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Debug|x64.ActiveCfg = Debug|x64
+		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Debug|x64.Build.0 = Debug|x64
 		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Release|Win32.ActiveCfg = Release|Win32
 		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Release|Win32.Build.0 = Release|Win32
-		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Release|x64.ActiveCfg = Release|Win32
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|Win32.ActiveCfg = Debug|Win32
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|Win32.Build.0 = Debug|Win32
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|x64.ActiveCfg = Debug|x64
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|x64.Build.0 = Debug|x64
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|Win32.ActiveCfg = Release|Win32
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|Win32.Build.0 = Release|Win32
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|x64.ActiveCfg = Release|x64
-		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|x64.Build.0 = Release|x64
+		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Release|x64.ActiveCfg = Release|x64
+		{EF16EEF7-10E7-4A02-866F-1F2F21237DA7}.Release|x64.Build.0 = Release|x64
 		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Debug|Win32.ActiveCfg = Debug|Win32
 		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Debug|Win32.Build.0 = Debug|Win32
-		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Debug|x64.ActiveCfg = Debug|Win32
+		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Debug|x64.ActiveCfg = Debug|x64
+		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Debug|x64.Build.0 = Debug|x64
 		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Release|Win32.ActiveCfg = Release|Win32
 		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Release|Win32.Build.0 = Release|Win32
-		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Release|x64.ActiveCfg = Release|Win32
+		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Release|x64.ActiveCfg = Release|x64
+		{EE79378F-9689-40B8-99F4-B0E5872A6337}.Release|x64.Build.0 = Release|x64
 		{607F2422-5660-4D06-B604-C975A30E5CD5}.Debug|Win32.ActiveCfg = Debug|Win32
 		{607F2422-5660-4D06-B604-C975A30E5CD5}.Debug|Win32.Build.0 = Debug|Win32
-		{607F2422-5660-4D06-B604-C975A30E5CD5}.Debug|x64.ActiveCfg = Debug|Win32
+		{607F2422-5660-4D06-B604-C975A30E5CD5}.Debug|x64.ActiveCfg = Debug|x64
+		{607F2422-5660-4D06-B604-C975A30E5CD5}.Debug|x64.Build.0 = Debug|x64
 		{607F2422-5660-4D06-B604-C975A30E5CD5}.Release|Win32.ActiveCfg = Release|Win32
 		{607F2422-5660-4D06-B604-C975A30E5CD5}.Release|Win32.Build.0 = Release|Win32
-		{607F2422-5660-4D06-B604-C975A30E5CD5}.Release|x64.ActiveCfg = Release|Win32
+		{607F2422-5660-4D06-B604-C975A30E5CD5}.Release|x64.ActiveCfg = Release|x64
+		{607F2422-5660-4D06-B604-C975A30E5CD5}.Release|x64.Build.0 = Release|x64
 		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Debug|Win32.ActiveCfg = Debug|Win32
 		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Debug|Win32.Build.0 = Debug|Win32
-		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Debug|x64.ActiveCfg = Debug|Win32
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Debug|x64.ActiveCfg = Debug|x64
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Debug|x64.Build.0 = Debug|x64
 		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Release|Win32.ActiveCfg = Release|Win32
 		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Release|Win32.Build.0 = Release|Win32
-		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Release|x64.ActiveCfg = Release|Win32
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Release|x64.ActiveCfg = Release|x64
+		{DC9BBFA1-6B89-44AA-ADDE-DBBBF3B2E533}.Release|x64.Build.0 = Release|x64
 		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Debug|Win32.ActiveCfg = Debug|Win32
 		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Debug|Win32.Build.0 = Debug|Win32
-		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Debug|x64.ActiveCfg = Debug|Win32
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Debug|x64.ActiveCfg = Debug|x64
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Debug|x64.Build.0 = Debug|x64
 		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Release|Win32.ActiveCfg = Release|Win32
 		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Release|Win32.Build.0 = Release|Win32
-		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Release|x64.ActiveCfg = Release|Win32
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Release|x64.ActiveCfg = Release|x64
+		{AEDD4819-EE4F-4A94-9776-10C430A9D291}.Release|x64.Build.0 = Release|x64
 		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Debug|Win32.ActiveCfg = Debug|Win32
 		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Debug|Win32.Build.0 = Debug|Win32
-		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Debug|x64.ActiveCfg = Debug|Win32
+		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Debug|x64.ActiveCfg = Debug|x64
+		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Debug|x64.Build.0 = Debug|x64
 		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Release|Win32.ActiveCfg = Release|Win32
 		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Release|Win32.Build.0 = Release|Win32
-		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Release|x64.ActiveCfg = Release|Win32
+		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Release|x64.ActiveCfg = Release|x64
+		{DD00F5CF-9520-44D2-BDC4-45130B5024FA}.Release|x64.Build.0 = Release|x64
 		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Debug|Win32.ActiveCfg = Debug|Win32
 		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Debug|Win32.Build.0 = Debug|Win32
-		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Debug|x64.ActiveCfg = Debug|Win32
+		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Debug|x64.ActiveCfg = Debug|x64
+		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Debug|x64.Build.0 = Debug|x64
 		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Release|Win32.ActiveCfg = Release|Win32
 		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Release|Win32.Build.0 = Release|Win32
-		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Release|x64.ActiveCfg = Release|Win32
+		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Release|x64.ActiveCfg = Release|x64
+		{1CD88557-1039-4B0C-9DF6-AB181E799536}.Release|x64.Build.0 = Release|x64
 		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Debug|Win32.ActiveCfg = Debug|Win32
 		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Debug|Win32.Build.0 = Debug|Win32
-		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Debug|x64.ActiveCfg = Debug|Win32
+		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Debug|x64.ActiveCfg = Debug|x64
+		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Debug|x64.Build.0 = Debug|x64
 		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Release|Win32.ActiveCfg = Release|Win32
 		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Release|Win32.Build.0 = Release|Win32
-		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Release|x64.ActiveCfg = Release|Win32
+		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Release|x64.ActiveCfg = Release|x64
+		{FC5A8ED8-3CE2-4FB7-B7A8-8D9DF929524A}.Release|x64.Build.0 = Release|x64
 		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Debug|Win32.ActiveCfg = Debug|Win32
 		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Debug|Win32.Build.0 = Debug|Win32
-		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Debug|x64.ActiveCfg = Debug|Win32
+		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Debug|x64.ActiveCfg = Debug|x64
+		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Debug|x64.Build.0 = Debug|x64
 		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Release|Win32.ActiveCfg = Release|Win32
 		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Release|Win32.Build.0 = Release|Win32
-		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Release|x64.ActiveCfg = Release|Win32
+		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Release|x64.ActiveCfg = Release|x64
+		{9DE9595D-4094-49EF-BC0B-851CE1ECCA5C}.Release|x64.Build.0 = Release|x64
 		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Debug|Win32.ActiveCfg = Debug|Win32
 		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Debug|Win32.Build.0 = Debug|Win32
-		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Debug|x64.ActiveCfg = Debug|Win32
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Debug|x64.ActiveCfg = Debug|x64
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Debug|x64.Build.0 = Debug|x64
 		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Release|Win32.ActiveCfg = Release|Win32
 		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Release|Win32.Build.0 = Release|Win32
-		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Release|x64.ActiveCfg = Release|Win32
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Release|x64.ActiveCfg = Release|x64
+		{8BF28A9B-EB60-4C1F-84B2-D133718C21A4}.Release|x64.Build.0 = Release|x64
 		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Debug|Win32.ActiveCfg = Debug|Win32
 		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Debug|Win32.Build.0 = Debug|Win32
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Debug|x64.ActiveCfg = Debug|Win32
+		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Debug|x64.ActiveCfg = Debug|x64
+		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Debug|x64.Build.0 = Debug|x64
 		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Release|Win32.ActiveCfg = Release|Win32
 		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Release|Win32.Build.0 = Release|Win32
-		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Release|x64.ActiveCfg = Release|Win32
+		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Release|x64.ActiveCfg = Release|x64
+		{D509CF19-F957-4F58-8F05-3AA6AA520B2F}.Release|x64.Build.0 = Release|x64
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Debug|Win32.ActiveCfg = Debug|Win32
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Debug|Win32.Build.0 = Debug|Win32
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Debug|x64.ActiveCfg = Debug|x64
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Debug|x64.Build.0 = Debug|x64
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Release|Win32.ActiveCfg = Release|Win32
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Release|Win32.Build.0 = Release|Win32
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Release|x64.ActiveCfg = Release|x64
+		{142A5D48-ED8D-4C77-A7C2-A983375D4A9B}.Release|x64.Build.0 = Release|x64
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|Win32.Build.0 = Debug|Win32
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|x64.ActiveCfg = Debug|x64
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Debug|x64.Build.0 = Debug|x64
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|Win32.ActiveCfg = Release|Win32
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|Win32.Build.0 = Release|Win32
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|x64.ActiveCfg = Release|x64
+		{6077B7D6-349F-4077-B552-3BC302EF5859}.Release|x64.Build.0 = Release|x64
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Debug|Win32.ActiveCfg = Debug|Win32
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Debug|Win32.Build.0 = Debug|Win32
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Debug|x64.ActiveCfg = Debug|x64
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Debug|x64.Build.0 = Debug|x64
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Release|Win32.ActiveCfg = Release|Win32
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Release|Win32.Build.0 = Release|Win32
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Release|x64.ActiveCfg = Release|x64
+		{45D28600-E993-49D7-97F1-B08D3A490244}.Release|x64.Build.0 = Release|x64
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff -Nur orig/msvc/vavoom.vcproj mod/msvc/vavoom.vcproj
--- orig/msvc/vavoom.vcproj	2010-12-17 16:09:03.000000000 +0100
+++ mod/msvc/vavoom.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,1710 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="vavoom"
-	ProjectGUID="{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}"
-	RootNamespace="vavoom"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-				Description="Checking svnrevision.h..."
-				CommandLine="&quot;$(OutDir)\updaterevision.exe&quot; ../ ../source/svnrev.h"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName=".\Release/vavoom.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				PreprocessorDefinitions="NDEBUG;WIN32;_WINDOWS;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				RuntimeTypeInfo="false"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CallingConvention="0"
-				CompileAs="2"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="0"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/LTCG"
-				AdditionalDependencies="winmm.lib opengl32.lib openal32.lib wsock32.lib libpng.lib jpeg.lib zlib.lib libmad.lib libvorbis_static.lib libogg_static.lib libmikmod.lib libFLAC_static.lib libFLAC++_static.lib"
-				OutputFile="$(OutDir)/vavoom.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				IgnoreDefaultLibraryNames=""
-				GenerateDebugInformation="false"
-				GenerateMapFile="false"
-				MapExports="false"
-				SubSystem="2"
-				TerminalServerAware="0"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				LinkTimeCodeGeneration="1"
-				SetChecksum="true"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-				Description="Checking svnrevision.h..."
-				CommandLine="&quot;$(OutDir)\updaterevision.exe&quot; ../ ../source/svnrev.h"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName=".\Debug/vavoom.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				PreprocessorDefinitions="_DEBUG;WIN32;_WINDOWS;_WIN32;_CRTDBG_MAP_ALLOC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				EnableFunctionLevelLinking="true"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-				CompileAs="0"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="0"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="user32.lib ole32.lib gdi32.lib winmm.lib opengl32.lib openal32.lib wsock32.lib libpngd.lib libjpeg_d.lib zlibd.lib libmad_d.lib libvorbis_static_d.lib libogg_static_d.lib libmikmod_d.lib libFLAC_static_d.lib libFLAC++_static_d.lib"
-				OutputFile="$(OutDir)/vavoom.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateDebugInformation="true"
-				SubSystem="2"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="0"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="..\source\cheats.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\cmd.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\cvar.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\debug.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\files.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\fs_dir.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\fs_wad.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\fs_zip.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\host.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\infostr.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\language.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\level.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\lockdefs.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\mapinfo.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\maths.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\misc.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\pr_cmds.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\pr_exec.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sc_man.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\template.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\vc_class.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_constant.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_decorate.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_dehacked.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_emit_context.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_error.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_array.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_assign.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_base.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_cast.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_field.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_invoke.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_literal.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_local.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_misc.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_type.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_unary_binary.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_field.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_lexer.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_location.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_member.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_method.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_modifiers.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_object.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_package.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_parser.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_property.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_state.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_statement.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_struct.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_type.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\wad.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\zipstream.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="..\source\build.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\cmd.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\common.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\cvar.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\debug.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\files.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\fs_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\fwaddefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\gamedefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\host.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\infostr.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\language.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\level.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\lockdefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\mapinfo.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\maths.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\misc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\progdefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\progs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\protocol.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\save.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\scripts.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\template.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_class.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_constant.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_decorate.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_dehacked.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_emit_context.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_error.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_array.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_assign.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_base.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_cast.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_field.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_invoke.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_literal.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_misc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_type.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_unary_binary.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_field.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_lexer.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_location.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_member.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_method.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_modifiers.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_object.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_package.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_parser.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_property.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_state.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_statement.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_struct.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_type.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\wad.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\zipstream.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-			<File
-				RelativePath="..\source\vavoom.ico"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vavoom.rc"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vavoom_2.ico"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vavoom_3.ico"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Rendering"
-			>
-			<File
-				RelativePath="..\source\anorm_dots.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\anorms.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\drawer.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\fmd2defs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_adv_light.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_adv_things.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_bsp.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_data.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_light.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_main.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_model.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_particle.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_portal.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_public.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_shared.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_sky.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_surf.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\r_things.cpp"
-				>
-			</File>
-			<Filter
-				Name="OpenGL"
-				>
-				<File
-					RelativePath="..\source\gl_agl.cpp"
-					>
-					<FileConfiguration
-						Name="Release|Win32"
-						ExcludedFromBuild="true"
-						>
-						<Tool
-							Name="VCCLCompilerTool"
-						/>
-					</FileConfiguration>
-					<FileConfiguration
-						Name="Debug|Win32"
-						ExcludedFromBuild="true"
-						>
-						<Tool
-							Name="VCCLCompilerTool"
-						/>
-					</FileConfiguration>
-				</File>
-				<File
-					RelativePath="..\source\gl_draw.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\gl_local.h"
-					>
-				</File>
-				<File
-					RelativePath="..\source\gl_main.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\gl_model.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\gl_poly.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\gl_sdl.cpp"
-					>
-					<FileConfiguration
-						Name="Release|Win32"
-						ExcludedFromBuild="true"
-						>
-						<Tool
-							Name="VCCLCompilerTool"
-						/>
-					</FileConfiguration>
-					<FileConfiguration
-						Name="Debug|Win32"
-						ExcludedFromBuild="true"
-						>
-						<Tool
-							Name="VCCLCompilerTool"
-						/>
-					</FileConfiguration>
-				</File>
-				<File
-					RelativePath="..\source\gl_tex.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\gl_win32.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\gl_x.cpp"
-					>
-					<FileConfiguration
-						Name="Release|Win32"
-						ExcludedFromBuild="true"
-						>
-						<Tool
-							Name="VCCLCompilerTool"
-						/>
-					</FileConfiguration>
-					<FileConfiguration
-						Name="Debug|Win32"
-						ExcludedFromBuild="true"
-						>
-						<Tool
-							Name="VCCLCompilerTool"
-						/>
-					</FileConfiguration>
-				</File>
-			</Filter>
-			<Filter
-				Name="Direct3D"
-				>
-				<File
-					RelativePath="..\source\d3d_draw.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\d3d_local.h"
-					>
-				</File>
-				<File
-					RelativePath="..\source\d3d_main.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\d3d_poly.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\d3d_tex.cpp"
-					>
-				</File>
-			</Filter>
-			<Filter
-				Name="Textures"
-				>
-				<File
-					RelativePath="..\source\r_tex.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex.h"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_automap.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_base.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_camera.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_flat.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_imgz.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_jpeg.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_multipatch.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_patch.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_pcx.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_png.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_raw.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_tga.cpp"
-					>
-				</File>
-				<File
-					RelativePath="..\source\r_tex_warp.cpp"
-					>
-				</File>
-			</Filter>
-		</Filter>
-		<Filter
-			Name="Networking"
-			>
-			<File
-				RelativePath="..\source\net_channel.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_channel_control.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_channel_level.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_channel_object_map.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_channel_player.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_channel_thinker.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_connection.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_context.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_datagram.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_demo.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_loopback.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_main.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_message.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_message.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_object_map.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\net_udp.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\net_winsock.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\network.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Sound"
-			>
-			<File
-				RelativePath="..\source\eax.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_al.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_allegro.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\snd_allegromusic.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\snd_audiocd_bsd.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\snd_audiocd_linux.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\snd_audiocd_win32.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_data.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_flac.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_main.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_mikmod.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_mp3.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_qmus2mid.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_reverbs.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_sdl.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\snd_sdlmusic.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\snd_streamplayer.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_timidity.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_vorbis.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_wav.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_win32.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\snd_win32music.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sound.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="User Interface"
-			>
-			<File
-				RelativePath="..\source\am_map.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\automap.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\chat.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\chat.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\console.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\console.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\finale.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\finale.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\iline.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\iline.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\l_glbsp.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\l_glvis.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\menu.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\menu.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sbar.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sbar.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\screen.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\screen.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\text.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\text.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui_actor.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui_font.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui_font.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui_root.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui_root.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui_widget.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\ui_widget.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\video.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Input"
-			>
-			<File
-				RelativePath="..\source\in_alleg.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\in_input.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\in_sdl.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\in_win32.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\input.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Play"
-			>
-			<File
-				RelativePath="..\source\p_acs.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_acs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_clip.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_clip.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_entity.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_entity.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_entity_sight.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_entity_world.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_gameinfo.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_gameinfo.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_gameobject.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_gameobject.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_level_think.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_levelinfo.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_levelinfo.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_nodebuild.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_player.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_player.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_player_input.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_playerreplicationinfo.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_playerreplicationinfo.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_polyobj.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_setup.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_setup_udmf.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_switch.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_terrain.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_thinker.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_thinker.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_trace.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_world.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_world.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_worldinfo.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\p_worldinfo.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Client"
-			>
-			<File
-				RelativePath="..\source\cl_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\cl_main.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\client.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Server"
-			>
-			<File
-				RelativePath="..\source\server.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sv_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sv_main.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sv_save.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sv_world.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="System"
-			>
-			<File
-				RelativePath="..\source\sys_bsd.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\sys_lin.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\sys_sdl.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\sys_win.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\sys_wind.cpp"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\source\system.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\winlocal.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/vavoom.vcxproj mod/msvc/vavoom.vcxproj
--- orig/msvc/vavoom.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vavoom.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,770 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{D4D2D73F-1D39-4832-8FBC-FE49CF3F0833}</ProjectGuid>
+    <RootNamespace>vavoom</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msv;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\lib;E:\Libraries\OpenAL 1.1 SDK\libs\Win32;E:\Libraries\Release;E:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;E:\Libraries\wxWidgets-2.8.12\lib\vc_lib;E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\lib;F:\Libraries\OpenAL 1.1 SDK\libs\Win64;F:\Libraries\Release64;F:\Libraries\Release;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64;F:\Libraries\wxWidgets-2.8.12\lib\vc_lib;F:\Libraries\boost_1_49_0\stage\lib\x64;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\include;E:\Libraries\OpenAL 1.1 SDK\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\Debug;E:\Libraries\OpenAL 1.1 SDK\libs\Win32;$(LibraryPath)</LibraryPath>
+    <ExecutablePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\bin;$(ExecutablePath)</ExecutablePath>
+    <ExecutablePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\bin;$(ExecutablePath)</ExecutablePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ExecutablePath>E:\Libraries\bin;E:\Libraries\Git\bin;$(ExecutablePath)</ExecutablePath>
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <RunCodeAnalysis>false</RunCodeAnalysis>
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Release/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;WIN32;_WINDOWS;MIKMOD_STATIC;MODPLUG_STATIC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>None</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <EnablePREfast>false</EnablePREfast>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalDependencies>winmm.lib;opengl32.lib;openal32.lib;wsock32.lib;libpng.lib;jpeg.lib;zlib.lib;libmad.lib;libmikmod.lib;libmodplug.lib;libvorbis_static.lib;libogg_static.lib;libFLAC_static.lib;libFLAC++_static.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)vavoom.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries);</IgnoreSpecificDefaultLibraries>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <GenerateMapFile>false</GenerateMapFile>
+      <MapExports>false</MapExports>
+      <SubSystem>Windows</SubSystem>
+      <TerminalServerAware>
+      </TerminalServerAware>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <SetChecksum>true</SetChecksum>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <StackReserveSize>
+      </StackReserveSize>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+    <ProjectReference />
+    <ProjectReference />
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TypeLibraryName>.\Release/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;WIN32;_WIN32;_WINDOWS;MIKMOD_STATIC;MODPLUG_STATIC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=0;FPM_64BIT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <UndefinePreprocessorDefinitions>
+      </UndefinePreprocessorDefinitions>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalDependencies>winmm.lib;opengl32.lib;openal32.lib;wsock32.lib;libpng.lib;jpeg.lib;zlib.lib;libmad.lib;libmikmod.lib;libmodplug.lib;libvorbis_static.lib;libogg_static.lib;libFLAC_static.lib;libFLAC++_static.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)vavoom.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <IgnoreSpecificDefaultLibraries>%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <GenerateMapFile>false</GenerateMapFile>
+      <MapExports>false</MapExports>
+      <SubSystem>Windows</SubSystem>
+      <TerminalServerAware>
+      </TerminalServerAware>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <SetChecksum>true</SetChecksum>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <StackReserveSize>
+      </StackReserveSize>
+      <TargetMachine>MachineX64</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TargetEnvironment>Win32</TargetEnvironment>
+      <TypeLibraryName>.\Debug/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_DEBUG;WIN32;_WINDOWS;_WIN32;_CRTDBG_MAP_ALLOC;MIKMOD_STATIC;MODPLUG_STATIC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>winmm.lib;opengl32.lib;openal32.lib;wsock32.lib;libpngd.lib;libjpeg_d.lib;zlibd.lib;libmad_d.lib;libmikmod_d.lib;libmodplug_d.lib;libvorbis_static_d.lib;libogg_static_d.lib;libFLAC_static_d.lib;libFLAC++_static_d.lib;win_utf8_io_static_d.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)vavoom.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <IgnoreSpecificDefaultLibraries>
+      </IgnoreSpecificDefaultLibraries>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <PreBuildEvent>
+      <Message>Update gitrev.h</Message>
+      <Command>"$(OutDir)updaterevision.exe" "C:\Program Files\Git\bin" "$(SolutionDir)../" "$(SolutionDir)../source/gitrev.h"</Command>
+    </PreBuildEvent>
+    <Midl>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MkTypLibCompatible>true</MkTypLibCompatible>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TypeLibraryName>.\Debug/vavoom.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_DEBUG;WIN32;_WINDOWS;_WIN32;_CRTDBG_MAP_ALLOC;FLAC__NO_DLL;_CRT_SECURE_NO_DEPRECATE;USE_ASM_I386=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <BrowseInformation>
+      </BrowseInformation>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAs>Default</CompileAs>
+      <MultiProcessorCompilation>false</MultiProcessorCompilation>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0000</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>user32.lib;ole32.lib;gdi32.lib;winmm.lib;opengl32.lib;openal32.lib;wsock32.lib;libpngd.lib;libjpeg_d.lib;zlibd.lib;libmad_d.lib;libmikmod_d.lib;libvorbis_static_d.lib;libogg_static_d.lib;libmikmod_d.lib;libmodplug_d.lib;libFLAC_static_d.lib;libFLAC++_static_d.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)vavoom.exe</OutputFile>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\cheats.cpp" />
+    <ClCompile Include="..\source\cmd.cpp" />
+    <ClCompile Include="..\source\cvar.cpp" />
+    <ClCompile Include="..\source\debug.cpp" />
+    <ClCompile Include="..\source\files.cpp" />
+    <ClCompile Include="..\source\fs_dir.cpp" />
+    <ClCompile Include="..\source\fs_wad.cpp" />
+    <ClCompile Include="..\source\fs_zip.cpp" />
+    <ClCompile Include="..\source\host.cpp" />
+    <ClCompile Include="..\source\infostr.cpp" />
+    <ClCompile Include="..\source\language.cpp" />
+    <ClCompile Include="..\source\level.cpp" />
+    <ClCompile Include="..\source\lockdefs.cpp" />
+    <ClCompile Include="..\source\mapinfo.cpp" />
+    <ClCompile Include="..\source\maths.cpp" />
+    <ClCompile Include="..\source\misc.cpp" />
+    <ClCompile Include="..\source\pr_cmds.cpp" />
+    <ClCompile Include="..\source\pr_exec.cpp" />
+    <ClCompile Include="..\source\sc_man.cpp" />
+    <ClCompile Include="..\source\template.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_class.cpp" />
+    <ClCompile Include="..\source\vc_constant.cpp" />
+    <ClCompile Include="..\source\vc_decorate.cpp" />
+    <ClCompile Include="..\source\vc_dehacked.cpp" />
+    <ClCompile Include="..\source\vc_emit_context.cpp" />
+    <ClCompile Include="..\source\vc_error.cpp" />
+    <ClCompile Include="..\source\vc_expr_array.cpp" />
+    <ClCompile Include="..\source\vc_expr_assign.cpp" />
+    <ClCompile Include="..\source\vc_expr_base.cpp" />
+    <ClCompile Include="..\source\vc_expr_cast.cpp" />
+    <ClCompile Include="..\source\vc_expr_field.cpp" />
+    <ClCompile Include="..\source\vc_expr_invoke.cpp" />
+    <ClCompile Include="..\source\vc_expr_literal.cpp" />
+    <ClCompile Include="..\source\vc_expr_local.cpp" />
+    <ClCompile Include="..\source\vc_expr_misc.cpp" />
+    <ClCompile Include="..\source\vc_expr_type.cpp" />
+    <ClCompile Include="..\source\vc_expr_unary_binary.cpp" />
+    <ClCompile Include="..\source\vc_field.cpp" />
+    <ClCompile Include="..\source\vc_lexer.cpp" />
+    <ClCompile Include="..\source\vc_location.cpp" />
+    <ClCompile Include="..\source\vc_member.cpp" />
+    <ClCompile Include="..\source\vc_method.cpp" />
+    <ClCompile Include="..\source\vc_modifiers.cpp" />
+    <ClCompile Include="..\source\vc_object.cpp" />
+    <ClCompile Include="..\source\vc_package.cpp" />
+    <ClCompile Include="..\source\vc_parser.cpp" />
+    <ClCompile Include="..\source\vc_property.cpp" />
+    <ClCompile Include="..\source\vc_state.cpp" />
+    <ClCompile Include="..\source\vc_statement.cpp" />
+    <ClCompile Include="..\source\vc_struct.cpp" />
+    <ClCompile Include="..\source\vc_type.cpp" />
+    <ClCompile Include="..\source\wad.cpp" />
+    <ClCompile Include="..\source\zipstream.cpp" />
+    <ClCompile Include="..\source\r_adv_light.cpp" />
+    <ClCompile Include="..\source\r_adv_things.cpp" />
+    <ClCompile Include="..\source\r_bsp.cpp" />
+    <ClCompile Include="..\source\r_data.cpp" />
+    <ClCompile Include="..\source\r_light.cpp" />
+    <ClCompile Include="..\source\r_main.cpp" />
+    <ClCompile Include="..\source\r_model.cpp" />
+    <ClCompile Include="..\source\r_particle.cpp" />
+    <ClCompile Include="..\source\r_portal.cpp" />
+    <ClCompile Include="..\source\r_sky.cpp" />
+    <ClCompile Include="..\source\r_surf.cpp" />
+    <ClCompile Include="..\source\r_things.cpp" />
+    <ClCompile Include="..\source\gl_agl.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_draw.cpp" />
+    <ClCompile Include="..\source\gl_main.cpp" />
+    <ClCompile Include="..\source\gl_model.cpp" />
+    <ClCompile Include="..\source\gl_poly.cpp" />
+    <ClCompile Include="..\source\gl_sdl.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_tex.cpp" />
+    <ClCompile Include="..\source\gl_win32.cpp" />
+    <ClCompile Include="..\source\gl_x.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\d3d_draw.cpp" />
+    <ClCompile Include="..\source\d3d_main.cpp" />
+    <ClCompile Include="..\source\d3d_poly.cpp" />
+    <ClCompile Include="..\source\d3d_tex.cpp" />
+    <ClCompile Include="..\source\r_tex.cpp" />
+    <ClCompile Include="..\source\r_tex_automap.cpp" />
+    <ClCompile Include="..\source\r_tex_base.cpp" />
+    <ClCompile Include="..\source\r_tex_camera.cpp" />
+    <ClCompile Include="..\source\r_tex_flat.cpp" />
+    <ClCompile Include="..\source\r_tex_imgz.cpp" />
+    <ClCompile Include="..\source\r_tex_jpeg.cpp" />
+    <ClCompile Include="..\source\r_tex_multipatch.cpp" />
+    <ClCompile Include="..\source\r_tex_patch.cpp" />
+    <ClCompile Include="..\source\r_tex_pcx.cpp" />
+    <ClCompile Include="..\source\r_tex_png.cpp" />
+    <ClCompile Include="..\source\r_tex_raw.cpp" />
+    <ClCompile Include="..\source\r_tex_tga.cpp" />
+    <ClCompile Include="..\source\r_tex_warp.cpp" />
+    <ClCompile Include="..\source\net_channel.cpp" />
+    <ClCompile Include="..\source\net_channel_control.cpp" />
+    <ClCompile Include="..\source\net_channel_level.cpp" />
+    <ClCompile Include="..\source\net_channel_object_map.cpp" />
+    <ClCompile Include="..\source\net_channel_player.cpp" />
+    <ClCompile Include="..\source\net_channel_thinker.cpp" />
+    <ClCompile Include="..\source\net_connection.cpp" />
+    <ClCompile Include="..\source\net_context.cpp" />
+    <ClCompile Include="..\source\net_datagram.cpp" />
+    <ClCompile Include="..\source\net_demo.cpp" />
+    <ClCompile Include="..\source\net_loopback.cpp" />
+    <ClCompile Include="..\source\net_main.cpp" />
+    <ClCompile Include="..\source\net_message.cpp" />
+    <ClCompile Include="..\source\net_object_map.cpp" />
+    <ClCompile Include="..\source\net_udp.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\net_winsock.cpp" />
+    <ClCompile Include="..\source\snd_al.cpp" />
+    <ClCompile Include="..\source\snd_allegro.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_allegromusic.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_audiocd_bsd.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_audiocd_linux.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_audiocd_win32.cpp" />
+    <ClCompile Include="..\source\snd_data.cpp" />
+    <ClCompile Include="..\source\snd_flac.cpp" />
+    <ClCompile Include="..\source\snd_gme.cpp" />
+    <ClCompile Include="..\source\snd_main.cpp" />
+    <ClCompile Include="..\source\snd_mikmod.cpp" />
+    <ClCompile Include="..\source\snd_modplug.cpp" />
+    <ClCompile Include="..\source\snd_mp3.cpp" />
+    <ClCompile Include="..\source\snd_qmus2mid.cpp" />
+    <ClCompile Include="..\source\snd_reverbs.cpp" />
+    <ClCompile Include="..\source\snd_sdl.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_sdlmusic.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_streamplayer.cpp" />
+    <ClCompile Include="..\source\snd_timidity.cpp" />
+    <ClCompile Include="..\source\snd_vorbis.cpp" />
+    <ClCompile Include="..\source\snd_wav.cpp" />
+    <ClCompile Include="..\source\snd_win32.cpp" />
+    <ClCompile Include="..\source\snd_win32music.cpp" />
+    <ClCompile Include="..\source\am_map.cpp" />
+    <ClCompile Include="..\source\chat.cpp" />
+    <ClCompile Include="..\source\console.cpp" />
+    <ClCompile Include="..\source\finale.cpp" />
+    <ClCompile Include="..\source\iline.cpp" />
+    <ClCompile Include="..\source\l_glbsp.cpp" />
+    <ClCompile Include="..\source\l_glvis.cpp" />
+    <ClCompile Include="..\source\menu.cpp" />
+    <ClCompile Include="..\source\sbar.cpp" />
+    <ClCompile Include="..\source\screen.cpp" />
+    <ClCompile Include="..\source\text.cpp" />
+    <ClCompile Include="..\source\ui_actor.cpp" />
+    <ClCompile Include="..\source\ui_font.cpp" />
+    <ClCompile Include="..\source\ui_root.cpp" />
+    <ClCompile Include="..\source\ui_widget.cpp" />
+    <ClCompile Include="..\source\in_alleg.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\in_input.cpp" />
+    <ClCompile Include="..\source\in_sdl.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\in_win32.cpp" />
+    <ClCompile Include="..\source\p_acs.cpp" />
+    <ClCompile Include="..\source\p_clip.cpp" />
+    <ClCompile Include="..\source\p_entity.cpp" />
+    <ClCompile Include="..\source\p_entity_sight.cpp" />
+    <ClCompile Include="..\source\p_entity_world.cpp" />
+    <ClCompile Include="..\source\p_gameinfo.cpp" />
+    <ClCompile Include="..\source\p_gameobject.cpp" />
+    <ClCompile Include="..\source\p_level_think.cpp" />
+    <ClCompile Include="..\source\p_levelinfo.cpp" />
+    <ClCompile Include="..\source\p_nodebuild.cpp" />
+    <ClCompile Include="..\source\p_player.cpp" />
+    <ClCompile Include="..\source\p_player_input.cpp" />
+    <ClCompile Include="..\source\p_playerreplicationinfo.cpp" />
+    <ClCompile Include="..\source\p_polyobj.cpp" />
+    <ClCompile Include="..\source\p_setup.cpp" />
+    <ClCompile Include="..\source\p_setup_udmf.cpp" />
+    <ClCompile Include="..\source\p_switch.cpp" />
+    <ClCompile Include="..\source\p_terrain.cpp" />
+    <ClCompile Include="..\source\p_thinker.cpp" />
+    <ClCompile Include="..\source\p_trace.cpp" />
+    <ClCompile Include="..\source\p_world.cpp" />
+    <ClCompile Include="..\source\p_worldinfo.cpp" />
+    <ClCompile Include="..\source\cl_main.cpp" />
+    <ClCompile Include="..\source\sv_main.cpp" />
+    <ClCompile Include="..\source\sv_save.cpp" />
+    <ClCompile Include="..\source\sv_world.cpp" />
+    <ClCompile Include="..\source\sys_bsd.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_lin.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_sdl.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_win.cpp" />
+    <ClCompile Include="..\source\sys_wind.cpp">
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\build.h" />
+    <ClInclude Include="..\source\cmd.h" />
+    <ClInclude Include="..\source\common.h" />
+    <ClInclude Include="..\source\cvar.h" />
+    <ClInclude Include="..\source\debug.h" />
+    <ClInclude Include="..\source\files.h" />
+    <ClInclude Include="..\source\fs_local.h" />
+    <ClInclude Include="..\source\fwaddefs.h" />
+    <ClInclude Include="..\source\gamedefs.h" />
+    <ClInclude Include="..\source\host.h" />
+    <ClInclude Include="..\source\infostr.h" />
+    <ClInclude Include="..\source\language.h" />
+    <ClInclude Include="..\source\level.h" />
+    <ClInclude Include="..\source\lockdefs.h" />
+    <ClInclude Include="..\source\mapinfo.h" />
+    <ClInclude Include="..\source\maths.h" />
+    <ClInclude Include="..\source\misc.h" />
+    <ClInclude Include="..\source\progdefs.h" />
+    <ClInclude Include="..\source\progs.h" />
+    <ClInclude Include="..\source\protocol.h" />
+    <ClInclude Include="..\source\resource.h" />
+    <ClInclude Include="..\source\save.h" />
+    <ClInclude Include="..\source\scripts.h" />
+    <ClInclude Include="..\source\template.h" />
+    <ClInclude Include="..\source\vc_class.h" />
+    <ClInclude Include="..\source\vc_constant.h" />
+    <ClInclude Include="..\source\vc_decorate.h" />
+    <ClInclude Include="..\source\vc_dehacked.h" />
+    <ClInclude Include="..\source\vc_emit_context.h" />
+    <ClInclude Include="..\source\vc_error.h" />
+    <ClInclude Include="..\source\vc_expr_array.h" />
+    <ClInclude Include="..\source\vc_expr_assign.h" />
+    <ClInclude Include="..\source\vc_expr_base.h" />
+    <ClInclude Include="..\source\vc_expr_cast.h" />
+    <ClInclude Include="..\source\vc_expr_field.h" />
+    <ClInclude Include="..\source\vc_expr_invoke.h" />
+    <ClInclude Include="..\source\vc_expr_literal.h" />
+    <ClInclude Include="..\source\vc_expr_local.h" />
+    <ClInclude Include="..\source\vc_expr_misc.h" />
+    <ClInclude Include="..\source\vc_expr_type.h" />
+    <ClInclude Include="..\source\vc_expr_unary_binary.h" />
+    <ClInclude Include="..\source\vc_field.h" />
+    <ClInclude Include="..\source\vc_lexer.h" />
+    <ClInclude Include="..\source\vc_location.h" />
+    <ClInclude Include="..\source\vc_member.h" />
+    <ClInclude Include="..\source\vc_method.h" />
+    <ClInclude Include="..\source\vc_modifiers.h" />
+    <ClInclude Include="..\source\vc_object.h" />
+    <ClInclude Include="..\source\vc_package.h" />
+    <ClInclude Include="..\source\vc_parser.h" />
+    <ClInclude Include="..\source\vc_property.h" />
+    <ClInclude Include="..\source\vc_state.h" />
+    <ClInclude Include="..\source\vc_statement.h" />
+    <ClInclude Include="..\source\vc_struct.h" />
+    <ClInclude Include="..\source\vc_type.h" />
+    <ClInclude Include="..\source\wad.h" />
+    <ClInclude Include="..\source\zipstream.h" />
+    <ClInclude Include="..\source\anorm_dots.h" />
+    <ClInclude Include="..\source\anorms.h" />
+    <ClInclude Include="..\source\drawer.h" />
+    <ClInclude Include="..\source\fmd2defs.h" />
+    <ClInclude Include="..\source\r_local.h" />
+    <ClInclude Include="..\source\r_public.h" />
+    <ClInclude Include="..\source\r_shared.h" />
+    <ClInclude Include="..\source\gl_local.h" />
+    <ClInclude Include="..\source\d3d_local.h" />
+    <ClInclude Include="..\source\r_tex.h" />
+    <ClInclude Include="..\source\net_local.h" />
+    <ClInclude Include="..\source\net_message.h" />
+    <ClInclude Include="..\source\network.h" />
+    <ClInclude Include="..\source\eax.h" />
+    <ClInclude Include="..\source\snd_local.h" />
+    <ClInclude Include="..\source\sound.h" />
+    <ClInclude Include="..\source\automap.h" />
+    <ClInclude Include="..\source\chat.h" />
+    <ClInclude Include="..\source\console.h" />
+    <ClInclude Include="..\source\finale.h" />
+    <ClInclude Include="..\source\iline.h" />
+    <ClInclude Include="..\source\menu.h" />
+    <ClInclude Include="..\source\sbar.h" />
+    <ClInclude Include="..\source\screen.h" />
+    <ClInclude Include="..\source\text.h" />
+    <ClInclude Include="..\source\ui.h" />
+    <ClInclude Include="..\source\ui_font.h" />
+    <ClInclude Include="..\source\ui_root.h" />
+    <ClInclude Include="..\source\ui_widget.h" />
+    <ClInclude Include="..\source\video.h" />
+    <ClInclude Include="..\source\input.h" />
+    <ClInclude Include="..\source\p_acs.h" />
+    <ClInclude Include="..\source\p_clip.h" />
+    <ClInclude Include="..\source\p_entity.h" />
+    <ClInclude Include="..\source\p_gameinfo.h" />
+    <ClInclude Include="..\source\p_gameobject.h" />
+    <ClInclude Include="..\source\p_levelinfo.h" />
+    <ClInclude Include="..\source\p_player.h" />
+    <ClInclude Include="..\source\p_playerreplicationinfo.h" />
+    <ClInclude Include="..\source\p_thinker.h" />
+    <ClInclude Include="..\source\p_world.h" />
+    <ClInclude Include="..\source\p_worldinfo.h" />
+    <ClInclude Include="..\source\cl_local.h" />
+    <ClInclude Include="..\source\client.h" />
+    <ClInclude Include="..\source\server.h" />
+    <ClInclude Include="..\source\sv_local.h" />
+    <ClInclude Include="..\source\system.h" />
+    <ClInclude Include="..\source\winlocal.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\source\vavoom.ico" />
+    <None Include="..\source\vavoom_2.ico" />
+    <None Include="..\source\vavoom_3.ico" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\source\vavoom.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="gme.vcxproj">
+      <Project>{142a5d48-ed8d-4c77-a7c2-a983375d4a9b}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="libglbsp.vcxproj">
+      <Project>{3dc4fb0f-24b7-4051-9faa-b2215cf73554}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="libglvis.vcxproj">
+      <Project>{0292d20b-0826-40e7-b713-a9b512505155}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+    <ProjectReference Include="timidity.vcxproj">
+      <Project>{a5e43684-5bc7-4dee-965b-f2e20c360793}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vavoom.vcxproj.filters mod/msvc/vavoom.vcxproj.filters
--- orig/msvc/vavoom.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vavoom.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,931 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{964861da-fd72-416f-9246-a80b713cf137}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{f347612a-0001-46f0-b6e1-aa9887e42476}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{0174d417-4e5b-458a-8baa-6595929a75ec}</UniqueIdentifier>
+      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
+    </Filter>
+    <Filter Include="Rendering">
+      <UniqueIdentifier>{b4bee56d-0916-4dd9-a6cd-caa5c85178c1}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Rendering\OpenGL">
+      <UniqueIdentifier>{1815aded-087b-4e9a-ba5e-1526372bb38f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Rendering\Direct3D">
+      <UniqueIdentifier>{82af70e4-39e3-496a-b682-17c4f637e216}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Rendering\Textures">
+      <UniqueIdentifier>{8a6ef6e2-d938-4ee3-b831-10f5d98395ea}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Networking">
+      <UniqueIdentifier>{b45397d6-7d11-4f1a-a892-6f9a34d151d8}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Sound">
+      <UniqueIdentifier>{5a09dd73-f9ca-4beb-8302-829e3e120925}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="User Interface">
+      <UniqueIdentifier>{e3cf832b-f01f-43bc-b2de-221611426e0f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Input">
+      <UniqueIdentifier>{cc3d1176-85e9-464b-8d1b-bd32989d6525}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Play">
+      <UniqueIdentifier>{cb5c6b6e-573e-4acd-8d1c-330a955f6d41}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Client">
+      <UniqueIdentifier>{17912d92-8ce1-468a-9109-bd88bf57e836}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Server">
+      <UniqueIdentifier>{850ec370-ba61-4311-bffe-e63010755f78}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="System">
+      <UniqueIdentifier>{326326c3-2ff4-4e67-a46e-4a170e38d181}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\cheats.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\cmd.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\cvar.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\debug.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\files.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\fs_dir.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\fs_wad.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\fs_zip.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\host.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\infostr.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\language.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\level.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\lockdefs.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\mapinfo.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\maths.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\misc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\pr_cmds.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\pr_exec.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sc_man.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\template.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_class.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_constant.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_decorate.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_dehacked.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_emit_context.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_error.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_array.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_assign.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_base.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_cast.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_field.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_invoke.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_literal.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_local.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_misc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_type.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_unary_binary.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_field.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_lexer.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_location.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_member.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_method.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_modifiers.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_object.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_package.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_parser.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_property.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_state.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_statement.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_struct.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_type.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\wad.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\zipstream.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_adv_light.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_adv_things.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_bsp.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_data.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_light.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_main.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_model.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_particle.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_portal.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_sky.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_surf.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_things.cpp">
+      <Filter>Rendering</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_agl.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_draw.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_main.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_model.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_poly.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_sdl.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_tex.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_win32.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\gl_x.cpp">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\d3d_draw.cpp">
+      <Filter>Rendering\Direct3D</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\d3d_main.cpp">
+      <Filter>Rendering\Direct3D</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\d3d_poly.cpp">
+      <Filter>Rendering\Direct3D</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\d3d_tex.cpp">
+      <Filter>Rendering\Direct3D</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_automap.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_base.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_camera.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_flat.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_imgz.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_jpeg.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_multipatch.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_patch.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_pcx.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_png.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_raw.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_tga.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\r_tex_warp.cpp">
+      <Filter>Rendering\Textures</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_control.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_level.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_object_map.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_player.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_channel_thinker.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_connection.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_context.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_datagram.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_demo.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_loopback.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_main.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_message.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_object_map.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_udp.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\net_winsock.cpp">
+      <Filter>Networking</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_al.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_allegro.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_allegromusic.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_audiocd_bsd.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_audiocd_linux.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_audiocd_win32.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_data.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_flac.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_gme.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_main.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_mikmod.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_modplug.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_mp3.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_qmus2mid.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_reverbs.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_sdl.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_sdlmusic.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_streamplayer.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_timidity.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_vorbis.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_wav.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_win32.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\snd_win32music.cpp">
+      <Filter>Sound</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\am_map.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\chat.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\console.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\finale.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\iline.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\l_glbsp.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\l_glvis.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\menu.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sbar.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\screen.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\text.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\ui_actor.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\ui_font.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\ui_root.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\ui_widget.cpp">
+      <Filter>User Interface</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\in_alleg.cpp">
+      <Filter>Input</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\in_input.cpp">
+      <Filter>Input</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\in_sdl.cpp">
+      <Filter>Input</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\in_win32.cpp">
+      <Filter>Input</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_acs.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_clip.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_entity.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_entity_sight.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_entity_world.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_gameinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_gameobject.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_level_think.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_levelinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_nodebuild.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_player.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_player_input.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_playerreplicationinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_polyobj.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_setup.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_setup_udmf.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_switch.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_terrain.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_thinker.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_trace.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_world.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\p_worldinfo.cpp">
+      <Filter>Play</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\cl_main.cpp">
+      <Filter>Client</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sv_main.cpp">
+      <Filter>Server</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sv_save.cpp">
+      <Filter>Server</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sv_world.cpp">
+      <Filter>Server</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_bsd.cpp">
+      <Filter>System</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_lin.cpp">
+      <Filter>System</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_sdl.cpp">
+      <Filter>System</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_win.cpp">
+      <Filter>System</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\sys_wind.cpp">
+      <Filter>System</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\build.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\cmd.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\cvar.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\debug.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\files.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\fs_local.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\fwaddefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gamedefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\host.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\infostr.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\language.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\level.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\lockdefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\mapinfo.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\maths.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\progdefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\progs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\protocol.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\save.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\scripts.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\template.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_class.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_constant.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_decorate.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_dehacked.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_emit_context.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_error.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_array.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_assign.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_cast.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_field.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_invoke.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_literal.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_local.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_unary_binary.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_field.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_lexer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_location.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_member.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_method.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_modifiers.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_object.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_package.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_parser.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_property.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_state.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_statement.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_struct.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\wad.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\zipstream.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\anorm_dots.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\anorms.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\drawer.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\fmd2defs.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_local.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_public.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_shared.h">
+      <Filter>Rendering</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\gl_local.h">
+      <Filter>Rendering\OpenGL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\d3d_local.h">
+      <Filter>Rendering\Direct3D</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\r_tex.h">
+      <Filter>Rendering\Textures</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\net_local.h">
+      <Filter>Networking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\net_message.h">
+      <Filter>Networking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\network.h">
+      <Filter>Networking</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\eax.h">
+      <Filter>Sound</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\snd_local.h">
+      <Filter>Sound</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\sound.h">
+      <Filter>Sound</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\automap.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\chat.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\console.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\finale.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\iline.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\menu.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\sbar.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\screen.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\text.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\ui.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\ui_font.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\ui_root.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\ui_widget.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\video.h">
+      <Filter>User Interface</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\input.h">
+      <Filter>Input</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_acs.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_clip.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_entity.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_gameinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_gameobject.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_levelinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_player.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_playerreplicationinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_thinker.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_world.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\p_worldinfo.h">
+      <Filter>Play</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\cl_local.h">
+      <Filter>Client</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\client.h">
+      <Filter>Client</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\server.h">
+      <Filter>Server</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\sv_local.h">
+      <Filter>Server</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\system.h">
+      <Filter>System</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\winlocal.h">
+      <Filter>System</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\resource.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="..\source\vavoom.ico">
+      <Filter>Resource Files</Filter>
+    </None>
+    <None Include="..\source\vavoom_2.ico">
+      <Filter>Resource Files</Filter>
+    </None>
+    <None Include="..\source\vavoom_3.ico">
+      <Filter>Resource Files</Filter>
+    </None>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\source\vavoom.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vcc.vcproj mod/msvc/vcc.vcproj
--- orig/msvc/vcc.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/vcc.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,469 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="vcc"
-	ProjectGUID="{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}"
-	RootNamespace="vcc"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\../../utils/bin/vcc.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;IN_VCC"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\../../utils/bin/vcc.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;IN_VCC"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CallingConvention="0"
-				CompileAs="2"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				SuppressStartupBanner="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				LinkTimeCodeGeneration="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="..\source\vc_class.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_constant.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_emit_context.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_error.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_array.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_assign.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_base.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_cast.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_field.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_invoke.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_literal.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_local.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_misc.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_type.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_unary_binary.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_field.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_lexer.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_location.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_member.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_method.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_modifiers.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_package.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_parser.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_property.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_state.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_statement.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_struct.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_type.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\vcc\vcc.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="..\source\array.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\common.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\crc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\name.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\names.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\str.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\stream.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_class.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_constant.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_emit_context.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_error.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_array.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_assign.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_base.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_cast.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_field.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_invoke.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_literal.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_local.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_misc.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_type.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_expr_unary_binary.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_field.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_lexer.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_location.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_member.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_method.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_modifiers.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_package.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_parser.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_property.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_state.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_statement.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_struct.h"
-				>
-			</File>
-			<File
-				RelativePath="..\source\vc_type.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\vcc\vcc.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/vcc.vcxproj mod/msvc/vcc.vcxproj
--- orig/msvc/vcc.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vcc.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,347 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{2DB17B76-8B9F-4F30-A5FA-DC3FBC2E6768}</ProjectGuid>
+    <RootNamespace>vcc</RootNamespace>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;E:\Libraries\wxWidgets-2.8.12\include\msvc;E:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\Libraries\boost_1_49_0\;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\boost_1_49_0\stage\lib\x64;$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Midl>
+      <TypeLibraryName>.\../../utils/bin/vcc.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;IN_VCC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TypeLibraryName>.\../../utils/bin/vcc.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;IN_VCC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Midl>
+      <TypeLibraryName>.\../../utils/bin/vcc.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;IN_VCC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>None</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <FloatingPointModel>Strict</FloatingPointModel>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TypeLibraryName>.\../../utils/bin/vcc.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;IN_VCC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\vc_class.cpp" />
+    <ClCompile Include="..\source\vc_constant.cpp" />
+    <ClCompile Include="..\source\vc_emit_context.cpp" />
+    <ClCompile Include="..\source\vc_error.cpp" />
+    <ClCompile Include="..\source\vc_expr_array.cpp" />
+    <ClCompile Include="..\source\vc_expr_assign.cpp" />
+    <ClCompile Include="..\source\vc_expr_base.cpp" />
+    <ClCompile Include="..\source\vc_expr_cast.cpp" />
+    <ClCompile Include="..\source\vc_expr_field.cpp" />
+    <ClCompile Include="..\source\vc_expr_invoke.cpp" />
+    <ClCompile Include="..\source\vc_expr_literal.cpp" />
+    <ClCompile Include="..\source\vc_expr_local.cpp" />
+    <ClCompile Include="..\source\vc_expr_misc.cpp" />
+    <ClCompile Include="..\source\vc_expr_type.cpp" />
+    <ClCompile Include="..\source\vc_expr_unary_binary.cpp" />
+    <ClCompile Include="..\source\vc_field.cpp" />
+    <ClCompile Include="..\source\vc_lexer.cpp" />
+    <ClCompile Include="..\source\vc_location.cpp" />
+    <ClCompile Include="..\source\vc_member.cpp" />
+    <ClCompile Include="..\source\vc_method.cpp" />
+    <ClCompile Include="..\source\vc_modifiers.cpp" />
+    <ClCompile Include="..\source\vc_package.cpp" />
+    <ClCompile Include="..\source\vc_parser.cpp" />
+    <ClCompile Include="..\source\vc_property.cpp" />
+    <ClCompile Include="..\source\vc_state.cpp" />
+    <ClCompile Include="..\source\vc_statement.cpp" />
+    <ClCompile Include="..\source\vc_struct.cpp" />
+    <ClCompile Include="..\source\vc_type.cpp" />
+    <ClCompile Include="..\utils\vcc\vcc.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\array.h" />
+    <ClInclude Include="..\source\common.h" />
+    <ClInclude Include="..\source\crc.h" />
+    <ClInclude Include="..\source\name.h" />
+    <ClInclude Include="..\source\names.h" />
+    <ClInclude Include="..\source\str.h" />
+    <ClInclude Include="..\source\stream.h" />
+    <ClInclude Include="..\source\vc_class.h" />
+    <ClInclude Include="..\source\vc_constant.h" />
+    <ClInclude Include="..\source\vc_emit_context.h" />
+    <ClInclude Include="..\source\vc_error.h" />
+    <ClInclude Include="..\source\vc_expr_array.h" />
+    <ClInclude Include="..\source\vc_expr_assign.h" />
+    <ClInclude Include="..\source\vc_expr_base.h" />
+    <ClInclude Include="..\source\vc_expr_cast.h" />
+    <ClInclude Include="..\source\vc_expr_field.h" />
+    <ClInclude Include="..\source\vc_expr_invoke.h" />
+    <ClInclude Include="..\source\vc_expr_literal.h" />
+    <ClInclude Include="..\source\vc_expr_local.h" />
+    <ClInclude Include="..\source\vc_expr_misc.h" />
+    <ClInclude Include="..\source\vc_expr_type.h" />
+    <ClInclude Include="..\source\vc_expr_unary_binary.h" />
+    <ClInclude Include="..\source\vc_field.h" />
+    <ClInclude Include="..\source\vc_lexer.h" />
+    <ClInclude Include="..\source\vc_location.h" />
+    <ClInclude Include="..\source\vc_member.h" />
+    <ClInclude Include="..\source\vc_method.h" />
+    <ClInclude Include="..\source\vc_modifiers.h" />
+    <ClInclude Include="..\source\vc_package.h" />
+    <ClInclude Include="..\source\vc_parser.h" />
+    <ClInclude Include="..\source\vc_property.h" />
+    <ClInclude Include="..\source\vc_state.h" />
+    <ClInclude Include="..\source\vc_statement.h" />
+    <ClInclude Include="..\source\vc_struct.h" />
+    <ClInclude Include="..\source\vc_type.h" />
+    <ClInclude Include="..\utils\vcc\vcc.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vcc.vcxproj.filters mod/msvc/vcc.vcxproj.filters
--- orig/msvc/vcc.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vcc.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,212 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{60075ad1-1e09-4c2d-a0de-d9eb9f2bf80f}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{d913d001-3ca0-4939-88a8-9689dd341e91}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\source\vc_class.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_constant.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_emit_context.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_error.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_array.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_assign.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_base.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_cast.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_field.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_invoke.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_literal.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_local.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_misc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_type.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_expr_unary_binary.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_field.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_lexer.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_location.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_member.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_method.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_modifiers.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_package.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_parser.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_property.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_state.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_statement.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_struct.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\source\vc_type.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\vcc\vcc.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\source\array.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\crc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\name.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\names.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\str.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\stream.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_class.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_constant.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_emit_context.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_error.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_array.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_assign.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_cast.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_field.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_invoke.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_literal.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_local.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_expr_unary_binary.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_field.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_lexer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_location.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_member.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_method.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_modifiers.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_package.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_parser.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_property.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_state.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_statement.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_struct.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\source\vc_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\vcc\vcc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vlumpy.vcproj mod/msvc/vlumpy.vcproj
--- orig/msvc/vlumpy.vcproj	2010-09-01 20:26:06.000000000 +0200
+++ mod/msvc/vlumpy.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,268 +0,0 @@
-<?xml version="1.0" encoding="windows-1253"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="vlumpy"
-	ProjectGUID="{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}"
-	RootNamespace="vlumpy"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/vlumpy.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="3"
-				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="true"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="1"
-				CallingConvention="0"
-				CompileAs="2"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="zlib.lib"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				LinkTimeCodeGeneration="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ProjectName)_$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Debug/vlumpy.tlb"
-				HeaderFileName=""
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../utils/common"
-				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1062"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="zlibd.lib"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\imglib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\vlumpy\ioapi.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\scrlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\vlumpy\vlumpy.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\wadlib.cpp"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\vlumpy\zip.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl"
-			>
-			<File
-				RelativePath="..\utils\common\cmdlib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\fwaddefs.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\imglib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\vlumpy\ioapi.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\scrlib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\common\wadlib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\utils\vlumpy\zip.h"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nur orig/msvc/vlumpy.vcxproj mod/msvc/vlumpy.vcxproj
--- orig/msvc/vlumpy.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vlumpy.vcxproj	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,302 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F65AC2B2-1632-4584-BDA1-DAC149FC9BDD}</ProjectGuid>
+    <RootNamespace>vlumpy</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseOfMfc>false</UseOfMfc>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)$(Configuration)_$(PlatformName)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName)_$(Configuration)_$(PlatformName)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)$(Configuration)\</OutDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)$(Configuration)\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName)_$(Configuration)\</IntDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName)_$(Configuration)\</IntDir>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
+    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
+    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\FMOD Programmers API Win32\api\inc;E:\Libraries\include;E:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;E:\Libraries\wxWidgets-2.8.11\include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\FMOD Programmers API Win32\api\inc;F:\Libraries\include64;F:\Libraries\include;F:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;F:\Libraries\wxWidgets-2.8.12\include\msvc;F:\Libraries\boost_1_49_0;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">E:\Libraries\Release;E:\Libraries\Debug;E:\Libraries\boost_1_49_0\stage\lib;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">E:\Libraries\Debug;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">F:\Libraries\boost_1_49_0\stage\lib\x64;F:\Libraries\Release64;$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Midl>
+      <TypeLibraryName>.\Release/vlumpy.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Full</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP /Oy- %(AdditionalOptions)</AdditionalOptions>
+      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <OpenMPSupport>false</OpenMPSupport>
+      <SDLCheck>false</SDLCheck>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TypeLibraryName>.\Release/vlumpy.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
+      <OmitFramePointers>true</OmitFramePointers>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>false</StringPooling>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <CallingConvention>Cdecl</CallingConvention>
+      <CompileAs>CompileAsCpp</CompileAs>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
+      <AdditionalOptions>/Qpar-report:1 /Qvec-report:1 /Gw /MP %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>zlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <SubSystem>Console</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>false</EnableCOMDATFolding>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Midl>
+      <TypeLibraryName>.\Debug/vlumpy.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>OldStyle</DebugInformationFormat>
+      <AdditionalOptions>/Oy- %(AdditionalOptions)</AdditionalOptions>
+      <SDLCheck>false</SDLCheck>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>zlibd.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX86</TargetMachine>
+      <LargeAddressAware>true</LargeAddressAware>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TypeLibraryName>.\Debug/vlumpy.tlb</TypeLibraryName>
+      <HeaderFileName>
+      </HeaderFileName>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../utils/common;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <WarningLevel>Level3</WarningLevel>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <Culture>0x0426</Culture>
+    </ResourceCompile>
+    <Link>
+      <AdditionalDependencies>zlibd.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Console</SubSystem>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+    <Bscmake>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+    </Bscmake>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp" />
+    <ClCompile Include="..\utils\common\imglib.cpp" />
+    <ClCompile Include="..\utils\vlumpy\ioapi.cpp" />
+    <ClCompile Include="..\utils\common\scrlib.cpp" />
+    <ClCompile Include="..\utils\vlumpy\vlumpy.cpp" />
+    <ClCompile Include="..\utils\common\wadlib.cpp" />
+    <ClCompile Include="..\utils\vlumpy\zip.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h" />
+    <ClInclude Include="..\utils\common\fwaddefs.h" />
+    <ClInclude Include="..\utils\common\imglib.h" />
+    <ClInclude Include="..\utils\vlumpy\ioapi.h" />
+    <ClInclude Include="..\utils\common\scrlib.h" />
+    <ClInclude Include="..\utils\common\wadlib.h" />
+    <ClInclude Include="..\utils\vlumpy\zip.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="core.vcxproj">
+      <Project>{d509cf19-f957-4f58-8f05-3aa6aa520b2f}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/msvc/vlumpy.vcxproj.filters mod/msvc/vlumpy.vcxproj.filters
--- orig/msvc/vlumpy.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ mod/msvc/vlumpy.vcxproj.filters	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,59 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{3a357db0-2c02-4399-b909-807d1818835d}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{563e499e-ead0-49c1-9571-c1126aa8434e}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\utils\common\cmdlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\common\imglib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\vlumpy\ioapi.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\common\scrlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\vlumpy\vlumpy.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\common\wadlib.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\utils\vlumpy\zip.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\utils\common\cmdlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\fwaddefs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\imglib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\vlumpy\ioapi.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\scrlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\common\wadlib.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\utils\vlumpy\zip.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ Nincs új sor a fájl végén
diff -Nur orig/progs/common/CMakeLists.txt mod/progs/common/CMakeLists.txt
--- orig/progs/common/CMakeLists.txt	2008-01-26 19:21:55.000000000 +0100
+++ mod/progs/common/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -3,18 +3,18 @@
 add_custom_command(OUTPUT ${OUTDIR}/engine.dat
 	COMMAND mkdir ARGS -p ${OUTDIR}
 	COMMAND ${VCC} ARGS -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/engine/classes.vc ${OUTDIR}/engine.dat
-	DEPENDS vcc engine/*.vc)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/engine/*.vc)
 add_custom_target(engine ALL DEPENDS ${OUTDIR}/engine.dat)
 add_dependencies(engine vcc)
 
 add_custom_command(OUTPUT ${OUTDIR}/linespec.dat
 	COMMAND ${VCC} ARGS -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/linespec/classes.vc ${OUTDIR}/linespec.dat
-	DEPENDS vcc linespec/*.vc ${OUTDIR}/engine.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/linespec/*.vc ${OUTDIR}/engine.dat)
 add_custom_target(linespec ALL DEPENDS ${OUTDIR}/linespec.dat)
 add_dependencies(linespec vcc engine)
 
 add_custom_command(OUTPUT ${OUTDIR}/uibase.dat
 	COMMAND ${VCC} ARGS -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/uibase/classes.vc ${OUTDIR}/uibase.dat
-	DEPENDS vcc uibase/*.vc ${OUTDIR}/engine.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/uibase/*.vc ${OUTDIR}/engine.dat)
 add_custom_target(uibase ALL DEPENDS ${OUTDIR}/uibase.dat)
-add_dependencies(uibase vcc engine)
+add_dependencies(uibase vcc engine linespec)
diff -Nur orig/progs/common/engine/ActorDisplayWindow.vc mod/progs/common/engine/ActorDisplayWindow.vc
--- orig/progs/common/engine/ActorDisplayWindow.vc	2007-11-25 21:28:57.000000000 +0100
+++ mod/progs/common/engine/ActorDisplayWindow.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ActorDisplayWindow.vc 2760 2007-11-08 18:30:13Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/BasePlayer.vc mod/progs/common/engine/BasePlayer.vc
--- orig/progs/common/engine/BasePlayer.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/common/engine/BasePlayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BasePlayer.vc 4336 2010-09-17 21:54:34Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -240,6 +240,10 @@
 {
 }
 
+bool CheckDoubleFiringSpeed()
+{
+}
+
 void Cheat_God()
 {
 }
@@ -280,6 +284,10 @@
 {
 }
 
+void Cheat_Freeze()
+{
+}
+
 void ServerImpulse(int AImpulse)
 {
 	Impulse = AImpulse;
diff -Nur orig/progs/common/engine/classes.vc mod/progs/common/engine/classes.vc
--- orig/progs/common/engine/classes.vc	2009-11-13 22:52:42.000000000 +0100
+++ mod/progs/common/engine/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 4110 2009-11-13 21:54:07Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/ClientGameBase.vc mod/progs/common/engine/ClientGameBase.vc
--- orig/progs/common/engine/ClientGameBase.vc	2009-11-13 21:28:36.000000000 +0100
+++ mod/progs/common/engine/ClientGameBase.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClientGameBase.vc 4109 2009-11-13 20:30:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/Entity.vc mod/progs/common/engine/Entity.vc
--- orig/progs/common/engine/Entity.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/engine/Entity.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Entity.vc 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -219,6 +219,7 @@
 name			FixedSpriteName;
 string			FixedModelName;
 byte			ModelVersion;
+int             NumTouchingLights;
 
 byte			RenderStyle;
 float			Alpha;
@@ -287,10 +288,10 @@
 bool bMissile;			// don't hit same species, explode on block
 bool bDontOverlap;		// Prevent some things from overlapping.
 readonly bool bUseDispState;	// Use DispState for rendering
-bool bActLikeBridge;	// Always allow obkects to pass.
+bool bActLikeBridge;	// Always allow objects to pass.
 bool bNoDropOff;		// Can't drop off under any circumstances
 bool bBright;			// Always render full bright
-bool bCanJump;			// A dedicated flag instead of the BOUNCES+FLOAT+sentient as in MBF
+bool bCanJump;			// Can perform standard jump
 bool bStepMissile;		// Missile can "walk" up steps
 
 int				Health;
@@ -333,9 +334,9 @@
 {
 	reliable if (Role == ROLE_Authority)
 		Origin, Angles, FloorClip, State, StateTime, SpriteType,
-		FixedSpriteName, ModelVersion, RenderStyle, Alpha, Translation,
-		ScaleX, ScaleY, bFly, bNoSector, bInvisible, bFullBright, bFixedModel,
-		SoundOriginID, bUseDispState, bBright;
+		FixedSpriteName, ModelVersion, NumTouchingLights, RenderStyle, Alpha,
+		Translation, ScaleX, ScaleY, bFly, bNoSector, bInvisible, bFullBright,
+		bFixedModel, SoundOriginID, bUseDispState, bBright;
 
 	reliable if (Role == ROLE_Authority && bUseDispState)
 		DispState;
diff -Nur orig/progs/common/engine/GameInfo.vc mod/progs/common/engine/GameInfo.vc
--- orig/progs/common/engine/GameInfo.vc	2009-11-13 22:52:42.000000000 +0100
+++ mod/progs/common/engine/GameInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: GameInfo.vc 4110 2009-11-13 21:54:07Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/GameObject.vc mod/progs/common/engine/GameObject.vc
--- orig/progs/common/engine/GameObject.vc	2010-06-13 21:30:29.000000000 +0200
+++ mod/progs/common/engine/GameObject.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: GameObject.vc 4305 2010-06-12 22:08:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/LevelInfo.vc mod/progs/common/engine/LevelInfo.vc
--- orig/progs/common/engine/LevelInfo.vc	2009-01-05 19:07:05.000000000 +0100
+++ mod/progs/common/engine/LevelInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LevelInfo.vc 3953 2009-01-05 18:10:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -27,7 +27,7 @@
 	native
 	abstract;
 
-const int TID_HASH_SIZE = 64;
+const int TID_HASH_SIZE = 128;
 
 struct MapSpecialAction
 {
@@ -114,6 +114,7 @@
 bool			bHaveMonsterActivation;
 bool			bClusterHub;
 readonly bool	bBegunPlay;
+bool			bFrozen;
 
 int				TotalKills;
 int				TotalItems;
@@ -318,6 +319,16 @@
 {
 }
 
+//==========================================================================
+//
+//  PolyCrushMobj
+//
+//==========================================================================
+
+void PolyCrushMobj(Entity A, polyobj_t * po)
+{
+}
+
 //==========================================================================
 //
 //	TagBusy
diff -Nur orig/progs/common/engine/Level.vc mod/progs/common/engine/Level.vc
--- orig/progs/common/engine/Level.vc	2009-11-13 22:52:42.000000000 +0100
+++ mod/progs/common/engine/Level.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Level.vc 4110 2009-11-13 21:54:07Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/Object.vc mod/progs/common/engine/Object.vc
--- orig/progs/common/engine/Object.vc	2010-03-02 18:51:51.000000000 +0100
+++ mod/progs/common/engine/Object.vc	2022-08-12 08:34:35.000000000 +0200
@@ -1,4 +1,4 @@
-//**************************************************************************
+﻿//**************************************************************************
 //**
 //**    ##   ##    ##    ##   ##   ####     ####   ###     ###
 //**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Object.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -703,6 +703,7 @@
 //  Handle shift+key
 native static final string TranslateKey(int c);
 native static final string P_GetMapName(int map);
+native static final int P_GetMapIndexByLevelNum(int map);
 native static final name P_GetMapLumpName(int map);
 native static final name P_TranslateMap(int map);
 native static final int P_GetNumEpisodes();
@@ -748,6 +749,7 @@
 native static final void SetSeqTrans(name Name, int Num, int SeqType);
 native static final name GetSeqTrans(int Num, int SeqType);
 native static final name GetSeqSlot(name Sequence);
+native static final void StopAllSounds();
 
 native static final GameObject::VTerrainInfo* TerrainType(int pic);
 native static final GameObject::VSplashInfo* GetSplashInfo(name Name);
diff -Nur orig/progs/common/engine/PlayerReplicationInfo.vc mod/progs/common/engine/PlayerReplicationInfo.vc
--- orig/progs/common/engine/PlayerReplicationInfo.vc	2008-01-03 09:36:55.000000000 +0100
+++ mod/progs/common/engine/PlayerReplicationInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: PlayerReplicationInfo.vc 2974 2008-01-03 08:36:51Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/RootWidget.vc mod/progs/common/engine/RootWidget.vc
--- orig/progs/common/engine/RootWidget.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/engine/RootWidget.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: RootWidget.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/ScriptsParser.vc mod/progs/common/engine/ScriptsParser.vc
--- orig/progs/common/engine/ScriptsParser.vc	2008-07-17 18:40:52.000000000 +0200
+++ mod/progs/common/engine/ScriptsParser.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ScriptsParser.vc 3727 2008-07-17 16:41:44Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/Thinker.vc mod/progs/common/engine/Thinker.vc
--- orig/progs/common/engine/Thinker.vc	2009-11-13 22:52:42.000000000 +0100
+++ mod/progs/common/engine/Thinker.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Thinker.vc 4110 2009-11-13 21:54:07Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/Widget.vc mod/progs/common/engine/Widget.vc
--- orig/progs/common/engine/Widget.vc	2008-01-03 09:36:55.000000000 +0100
+++ mod/progs/common/engine/Widget.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Widget.vc 2974 2008-01-03 08:36:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/engine/WorldInfo.vc mod/progs/common/engine/WorldInfo.vc
--- orig/progs/common/engine/WorldInfo.vc	2009-11-13 22:52:42.000000000 +0100
+++ mod/progs/common/engine/WorldInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: WorldInfo.vc 4110 2009-11-13 21:54:07Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.DoomAttack.vc mod/progs/common/linespec/Actor.DoomAttack.vc
--- orig/progs/common/linespec/Actor.DoomAttack.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Actor.DoomAttack.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.DoomAttack.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.DoomSpecific.vc mod/progs/common/linespec/Actor.DoomSpecific.vc
--- orig/progs/common/linespec/Actor.DoomSpecific.vc	2010-03-02 18:51:50.000000000 +0100
+++ mod/progs/common/linespec/Actor.DoomSpecific.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.DoomSpecific.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.FlagsAndAppearance.vc mod/progs/common/linespec/Actor.FlagsAndAppearance.vc
--- orig/progs/common/linespec/Actor.FlagsAndAppearance.vc	2010-03-02 18:51:50.000000000 +0100
+++ mod/progs/common/linespec/Actor.FlagsAndAppearance.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.FlagsAndAppearance.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.FreezeDeath.vc mod/progs/common/linespec/Actor.FreezeDeath.vc
--- orig/progs/common/linespec/Actor.FreezeDeath.vc	2008-05-08 20:06:25.000000000 +0200
+++ mod/progs/common/linespec/Actor.FreezeDeath.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.FreezeDeath.vc 3602 2008-05-08 18:09:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.GenericAttacks.vc mod/progs/common/linespec/Actor.GenericAttacks.vc
--- orig/progs/common/linespec/Actor.GenericAttacks.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Actor.GenericAttacks.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.GenericAttacks.vc 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -481,11 +481,19 @@
 //
 //==========================================================================
 
-final void DoExplode(int damage, float distance, bool damageSelf)
+final void DoExplode(int damage, float distance, bool damageSelf,
+					 optional int dmgdistance)
 {
 	int			i;
 
-	RadiusAttack(Target, damage, distance, damageSelf, DamageType);
+	if (specified_dmgdistance && dmgdistance > 0)
+	{
+		RadiusAttack(Target, damage, distance, damageSelf, DamageType, dmgdistance);
+	}
+	else
+	{
+		RadiusAttack(Target, damage, distance, damageSelf, DamageType);
+	}
 	if (Origin.z <= FloorZ + distance)
 	{
 		HitFloorType();
@@ -589,7 +597,8 @@
 //==========================================================================
 
 final void decorate_A_Explode(optional int damage, optional int distance,
-	optional bool damageSelf, optional bool Alert)
+	optional bool damageSelf, optional bool Alert, optional int dmgdistance,
+	optional int nails, optional int naildamage)
 {
 	if (specified_damage)
 	{
@@ -621,7 +630,31 @@
 		}
 	}
 
-	DoExplode(damage, itof(distance), damageSelf);
+	// NailBomb effect, from SMMU but not from its source code: instead it was
+	// implemented and generalized from the documentation at
+	// http://www.doomworld.com/eternity/engine/codeptrs.html
+	if (specified_nails && nails > 0)
+	{
+		int i;
+		TAVec Ang;
+		for (i = 0; i < nails; i++)
+		{
+			Ang.yaw = AngleMod360(itof(i * (360 / nails)));
+			// Comparing the results of a test wad with Eternity, it seems
+			// A_NailBomb does not aim
+			//AimLineAttack (self, Ang, MISSILERANGE), 
+			LineAttack (Ang, MISSILERANGE, 0, naildamage, 'None', BulletPuff);
+		}
+	}
+
+	if (specified_dmgdistance && dmgdistance > 0)
+	{
+		DoExplode(damage, itof(distance), damageSelf, dmgdistance);
+	}
+	else
+	{
+		DoExplode(damage, itof(distance), damageSelf);
+	}
 	CheckSplash(itof(distance));
 	if (Alert && Target && Target.bIsPlayer)
 	{
@@ -980,6 +1013,28 @@
 	}
 }
 
+//==========================================================================
+//
+//  A_MonsterRefire
+//
+//==========================================================================
+
+final void A_MonsterRefire(int prob, state jump)
+{
+	// keep firing unless target got out of sight
+	A_FaceTarget();
+
+	if (P_Random() < prob)
+	{
+		return;
+	}
+
+	if (!Target || Target.Health <= 0 || !CanSee(Target))
+	{
+		DoJump(jump);
+	}
+}
+
 //==========================================================================
 //
 //  FindEnemySelf
diff -Nur orig/progs/common/linespec/Actor.Heretic.vc mod/progs/common/linespec/Actor.Heretic.vc
--- orig/progs/common/linespec/Actor.Heretic.vc	2009-09-01 20:04:01.000000000 +0200
+++ mod/progs/common/linespec/Actor.Heretic.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Heretic.vc 4022 2009-06-20 16:05:31Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.Hexen.vc mod/progs/common/linespec/Actor.Hexen.vc
--- orig/progs/common/linespec/Actor.Hexen.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Actor.Hexen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Hexen.vc 4319 2010-07-03 18:24:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -525,9 +525,22 @@
 	newX += cos(angle) * Level.Game.FloatBobOffsets[WeaveXY] * 4.0;
 	newY += sin(angle) * Level.Game.FloatBobOffsets[WeaveXY] * 4.0;
 	TryMove(vector(newX, newY, Origin.z), false);
+	float savedz = Origin.z;
 	Origin.z -= Level.Game.FloatBobOffsets[WeaveZ] * 2.0;
+	// Check to make sure there's nothing in the way of the float
+	if (!TestMobjZ())
+	{
+		Origin.z = savedz;
+	}
+
 	WeaveZ = (WeaveZ + (P_Random() % 5)) & 63;
-	Origin.z += Level.Game.FloatBobOffsets[WeaveZ] * 2.0;
+	savedz = Origin.z;
+	// Check to make sure there's nothing in the way of the float
+	if (TestMobjZ())
+	{
+		Origin.z += Level.Game.FloatBobOffsets[WeaveZ] * 2.0;
+	}
+
 	Special2 = (WeaveXY << 16) | (WeaveZ & 0xffff);
 }
 
@@ -758,7 +771,12 @@
 		PlaySound('BatScream', CHAN_VOICE);
 
 	// Handle Z movement
+	float savedz = Origin.z;
 	Origin.z = Target.Origin.z + 2.0 * Level.Game.FloatBobOffsets[Args[0]];
+	if (!TestMobjZ())
+	{
+		Origin.z = savedz;
+	}
 	Args[0] = (Args[0] + 3) & 63;
 }
 
@@ -897,7 +915,12 @@
 
 	if ((Args[3] % 4) == 0)
 	{
+		float savedz = Origin.z;
 		Origin.z += Level.Game.FloatBobOffsets[Special2] / 2.0;
+		if (!TestMobjZ())
+		{
+			Origin.z = savedz;
+		}
 		Special2 = (Special2 + 1) & 63;
 	}
 
@@ -1134,6 +1157,7 @@
 	if (mo)
 	{
 		mo.Target = self;
+		mo.Translation = Translation;
 		mo.Velocity.x = (Random() - 0.5) * 4.0 * 35.0;
 		mo.Velocity.y = (Random() - 0.5) * 4.0 * 35.0;
 		mo.Velocity.z = Random() * 4.0 * 35.0;
@@ -1177,14 +1201,24 @@
 		Threshold--;
 
 	// Float up and down
+	float savedz = Origin.z;
 	Origin.z += Level.Game.FloatBobOffsets[Special1];
+	if (!TestMobjZ())
+	{
+		Origin.z = savedz;
+	}
 	Special1 = (Special1 + 2) & 63;
 
 
 	// Insure it stays above certain height
 	if (Origin.z < FloorZ + 64.0)
 	{
+		savedz = Origin.z;
 		Origin.z += 2.0;
+		if (!TestMobjZ())
+		{
+			Origin.z = savedz;
+		}
 	}
 
 	if (!Target || !Target.bShootable)
@@ -1285,6 +1319,7 @@
 	A = Spawn(FireDemonSplotch1, Origin);
 	if (A)
 	{
+		A.Translation = Translation;
 		A.Velocity.x = (Random() - 0.5) * 8.0 * 35.0;
 		A.Velocity.y = (Random() - 0.5) * 8.0 * 35.0;
 		A.Velocity.z = (3.0 + Random() * 4.0) * 35.0;
@@ -1292,6 +1327,7 @@
 	A = Spawn(FireDemonSplotch2, Origin);
 	if (A)
 	{
+		A.Translation = Translation;
 		A.Velocity.x = (Random() - 0.5) * 8.0 * 35.0;
 		A.Velocity.y = (Random() - 0.5) * 8.0 * 35.0;
 		A.Velocity.z = (3.0 + Random() * 4.0) * 35.0;
@@ -1392,9 +1428,20 @@
 
 final void A_BishopChase()
 {
+	float savedz = Origin.z;
+
 	Origin.z -= Level.Game.FloatBobOffsets[Special2] / 2.0;
+	if (!TestMobjZ())
+	{
+		Origin.z = savedz;
+	}
 	Special2 = (Special2 + 4) & 63;
+	savedz = Origin.z;
 	Origin.z += Level.Game.FloatBobOffsets[Special2] / 2.0;
+	if (!TestMobjZ())
+	{
+		Origin.z = savedz;
+	}
 }
 
 //==========================================================================
@@ -1454,7 +1501,7 @@
 	{
 		Velocity.x = 0.0;
 		Velocity.y = 0.0;
-		if (P_Random() > 96)
+		if (P_Random() > 96 || (GetCvar('alternate_monster_attacks') && !CanSee(Target)))
 		{
 			SetState(SeeState);
 		}
@@ -1466,6 +1513,7 @@
 	blur = Spawn(BishopBlur, Origin);
 	if (blur)
 	{
+		blur.Translation = Translation;
 		blur.Angles = Angles;
 	}
 }
@@ -1538,6 +1586,7 @@
 		(Random() - Random()) * 16.0, (Random() - Random()) * 8.0));
 	if (blur)
 	{
+		blur.Translation = Translation;
 		blur.Angles = Angles;
 	}
 }
@@ -1685,7 +1734,7 @@
 {
 	if (MissileState)
 	{
-		if (!Target || CheckMeleeRange())
+		if (!Target || (GetCvar('alternate_monster_attacks') && !CanSee(Target)) || CheckMeleeRange())
 		{
 			return;
 		}
@@ -1867,7 +1916,13 @@
 
 final void A_WraithChase()
 {
+	float savedz = Origin.z;
+
 	Origin.z += Level.Game.FloatBobOffsets[Special1];
+	if (!TestMobjZ())
+	{
+		Origin.z = savedz;
+	}
 	Special1 = (Special1 + 2) & 63;
 //  if (actor->FloorClip > 0)
 //  {
diff -Nur orig/progs/common/linespec/Actor.HexenWeapons.vc mod/progs/common/linespec/Actor.HexenWeapons.vc
--- orig/progs/common/linespec/Actor.HexenWeapons.vc	2009-02-02 20:34:33.000000000 +0100
+++ mod/progs/common/linespec/Actor.HexenWeapons.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.HexenWeapons.vc 3982 2009-02-02 19:46:52Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.Inventory.vc mod/progs/common/linespec/Actor.Inventory.vc
--- orig/progs/common/linespec/Actor.Inventory.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/Actor.Inventory.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Inventory.vc 4154 2010-03-11 20:42:47Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.Misc.vc mod/progs/common/linespec/Actor.Misc.vc
--- orig/progs/common/linespec/Actor.Misc.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Actor.Misc.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Misc.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -396,6 +396,52 @@
 	}
 }
 
+//==========================================================================
+//
+//	A_PreExplode
+//
+//  This method is used to set properties to exploding things
+//  just before exploding. This one can be used in DECORATE now.
+//
+//==========================================================================
+
+void A_PreExplode(int Style, float A)
+{
+	RenderStyle = Style;
+	Alpha = A;
+}
+
+//============================================================================
+//
+//  A_BarrelDestroy
+//
+//  This is only a stub method
+//
+//============================================================================
+
+final void A_BarrelDestroy()
+{
+	// In ZDoom this method is used to preserve barrels because of
+	// deathmatch flags... here the only relevant function for it
+	// would be to make things invisible.
+	RenderStyle = STYLE_None;
+}
+
+//============================================================================
+//
+//  A_PlayerSkinCheck
+//
+//  This is only a stub method
+//
+//============================================================================
+
+final void A_PlayerSkinCheck(state label)
+{
+	// Vavoom doesn't support skins as of now...
+	// but there are some MODs that use this method
+	return;
+}
+
 //**************************************************************************
 //**************************************************************************
 
@@ -429,6 +475,7 @@
 	bCountKill = false;
 	bMonster = false;
 	bSkullFly = false;
+	bIceCorpse = false;
 	bNoGravity = true;
 	bDropOff = true;
 	bCorpse = true;
diff -Nur orig/progs/common/linespec/Actor.MissileMovement.vc mod/progs/common/linespec/Actor.MissileMovement.vc
--- orig/progs/common/linespec/Actor.MissileMovement.vc	2010-09-09 19:38:34.000000000 +0200
+++ mod/progs/common/linespec/Actor.MissileMovement.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.MissileMovement.vc 4330 2010-09-09 17:39:30Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.MonsterAi.vc mod/progs/common/linespec/Actor.MonsterAi.vc
--- orig/progs/common/linespec/Actor.MonsterAi.vc	2010-06-13 21:30:29.000000000 +0200
+++ mod/progs/common/linespec/Actor.MonsterAi.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.MonsterAi.vc 4302 2010-06-10 23:34:26Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ActorMover.vc mod/progs/common/linespec/ActorMover.vc
--- orig/progs/common/linespec/ActorMover.vc	2008-04-28 20:30:04.000000000 +0200
+++ mod/progs/common/linespec/ActorMover.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ActorMover.vc 3588 2008-04-28 18:33:52Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.Sound.vc mod/progs/common/linespec/Actor.Sound.vc
--- orig/progs/common/linespec/Actor.Sound.vc	2009-01-04 17:39:40.000000000 +0100
+++ mod/progs/common/linespec/Actor.Sound.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Sound.vc 3941 2009-01-04 16:45:33Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.Spawn.vc mod/progs/common/linespec/Actor.Spawn.vc
--- orig/progs/common/linespec/Actor.Spawn.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Actor.Spawn.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Spawn.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -182,7 +182,7 @@
 			{
 				//	Make monster friendly.
 				A.bFriendly = true;
-				EntityEx Atk = PlayerEx(Player).Attacker;
+				EntityEx Atk = PlayerEx(Instig.Player).Attacker;
 				if (Atk && !Atk.bFriendly)
 				{
 					//	Make it attack monster who last attacked player.
@@ -267,7 +267,7 @@
 final void A_SpawnItemEx(class<Actor> ItemType, optional float XOffs,
 	optional float YOffs, optional float ZOffs, optional float XVel,
 	optional float YVel, optional float ZVel, optional float Angle,
-	optional int Flags, optional int Chance)
+	optional int Flags, optional int Chance, optional bool ApplyTranslation)
 {
 	if (!ItemType)
 	{
@@ -309,6 +309,10 @@
 		!!(Flags & 64), !!(Flags & 512), !!(Flags & 1024));
 	if (A)
 	{
+		if (ApplyTranslation)
+		{
+			A.Translation = Translation;
+		}
 		A.Velocity.x = XVel * 35.0;
 		A.Velocity.y = YVel * 35.0;
 		A.Velocity.z = ZVel * 35.0;
diff -Nur orig/progs/common/linespec/Actor.Special.vc mod/progs/common/linespec/Actor.Special.vc
--- orig/progs/common/linespec/Actor.Special.vc	2010-03-02 18:51:51.000000000 +0100
+++ mod/progs/common/linespec/Actor.Special.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Special.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -181,10 +181,7 @@
 	{
 		Target = none;
 		ReactionCount = 60;
-		if (Target == none)
-		{
-			SetState(IdleState);
-		}
+		SetState(IdleState);
 	}
 	if (ReactionCount == 2)
 	{
diff -Nur orig/progs/common/linespec/Actor.StateJump.vc mod/progs/common/linespec/Actor.StateJump.vc
--- orig/progs/common/linespec/Actor.StateJump.vc	2008-04-29 23:19:38.000000000 +0200
+++ mod/progs/common/linespec/Actor.StateJump.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.StateJump.vc 3595 2008-04-29 21:23:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.States.vc mod/progs/common/linespec/Actor.States.vc
--- orig/progs/common/linespec/Actor.States.vc	2008-07-24 23:15:40.000000000 +0200
+++ mod/progs/common/linespec/Actor.States.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.States.vc 3736 2008-07-24 21:16:58Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Actor.Strife.vc mod/progs/common/linespec/Actor.Strife.vc
--- orig/progs/common/linespec/Actor.Strife.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Actor.Strife.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Actor.Strife.vc 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -636,9 +636,12 @@
 
 final void A_InquisitorCheckJump()
 {
+	EntityEx onmo = EntityEx(CheckOnmobj());
+	
 	if (Origin.z != Target.Origin.z)
 	{
-		if (Origin.z < Target.Origin.z)
+		if (Origin.z < Target.Origin.z && (((onmo && onmo.TestMobjZ()) ||
+			!onmo) && TestMobjZ()))
 		{
 			A_FaceTarget();
 			if (Origin.z + Height + 64.0 < CeilingZ)
@@ -651,7 +654,8 @@
 				Origin.z = FloorZ;
 			}
 		}
-		else if(Origin.z != FloorZ && fabs(Velocity.z) < -21.0)
+		else if(Origin.z != FloorZ && fabs(Velocity.z) < -21.0 && (((onmo && onmo.TestMobjZ()) ||
+			!onmo) && TestMobjZ()))
 		{
 			//fly when he is falling
 			A_FaceTarget();
@@ -709,24 +713,45 @@
 {
 	float an;
 	float dist;
+	TVec OldOrg;
 
 	if (!Target)
 		return;
 
-	PlaySound('inquisitor/jump', CHAN_BODY);
+	EntityEx onmo = EntityEx(CheckOnmobj());
+
 	A_FaceTarget();
+	// Increase origin, then check for possibility
+	// of getting stuck, if we can get stuck, reset
+	// origin value...
+	OldOrg = Origin;
 	Origin.z += 64.0;
-	Velocity.x += 6.0 * 35.0 * cos(Angles.yaw);
-	Velocity.y += 6.0 * 35.0 * sin(Angles.yaw);
-	dist = DistTo2(Target);
-	dist /= 6.0 * 35.0;
-	if (dist < 1.0)
+	if (((onmo && onmo.TestMobjZ()) ||
+		!onmo) && TestMobjZ())
 	{
-		dist = 1.0;
+		// The way is free, so continue along...
+		PlaySound('inquisitor/jump', CHAN_BODY);
+		Velocity.x += 6.0 * 35.0 * cos(Angles.yaw);
+		Velocity.y += 6.0 * 35.0 * sin(Angles.yaw);
+		dist = DistTo2(Target);
+		dist /= 6.0 * 35.0;
+		if (dist < 1.0)
+		{
+			dist = 1.0;
+		}
+		Velocity.z = (Target.Origin.z - Origin.z) / dist;
+		ReactionCount = 60;
+		bNoGravity = true;
+		return;
+	}
+	else
+	{
+		// Something is in the way, reset the Origin value...
+		Origin = OldOrg;
+		ReactionCount = 0;
+		bNoGravity = false;
+		return;
 	}
-	Velocity.z = (Target.Origin.z - Origin.z) / dist;
-	ReactionCount = 60;
-	bNoGravity = true;
 }
 
 //==========================================================================
@@ -738,14 +763,35 @@
 final void A_InquisitorCheckLand()
 {
 	ReactionCount--;
-	if (Velocity.x == 0.0 && Velocity.y == 0.0 || Origin.z <= FloorZ ||
-		fabs(Velocity.x) > 6.0 * 35.0 && fabs(Velocity.y) > 6.0 * 35.0 ||
-		ReactionCount < 0 || Origin.z >= Target.Origin.z + Height / 6.0)
+	EntityEx onmo = EntityEx(CheckOnmobj());
+
+	if (((onmo && onmo.TestMobjZ()) ||
+		!onmo) && TestMobjZ())
 	{
-		SetState(GetStatePlus(SeeState, 1));
-		ReactionCount = 0;
-		bNoGravity = false;
-		return;
+		if (Velocity.x == 0.0 && Velocity.y == 0.0 || Origin.z <= FloorZ ||
+			fabs(Velocity.x) > 6.0 * 35.0 && fabs(Velocity.y) > 6.0 * 35.0 ||
+			ReactionCount < 0 || Origin.z >= Target.Origin.z + Height / 6.0)
+		{
+			SetState(GetStatePlus(SeeState, 1));
+			ReactionCount = 0;
+			bNoGravity = false;
+			return;
+		}
+	}
+	else
+	{
+		float dist;
+
+		A_FaceTarget();
+		Velocity.x += 6.0 * 35.0 * cos(Angles.yaw);
+		Velocity.y += 6.0 * 35.0 * sin(Angles.yaw);
+		dist = DistTo2(Target);
+		dist /= 6.0 * 35.0;
+		if (dist < 1.0)
+		{
+			dist = 1.0;
+		}
+		Velocity.z = (Target.Origin.z - Origin.z) / dist;
 	}
 	PlaySound('inquisitor/jump', CHAN_BODY);
 }
diff -Nur orig/progs/common/linespec/AimingCamera.vc mod/progs/common/linespec/AimingCamera.vc
--- orig/progs/common/linespec/AimingCamera.vc	2007-12-03 22:38:22.000000000 +0100
+++ mod/progs/common/linespec/AimingCamera.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: AimingCamera.vc 2932 2007-12-03 21:42:43Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/AmbientSound.vc mod/progs/common/linespec/AmbientSound.vc
--- orig/progs/common/linespec/AmbientSound.vc	2008-04-28 17:52:42.000000000 +0200
+++ mod/progs/common/linespec/AmbientSound.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: AmbientSound.vc 3585 2008-04-28 15:56:29Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/AmmoFillup.vc mod/progs/common/linespec/AmmoFillup.vc
--- orig/progs/common/linespec/AmmoFillup.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/AmmoFillup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: AmmoFillup.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Ammo.vc mod/progs/common/linespec/Ammo.vc
--- orig/progs/common/linespec/Ammo.vc	2009-01-04 15:21:27.000000000 +0100
+++ mod/progs/common/linespec/Ammo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Ammo.vc 3936 2009-01-04 14:27:18Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Armor.vc mod/progs/common/linespec/Armor.vc
--- orig/progs/common/linespec/Armor.vc	2007-08-11 16:02:39.000000000 +0200
+++ mod/progs/common/linespec/Armor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Armor.vc 2623 2007-08-11 14:03:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiBlastRadius.vc mod/progs/common/linespec/ArtiBlastRadius.vc
--- orig/progs/common/linespec/ArtiBlastRadius.vc	2010-03-02 18:51:50.000000000 +0100
+++ mod/progs/common/linespec/ArtiBlastRadius.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiBlastRadius.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiBoostArmor.vc mod/progs/common/linespec/ArtiBoostArmor.vc
--- orig/progs/common/linespec/ArtiBoostArmor.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/ArtiBoostArmor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiBoostArmor.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiDarkServant.vc mod/progs/common/linespec/ArtiDarkServant.vc
--- orig/progs/common/linespec/ArtiDarkServant.vc	2009-03-17 20:02:29.000000000 +0100
+++ mod/progs/common/linespec/ArtiDarkServant.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiDarkServant.vc 4013 2009-03-17 19:05:19Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiHealingRadius.vc mod/progs/common/linespec/ArtiHealingRadius.vc
--- orig/progs/common/linespec/ArtiHealingRadius.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/ArtiHealingRadius.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiHealingRadius.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiPoisonBag.vc mod/progs/common/linespec/ArtiPoisonBag.vc
--- orig/progs/common/linespec/ArtiPoisonBag.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/ArtiPoisonBag.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiPoisonBag.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -66,13 +66,14 @@
 		{
 			bomb.Angles.yaw = AngleMod360(Owner.Angles.yaw +
 				(Random() * 2.0 - 1.0) * 45.0 / 8.0);
-			bomb.Velocity.z =
-				(4.0 + 173.0 * -tan(Owner.Angles.pitch) / 16.0) * 35.0;
-			bomb.Origin.z += 173.0 * -tan(Owner.Angles.pitch) / 16.0;
 			bomb.Velocity.x += bomb.Speed * cos(bomb.Angles.yaw);
 			bomb.Velocity.y += bomb.Speed * sin(bomb.Angles.yaw);
+			bomb.Velocity.z +=
+				(bomb.Speed * -tan(Owner.Angles.pitch) / 48.0) * 35.0;
+			bomb.Origin.z += 173.0 * -tan(Owner.Angles.pitch) / 16.0;
 			bomb.Velocity.x += Owner.Velocity.x / 2.0;
 			bomb.Velocity.y += Owner.Velocity.y / 2.0;
+			bomb.Velocity.z += Owner.Velocity.z / 2.0;
 			bomb.Target = EntityEx(Owner);
 			bomb.StateTime -= Random() * 0.1;
 			bomb.CheckMissileSpawn();
diff -Nur orig/progs/common/linespec/ArtiTeleportOther.vc mod/progs/common/linespec/ArtiTeleportOther.vc
--- orig/progs/common/linespec/ArtiTeleportOther.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/ArtiTeleportOther.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiTeleportOther.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiTeleport.vc mod/progs/common/linespec/ArtiTeleport.vc
--- orig/progs/common/linespec/ArtiTeleport.vc	2009-01-21 21:50:59.000000000 +0100
+++ mod/progs/common/linespec/ArtiTeleport.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiTeleport.vc 3973 2009-01-21 20:59:41Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiTimeBomb.vc mod/progs/common/linespec/ArtiTimeBomb.vc
--- orig/progs/common/linespec/ArtiTimeBomb.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/ArtiTimeBomb.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiTimeBomb.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ArtiTomeOfPower.vc mod/progs/common/linespec/ArtiTomeOfPower.vc
--- orig/progs/common/linespec/ArtiTomeOfPower.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/ArtiTomeOfPower.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ArtiTomeOfPower.vc 4326 2010-07-19 21:00:24Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BackpackItem.vc mod/progs/common/linespec/BackpackItem.vc
--- orig/progs/common/linespec/BackpackItem.vc	2008-05-19 23:11:00.000000000 +0200
+++ mod/progs/common/linespec/BackpackItem.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BackpackItem.vc 3649 2008-05-19 21:14:34Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BasicArmorBonus.vc mod/progs/common/linespec/BasicArmorBonus.vc
--- orig/progs/common/linespec/BasicArmorBonus.vc	2008-01-06 14:27:03.000000000 +0100
+++ mod/progs/common/linespec/BasicArmorBonus.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BasicArmorBonus.vc 2989 2008-01-06 13:27:01Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BasicArmorPickup.vc mod/progs/common/linespec/BasicArmorPickup.vc
--- orig/progs/common/linespec/BasicArmorPickup.vc	2008-01-06 14:27:03.000000000 +0100
+++ mod/progs/common/linespec/BasicArmorPickup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BasicArmorPickup.vc 2989 2008-01-06 13:27:01Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BasicArmor.vc mod/progs/common/linespec/BasicArmor.vc
--- orig/progs/common/linespec/BasicArmor.vc	2009-01-05 20:46:53.000000000 +0100
+++ mod/progs/common/linespec/BasicArmor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BasicArmor.vc 2989 2008-01-06 13:27:01Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BlasterFX1.vc mod/progs/common/linespec/BlasterFX1.vc
--- orig/progs/common/linespec/BlasterFX1.vc	2009-01-25 20:54:44.000000000 +0100
+++ mod/progs/common/linespec/BlasterFX1.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BlasterFX1.vc 3975 2009-01-25 20:04:38Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BossSpot.vc mod/progs/common/linespec/BossSpot.vc
--- orig/progs/common/linespec/BossSpot.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/BossSpot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BossSpot.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BrainState.vc mod/progs/common/linespec/BrainState.vc
--- orig/progs/common/linespec/BrainState.vc	2008-08-30 20:58:47.000000000 +0200
+++ mod/progs/common/linespec/BrainState.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BrainState.vc 3754 2008-08-30 19:00:48Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/BridgeBall.vc mod/progs/common/linespec/BridgeBall.vc
--- orig/progs/common/linespec/BridgeBall.vc	2008-10-24 19:36:21.000000000 +0200
+++ mod/progs/common/linespec/BridgeBall.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BridgeBall.vc 3852 2008-10-24 17:39:19Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Bridge.vc mod/progs/common/linespec/Bridge.vc
--- orig/progs/common/linespec/Bridge.vc	2008-10-19 19:43:02.000000000 +0200
+++ mod/progs/common/linespec/Bridge.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Bridge.vc 3827 2008-10-19 16:32:43Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/CeilingMover.vc mod/progs/common/linespec/CeilingMover.vc
--- orig/progs/common/linespec/CeilingMover.vc	2008-05-16 19:49:54.000000000 +0200
+++ mod/progs/common/linespec/CeilingMover.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: CeilingMover.vc 3635 2008-05-16 17:53:44Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/CeilingWaggle.vc mod/progs/common/linespec/CeilingWaggle.vc
--- orig/progs/common/linespec/CeilingWaggle.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/CeilingWaggle.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: CeilingWaggle.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/CFlameMissile.vc mod/progs/common/linespec/CFlameMissile.vc
--- orig/progs/common/linespec/CFlameMissile.vc	2009-01-25 20:54:44.000000000 +0100
+++ mod/progs/common/linespec/CFlameMissile.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: CFlameMissile.vc 3975 2009-01-25 20:04:38Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ChickenPlayer.vc mod/progs/common/linespec/ChickenPlayer.vc
--- orig/progs/common/linespec/ChickenPlayer.vc	2008-09-21 23:01:29.000000000 +0200
+++ mod/progs/common/linespec/ChickenPlayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ChickenPlayer.vc 3795 2008-09-21 21:03:54Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/classes.vc mod/progs/common/linespec/classes.vc
--- orig/progs/common/linespec/classes.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 4319 2010-07-03 18:24:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -107,13 +107,16 @@
 #include "PowerFrightener.vc"
 #include "PowerWeaponLevel2.vc"
 #include "PowerSpeed.vc"
+#include "PowerHighJump.vc"
 #include "PowerMinotaur.vc"
 #include "PowerScanner.vc"
 #include "PowerTargeter.vc"
 #include "PowerMorph.vc"
 #include "PowerDamage.vc"
+#include "PowerDoubleFiringSpeed.vc"
 #include "PowerProtection.vc"
 #include "PowerRegeneration.vc"
+#include "PowerTimeFreeze.vc"
 #include "Health.vc"
 #include "HealthPickup.vc"
 #include "Armor.vc"
diff -Nur orig/progs/common/linespec/ClericWeaponPiece.vc mod/progs/common/linespec/ClericWeaponPiece.vc
--- orig/progs/common/linespec/ClericWeaponPiece.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/ClericWeaponPiece.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClericWeaponPiece.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ClericWeapon.vc mod/progs/common/linespec/ClericWeapon.vc
--- orig/progs/common/linespec/ClericWeapon.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/ClericWeapon.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClericWeapon.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/CloseDoor222.vc mod/progs/common/linespec/CloseDoor222.vc
--- orig/progs/common/linespec/CloseDoor222.vc	2009-09-01 20:04:02.000000000 +0200
+++ mod/progs/common/linespec/CloseDoor222.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: CloseDoor222.vc 4056 2009-08-10 19:15:19Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Coin.vc mod/progs/common/linespec/Coin.vc
--- orig/progs/common/linespec/Coin.vc	2008-03-01 12:12:06.000000000 +0100
+++ mod/progs/common/linespec/Coin.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Coin.vc 3205 2008-03-01 11:18:11Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/CustomInventory.vc mod/progs/common/linespec/CustomInventory.vc
--- orig/progs/common/linespec/CustomInventory.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/CustomInventory.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: CustomInventory.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/CWeapWraithverge.vc mod/progs/common/linespec/CWeapWraithverge.vc
--- orig/progs/common/linespec/CWeapWraithverge.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/CWeapWraithverge.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: CWeapWraithverge.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/DegninOre.vc mod/progs/common/linespec/DegninOre.vc
--- orig/progs/common/linespec/DegninOre.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/DegninOre.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: DegninOre.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/DoomBuilderCamera.vc mod/progs/common/linespec/DoomBuilderCamera.vc
--- orig/progs/common/linespec/DoomBuilderCamera.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/DoomBuilderCamera.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: DoomBuilderCamera.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/DummyStrifeItem.vc mod/progs/common/linespec/DummyStrifeItem.vc
--- orig/progs/common/linespec/DummyStrifeItem.vc	2008-09-07 20:33:39.000000000 +0200
+++ mod/progs/common/linespec/DummyStrifeItem.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: DummyStrifeItem.vc 3760 2008-09-07 18:35:50Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/DynamicLight.vc mod/progs/common/linespec/DynamicLight.vc
--- orig/progs/common/linespec/DynamicLight.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/DynamicLight.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: DynamicLight.vc 4154 2010-03-11 20:42:47Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Elevator.vc mod/progs/common/linespec/Elevator.vc
--- orig/progs/common/linespec/Elevator.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/Elevator.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Elevator.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/EntityEx.AiUtils.vc mod/progs/common/linespec/EntityEx.AiUtils.vc
--- orig/progs/common/linespec/EntityEx.AiUtils.vc	2010-11-30 12:36:12.000000000 +0100
+++ mod/progs/common/linespec/EntityEx.AiUtils.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.AiUtils.vc 4335 2010-09-17 15:40:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -748,17 +748,25 @@
 		// open any specials
 		if (bFloat && tmtrace.bFloatOk)
 		{
+			float savedz = Origin.z;
+
 			// must adjust height
 			if (Origin.z < tmtrace.FloorZ)
 			{
-				Origin.z += FloatSpeed * Level.Game.frametime;
+				Origin.z += FloatSpeed * 2.0 * Level.Game.frametime;
 			}
 			else
 			{
-				Origin.z -= FloatSpeed * Level.Game.frametime;
+				Origin.z -= FloatSpeed * 2.0 * Level.Game.frametime;
 			}
-			bInFloat = true;
-			return true;
+
+			// Check to make sure there's nothing in the way of the float
+			if (TestMobjZ())
+			{
+				bInFloat = true;
+				return true;
+			}
+			Origin.z = savedz;
 		}
 		if (bCanJump && !bFloat && tmtrace.bFloatOk && 
 			(Origin.z <= FloorZ || bOnMobj) && !JumpTime)
@@ -845,7 +853,7 @@
 		bInFloat = false;
 	}
 
-	if (!bFloat && !bNoGravity)
+	if (!bFloat && !bNoGravity && !bDropOff && !bOnMobj)
 	{
 		if (Origin.z > FloorZ)
 		{
diff -Nur orig/progs/common/linespec/EntityEx.Damage.vc mod/progs/common/linespec/EntityEx.Damage.vc
--- orig/progs/common/linespec/EntityEx.Damage.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/EntityEx.Damage.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.Damage.vc 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -111,6 +111,7 @@
 			// Invulnerable during charge attack
 			return;
 		}
+		bSkullFly = false;
 		Velocity = vector(0.0, 0.0, 0.0);
 		if (Health > 0)
 		{
@@ -350,15 +351,18 @@
 		}
 	}
 
-	if (!bNoPain && (((Random() < PChance) && !bSkullFly && (inflictor && !inflictor.bPainless)) ||
-		(inflictor && inflictor.bForcePain)))
+	if (!bNoPain && ((Random() < PChance) && !bSkullFly))
 	{
 		if (inflictor && inflictor.bLightning)
 		{
-			if (P_Random() < 96)
+			if ((P_Random() < 96 && !inflictor.bPainless) ||
+			    inflictor.bForcePain)
 			{
 				bJustHit = true;	// fight back!
-				SetState(FindState('Pain', DmgType, false));
+				if (FindState('Pain', DmgType, false))
+				{
+					SetState(FindState('Pain', DmgType, false));
+				}
 			}
 			else
 			{
@@ -374,7 +378,14 @@
 		else
 		{
 			bJustHit = true;	// fight back!
-			SetState(FindState('Pain', DmgType, false));
+			if (!inflictor || (inflictor && (!inflictor.bPainless ||
+			    inflictor.bForcePain)))
+			{
+				if (FindState('Pain', DmgType, false))
+				{
+					SetState(FindState('Pain', DmgType, false));
+				}
+			}
 			if (inflictor && inflictor.bHowlVictims)
 			{
 				if (HowlSound && bMonster && P_Random() < 128 &&
@@ -727,7 +738,14 @@
 		DeathState = FindState('Death', DamageType, true);
 		if (DamageType == 'Ice' && !bNoIceDeath && (bIsPlayer || bMonster))
 		{
-			DeathState = FindState('GenericFreezeDeath');
+			if (FindState('Death', 'Ice', true))
+			{
+				DeathState = FindState('Death', 'Ice', true);
+			}
+			else
+			{
+				DeathState = FindState('GenericFreezeDeath');
+			}
 		}
 	}
 	if (!DeathState)
diff -Nur orig/progs/common/linespec/EntityEx.Defaults.vc mod/progs/common/linespec/EntityEx.Defaults.vc
--- orig/progs/common/linespec/EntityEx.Defaults.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/EntityEx.Defaults.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.Defaults.vc 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/EntityEx.Head.vc mod/progs/common/linespec/EntityEx.Head.vc
--- orig/progs/common/linespec/EntityEx.Head.vc	2010-11-30 12:36:12.000000000 +0100
+++ mod/progs/common/linespec/EntityEx.Head.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.Head.vc 4335 2010-09-17 15:40:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -324,6 +324,8 @@
 bool bBumpSpecial;		//  Actor executes its special when being collided (as the ST flag).
 bool bMBFBounce;		//	Doesn't dies while bouncing speed is higher than 0.
 bool bAvoidsDropOffs;	//	Monster does avoid dropoffs, overrides value of compat_dropoff CVar.
+bool bNoTimeFreeze;		//  Monster isn't affected by Time Freeze powerups.
+bool bCrashed;			//	Means a monster that has crash state hasn't crashed and can execute Crash method.
 
 //  Params
 float			Speed;
diff -Nur orig/progs/common/linespec/EntityEx.Inventory.vc mod/progs/common/linespec/EntityEx.Inventory.vc
--- orig/progs/common/linespec/EntityEx.Inventory.vc	2009-09-01 20:04:01.000000000 +0200
+++ mod/progs/common/linespec/EntityEx.Inventory.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.Inventory.vc 4024 2009-06-20 16:11:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/EntityEx.LineAttack.vc mod/progs/common/linespec/EntityEx.LineAttack.vc
--- orig/progs/common/linespec/EntityEx.LineAttack.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/EntityEx.LineAttack.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.LineAttack.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -102,7 +102,8 @@
 
 			li = in->line;
 
-			if (!(li->flags & ML_TWOSIDED))
+			if (!(li->flags & ML_TWOSIDED) ||
+				(li->flags & ML_BLOCKEVERYTHING))
 			{
 				break;	// stop
 			}
@@ -508,8 +509,11 @@
 				{
 					if (open->bottom <= hit_point.z && open->top >= hit_point.z)
 					{
-						// shot continues
-						break;
+						if (!(li->flags & ML_BLOCKEVERYTHING))
+						{
+							// shot continues
+							break;
+						}
 					}
 					open = open->next;
 				}
@@ -858,8 +862,11 @@
 				{
 					if (open->bottom <= hit_point.z && open->top >= hit_point.z)
 					{
-						// shot continues
-						break;
+						if (!(li->flags & ML_BLOCKEVERYTHING))
+						{
+							// shot continues
+							break;
+						}
 					}
 					open = open->next;
 				}
diff -Nur orig/progs/common/linespec/EntityEx.Misc.vc mod/progs/common/linespec/EntityEx.Misc.vc
--- orig/progs/common/linespec/EntityEx.Misc.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/EntityEx.Misc.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.Misc.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -112,7 +112,8 @@
 //==========================================================================
 
 final void RadiusAttack(EntityEx Source, int BombDamage, float BombDistance,
-	bool DamageSource, optional name BombDmgType, optional bool DoDamage)
+	bool DamageSource, optional name BombDmgType, optional bool DoDamage,
+	optional int damagedistance)
 {
 	EntityEx	Other;
 	float		dist;
@@ -165,9 +166,28 @@
 
 		if (Other.CanSee(self))
 		{
+			float dist2;
+			
 			// OK to damage, target is in direct path
-			damage = ftoi(itof(BombDamage) * RDFactor *
-				(BombDistance - dist) / BombDistance);
+			if (!specified_damagedistance)
+			{
+				dist2 = dist;
+			}
+			else
+			{
+				dist2 = dist - itof(damagedistance);
+				
+				if (dist2 <= 0.0)
+				{
+					dist2 = 0.0;
+				}
+				else if (dist2 >= dist)
+				{
+					dist2 = dist;
+				}
+			}
+			damage = ftoi(((itof(BombDamage) * RDFactor *
+				(BombDistance - dist2)) / BombDistance));
 			if (DoDamage)
 			{
 				Other.Damage(self, Source, damage, BombDmgType);
@@ -180,7 +200,7 @@
 			if (!Other.bIceCorpse && (!DoDamage || !bNoDamageThrust))
 			{
 				float Thrust = itof(damage) * 0.5;
-				float VelZ = (Other.Origin.z + Other.Height * 0.5 -
+				float VelZ = ((Other.Origin.z + (Other.Height * 0.5)) -
 					Origin.z) * Thrust;
 				if (Source != Other)
 				{
@@ -539,6 +559,25 @@
 		// walking monsters rise and fall with the floor
 		if ((Origin.z - FloorZ < 9.0) || bNoGravity || !XLevel.bExtended)
 		{
+			EntityEx onmo = EntityEx(CheckOnmobj());
+
+			// Do we have something over us?
+			if (bSolid && onmo && onmo.bSolid)
+			{
+				// Adjust height for the thing over us...
+				onmo.Origin.z += FloorZ - Origin.z;
+
+				// don't adjust a floating monster unless forced to...
+				if (onmo.Origin.z + onmo.Height > CeilingZ)
+				{
+					onmo.Origin.z = CeilingZ - onmo.Height;
+				}
+				if (CeilingZ - (FloorZ + Height) < onmo.Height)
+				{
+					// Things don't fit, stop...
+					return false;
+				}
+			}
 			Origin.z = FloorZ;
 		}
 	}
@@ -546,13 +585,26 @@
 	{
 		// don't adjust a floating monster unless forced to
 		if (Origin.z + Height > CeilingZ)
+		{
 			Origin.z = CeilingZ - Height;
+		}
 	}
 
 	CheckFakeFloorTriggers(OldZ);
 
 	if (CeilingZ - FloorZ < Height)
-		return false;
+	{
+		if (bIceCorpse && bSolid)
+		{
+			Actor(self).A_FreezeDeathChunks();
+			return true;
+		}
+		else
+		{
+			// Doesn't fit, stop...
+			return false;
+		}
+	}
 
 	return true;
 }
@@ -1482,7 +1534,11 @@
 		DropZ = Height / 2.0;
 	}
 	A = Spawn(type, Origin + vector(0.0, 0.0, DropZ));
-	A.bDropped = true;	// special versions of items
+	if (A.bSpecial)
+	{
+		A.bDropped = true;	// special versions of items
+	}
+
 	if (Inventory(A))
 	{
 		Inventory Item = Inventory(A);
@@ -1553,6 +1609,12 @@
 {
 	Inventory		Item;
 
+	if (Level.bFrozen && ((!bIsPlayer && !bNoTimeFreeze) ||
+		(bIsPlayer && !(PlayerEx(Player).Cheats & PlayerEx::CF_TIMEFREEZE))))
+	{
+		return;
+	}
+
 	//	Handle powerup effects.
 	for (Item = Inventory; Item && Item.Owner == self; Item = Item.Inventory)
 	{
@@ -1574,7 +1636,7 @@
 		else
 		{
 			Alpha -= 0.75 * deltaTime;
-			if (Alpha < 0.25)
+			if (Alpha <= 0.25)
 			{
 				Alpha = 0.25;
 				VisDir = 1;
@@ -3087,19 +3149,19 @@
 
 	for(inv = Inventory; inv; inv = inv.Inventory)
 	{
-		if (inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup))
+		if (inv && inv.Amount > 0 && ClassIsChildOf(inv.Class, HealthPickup))
 		{
 			int mode = HealthPickup(inv).AutoUseMode;
 
 			if (mode == 3)
 			{
-				Items[Items.Num] = inv;
 				Items.Num = Items.Num + 1;
+				Items[Items.Num - 1] = inv;
 			}
 		}
 	}
 
-	for(i = 0; i < Items.Num - 1; i++)
+	for(i = 0; i < Items.Num; i++)
 	{
 		itemshealth += Items[i].Amount * Items[i].Health;
 	}
@@ -3110,7 +3172,7 @@
 		int index = -1;
 
 		// Find the largest item in the list
-		for(i = 0; i < Items.Num - 1; i++)
+		for(i = 0; i < Items.Num; i++)
 		{
 			if (Items[i].Health > maxhealth)
 			{
@@ -3133,6 +3195,13 @@
 		}
 		// Using all of this item was not enough so delete it and restart with the next best one
 		Items[index] = none;
+		if (index < Items.Num)
+		{
+			for (i = Items.Num - index; i < Items.Num - 1; i++)
+			{
+				Items[i] = Items[i+1];
+			}
+		}
 		Items.Num = Items.Num - 1;
 	}
 
diff -Nur orig/progs/common/linespec/EntityEx.Morph.vc mod/progs/common/linespec/EntityEx.Morph.vc
--- orig/progs/common/linespec/EntityEx.Morph.vc	2009-03-09 23:14:03.000000000 +0100
+++ mod/progs/common/linespec/EntityEx.Morph.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.Morph.vc 4011 2009-03-09 22:17:27Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -74,10 +74,6 @@
 {
 	int i;
 
-	if (bIsPlayer)
-	{
-		return false;
-	}
 	if (!bMonster)
 	{
 		return false;
diff -Nur orig/progs/common/linespec/EntityEx.Physics.vc mod/progs/common/linespec/EntityEx.Physics.vc
--- orig/progs/common/linespec/EntityEx.Physics.vc	2010-12-24 17:10:49.000000000 +0100
+++ mod/progs/common/linespec/EntityEx.Physics.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.Physics.vc 4356 2010-12-24 03:49:32Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -147,11 +147,23 @@
 		else
 		{
 			//	Floating bobbing motion for monsters.
+			float savedz = Origin.z;
+
 			Origin.z -= Level.Game.FloatBobOffsets[
 				ftoi(FloatBobPhase * 35.0) & 63];
+			if (!TestMobjZ())
+			{
+				Origin.z = savedz;
+			}
 			FloatBobPhase += DeltaTime;
+
+			savedz = Origin.z;
 			Origin.z += Level.Game.FloatBobOffsets[
 				ftoi(FloatBobPhase * 35.0) & 63];
+			if (!TestMobjZ())
+			{
+				Origin.z = savedz;
+			}
 		}
 	}
 
@@ -507,7 +519,7 @@
 			}
 		}
 
-	CheckFakeFloorTriggers(OldZ);
+		CheckFakeFloorTriggers(OldZ);
 	}
 }
 
@@ -531,6 +543,27 @@
 				return;
 			}
 
+			// explode a missile
+			if (tmtrace->CeilingLine && tmtrace->CeilingLine->backsector &&
+				tmtrace->CeilingLine->backsector->ceiling.pic == Level.Game.skyflatnum)
+			{
+				// Hack to prevent missiles exploding against the sky.
+				// Does not handle sky floors.
+				if (bBounceSky)
+				{
+					Velocity = vector(0.0, 0.0, -1.0 * 35.0);
+				}
+				else if (bExplodeOnSky)
+				{
+					ExplodeMissile(none);
+				}
+				else
+				{
+					Destroy();
+				}
+				return;
+			}
+
 			if (tmtrace->BlockingLine && tmtrace->BlockingLine->special ==
 				LNSPEC_LineHorizon)
 			{
@@ -615,15 +648,21 @@
 		if (bBounceOnActors || bBounceOnAllActors ||
 			BounceType == BOUNCE_Doom || BounceType == BOUNCE_Hexen)
 		{
+			//	If number of bounces is limited.
+			if (BounceCount > 0 && --BounceCount <= 0)
+			{
+				ExplodeMissile(none);
+				return;
+			}
+
 			//  Bounce against walls and non-killable objects
 			if ((bBounceOnActors || EntityEx(Other).bReflective ||
-				(!Other.bIsPlayer && !EntityEx(Other).bMonster) /* || EntityEx(Other).IsSentient()*/) /* ||
-				EntityEx(Other).bBounceOnAllActors*/)
+				(!Other.bIsPlayer && !EntityEx(Other).bMonster)  || !EntityEx(Other).IsSentient()) ||
+				EntityEx(Other).bBounceOnAllActors)
 			{
 				angle = AngleMod360(atan2(Origin.y - Other.Origin.y,
 					Origin.x - Other.Origin.x) + (Random() * 16.0 - 8.0));
-				speed = Length(Velocity);
-				speed = speed * WallBounceFactor;
+				speed = Length(Velocity) * WallBounceFactor;
 				Angles.yaw = angle;
 				Velocity.x = speed * cos(angle);
 				Velocity.y = speed * sin(angle);
@@ -746,10 +785,6 @@
 		}
 	}
 	Origin.z = FloorZ;
-	if (bCanJump)
-	{
-		JumpTime = 0.2;	// delay any jumping for a short time
-	}
 	if (vdot < -0.1)
 	{
 		// Spawn splashes, etc.
@@ -762,6 +797,10 @@
 			Velocity.z = 0.0;
 			return false;
 		}
+		if (bCanJump)
+		{
+			JumpTime = 0.5;	// delay any jumping for a short time
+		}
 		//	Do some special action when hitting the floor.
 		OnHitFloor();
 		if (bIsPlayer)
@@ -804,13 +843,6 @@
 		SectorAction(Sector->ActionList).TriggerAction(self,
 			SectorAction::SECSPAC_HitCeiling);
 	}
-
-	vdot = DotProduct(Velocity, Ceiling->normal);
-	if (vdot < 0.0)
-	{
-		TVec Vel = vdot * Ceiling->normal;
-		Velocity.z -= Vel.z;
-	}
 	Origin.z = CeilingZ - Height;
 
 	if (bMissile && (bColideWithWorld ||
@@ -844,11 +876,20 @@
 		ExplodeMissile(none);
 		return false;
 	}
+	vdot = DotProduct(Velocity, Ceiling->normal);
+
+	if (vdot < 0.0)
+	{
+		TVec Vel = vdot * Ceiling->normal;
+		Velocity.z -= Vel.z;
+	}
+
 	if (bSkullFly)
 	{
 		// the skull slammed into something
 		Velocity.z = -Velocity.z;
 	}
+
 	return true;
 }
 
@@ -889,15 +930,21 @@
 	if (bBounceLikeHeretic || BounceType == BOUNCE_Heretic &&
 		!bMBFBounce)
 	{
-		Velocity -= 2.0 * vdot * Floor->normal;
+		Velocity -= 2.0 * (vdot * Floor->normal);
 		Angles.yaw = atan2(Velocity.y, Velocity.x);
 		SetState(FindState('Death'));
 		return;
 	}
 
-	if (!bMBFBounce)
+	if (bMBFBounce)
 	{
-		Velocity = (Velocity - 2.0 * vdot * Floor->normal) * BounceFactor;
+		Velocity = Velocity - (2.0 * (vdot * Floor->normal));
+		Velocity.z = Velocity.z * BounceFactor;
+		Angles.yaw = atan2(Velocity.y, Velocity.x);
+	}
+	else
+	{
+		Velocity = (Velocity - (2.0 * (vdot * Floor->normal))) * BounceFactor;
 		Angles.yaw = atan2(Velocity.y, Velocity.x);
 	}
 
@@ -908,7 +955,7 @@
 
 	if (bMBFBounce)
 	{
-		if (Velocity.z < (Mass * Gravity / 64.0))
+		if (Velocity.z < ((Mass * Gravity) / 64.0))
 		{
 			// Bring it to rest below a certain speed
 			Velocity.z = 0.0;
@@ -917,7 +964,7 @@
 
 	if (bBounceAutoOff || BounceType == BOUNCE_Doom)
 	{
-		if (!bNoGravity && Velocity.z < 3.0 * 35.0)
+		if (!bNoGravity && Velocity.z < (3.0 * 35.0))
 		{
 			BounceType = BOUNCE_None;
 		}
@@ -946,20 +993,46 @@
 	if (bBounceLikeHeretic || BounceType == BOUNCE_Heretic &&
 		!bMBFBounce)
 	{
-		Velocity -= 2.0 * vdot * Ceiling->normal;
+		Velocity -= 2.0 * (vdot * Ceiling->normal);
 		Angles.yaw = atan2(Velocity.y, Velocity.x);
 		SetState(FindState('Death'));
 		return;
 	}
 
 	// Reverse momentum here for ceiling bounce
-	Velocity = (Velocity - 2.0 * vdot * Ceiling->normal) * BounceFactor;
-	Angles.yaw = atan2(Velocity.y, Velocity.x);
+	if (bMBFBounce)
+	{
+		Velocity = Velocity - (2.0 * (vdot * Ceiling->normal));
+		Velocity.z = Velocity.z * BounceFactor;
+		Angles.yaw = atan2(Velocity.y, Velocity.x);
+	}
+	else
+	{
+		Velocity = (Velocity - (2.0 * (vdot * Ceiling->normal))) * BounceFactor;
+		Angles.yaw = atan2(Velocity.y, Velocity.x);
+	}
 
 	if (!bNoBounceSound && (BounceSound || SightSound))
 	{
 		PlaySound(BounceSound ? BounceSound : SightSound, CHAN_VOICE);
 	}
+
+	if (bMBFBounce)
+	{
+		if (Velocity.z < (Mass * Gravity / 64.0))
+		{
+			// Bring it to rest below a certain speed
+			Velocity.z = 0.0;
+		}
+	}
+
+	if (bBounceAutoOff || BounceType == BOUNCE_Doom)
+	{
+		if (!bNoGravity && Velocity.z < (3.0 * 35.0))
+		{
+			BounceType = BOUNCE_None;
+		}
+	}
 }
 
 //==========================================================================
@@ -1029,9 +1102,10 @@
 final void Crash()
 {
 	state CrashState = FindState('Crash');
-	if (CrashState && bCorpse && DamageType != 'Ice')
+	if (CrashState && bCorpse && DamageType != 'Ice' && !bCrashed)
 	{
 		SetState(CrashState);
+		bCrashed = true;
 	}
 }
 
@@ -1377,6 +1451,7 @@
 	if (Origin.z <= FloorZ)
 	{
 		dot = DotProduct(Velocity, Floor->normal);
+
 		if (dot < 0.0)
 		{
 			TVec Vel;
diff -Nur orig/progs/common/linespec/EntityEx.SpawnMissile.vc mod/progs/common/linespec/EntityEx.SpawnMissile.vc
--- orig/progs/common/linespec/EntityEx.SpawnMissile.vc	2010-06-13 21:30:29.000000000 +0200
+++ mod/progs/common/linespec/EntityEx.SpawnMissile.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: EntityEx.SpawnMissile.vc 4306 2010-06-13 17:26:33Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -257,6 +257,16 @@
 	{
 		A.Velocity.z = 0.0;
 	}
+	// Adjust the trajectory if the missile will go over the target's head.
+	else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z + dest.Height && A.Origin.z >= dest.Origin.z + dest.Height)
+	{
+		float dist = A.DistTo(dest);
+
+		dir.z += (dest.Origin.z + dest.Height - A.Origin.z) / dist;
+		dir = Normalise(dir);
+
+		A.Velocity.z = dir.z * A.Speed;
+	}
 	VectorAngles(&dir, &A.Angles);
 
 	return A.CheckMissileSpawn() ? A : none;
@@ -296,6 +306,15 @@
 	{
 		A.Velocity.z = 0.0;
 	}
+	// Adjust the trajectory if the missile will go over the target's head.
+	else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z + dest.Height && A.Origin.z >= dest.Origin.z + dest.Height)
+	{
+		float dist = A.DistTo(dest);
+		dir.z += (dest.Origin.z + dest.Height - A.Origin.z) / dist;
+		dir = Normalise(dir);
+
+		A.Velocity.z = dir.z * A.Speed;
+	}
 	VectorAngles(&dir, &A.Angles);
 	return A.CheckMissileSpawn() ? A : none;
 }
@@ -310,9 +329,12 @@
 {
 	EntityEx	A;
 	TVec		dir;
+	TVec        org;
 	float		dist;
 
-	A = Spawn(type, Origin + vector(0.0, 0.0, z != ONFLOORZ ? z - FloorClip : z));
+	org = Origin + vector(0.0, 0.0, z != ONFLOORZ ? z - FloorClip : z);
+
+	A = Spawn(type, org);
 
 	A.PlayMissileSpawnSound(self);
 
@@ -334,6 +356,15 @@
 	{
 		A.Velocity.z = 0.0;
 	}
+	// Adjust the trajectory if the missile will go over the target's head.
+	else if (dest && Origin.z >= dest.Origin.z && Origin.z <= dest.Origin.z + dest.Height && A.Origin.z >= dest.Origin.z + dest.Height)
+	{
+		float dist2 = A.DistTo(dest);
+		dir.z += (dest.Origin.z + dest.Height - A.Origin.z) / dist2;
+		dir = Normalise(dir);
+
+		A.Velocity.z = dir.z * A.Speed;
+	}
 	VectorAngles(&dir, &A.Angles);
 
 	return A.CheckMissileSpawn() ? A : none;
@@ -594,6 +625,15 @@
 
 	A.Target = self;
 	A.Velocity = dir * A.Speed;
+	// Adjust the trajectory if the missile will go over the target's head.
+	if (AimTarget && Origin.z >= AimTarget.Origin.z && Origin.z <= AimTarget.Origin.z + AimTarget.Height && A.Origin.z >= AimTarget.Origin.z + AimTarget.Height)
+	{
+		float dist = A.DistTo(AimTarget);
+		dir.z += (AimTarget.Origin.z + AimTarget.Height - A.Origin.z) / dist;
+		dir = Normalise(dir);
+
+		A.Velocity.z = dir.z * A.Speed;
+	}
 	VectorAngles(&dir, &A.Angles);
 
 	return A.CheckMissileSpawn() || RetExploded ? A : none;
diff -Nur orig/progs/common/linespec/FakeInventory.vc mod/progs/common/linespec/FakeInventory.vc
--- orig/progs/common/linespec/FakeInventory.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/FakeInventory.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FakeInventory.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FastProjectile.vc mod/progs/common/linespec/FastProjectile.vc
--- orig/progs/common/linespec/FastProjectile.vc	2009-11-13 19:28:33.000000000 +0100
+++ mod/progs/common/linespec/FastProjectile.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FastProjectile.vc 4104 2009-11-13 15:28:54Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FighterWeaponPiece.vc mod/progs/common/linespec/FighterWeaponPiece.vc
--- orig/progs/common/linespec/FighterWeaponPiece.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/FighterWeaponPiece.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FighterWeaponPiece.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FighterWeapon.vc mod/progs/common/linespec/FighterWeapon.vc
--- orig/progs/common/linespec/FighterWeapon.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/FighterWeapon.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FighterWeapon.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FireFlicker.vc mod/progs/common/linespec/FireFlicker.vc
--- orig/progs/common/linespec/FireFlicker.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/FireFlicker.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FireFlicker.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FlashFader.vc mod/progs/common/linespec/FlashFader.vc
--- orig/progs/common/linespec/FlashFader.vc	2008-03-27 22:15:46.000000000 +0100
+++ mod/progs/common/linespec/FlashFader.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FlashFader.vc 3396 2008-03-27 21:21:36Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FloorMover.vc mod/progs/common/linespec/FloorMover.vc
--- orig/progs/common/linespec/FloorMover.vc	2010-06-13 21:30:29.000000000 +0200
+++ mod/progs/common/linespec/FloorMover.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FloorMover.vc 4305 2010-06-12 22:08:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FloorWaggle.vc mod/progs/common/linespec/FloorWaggle.vc
--- orig/progs/common/linespec/FloorWaggle.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/FloorWaggle.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FloorWaggle.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ForceFieldGuard.vc mod/progs/common/linespec/ForceFieldGuard.vc
--- orig/progs/common/linespec/ForceFieldGuard.vc	2008-09-20 00:03:26.000000000 +0200
+++ mod/progs/common/linespec/ForceFieldGuard.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ForceFieldGuard.vc 3793 2008-09-19 22:05:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FourthWeaponHolder.vc mod/progs/common/linespec/FourthWeaponHolder.vc
--- orig/progs/common/linespec/FourthWeaponHolder.vc	2008-07-06 22:06:47.000000000 +0200
+++ mod/progs/common/linespec/FourthWeaponHolder.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FourthWeaponHolder.vc 3709 2008-07-06 20:07:43Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FourthWeaponPiece.vc mod/progs/common/linespec/FourthWeaponPiece.vc
--- orig/progs/common/linespec/FourthWeaponPiece.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/FourthWeaponPiece.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FourthWeaponPiece.vc 4326 2010-07-19 21:00:24Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FrostMissile.vc mod/progs/common/linespec/FrostMissile.vc
--- orig/progs/common/linespec/FrostMissile.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/FrostMissile.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FrostMissile.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FSwordMissile.vc mod/progs/common/linespec/FSwordMissile.vc
--- orig/progs/common/linespec/FSwordMissile.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/FSwordMissile.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FSwordMissile.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/FWeapAxe.vc mod/progs/common/linespec/FWeapAxe.vc
--- orig/progs/common/linespec/FWeapAxe.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/FWeapAxe.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FWeapAxe.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/GlassShard.vc mod/progs/common/linespec/GlassShard.vc
--- orig/progs/common/linespec/GlassShard.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/GlassShard.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: GlassShard.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/GlowingLight.vc mod/progs/common/linespec/GlowingLight.vc
--- orig/progs/common/linespec/GlowingLight.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/GlowingLight.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: GlowingLight.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HateTarget.vc mod/progs/common/linespec/HateTarget.vc
--- orig/progs/common/linespec/HateTarget.vc	2008-04-28 19:21:56.000000000 +0200
+++ mod/progs/common/linespec/HateTarget.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HateTarget.vc 3587 2008-04-28 17:25:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HealthFillup.vc mod/progs/common/linespec/HealthFillup.vc
--- orig/progs/common/linespec/HealthFillup.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/HealthFillup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HealthFillup.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HealthPickup.vc mod/progs/common/linespec/HealthPickup.vc
--- orig/progs/common/linespec/HealthPickup.vc	2010-06-13 21:30:29.000000000 +0200
+++ mod/progs/common/linespec/HealthPickup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HealthPickup.vc 4302 2010-06-10 23:34:26Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HealthTraining.vc mod/progs/common/linespec/HealthTraining.vc
--- orig/progs/common/linespec/HealthTraining.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/HealthTraining.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HealthTraining.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Health.vc mod/progs/common/linespec/Health.vc
--- orig/progs/common/linespec/Health.vc	2007-08-11 12:35:56.000000000 +0200
+++ mod/progs/common/linespec/Health.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Health.vc 2619 2007-08-11 10:36:55Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Heresiarch.vc mod/progs/common/linespec/Heresiarch.vc
--- orig/progs/common/linespec/Heresiarch.vc	2008-09-21 22:39:37.000000000 +0200
+++ mod/progs/common/linespec/Heresiarch.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Heresiarch.vc 3794 2008-09-21 20:42:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HereticWeapon.vc mod/progs/common/linespec/HereticWeapon.vc
--- orig/progs/common/linespec/HereticWeapon.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/HereticWeapon.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HereticWeapon.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HexenArmor.vc mod/progs/common/linespec/HexenArmor.vc
--- orig/progs/common/linespec/HexenArmor.vc	2008-01-06 14:27:03.000000000 +0100
+++ mod/progs/common/linespec/HexenArmor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HexenArmor.vc 2989 2008-01-06 13:27:01Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HexenWeapon.vc mod/progs/common/linespec/HexenWeapon.vc
--- orig/progs/common/linespec/HexenWeapon.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/HexenWeapon.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HexenWeapon.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/HolySpirit.vc mod/progs/common/linespec/HolySpirit.vc
--- orig/progs/common/linespec/HolySpirit.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/HolySpirit.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HolySpirit.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -133,19 +133,9 @@
 		}
 		if (bScreenSeeker)
 		{
-			if (CanSee(link))
-			{
-				float angle = AngleMod360(atan2(link.Origin.y - Target.Origin.y,
-					link.Origin.x - Target.Origin.x) - Target.Angles.yaw);
-				if (angle <= 226.0 * 360.0 / 256.0 || angle >= 30.0 * 360.0 / 256.0)
-				{
-					continue;
-				}
-			}
-		}
-		else
-		{
-			if (!CanSee(link))
+			float angle = AngleMod360(atan2(link.Origin.y - Target.Origin.y,
+				link.Origin.x - Target.Origin.x) - Target.Angles.yaw);
+			if (angle <= 226.0 * 360.0 / 256.0 || angle >= 30.0 * 360.0 / 256.0)
 			{
 				continue;
 			}
diff -Nur orig/progs/common/linespec/HornRodFX2.vc mod/progs/common/linespec/HornRodFX2.vc
--- orig/progs/common/linespec/HornRodFX2.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/HornRodFX2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HornRodFX2.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/IceChunkHead.vc mod/progs/common/linespec/IceChunkHead.vc
--- orig/progs/common/linespec/IceChunkHead.vc	2008-03-18 19:44:21.000000000 +0100
+++ mod/progs/common/linespec/IceChunkHead.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: IceChunkHead.vc 3334 2008-03-18 18:50:44Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/IceChunk.vc mod/progs/common/linespec/IceChunk.vc
--- orig/progs/common/linespec/IceChunk.vc	2008-03-15 14:50:18.000000000 +0100
+++ mod/progs/common/linespec/IceChunk.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: IceChunk.vc 3316 2008-03-15 13:55:32Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/InterpolationPoint.vc mod/progs/common/linespec/InterpolationPoint.vc
--- orig/progs/common/linespec/InterpolationPoint.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/InterpolationPoint.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: InterpolationPoint.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/InterpolationSpecial.vc mod/progs/common/linespec/InterpolationSpecial.vc
--- orig/progs/common/linespec/InterpolationSpecial.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/InterpolationSpecial.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: InterpolationSpecial.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Inventory.vc mod/progs/common/linespec/Inventory.vc
--- orig/progs/common/linespec/Inventory.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Inventory.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Inventory.vc 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/InvisibleBridge16.vc mod/progs/common/linespec/InvisibleBridge16.vc
--- orig/progs/common/linespec/InvisibleBridge16.vc	2008-03-27 13:48:55.000000000 +0100
+++ mod/progs/common/linespec/InvisibleBridge16.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: InvisibleBridge16.vc 3387 2008-03-27 12:54:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/InvisibleBridge32.vc mod/progs/common/linespec/InvisibleBridge32.vc
--- orig/progs/common/linespec/InvisibleBridge32.vc	2008-03-27 13:48:55.000000000 +0100
+++ mod/progs/common/linespec/InvisibleBridge32.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: InvisibleBridge32.vc 3387 2008-03-27 12:54:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/InvisibleBridge8.vc mod/progs/common/linespec/InvisibleBridge8.vc
--- orig/progs/common/linespec/InvisibleBridge8.vc	2008-03-27 13:48:55.000000000 +0100
+++ mod/progs/common/linespec/InvisibleBridge8.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: InvisibleBridge8.vc 3387 2008-03-27 12:54:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/InvisibleBridge.vc mod/progs/common/linespec/InvisibleBridge.vc
--- orig/progs/common/linespec/InvisibleBridge.vc	2008-04-20 00:28:12.000000000 +0200
+++ mod/progs/common/linespec/InvisibleBridge.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: InvisibleBridge.vc 3564 2008-04-19 22:31:32Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Key.vc mod/progs/common/linespec/Key.vc
--- orig/progs/common/linespec/Key.vc	2008-03-08 21:48:27.000000000 +0100
+++ mod/progs/common/linespec/Key.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Key.vc 3251 2008-03-08 20:52:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LightEffect.vc mod/progs/common/linespec/LightEffect.vc
--- orig/progs/common/linespec/LightEffect.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/LightEffect.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LightEffect.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LightFlash.vc mod/progs/common/linespec/LightFlash.vc
--- orig/progs/common/linespec/LightFlash.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/LightFlash.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LightFlash.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Lighting.vc mod/progs/common/linespec/Lighting.vc
--- orig/progs/common/linespec/Lighting.vc	2006-10-10 00:23:34.000000000 +0200
+++ mod/progs/common/linespec/Lighting.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Lighting.vc 1769 2006-10-09 22:10:07Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LightningThinker.vc mod/progs/common/linespec/LightningThinker.vc
--- orig/progs/common/linespec/LightningThinker.vc	2008-07-09 23:01:01.000000000 +0200
+++ mod/progs/common/linespec/LightningThinker.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LightningThinker.vc 3716 2008-07-09 21:01:52Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Lightning.vc mod/progs/common/linespec/Lightning.vc
--- orig/progs/common/linespec/Lightning.vc	2010-03-21 21:26:16.000000000 +0100
+++ mod/progs/common/linespec/Lightning.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Lightning.vc 4181 2010-03-21 20:30:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LightningZap.vc mod/progs/common/linespec/LightningZap.vc
--- orig/progs/common/linespec/LightningZap.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/LightningZap.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LightningZap.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LineSpecialClientGame.vc mod/progs/common/linespec/LineSpecialClientGame.vc
--- orig/progs/common/linespec/LineSpecialClientGame.vc	2008-09-20 00:03:26.000000000 +0200
+++ mod/progs/common/linespec/LineSpecialClientGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LineSpecialClientGame.vc 3793 2008-09-19 22:05:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LineSpecialGameInfo.vc mod/progs/common/linespec/LineSpecialGameInfo.vc
--- orig/progs/common/linespec/LineSpecialGameInfo.vc	2010-11-30 12:36:12.000000000 +0100
+++ mod/progs/common/linespec/LineSpecialGameInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LineSpecialGameInfo.vc 4335 2010-09-17 15:40:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -132,6 +132,9 @@
 	CreateCvar('damage_thrust', "1", CVAR_ARCHIVE);
 	CreateCvar('autoaim', "1", CVAR_ARCHIVE);
 	CreateCvar('monster_dropoff', "0", CVAR_ARCHIVE);
+	// This one is only used in Hexen for now, but it could come in
+	// handy for other games if needed
+	CreateCvar('alternate_monster_attacks', "0", CVAR_ARCHIVE);
 }
 
 //==========================================================================
@@ -1033,17 +1036,6 @@
 		}
 	}
 
-	//	Initialise initial friction values.
-	for (i = 0; i < InLevel.NumSectors; i++)
-	{
-		InLevel.Sectors[i].Friction = EntityEx::FRICTION_NORMAL;
-		//	Handle Sky2 sector special.
-		if (InLevel.Sectors[i].special == SECSPEC_Sky2)
-		{
-			InLevel.Sectors[i].Sky = SKY_FROM_SIDE;
-		}
-	}
-
 	//	Set up 3D floors, transfers of light, etc.
 	for (i = 0; i < InLevel.NumLines; i++)
 	{
@@ -1104,6 +1096,17 @@
 		}
 	}
 
+	//	Initialise initial friction values.
+	for (i = 0; i < InLevel.NumSectors; i++)
+	{
+		InLevel.Sectors[i].Friction = EntityEx::FRICTION_NORMAL;
+		//	Handle Sky2 sector special.
+		if (InLevel.Sectors[i].special == SECSPEC_Sky2)
+		{
+			InLevel.Sectors[i].Sky = SKY_FROM_SIDE;
+		}
+	}
+
 	//	Process translucent lines
 	for (i = 0; i < InLevel.NumLines; i++)
 	{
@@ -1305,7 +1308,9 @@
 	{
 		for (i = 2; i < Args.Num; i++)
 		{
-			class<Weapon> Cls = class<Weapon>(FindClass(StrToName(Args[i])));
+			// Standarize class name here, since I've found people writing in all types of
+			// mixed cases...
+			class<Weapon> Cls = class<Weapon>(FindClassLowerCase(StrToName(strlwr(Args[i]))));
 			if (!Cls)
 			{
 				print("%s is not a weapon", Args[i]);
@@ -1340,7 +1345,9 @@
 		return;
 	}
 
-	class<Weapon> Cls = class<Weapon>(FindClass(StrToName(Args[2])));
+	// Standarize class name here, since I've found people writing in all types of
+	// mixed cases...
+	class<Weapon> Cls = class<Weapon>(FindClassLowerCase(StrToName(strlwr(Args[2]))));
 	if (!Cls)
 	{
 		print("%s is not a weapon", Args[2]);
diff -Nur orig/progs/common/linespec/LineSpecialLevelInfo.vc mod/progs/common/linespec/LineSpecialLevelInfo.vc
--- orig/progs/common/linespec/LineSpecialLevelInfo.vc	2010-03-06 19:59:32.000000000 +0100
+++ mod/progs/common/linespec/LineSpecialLevelInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LineSpecialLevelInfo.vc 4140 2010-03-04 23:04:43Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -4190,7 +4190,10 @@
 			newA.Velocity.y = speed * sin(angle) * 35.0;
 			newA.Velocity.z = vspeed * 35.0;
 		}
-		newA.bDropped = true;	// Don't respawn
+		if (newA.bSpecial)
+		{
+			newA.bDropped = true;	// Don't respawn
+		}
 		if (gravity)
 		{
 			newA.bNoGravity = false;
@@ -4269,7 +4272,7 @@
 			newAct.Origin.z = A.Origin.z - A.FloorZ;
 			newAct.SetOrigin2(newAct.Origin);
 		}
-		if (newAct.TestLocation() == false)
+		if (!newAct.TestLocation())
 		{
 			// Didn't fit
 			//	If it counts as kill, adjust total kills count
@@ -4293,7 +4296,10 @@
 				Spawn(TeleportFog, A.Origin + vector(0.0, 0.0,
 					LineSpecialGameInfo(Game).TeleFogHeight));
 			}
-			newAct.bDropped = true;	// Don't respawn
+			if (newAct.bSpecial)
+			{
+				newAct.bDropped = true;	// Don't respawn
+			}
 			if (newAct.bFloatBob)
 			{
 				newAct.Special1f = newAct.Origin.z - newAct.FloorZ;
@@ -4332,7 +4338,7 @@
 	EntityEx NewAct = Spawn(EntClass, Org);
 	bool PrevPassMobj = NewAct.bPassMobj;
 	NewAct.bPassMobj = true;
-	if (NewAct.TestLocation() == false)
+	if (!NewAct.TestLocation())
 	{
 		// Didn't fit
 		//	If it counts as kill, subtract total.
@@ -4352,7 +4358,10 @@
 
 	NewAct.Angles.yaw = Angle;
 	NewAct.SetTID(Tid);
-	NewAct.bDropped = true;	// Don't respawn
+	if (NewAct.bSpecial)
+	{
+		NewAct.bDropped = true;	// Don't respawn
+	}
 	return true;
 }
 
@@ -6319,7 +6328,15 @@
 	pe = PolyobjThinker(po->SpecialData);
 	if (pe)
 	{
-		force = pe.thrust_force;
+		if (pe.IsA('PolyobjRotator'))
+		{
+			force = pe.thrust_force * 8.0;
+		}
+		else
+		{
+			force = pe.thrust_force * 3.0;
+		}
+
 		if (force < 1.0)
 		{
 			force = 1.0;
@@ -6334,7 +6351,7 @@
 		force = 1.0;
 	}
 
-	Other.Velocity += force * thrustDir;
+	Other.Velocity += (force * thrustDir) * 2.0;
 	if (po->bCrush)
 	{
 		TVec testPos;
@@ -6342,6 +6359,7 @@
 		testPos = Other.Origin + force * thrustDir * Game.frametime;
 		if (po->bHurtOnTouch || !Other.CheckPosition(testPos))
 		{
+			// Damage other type of actors
 			EntityEx(Other).Damage(none, none, 3, 'Crush');
 		}
 	}
@@ -6349,6 +6367,76 @@
 
 //==========================================================================
 //
+//  PolyCrushMobj
+//
+//==========================================================================
+
+final void PolyCrushMobj(Entity Other, polyobj_t* po)
+{
+	if (po->bCrush)
+	{
+		//	Crunch Ice Corpses
+		if (EntityEx(Other).bIceCorpse)
+		{
+			// Crush Ice corpses
+			Actor(Other).A_FreezeDeathChunks();
+			return;
+		}
+
+		//	Crunch bodies to giblets
+		if (EntityEx(Other).bCorpse && !EntityEx(Other).bDontGib && Other.Health <= 0)
+		{
+			bool CanDestroy = false;
+			if (!EntityEx(Other).bNoBlood)
+			{
+				class c = FindClass('RealGibs');
+
+				if (c)
+				{
+					if (!FindClassState(GetClassReplacement(c), 'Spawn') ||
+						!AreStateSpritesPresent(FindClassState(GetClassReplacement(c), 'Spawn')))
+					{
+						c = none;
+					}
+				}
+
+				if (c)
+				{
+					Actor Gib = Spawn(RealGibs);
+					Gib.RenderStyle = EntityEx(Other).RenderStyle;
+					Gib.Alpha = EntityEx(Other).Alpha;
+					Gib.Height = 0.0;
+					Gib.Radius = 0.0;
+					if (EntityEx(Other).BloodTranslation && !Gib.bDontTranslate)
+					{
+						Gib.Translation = EntityEx(Other).BloodTranslation;
+					}
+					Gib.PlaySound('misc/fallingsplat', CHAN_BODY);
+					CanDestroy = true;
+				}
+				else
+				{
+					EntityEx(Other).bDontGib = true;
+				}
+			}
+			if (Other.bIsPlayer)
+			{
+				Other.bColideWithWorld = false;
+				Other.bColideWithThings = false;
+				EntityEx(Other).bDontGib = true;
+				EntityEx(Other).bInvisible = true;
+			}
+			else
+			{
+				if (CanDestroy)
+					Other.Destroy();
+			}
+		}
+	}
+}
+
+//==========================================================================
+//
 //  PolyBusy
 //
 //==========================================================================
@@ -6408,6 +6496,7 @@
 			Count += DoThingCount(RepType, tid, SectorTag);
 		}
 	}
+
 	return Count;
 }
 
@@ -6429,7 +6518,7 @@
 		for (Ent = EntityEx(FindMobjFromTID(tid, none)); Ent != none;
 			Ent = EntityEx(FindMobjFromTID(tid, Ent)))
 		{
-			if (Ent.bMonster && Ent.Health <= 0)
+			if (Ent.Health <= 0)
 			{
 				// Don't count dead monsters
 				continue;
@@ -6460,7 +6549,7 @@
 				// Doesn't match
 				continue;
 			}
-			if (Ent.bMonster && Ent.Health <= 0)
+			if (Ent.Health <= 0)
 			{
 				// Don't count dead monsters
 				continue;
@@ -7378,6 +7467,7 @@
 		{
 			mo.bNonShootable = false;
 			mo.bInvulnerable = false;
+			mo.bDormant = false;
 			mo.bShootable = true;
 			mo.Damage(none, none, 10000);
 			count++;
diff -Nur orig/progs/common/linespec/LookAtCamera.vc mod/progs/common/linespec/LookAtCamera.vc
--- orig/progs/common/linespec/LookAtCamera.vc	2007-12-03 22:38:22.000000000 +0100
+++ mod/progs/common/linespec/LookAtCamera.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LookAtCamera.vc 2932 2007-12-03 21:42:43Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LoreShot.vc mod/progs/common/linespec/LoreShot.vc
--- orig/progs/common/linespec/LoreShot.vc	2008-09-07 20:33:39.000000000 +0200
+++ mod/progs/common/linespec/LoreShot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LoreShot.vc 3760 2008-09-07 18:35:50Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/LowerStackLookOnly.vc mod/progs/common/linespec/LowerStackLookOnly.vc
--- orig/progs/common/linespec/LowerStackLookOnly.vc	2008-05-08 20:06:25.000000000 +0200
+++ mod/progs/common/linespec/LowerStackLookOnly.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: LowerStackLookOnly.vc 3602 2008-05-08 18:09:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MaceFX4.vc mod/progs/common/linespec/MaceFX4.vc
--- orig/progs/common/linespec/MaceFX4.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/MaceFX4.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MaceFX4.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Mace.vc mod/progs/common/linespec/Mace.vc
--- orig/progs/common/linespec/Mace.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Mace.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Mace.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Macil1.vc mod/progs/common/linespec/Macil1.vc
--- orig/progs/common/linespec/Macil1.vc	2010-03-02 18:51:51.000000000 +0100
+++ mod/progs/common/linespec/Macil1.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Macil1.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MageStaffFX2.vc mod/progs/common/linespec/MageStaffFX2.vc
--- orig/progs/common/linespec/MageStaffFX2.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/MageStaffFX2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MageStaffFX2.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MageWandMissile.vc mod/progs/common/linespec/MageWandMissile.vc
--- orig/progs/common/linespec/MageWandMissile.vc	2009-01-25 20:54:44.000000000 +0100
+++ mod/progs/common/linespec/MageWandMissile.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MageWandMissile.vc 3975 2009-01-25 20:04:38Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MageWeaponPiece.vc mod/progs/common/linespec/MageWeaponPiece.vc
--- orig/progs/common/linespec/MageWeaponPiece.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/MageWeaponPiece.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MageWeaponPiece.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MageWeapon.vc mod/progs/common/linespec/MageWeapon.vc
--- orig/progs/common/linespec/MageWeapon.vc	2008-09-16 00:07:51.000000000 +0200
+++ mod/progs/common/linespec/MageWeapon.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MageWeapon.vc 3787 2008-09-15 22:10:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MapRevealer.vc mod/progs/common/linespec/MapRevealer.vc
--- orig/progs/common/linespec/MapRevealer.vc	2007-08-12 19:40:06.000000000 +0200
+++ mod/progs/common/linespec/MapRevealer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MapRevealer.vc 2635 2007-08-12 17:41:11Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Meat.vc mod/progs/common/linespec/Meat.vc
--- orig/progs/common/linespec/Meat.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/Meat.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Meat.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MinotaurFriend.vc mod/progs/common/linespec/MinotaurFriend.vc
--- orig/progs/common/linespec/MinotaurFriend.vc	2009-03-17 20:02:29.000000000 +0100
+++ mod/progs/common/linespec/MinotaurFriend.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MinotaurFriend.vc 4013 2009-03-17 19:05:19Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Minotaur.vc mod/progs/common/linespec/Minotaur.vc
--- orig/progs/common/linespec/Minotaur.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Minotaur.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Minotaur.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MorphedMonster.vc mod/progs/common/linespec/MorphedMonster.vc
--- orig/progs/common/linespec/MorphedMonster.vc	2009-03-17 20:02:29.000000000 +0100
+++ mod/progs/common/linespec/MorphedMonster.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MorphedMonster.vc 4013 2009-03-17 19:05:19Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MorphProjectile.vc mod/progs/common/linespec/MorphProjectile.vc
--- orig/progs/common/linespec/MorphProjectile.vc	2009-01-18 19:19:04.000000000 +0100
+++ mod/progs/common/linespec/MorphProjectile.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MorphProjectile.vc 3970 2009-01-18 18:26:46Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/MWeapBloodscourge.vc mod/progs/common/linespec/MWeapBloodscourge.vc
--- orig/progs/common/linespec/MWeapBloodscourge.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/MWeapBloodscourge.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MWeapBloodscourge.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/OpenDoor222.vc mod/progs/common/linespec/OpenDoor222.vc
--- orig/progs/common/linespec/OpenDoor222.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/OpenDoor222.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: OpenDoor222.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/OpenDoor224.vc mod/progs/common/linespec/OpenDoor224.vc
--- orig/progs/common/linespec/OpenDoor224.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/OpenDoor224.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: OpenDoor224.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Oracle.vc mod/progs/common/linespec/Oracle.vc
--- orig/progs/common/linespec/Oracle.vc	2010-03-02 18:51:51.000000000 +0100
+++ mod/progs/common/linespec/Oracle.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Oracle.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ParticleFountain.vc mod/progs/common/linespec/ParticleFountain.vc
--- orig/progs/common/linespec/ParticleFountain.vc	2010-03-04 20:24:48.000000000 +0100
+++ mod/progs/common/linespec/ParticleFountain.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ParticleFountain.vc 4134 2010-03-04 19:28:11Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PathFollower.vc mod/progs/common/linespec/PathFollower.vc
--- orig/progs/common/linespec/PathFollower.vc	2008-04-28 19:48:29.000000000 +0200
+++ mod/progs/common/linespec/PathFollower.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PathFollower.vc 3585 2008-04-28 15:56:29Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PatrolSpecial.vc mod/progs/common/linespec/PatrolSpecial.vc
--- orig/progs/common/linespec/PatrolSpecial.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/PatrolSpecial.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PatrolSpecial.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PhasedLight.vc mod/progs/common/linespec/PhasedLight.vc
--- orig/progs/common/linespec/PhasedLight.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/PhasedLight.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PhasedLight.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PhoenixFX1.vc mod/progs/common/linespec/PhoenixFX1.vc
--- orig/progs/common/linespec/PhoenixFX1.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/PhoenixFX1.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PhoenixFX1.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PhoenixFX2.vc mod/progs/common/linespec/PhoenixFX2.vc
--- orig/progs/common/linespec/PhoenixFX2.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/PhoenixFX2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PhoenixFX2.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PhoenixRodPowered.vc mod/progs/common/linespec/PhoenixRodPowered.vc
--- orig/progs/common/linespec/PhoenixRodPowered.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/PhoenixRodPowered.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PhoenixRodPowered.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PhoenixRod.vc mod/progs/common/linespec/PhoenixRod.vc
--- orig/progs/common/linespec/PhoenixRod.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/PhoenixRod.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PhoenixRod.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PhosphorousFire.vc mod/progs/common/linespec/PhosphorousFire.vc
--- orig/progs/common/linespec/PhosphorousFire.vc	2008-09-19 19:56:47.000000000 +0200
+++ mod/progs/common/linespec/PhosphorousFire.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PhosphorousFire.vc 3789 2008-09-19 17:58:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PickupFlash.vc mod/progs/common/linespec/PickupFlash.vc
--- orig/progs/common/linespec/PickupFlash.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/PickupFlash.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PickupFlash.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PigPlayer.vc mod/progs/common/linespec/PigPlayer.vc
--- orig/progs/common/linespec/PigPlayer.vc	2008-09-21 23:01:29.000000000 +0200
+++ mod/progs/common/linespec/PigPlayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PigPlayer.vc 3795 2008-09-21 21:03:54Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Pillar.vc mod/progs/common/linespec/Pillar.vc
--- orig/progs/common/linespec/Pillar.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/Pillar.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Pillar.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PlaneWatcher.vc mod/progs/common/linespec/PlaneWatcher.vc
--- orig/progs/common/linespec/PlaneWatcher.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/PlaneWatcher.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PlaneWatcher.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Platform.vc mod/progs/common/linespec/Platform.vc
--- orig/progs/common/linespec/Platform.vc	2008-12-30 18:55:00.000000000 +0100
+++ mod/progs/common/linespec/Platform.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Platform.vc 3914 2008-12-29 12:09:25Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -316,7 +316,10 @@
 			else
 			{
 				Time = Wait;
-				Status = PLAT_Waiting;
+				if (Wait > 0.0)
+				{
+					Status = PLAT_Waiting;
+				}
 				SectorStopSequence(Sector);
 				switch (Type)
 				{
@@ -348,7 +351,10 @@
 			else
 			{
 				Time = Wait;
-				Status = PLAT_Waiting;
+				if (Wait > 0.0)
+				{
+					Status = PLAT_Waiting;
+				}
 				SectorStopSequence(Sector);
 				switch (Type)
 				{
diff -Nur orig/progs/common/linespec/PlayerChunk.vc mod/progs/common/linespec/PlayerChunk.vc
--- orig/progs/common/linespec/PlayerChunk.vc	2008-03-18 19:31:47.000000000 +0100
+++ mod/progs/common/linespec/PlayerChunk.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PlayerChunk.vc 3333 2008-03-18 18:37:47Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PlayerEx.vc mod/progs/common/linespec/PlayerEx.vc
--- orig/progs/common/linespec/PlayerEx.vc	2010-12-30 19:37:04.000000000 +0100
+++ mod/progs/common/linespec/PlayerEx.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PlayerEx.vc 4359 2010-12-26 19:05:55Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -31,10 +31,13 @@
 //
 enum
 {
-	CF_NOCLIP		= 1 << 0,		// No clipping, walk through barriers.
-	CF_GODMODE		= 1 << 1,		// No damage, no health loss.
-	CF_REGENERATION	= 1 << 2,		// Regenerate Health points.
-	CF_FRIGHTENING	= 1 << 3		// Scare monsters away.
+	CF_NOCLIP			= 1 << 0,		// No clipping, walk through barriers.
+	CF_GODMODE			= 1 << 1,		// No damage, no health loss.
+	CF_REGENERATION		= 1 << 2,		// Regenerate Health points.
+	CF_FRIGHTENING		= 1 << 3,		// Scare monsters away.
+	CF_DOUBLEFIRINGSPEED= 1 << 4,		// Player owns a double firing speed artifact
+	CF_HIGHJUMP			= 1 << 5,		// Player owns a high jump artifact
+	CF_TIMEFREEZE		= 1 << 6		// Player owns a time freeze artifact
 };
 
 const float USERANGE		= 64.0;
@@ -336,7 +339,14 @@
 
 	if ((Buttons & BT_JUMP) && onground && !JumpTime)
 	{
-		MO.Velocity.z = PlayerPawn(MO).JumpVelZ * 1.1;
+		if (Cheats & CF_HIGHJUMP)
+		{
+			MO.Velocity.z = (PlayerPawn(MO).JumpVelZ * 2.0) * 1.1;
+		}
+		else
+		{
+			MO.Velocity.z = PlayerPawn(MO).JumpVelZ * 1.1;
+		}
 		EntityEx(MO).bOnMobj = false;
 		JumpTime = 0.5;
 	}
@@ -1712,6 +1722,10 @@
 {
 	Inventory item = EntityEx(MO).FindInventory(class<Inventory>(FindClass(StrToName(Inv))));
 
+	if (bTotallyFrozen || (Level.bFrozen && !(Cheats & CF_TIMEFREEZE)))
+	{ // You can't use items if you're totally frozen
+		return;
+	}
 	if (item)
 	{
 		// Use Inventory item
@@ -1721,6 +1735,17 @@
 
 //==========================================================================
 //
+//  CheckDoubleFiringSpeed
+//
+//==========================================================================
+
+bool CheckDoubleFiringSpeed()
+{
+	return Cheats & CF_DOUBLEFIRINGSPEED;
+}
+
+//==========================================================================
+//
 //  ClientSpeech
 //
 //==========================================================================
@@ -3044,7 +3069,10 @@
 {
 	if (bIsBot)
 	{
-		BotTick(deltaTime);
+		if (Level.bFrozen && !(Cheats & CF_TIMEFREEZE))
+		{
+			BotTick(deltaTime);
+		}
 	}
 
 	if ((MO.XLevel.TicTime % (3 * 35) == 0) && Cheats & CF_REGENERATION && Health > 0)
@@ -3064,7 +3092,7 @@
 	}
 
 	//	You can only press use while totally frozen
-	if (bTotallyFrozen)
+	if (bTotallyFrozen || (Level.bFrozen && !(Cheats & CF_TIMEFREEZE)))
 	{
 		Buttons &= BT_USE;
 		Impulse = 0;
@@ -3777,6 +3805,27 @@
 	}
 }
 
+//==========================================================================
+//
+//  Cheat_Freeze
+//
+//==========================================================================
+
+final void Cheat_Freeze()
+{
+	Cheats ^= CF_TIMEFREEZE;
+	if (Cheats & CF_TIMEFREEZE)
+	{
+		cprint("Freeze mode on");
+		Level.bFrozen = true;
+	}
+	else
+	{
+		cprint("Freeze mode off");
+		Level.bFrozen = false;
+	}
+}
+
 bool CheckFriendlyFire(EntityEx source, int damage)
 {
 	return false;
diff -Nur orig/progs/common/linespec/PlayerPawn.vc mod/progs/common/linespec/PlayerPawn.vc
--- orig/progs/common/linespec/PlayerPawn.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/PlayerPawn.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PlayerPawn.vc 4326 2010-07-19 21:00:24Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -165,7 +165,9 @@
 bool UseInventory(Inventory Item)
 {
 	//	Can't use anything while totally frozen
-	if (PlayerEx(Player).bTotallyFrozen)
+	if (PlayerEx(Player).bTotallyFrozen ||
+		(Level.bFrozen &&
+		!(PlayerEx(Player).Cheats & PlayerEx::CF_TIMEFREEZE)))
 	{
 		return false;
 	}
diff -Nur orig/progs/common/linespec/PointLightFlickerRandom.vc mod/progs/common/linespec/PointLightFlickerRandom.vc
--- orig/progs/common/linespec/PointLightFlickerRandom.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/PointLightFlickerRandom.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PointLightFlickerRandom.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PointLightFlicker.vc mod/progs/common/linespec/PointLightFlicker.vc
--- orig/progs/common/linespec/PointLightFlicker.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/PointLightFlicker.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PointLightFlicker.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PointLightPulse.vc mod/progs/common/linespec/PointLightPulse.vc
--- orig/progs/common/linespec/PointLightPulse.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/PointLightPulse.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PointLightPulse.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PointLight.vc mod/progs/common/linespec/PointLight.vc
--- orig/progs/common/linespec/PointLight.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/PointLight.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PointLight.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PointPuller.vc mod/progs/common/linespec/PointPuller.vc
--- orig/progs/common/linespec/PointPuller.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/PointPuller.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PointPuller.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PointPusher.vc mod/progs/common/linespec/PointPusher.vc
--- orig/progs/common/linespec/PointPusher.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/PointPusher.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PointPusher.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PoisonBolt.vc mod/progs/common/linespec/PoisonBolt.vc
--- orig/progs/common/linespec/PoisonBolt.vc	2009-09-01 20:04:02.000000000 +0200
+++ mod/progs/common/linespec/PoisonBolt.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PoisonBolt.vc 4042 2009-07-28 21:58:55Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PoisonCloud.vc mod/progs/common/linespec/PoisonCloud.vc
--- orig/progs/common/linespec/PoisonCloud.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/PoisonCloud.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PoisonCloud.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -50,12 +50,20 @@
 {
 	if (victim.bIsPlayer)
 	{
+		if ((PlayerEx(victim.Player).Cheats & PlayerEx::CF_GODMODE) ||
+			victim.bInvulnerable)
+		{
+			return -1;
+		}
 		if (PlayerEx(victim.Player).PoisonCount < 4)
 		{
 			Actor(victim).PoisonDamage(Actor(source), Actor(source),
 				15 + (P_Random() & 15), false);	// Don't play painsound
 			Actor(victim).PoisonPlayer(Actor(source), 50);
-			victim.PlaySound('*poison', CHAN_VOICE);
+			if (!PlayerEx(victim.Player).MorphTime)
+			{
+				victim.PlaySound('*poison', CHAN_VOICE);
+			}
 		}
 		return -1;
 	}
diff -Nur orig/progs/common/linespec/PolyobjDoor.vc mod/progs/common/linespec/PolyobjDoor.vc
--- orig/progs/common/linespec/PolyobjDoor.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/PolyobjDoor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PolyobjDoor.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PolyobjMover.vc mod/progs/common/linespec/PolyobjMover.vc
--- orig/progs/common/linespec/PolyobjMover.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/PolyobjMover.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PolyobjMover.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PolyobjRotator.vc mod/progs/common/linespec/PolyobjRotator.vc
--- orig/progs/common/linespec/PolyobjRotator.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/PolyobjRotator.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PolyobjRotator.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PolyobjThinker.vc mod/progs/common/linespec/PolyobjThinker.vc
--- orig/progs/common/linespec/PolyobjThinker.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/PolyobjThinker.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PolyobjThinker.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Pottery1.vc mod/progs/common/linespec/Pottery1.vc
--- orig/progs/common/linespec/Pottery1.vc	2008-09-20 00:03:26.000000000 +0200
+++ mod/progs/common/linespec/Pottery1.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Pottery1.vc 3793 2008-09-19 22:05:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerCoupling.vc mod/progs/common/linespec/PowerCoupling.vc
--- orig/progs/common/linespec/PowerCoupling.vc	2009-10-01 15:24:46.000000000 +0200
+++ mod/progs/common/linespec/PowerCoupling.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerCoupling.vc 4068 2009-09-14 20:48:29Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerDamage.vc mod/progs/common/linespec/PowerDamage.vc
--- orig/progs/common/linespec/PowerDamage.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/PowerDamage.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerDamage.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -95,7 +95,5 @@
 
 defaultproperties
 {
-	BlendColour = 0;
-	EffectTime = 60.0;
-	bHubPower = true;
+	EffectTime = 25.0;
 }
diff -Nur orig/progs/common/linespec/PowerDoubleFiringSpeed.vc mod/progs/common/linespec/PowerDoubleFiringSpeed.vc
--- orig/progs/common/linespec/PowerDoubleFiringSpeed.vc	1970-01-01 01:00:00.000000000 +0100
+++ mod/progs/common/linespec/PowerDoubleFiringSpeed.vc	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,62 @@
+//**************************************************************************
+//**
+//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
+//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**       #    ##    ##    #      ####     ####   ##       ##
+//**
+//**    $Id: PowerRegeneration.vc 4319 2010-07-03 18:24:22Z firebrand_kh $
+//**
+//**    Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**    This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**    This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+class PowerDoubleFiringSpeed : Powerup;
+
+//==========================================================================
+//
+//	InitEffect
+//
+//==========================================================================
+
+void InitEffect()
+{
+	if (Owner && Owner.Player)
+	{
+		Owner.PlaySound(SightSound, CHAN_VOICE);
+		// Apply effect.
+		PlayerEx(Owner.Player).Cheats |= PlayerEx::CF_DOUBLEFIRINGSPEED;
+	}
+}
+
+//==========================================================================
+//
+//	EndEffect
+//
+//==========================================================================
+
+void EndEffect()
+{
+	if (Owner && Owner.Player)
+	{
+		Owner.PlaySound(DeathSound, CHAN_VOICE);
+		// Remove effect.
+		PlayerEx(Owner.Player).Cheats &= ~PlayerEx::CF_DOUBLEFIRINGSPEED;
+	}
+}
+
+defaultproperties
+{
+}
diff -Nur orig/progs/common/linespec/PowerFlight.vc mod/progs/common/linespec/PowerFlight.vc
--- orig/progs/common/linespec/PowerFlight.vc	2008-05-08 23:21:09.000000000 +0200
+++ mod/progs/common/linespec/PowerFlight.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerFlight.vc 3614 2008-05-08 21:23:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerFrightener.vc mod/progs/common/linespec/PowerFrightener.vc
--- orig/progs/common/linespec/PowerFrightener.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/PowerFrightener.vc	2022-08-12 08:34:35.000000000 +0200
@@ -55,7 +55,5 @@
 
 defaultproperties
 {
-	BlendColour = 0;
 	EffectTime = 60.0;
-	bHubPower = true;
 }
diff -Nur orig/progs/common/linespec/PowerGhost.vc mod/progs/common/linespec/PowerGhost.vc
--- orig/progs/common/linespec/PowerGhost.vc	2009-03-04 21:04:43.000000000 +0100
+++ mod/progs/common/linespec/PowerGhost.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerGhost.vc 4003 2009-03-04 20:08:00Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -61,4 +61,6 @@
 
 defaultproperties
 {
+	bGhost = true;
+	EffectTime = 60.0;
 }
diff -Nur orig/progs/common/linespec/PowerHighJump.vc mod/progs/common/linespec/PowerHighJump.vc
--- orig/progs/common/linespec/PowerHighJump.vc	1970-01-01 01:00:00.000000000 +0100
+++ mod/progs/common/linespec/PowerHighJump.vc	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,62 @@
+//**************************************************************************
+//**
+//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
+//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**       #    ##    ##    #      ####     ####   ##       ##
+//**
+//**    $Id: PowerRegeneration.vc 4319 2010-07-03 18:24:22Z firebrand_kh $
+//**
+//**    Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**    This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**    This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+class PowerHighJump : Powerup;
+
+//==========================================================================
+//
+//	InitEffect
+//
+//==========================================================================
+
+void InitEffect()
+{
+	if (Owner && Owner.Player)
+	{
+		Owner.PlaySound(SightSound, CHAN_VOICE);
+		// Apply effect.
+		PlayerEx(Owner.Player).Cheats |= PlayerEx::CF_HIGHJUMP;
+	}
+}
+
+//==========================================================================
+//
+//	EndEffect
+//
+//==========================================================================
+
+void EndEffect()
+{
+	if (Owner && Owner.Player)
+	{
+		Owner.PlaySound(DeathSound, CHAN_VOICE);
+		// Remove effect.
+		PlayerEx(Owner.Player).Cheats &= ~PlayerEx::CF_HIGHJUMP;
+	}
+}
+
+defaultproperties
+{
+}
diff -Nur orig/progs/common/linespec/PowerInfiniteAmmo.vc mod/progs/common/linespec/PowerInfiniteAmmo.vc
--- orig/progs/common/linespec/PowerInfiniteAmmo.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/PowerInfiniteAmmo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerInfiniteAmmo.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -55,7 +55,5 @@
 
 defaultproperties
 {
-	BlendColour = 0;
-	EffectTime = 60.0;
-	bHubPower = true;
+	EffectTime = 30.0;
 }
diff -Nur orig/progs/common/linespec/PowerInvisibility.vc mod/progs/common/linespec/PowerInvisibility.vc
--- orig/progs/common/linespec/PowerInvisibility.vc	2009-03-04 21:04:43.000000000 +0100
+++ mod/progs/common/linespec/PowerInvisibility.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerInvisibility.vc 4003 2009-03-04 20:08:00Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -102,5 +102,6 @@
 
 defaultproperties
 {
+	bShadow = true;
 	EffectTime = 60.0;
 }
diff -Nur orig/progs/common/linespec/PowerInvulnerable.vc mod/progs/common/linespec/PowerInvulnerable.vc
--- orig/progs/common/linespec/PowerInvulnerable.vc	2009-03-17 20:13:50.000000000 +0100
+++ mod/progs/common/linespec/PowerInvulnerable.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerInvulnerable.vc 4015 2009-03-17 19:16:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerIronFeet.vc mod/progs/common/linespec/PowerIronFeet.vc
--- orig/progs/common/linespec/PowerIronFeet.vc	2007-08-09 23:40:05.000000000 +0200
+++ mod/progs/common/linespec/PowerIronFeet.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerIronFeet.vc 2607 2007-08-09 21:41:28Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerLightAmp.vc mod/progs/common/linespec/PowerLightAmp.vc
--- orig/progs/common/linespec/PowerLightAmp.vc	2008-03-22 20:57:31.000000000 +0100
+++ mod/progs/common/linespec/PowerLightAmp.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerLightAmp.vc 3357 2008-03-22 20:01:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerMask.vc mod/progs/common/linespec/PowerMask.vc
--- orig/progs/common/linespec/PowerMask.vc	2007-08-09 23:40:05.000000000 +0200
+++ mod/progs/common/linespec/PowerMask.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerMask.vc 2607 2007-08-09 21:41:28Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerMinotaur.vc mod/progs/common/linespec/PowerMinotaur.vc
--- orig/progs/common/linespec/PowerMinotaur.vc	2007-08-10 20:47:00.000000000 +0200
+++ mod/progs/common/linespec/PowerMinotaur.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerMinotaur.vc 2614 2007-08-10 18:47:57Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerMorph.vc mod/progs/common/linespec/PowerMorph.vc
--- orig/progs/common/linespec/PowerMorph.vc	2009-01-24 20:55:00.000000000 +0100
+++ mod/progs/common/linespec/PowerMorph.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerMorph.vc 3974 2009-01-24 20:04:35Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -43,7 +43,7 @@
 	{
 		//	Remember the identity of the player
 		OwnerPlayer = PlayerEx(Owner.Player);
-		if (EntityEx(Owner).MorphPlayer(PlayerClass, -1.0/*INDEFINITELY*/,
+		if (EntityEx(Owner).MorphPlayer(PlayerClass, -1.0 /* INDEFINITELY */,
 			MorphStyle, MorphFlash, UnmorphFlash, EntityEx(Owner)))
 		{
 			//	Replace the new owner in our owner; safe because we are not
diff -Nur orig/progs/common/linespec/PowerProtection.vc mod/progs/common/linespec/PowerProtection.vc
--- orig/progs/common/linespec/PowerProtection.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/PowerProtection.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerProtection.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -113,7 +113,5 @@
 
 defaultproperties
 {
-	BlendColour = 0;
-	EffectTime = 60.0;
-	bHubPower = true;
+	EffectTime = 25.0;
 }
diff -Nur orig/progs/common/linespec/PowerRegeneration.vc mod/progs/common/linespec/PowerRegeneration.vc
--- orig/progs/common/linespec/PowerRegeneration.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/PowerRegeneration.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerRegeneration.vc 4319 2010-07-03 18:24:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -59,7 +59,5 @@
 
 defaultproperties
 {
-	BlendColour = 0;
-	EffectTime = 60.0;
-	bHubPower = true;
+	EffectTime = 120.0;
 }
diff -Nur orig/progs/common/linespec/PowerScanner.vc mod/progs/common/linespec/PowerScanner.vc
--- orig/progs/common/linespec/PowerScanner.vc	2007-08-12 20:12:29.000000000 +0200
+++ mod/progs/common/linespec/PowerScanner.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerScanner.vc 2636 2007-08-12 18:13:36Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerShadow.vc mod/progs/common/linespec/PowerShadow.vc
--- orig/progs/common/linespec/PowerShadow.vc	2009-03-04 21:04:43.000000000 +0100
+++ mod/progs/common/linespec/PowerShadow.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerShadow.vc 4003 2009-03-04 20:08:00Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerSpeed.vc mod/progs/common/linespec/PowerSpeed.vc
--- orig/progs/common/linespec/PowerSpeed.vc	2007-08-10 20:30:23.000000000 +0200
+++ mod/progs/common/linespec/PowerSpeed.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerSpeed.vc 2613 2007-08-10 18:31:21Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerStrength.vc mod/progs/common/linespec/PowerStrength.vc
--- orig/progs/common/linespec/PowerStrength.vc	2007-08-09 00:09:02.000000000 +0200
+++ mod/progs/common/linespec/PowerStrength.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerStrength.vc 2601 2007-08-08 22:10:20Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerTargeter.vc mod/progs/common/linespec/PowerTargeter.vc
--- orig/progs/common/linespec/PowerTargeter.vc	2008-03-09 14:27:40.000000000 +0100
+++ mod/progs/common/linespec/PowerTargeter.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerTargeter.vc 3255 2008-03-09 13:31:04Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -28,5 +28,6 @@
 
 defaultproperties
 {
-	EffectTime = 0.1;
+	EffectTime = 160.0;
+	bHubPower = true;
 }
diff -Nur orig/progs/common/linespec/PowerTimeFreeze.vc mod/progs/common/linespec/PowerTimeFreeze.vc
--- orig/progs/common/linespec/PowerTimeFreeze.vc	1970-01-01 01:00:00.000000000 +0100
+++ mod/progs/common/linespec/PowerTimeFreeze.vc	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,141 @@
+//**************************************************************************
+//**
+//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
+//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**       #    ##    ##    #      ####     ####   ##       ##
+//**
+//**    $Id: PowerRegeneration.vc 4319 2010-07-03 18:24:22Z firebrand_kh $
+//**
+//**    Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**    This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**    This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+class PowerTimeFreezer : Powerup;
+
+//==========================================================================
+//
+//	InitEffect
+//
+//==========================================================================
+
+void InitEffect()
+{
+	if (Owner && Owner.Player)
+	{
+		int i;
+
+		Owner.PlaySound(SightSound, CHAN_VOICE);
+
+		// Give the player and his teammates the power to move when time is frozen.
+		PlayerEx(Owner.Player).Cheats |= PlayerEx::CF_TIMEFREEZE;
+		for (i = 0; i < MAXPLAYERS; i++)
+		{
+			if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned &&
+				Level.Game.Players[i].MO && EntityEx(Level.Game.Players[i].MO).IsTeammate(EntityEx(Owner)))
+			{
+				PlayerEx(Level.Game.Players[i]).Cheats |= PlayerEx::CF_TIMEFREEZE;
+			}
+		}
+		// When this powerup is in effect, pause the music and stop sounds.
+		CmdBuf_AddText("music pause");
+		StopAllSounds();
+
+		// [RH] The effect ends one tic after the counter hits zero, so make
+		// sure we start at an odd count.
+		EffectTime += itof(!(ftoi(EffectTime) & 1));
+		if (!(ftoi(EffectTime) & 1))
+		{
+			EffectTime += 1.0;
+		}
+		// Make sure the effect starts and ends on an even tic.
+		if (!(ftoi(XLevel.Time) & 1))
+		{
+			Level.bFrozen = true;
+		}
+		else
+		{
+			EffectTime += 1.0;
+		}
+	}
+}
+
+//==========================================================================
+//
+//	DoEffect
+//
+//==========================================================================
+
+void DoEffect()
+{
+	::DoEffect();
+	// [RH] Do not change LEVEL_FROZEN on odd tics, or the Revenant's tracer
+	// will get thrown off.
+	if (ftoi(XLevel.Time) & 1)
+	{
+		
+		return;
+	}
+	// [RH] The "blinking" can't check against EffectTics exactly or it will
+	// never happen, because InitEffect ensures that EffectTics will always
+	// be odd when level.time is even.
+	if (EffectTime > PlayerEx::BLINKTHRESHOLD || (ftoi(4.0 * EffectTime) & 1))
+	{
+		Level.bFrozen = true;
+	}
+	else
+	{
+		Level.bFrozen = false;
+	}
+}
+
+//==========================================================================
+//
+//	EndEffect
+//
+//==========================================================================
+
+void EndEffect()
+{
+	// Allow other actors to move about freely once again.
+	Level.bFrozen = false;
+
+	// Also, turn the music back on.
+	CmdBuf_AddText("music resume");
+
+	// Nothing more to do if there's no owner.
+	if (Owner && Owner.Player)
+	{
+		int i;
+		Owner.PlaySound(DeathSound, CHAN_VOICE);
+
+		PlayerEx(Owner.Player).Cheats &= ~PlayerEx::CF_TIMEFREEZE;
+		for (i = 0; i < MAXPLAYERS; i++)
+		{
+			if (Level.Game.Players[i] && Level.Game.Players[i].bSpawned &&
+				Level.Game.Players[i].MO && EntityEx(Level.Game.Players[i].MO).IsTeammate(EntityEx(Owner)))
+			{
+				PlayerEx(Level.Game.Players[i]).Cheats &= ~PlayerEx::CF_TIMEFREEZE;
+			}
+		}
+	}
+}
+
+defaultproperties
+{
+	BlendColour = GOLDCOLOUR;
+	EffectTime = 12.0;
+	bHubPower = true;
+}
diff -Nur orig/progs/common/linespec/PowerTorch.vc mod/progs/common/linespec/PowerTorch.vc
--- orig/progs/common/linespec/PowerTorch.vc	2008-03-22 20:57:31.000000000 +0100
+++ mod/progs/common/linespec/PowerTorch.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerTorch.vc 3357 2008-03-22 20:01:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerupGiver.vc mod/progs/common/linespec/PowerupGiver.vc
--- orig/progs/common/linespec/PowerupGiver.vc	2010-03-02 18:51:51.000000000 +0100
+++ mod/progs/common/linespec/PowerupGiver.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerupGiver.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Powerup.vc mod/progs/common/linespec/Powerup.vc
--- orig/progs/common/linespec/Powerup.vc	2010-03-02 18:51:51.000000000 +0100
+++ mod/progs/common/linespec/Powerup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Powerup.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PowerWeaponLevel2.vc mod/progs/common/linespec/PowerWeaponLevel2.vc
--- orig/progs/common/linespec/PowerWeaponLevel2.vc	2007-08-10 20:28:37.000000000 +0200
+++ mod/progs/common/linespec/PowerWeaponLevel2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PowerWeaponLevel2.vc 2612 2007-08-10 18:29:34Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/PrisonPass.vc mod/progs/common/linespec/PrisonPass.vc
--- orig/progs/common/linespec/PrisonPass.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/PrisonPass.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PrisonPass.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Pusher.vc mod/progs/common/linespec/Pusher.vc
--- orig/progs/common/linespec/Pusher.vc	2009-09-01 20:04:02.000000000 +0200
+++ mod/progs/common/linespec/Pusher.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Pusher.vc 4056 2009-08-10 19:15:19Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -244,8 +244,14 @@
 	for (Node = sec->TouchingThingList; Node; Node = Node->SNext)
 	{
 		thing = EntityEx(Node->Thing);
-		if (!thing.bWindThrust || !thing.bColideWithWorld)
+		if (!thing.bColideWithWorld)
+		{
 			continue;
+		}
+		if (!thing.bWindThrust)
+		{
+			continue;
+		}
 		if (Type == PUSHER_Wind)
 		{
 			if (thing.WaterLevel > 2) // underwater
diff -Nur orig/progs/common/linespec/PuzzleItem.vc mod/progs/common/linespec/PuzzleItem.vc
--- orig/progs/common/linespec/PuzzleItem.vc	2008-03-25 22:22:52.000000000 +0100
+++ mod/progs/common/linespec/PuzzleItem.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PuzzleItem.vc 3379 2008-03-25 21:27:42Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/QuakeFocus.vc mod/progs/common/linespec/QuakeFocus.vc
--- orig/progs/common/linespec/QuakeFocus.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/QuakeFocus.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: QuakeFocus.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -49,6 +49,11 @@
 
 	if (QuakeDuration-- > 0)
 	{
+		if (Richters > 256 / 9)
+		{
+			Richters = 256 / 9;
+		}
+
 		for (playnum = 0; playnum < MAXPLAYERS; playnum++)
 		{
 			pl = PlayerEx(Level.Game.Players[playnum]);
diff -Nur orig/progs/common/linespec/RainPillar.vc mod/progs/common/linespec/RainPillar.vc
--- orig/progs/common/linespec/RainPillar.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/RainPillar.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: RainPillar.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/RainPlayer2.vc mod/progs/common/linespec/RainPlayer2.vc
--- orig/progs/common/linespec/RainPlayer2.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/RainPlayer2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: RainPlayer2.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/RainPlayer3.vc mod/progs/common/linespec/RainPlayer3.vc
--- orig/progs/common/linespec/RainPlayer3.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/RainPlayer3.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: RainPlayer3.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/RainPlayer4.vc mod/progs/common/linespec/RainPlayer4.vc
--- orig/progs/common/linespec/RainPlayer4.vc	2008-09-17 20:57:18.000000000 +0200
+++ mod/progs/common/linespec/RainPlayer4.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: RainPlayer4.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/RaiseAlarm.vc mod/progs/common/linespec/RaiseAlarm.vc
--- orig/progs/common/linespec/RaiseAlarm.vc	2009-09-01 20:04:02.000000000 +0200
+++ mod/progs/common/linespec/RaiseAlarm.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: RaiseAlarm.vc 4056 2009-08-10 19:15:19Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/RandomSpawner.vc mod/progs/common/linespec/RandomSpawner.vc
--- orig/progs/common/linespec/RandomSpawner.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/RandomSpawner.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: RandomSpawner.vc 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Ripper.vc mod/progs/common/linespec/Ripper.vc
--- orig/progs/common/linespec/Ripper.vc	2009-01-25 20:30:53.000000000 +0100
+++ mod/progs/common/linespec/Ripper.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Ripper.vc 3788 2008-09-17 18:59:31Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Scanner.vc mod/progs/common/linespec/Scanner.vc
--- orig/progs/common/linespec/Scanner.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/Scanner.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Scanner.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ScriptedMarine.vc mod/progs/common/linespec/ScriptedMarine.vc
--- orig/progs/common/linespec/ScriptedMarine.vc	2009-03-01 12:26:34.000000000 +0100
+++ mod/progs/common/linespec/ScriptedMarine.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ScriptedMarine.vc 3999 2009-03-01 11:29:36Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -73,7 +73,7 @@
 
 	if (Special1f)
 	{
-		if (MissileState == FindState('AtkDShotgun'))
+		if (MissileState == FindState('Missile', 'SSG', true))
 		{
 			//	Super shotgun sounds.
 			int Ticks = ftoi((XLevel.Time - Special1f) * 35.0);
@@ -131,51 +131,51 @@
 	{
 	default:
 	case WEAPON_Dummy:
-		MissileState = FindState('AtkDummy');
+		MissileState = FindState('Missile', 'None', true);
 		break;
 
 	case WEAPON_Fist:
-		MeleeState = FindState('AtkFist');
+		MeleeState = FindState('Melee', 'Fist', true);
 		break;
 
 	case WEAPON_BerserkFist:
-		MeleeState = FindState('AtkBerserk');
+		MeleeState = FindState('Melee', 'Berserker', true);
 		break;
 
 	case WEAPON_Chainsaw:
-		MeleeState = FindState('AtkChainsaw');
+		MeleeState = FindState('Melee', 'Chainsaw', true);
 		break;
 
 	case WEAPON_Pistol:
-		MissileState = FindState('AtkPistol');
+		MissileState = FindState('Missile', 'Pistol', true);
 		break;
 
 	case WEAPON_Shotgun:
-		MissileState = FindState('AtkShotgun');
+		MissileState = FindState('Missile', 'Shotgun', true);
 		break;
 
 	case WEAPON_SuperShotgun:
-		MissileState = FindState('AtkDShotgun');
+		MissileState = FindState('Missile', 'SSG', true);
 		break;
 
 	case WEAPON_Chaingun:
-		MissileState = FindState('AtkChaingun');
+		MissileState = FindState('Missile', 'Chaingun', true);
 		break;
 
 	case WEAPON_RocketLauncher:
-		MissileState = FindState('AtkRocket');
+		MissileState = FindState('Missile', 'Rocket', true);
 		break;
 
 	case WEAPON_PlasmaRifle:
-		MissileState = FindState('AtkPlasma');
+		MissileState = FindState('Missile', 'Plasma', true);
 		break;
 
 	case WEAPON_Railgun:
-		MissileState = FindState('AtkRailgun');
+		MissileState = FindState('Missile', 'Railgun', true);
 		break;
 
 	case WEAPON_BFG:
-		MissileState = FindState('AtkBfg');
+		MissileState = FindState('Missile', 'Bfg', true);
 		break;
 	}
 }
@@ -224,7 +224,7 @@
 
 final void A_MarineNoise()
 {
-	if (MeleeState == FindState('AtkChainsaw'))
+	if (MeleeState == FindState('Melee', 'Chainsaw', true))
 	{
 		PlaySound('weapons/sawidle', CHAN_WEAPON);
 	}
@@ -570,7 +570,13 @@
 
 final void A_M_FireRailgun()
 {
-	print("Railgun is not implemented yet");
+	if (!Target)
+	{
+		return;
+	}
+
+	A_MonsterRail();
+	Special1f = XLevel.Time + 50.0 / 35.0;
 }
 
 //===========================================================================
diff -Nur orig/progs/common/linespec/Scroller.vc mod/progs/common/linespec/Scroller.vc
--- orig/progs/common/linespec/Scroller.vc	2009-01-03 20:06:59.000000000 +0100
+++ mod/progs/common/linespec/Scroller.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Scroller.vc 3932 2009-01-03 19:12:35Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActEnter.vc mod/progs/common/linespec/SecActEnter.vc
--- orig/progs/common/linespec/SecActEnter.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActEnter.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActEnter.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActExit.vc mod/progs/common/linespec/SecActExit.vc
--- orig/progs/common/linespec/SecActExit.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActExit.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActExit.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActEyesAboveC.vc mod/progs/common/linespec/SecActEyesAboveC.vc
--- orig/progs/common/linespec/SecActEyesAboveC.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActEyesAboveC.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActEyesAboveC.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActEyesBelowC.vc mod/progs/common/linespec/SecActEyesBelowC.vc
--- orig/progs/common/linespec/SecActEyesBelowC.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActEyesBelowC.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActEyesBelowC.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActEyesDive.vc mod/progs/common/linespec/SecActEyesDive.vc
--- orig/progs/common/linespec/SecActEyesDive.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActEyesDive.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActEyesDive.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActEyesSurface.vc mod/progs/common/linespec/SecActEyesSurface.vc
--- orig/progs/common/linespec/SecActEyesSurface.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActEyesSurface.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActEyesSurface.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActHitCeiling.vc mod/progs/common/linespec/SecActHitCeiling.vc
--- orig/progs/common/linespec/SecActHitCeiling.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActHitCeiling.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActHitCeiling.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActHitFakeFloor.vc mod/progs/common/linespec/SecActHitFakeFloor.vc
--- orig/progs/common/linespec/SecActHitFakeFloor.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActHitFakeFloor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActHitFakeFloor.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActHitFloor.vc mod/progs/common/linespec/SecActHitFloor.vc
--- orig/progs/common/linespec/SecActHitFloor.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActHitFloor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActHitFloor.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActUse.vc mod/progs/common/linespec/SecActUse.vc
--- orig/progs/common/linespec/SecActUse.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActUse.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActUse.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecActUseWall.vc mod/progs/common/linespec/SecActUseWall.vc
--- orig/progs/common/linespec/SecActUseWall.vc	2008-03-23 20:15:06.000000000 +0100
+++ mod/progs/common/linespec/SecActUseWall.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecActUseWall.vc 3369 2008-03-23 19:19:39Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecretTrigger.vc mod/progs/common/linespec/SecretTrigger.vc
--- orig/progs/common/linespec/SecretTrigger.vc	2008-04-28 17:56:00.000000000 +0200
+++ mod/progs/common/linespec/SecretTrigger.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecretTrigger.vc 3586 2008-04-28 15:59:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SectorAction.vc mod/progs/common/linespec/SectorAction.vc
--- orig/progs/common/linespec/SectorAction.vc	2008-04-28 17:52:42.000000000 +0200
+++ mod/progs/common/linespec/SectorAction.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SectorAction.vc 3585 2008-04-28 15:56:29Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SectorMover.vc mod/progs/common/linespec/SectorMover.vc
--- orig/progs/common/linespec/SectorMover.vc	2010-06-13 21:30:29.000000000 +0200
+++ mod/progs/common/linespec/SectorMover.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SectorMover.vc 4305 2010-06-12 22:08:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SectorPointLight.vc mod/progs/common/linespec/SectorPointLight.vc
--- orig/progs/common/linespec/SectorPointLight.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/SectorPointLight.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SectorPointLight.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SectorSilencer.vc mod/progs/common/linespec/SectorSilencer.vc
--- orig/progs/common/linespec/SectorSilencer.vc	2008-04-13 18:07:09.000000000 +0200
+++ mod/progs/common/linespec/SectorSilencer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SectorSilencer.vc 3514 2008-04-13 16:13:00Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SectorThinker.vc mod/progs/common/linespec/SectorThinker.vc
--- orig/progs/common/linespec/SectorThinker.vc	2007-04-23 21:55:48.000000000 +0200
+++ mod/progs/common/linespec/SectorThinker.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SectorThinker.vc 2177 2007-04-23 19:57:01Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SecurityCamera.vc mod/progs/common/linespec/SecurityCamera.vc
--- orig/progs/common/linespec/SecurityCamera.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/SecurityCamera.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SecurityCamera.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Sigil.vc mod/progs/common/linespec/Sigil.vc
--- orig/progs/common/linespec/Sigil.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Sigil.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Sigil.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -416,9 +416,12 @@
 	{
 		sigilspread = SpawnPlayerMissileAngle(SpectralLightningBall1,
 			Angles.yaw - 90.0 + itof(i) * (45.0 / 4.0));
-		angle = sigilspread.Angles.yaw;
-		sigilspread.Velocity.x = sigilspread.Speed * cos(angle);
-		sigilspread.Velocity.y = sigilspread.Speed * sin(angle);
+		if (sigilspread)
+		{
+			angle = sigilspread.Angles.yaw;
+			sigilspread.Velocity.x = sigilspread.Speed * cos(angle);
+			sigilspread.Velocity.y = sigilspread.Speed * sin(angle);
+		}
 	}
 }
 
diff -Nur orig/progs/common/linespec/SkyPicker.vc mod/progs/common/linespec/SkyPicker.vc
--- orig/progs/common/linespec/SkyPicker.vc	2008-05-08 20:06:25.000000000 +0200
+++ mod/progs/common/linespec/SkyPicker.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SkyPicker.vc 3602 2008-05-08 18:09:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SkyViewpoint.vc mod/progs/common/linespec/SkyViewpoint.vc
--- orig/progs/common/linespec/SkyViewpoint.vc	2008-04-13 17:27:11.000000000 +0200
+++ mod/progs/common/linespec/SkyViewpoint.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SkyViewpoint.vc 3513 2008-04-13 15:33:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SlideshowStarter.vc mod/progs/common/linespec/SlideshowStarter.vc
--- orig/progs/common/linespec/SlideshowStarter.vc	2010-03-02 18:51:50.000000000 +0100
+++ mod/progs/common/linespec/SlideshowStarter.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SlideshowStarter.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SorcBall1.vc mod/progs/common/linespec/SorcBall1.vc
--- orig/progs/common/linespec/SorcBall1.vc	2008-09-21 22:39:37.000000000 +0200
+++ mod/progs/common/linespec/SorcBall1.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SorcBall1.vc 3794 2008-09-21 20:42:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SorcBall2.vc mod/progs/common/linespec/SorcBall2.vc
--- orig/progs/common/linespec/SorcBall2.vc	2008-09-21 22:39:37.000000000 +0200
+++ mod/progs/common/linespec/SorcBall2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SorcBall2.vc 3794 2008-09-21 20:42:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SorcBall3.vc mod/progs/common/linespec/SorcBall3.vc
--- orig/progs/common/linespec/SorcBall3.vc	2008-09-21 22:39:37.000000000 +0200
+++ mod/progs/common/linespec/SorcBall3.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SorcBall3.vc 3794 2008-09-21 20:42:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SorcBall.vc mod/progs/common/linespec/SorcBall.vc
--- orig/progs/common/linespec/SorcBall.vc	2008-09-21 22:39:37.000000000 +0200
+++ mod/progs/common/linespec/SorcBall.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SorcBall.vc 3794 2008-09-21 20:42:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -151,7 +151,10 @@
 	if (mo)
 	{
 		Actor(mo).Special2 = 35 * 5 / 2;	// 5 seconds
-		dist = Target.Target.DistTo2(mo);
+		if (Target && Target.Target)
+		{
+			dist = Target.Target.DistTo2(mo);
+		}
 		dist = dist / mo.Speed;
 		if (dist < 1.0)
 			dist = 1.0;
diff -Nur orig/progs/common/linespec/Sorcerer2.vc mod/progs/common/linespec/Sorcerer2.vc
--- orig/progs/common/linespec/Sorcerer2.vc	2009-11-13 19:28:33.000000000 +0100
+++ mod/progs/common/linespec/Sorcerer2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Sorcerer2.vc 4104 2009-11-13 15:28:54Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SoundEnvironment.vc mod/progs/common/linespec/SoundEnvironment.vc
--- orig/progs/common/linespec/SoundEnvironment.vc	2008-05-30 20:03:32.000000000 +0200
+++ mod/progs/common/linespec/SoundEnvironment.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SoundEnvironment.vc 3676 2008-05-30 18:10:05Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SoundSequenceSlot.vc mod/progs/common/linespec/SoundSequenceSlot.vc
--- orig/progs/common/linespec/SoundSequenceSlot.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/SoundSequenceSlot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SoundSequenceSlot.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SoundSequence.vc mod/progs/common/linespec/SoundSequence.vc
--- orig/progs/common/linespec/SoundSequence.vc	2008-04-28 17:52:42.000000000 +0200
+++ mod/progs/common/linespec/SoundSequence.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SoundSequence.vc 3585 2008-04-28 15:56:29Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Spark.vc mod/progs/common/linespec/Spark.vc
--- orig/progs/common/linespec/Spark.vc	2010-03-04 20:24:48.000000000 +0100
+++ mod/progs/common/linespec/Spark.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Spark.vc 4134 2010-03-04 19:28:11Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SpecialSpot.vc mod/progs/common/linespec/SpecialSpot.vc
--- orig/progs/common/linespec/SpecialSpot.vc	2008-08-31 22:17:10.000000000 +0200
+++ mod/progs/common/linespec/SpecialSpot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SpecialSpot.vc 3756 2008-08-31 20:19:28Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SpectralMonster.vc mod/progs/common/linespec/SpectralMonster.vc
--- orig/progs/common/linespec/SpectralMonster.vc	2010-03-02 18:51:50.000000000 +0100
+++ mod/progs/common/linespec/SpectralMonster.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SpectralMonster.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/StackPoint.vc mod/progs/common/linespec/StackPoint.vc
--- orig/progs/common/linespec/StackPoint.vc	2008-04-13 17:27:11.000000000 +0200
+++ mod/progs/common/linespec/StackPoint.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StackPoint.vc 3513 2008-04-13 15:33:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/StairStepMover.vc mod/progs/common/linespec/StairStepMover.vc
--- orig/progs/common/linespec/StairStepMover.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/StairStepMover.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StairStepMover.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/StaticLightSource.vc mod/progs/common/linespec/StaticLightSource.vc
--- orig/progs/common/linespec/StaticLightSource.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/StaticLightSource.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StaticLightSource.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/StaticRGBLightSource.vc mod/progs/common/linespec/StaticRGBLightSource.vc
--- orig/progs/common/linespec/StaticRGBLightSource.vc	2010-03-12 18:21:53.000000000 +0100
+++ mod/progs/common/linespec/StaticRGBLightSource.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StaticRGBLightSource.vc 4158 2010-03-12 09:08:49Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Strobe.vc mod/progs/common/linespec/Strobe.vc
--- orig/progs/common/linespec/Strobe.vc	2008-01-04 10:16:37.000000000 +0100
+++ mod/progs/common/linespec/Strobe.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Strobe.vc 2976 2008-01-03 16:27:08Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SwitchableDecoration.vc mod/progs/common/linespec/SwitchableDecoration.vc
--- orig/progs/common/linespec/SwitchableDecoration.vc	2008-08-25 23:16:51.000000000 +0200
+++ mod/progs/common/linespec/SwitchableDecoration.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SwitchableDecoration.vc 3750 2008-08-25 21:18:36Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/SwitchingDecoration.vc mod/progs/common/linespec/SwitchingDecoration.vc
--- orig/progs/common/linespec/SwitchingDecoration.vc	2008-04-28 17:52:42.000000000 +0200
+++ mod/progs/common/linespec/SwitchingDecoration.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: SwitchingDecoration.vc 3585 2008-04-28 15:56:29Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/TeleportDest2.vc mod/progs/common/linespec/TeleportDest2.vc
--- orig/progs/common/linespec/TeleportDest2.vc	2007-08-15 15:07:32.000000000 +0200
+++ mod/progs/common/linespec/TeleportDest2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TeleportDest2.vc 2642 2007-08-15 13:08:54Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/TeleportDest3.vc mod/progs/common/linespec/TeleportDest3.vc
--- orig/progs/common/linespec/TeleportDest3.vc	2007-08-15 15:07:32.000000000 +0200
+++ mod/progs/common/linespec/TeleportDest3.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TeleportDest3.vc 2642 2007-08-15 13:08:54Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/TeleportDest.vc mod/progs/common/linespec/TeleportDest.vc
--- orig/progs/common/linespec/TeleportDest.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/TeleportDest.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TeleportDest.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/TeleporterBeacon.vc mod/progs/common/linespec/TeleporterBeacon.vc
--- orig/progs/common/linespec/TeleporterBeacon.vc	2009-03-17 20:02:29.000000000 +0100
+++ mod/progs/common/linespec/TeleporterBeacon.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TeleporterBeacon.vc 4013 2009-03-17 19:05:19Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/TeleportFog.vc mod/progs/common/linespec/TeleportFog.vc
--- orig/progs/common/linespec/TeleportFog.vc	2008-09-22 19:17:00.000000000 +0200
+++ mod/progs/common/linespec/TeleportFog.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TeleportFog.vc 3796 2008-09-22 17:19:37Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/TelOtherFX1.vc mod/progs/common/linespec/TelOtherFX1.vc
--- orig/progs/common/linespec/TelOtherFX1.vc	2008-09-19 23:08:50.000000000 +0200
+++ mod/progs/common/linespec/TelOtherFX1.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TelOtherFX1.vc 3792 2008-09-19 21:11:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -33,7 +33,7 @@
 
 int DoSpecialDamage(EntityEx victim, EntityEx source, int damage)
 {
-	if (victim.bMonster && !victim.bBoss && !victim.bNoTeleOther)
+   if ((victim.bMonster || victim.bIsPlayer) && !victim.bBoss && !victim.bNoTeleOther)
 	{
 		TeleportOther(Actor(victim));
 	}
diff -Nur orig/progs/common/linespec/TextureChangeDoor.vc mod/progs/common/linespec/TextureChangeDoor.vc
--- orig/progs/common/linespec/TextureChangeDoor.vc	2010-03-06 19:59:32.000000000 +0100
+++ mod/progs/common/linespec/TextureChangeDoor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TextureChangeDoor.vc 4140 2010-03-04 23:04:43Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -85,7 +85,15 @@
 	Timer = AnimSpeed;
 
 	Line1->flags |= ML_BLOCKING;
+	if (!(Line1->flags & ML_DONTPEGBOTTOM))
+	{
+		Line1->flags |= ML_DONTPEGBOTTOM;
+	}
 	Line2->flags |= ML_BLOCKING;
+	if (!(Line2->flags & ML_DONTPEGBOTTOM))
+	{
+		Line2->flags |= ML_DONTPEGBOTTOM;
+	}
 
 	Direction = 1;
 	TopWait = itof(Arg3) / 35.0;
diff -Nur orig/progs/common/linespec/ThrustFloorDown.vc mod/progs/common/linespec/ThrustFloorDown.vc
--- orig/progs/common/linespec/ThrustFloorDown.vc	2008-09-20 00:03:26.000000000 +0200
+++ mod/progs/common/linespec/ThrustFloorDown.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ThrustFloorDown.vc 3793 2008-09-19 22:05:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/UpgradeAccuracy.vc mod/progs/common/linespec/UpgradeAccuracy.vc
--- orig/progs/common/linespec/UpgradeAccuracy.vc	2008-09-07 20:33:39.000000000 +0200
+++ mod/progs/common/linespec/UpgradeAccuracy.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: UpgradeAccuracy.vc 3760 2008-09-07 18:35:50Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/UpgradeStamina.vc mod/progs/common/linespec/UpgradeStamina.vc
--- orig/progs/common/linespec/UpgradeStamina.vc	2008-09-07 20:33:39.000000000 +0200
+++ mod/progs/common/linespec/UpgradeStamina.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: UpgradeStamina.vc 3760 2008-09-07 18:35:50Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/UpperStackLookOnly.vc mod/progs/common/linespec/UpperStackLookOnly.vc
--- orig/progs/common/linespec/UpperStackLookOnly.vc	2008-05-08 20:06:25.000000000 +0200
+++ mod/progs/common/linespec/UpperStackLookOnly.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: UpperStackLookOnly.vc 3602 2008-05-08 18:09:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/VerticalDoor.vc mod/progs/common/linespec/VerticalDoor.vc
--- orig/progs/common/linespec/VerticalDoor.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/VerticalDoor.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: VerticalDoor.vc 4311 2010-06-14 15:12:00Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/WallLightTransfer.vc mod/progs/common/linespec/WallLightTransfer.vc
--- orig/progs/common/linespec/WallLightTransfer.vc	2008-05-15 20:37:23.000000000 +0200
+++ mod/progs/common/linespec/WallLightTransfer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: WallLightTransfer.vc 3634 2008-05-15 18:40:55Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/WaterZone.vc mod/progs/common/linespec/WaterZone.vc
--- orig/progs/common/linespec/WaterZone.vc	2008-03-14 20:46:46.000000000 +0100
+++ mod/progs/common/linespec/WaterZone.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: WaterZone.vc 3312 2008-03-14 19:51:51Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/WeaponGiver.vc mod/progs/common/linespec/WeaponGiver.vc
--- orig/progs/common/linespec/WeaponGiver.vc	2008-09-19 19:56:47.000000000 +0200
+++ mod/progs/common/linespec/WeaponGiver.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: WeaponGiver.vc 3789 2008-09-19 17:58:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/WeaponHolder.vc mod/progs/common/linespec/WeaponHolder.vc
--- orig/progs/common/linespec/WeaponHolder.vc	2008-05-19 20:27:14.000000000 +0200
+++ mod/progs/common/linespec/WeaponHolder.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: WeaponHolder.vc 3644 2008-05-19 18:30:32Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/WeaponPiece.vc mod/progs/common/linespec/WeaponPiece.vc
--- orig/progs/common/linespec/WeaponPiece.vc	2008-05-19 20:27:14.000000000 +0200
+++ mod/progs/common/linespec/WeaponPiece.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: WeaponPiece.vc 3644 2008-05-19 18:30:32Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Weapon.vc mod/progs/common/linespec/Weapon.vc
--- orig/progs/common/linespec/Weapon.vc	2010-09-01 20:26:08.000000000 +0200
+++ mod/progs/common/linespec/Weapon.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Weapon.vc 4325 2010-07-15 23:11:16Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/Whirlwind.vc mod/progs/common/linespec/Whirlwind.vc
--- orig/progs/common/linespec/Whirlwind.vc	2008-08-31 14:05:41.000000000 +0200
+++ mod/progs/common/linespec/Whirlwind.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Whirlwind.vc 3755 2008-08-31 12:07:53Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -120,6 +120,7 @@
 	MissileDamage = 1;
 	RenderStyle = STYLE_Translucent;
 	Alpha = 0.666;
+	bStepMissile = true;
 	bMissile = true;
 	bNoBlockmap = true;
 	bNoGravity = true;
diff -Nur orig/progs/common/linespec/WorldInfoEx.vc mod/progs/common/linespec/WorldInfoEx.vc
--- orig/progs/common/linespec/WorldInfoEx.vc	2008-05-19 20:44:14.000000000 +0200
+++ mod/progs/common/linespec/WorldInfoEx.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: WorldInfoEx.vc 3645 2008-05-19 18:47:35Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ZBell.vc mod/progs/common/linespec/ZBell.vc
--- orig/progs/common/linespec/ZBell.vc	2008-09-20 00:03:26.000000000 +0200
+++ mod/progs/common/linespec/ZBell.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ZBell.vc 3793 2008-09-19 22:05:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ZBridge.vc mod/progs/common/linespec/ZBridge.vc
--- orig/progs/common/linespec/ZBridge.vc	2008-10-19 19:43:02.000000000 +0200
+++ mod/progs/common/linespec/ZBridge.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ZBridge.vc 3827 2008-10-19 16:32:43Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/linespec/ZCorpseLynchedNoHeart.vc mod/progs/common/linespec/ZCorpseLynchedNoHeart.vc
--- orig/progs/common/linespec/ZCorpseLynchedNoHeart.vc	2008-09-20 00:03:26.000000000 +0200
+++ mod/progs/common/linespec/ZCorpseLynchedNoHeart.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ZCorpseLynchedNoHeart.vc 3793 2008-09-19 22:05:51Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/classes.vc mod/progs/common/uibase/classes.vc
--- orig/progs/common/uibase/classes.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/common/uibase/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 4333 2010-09-17 12:59:40Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -69,6 +69,8 @@
 #include "MenuScreenAdvancedVideoOptions.vc"
 #include "MenuScreenVideoOptions.vc"
 #include "MenuScreenSoundOptions.vc"
+#include "MenuScreenSpecialControls.vc"
+#include "MenuScreenMODOptions.vc"
 
 #include "ConDlgChoice.vc"
 #include "ConDialog.vc"
diff -Nur orig/progs/common/uibase/ClientGameShared.vc mod/progs/common/uibase/ClientGameShared.vc
--- orig/progs/common/uibase/ClientGameShared.vc	2008-07-20 10:10:14.000000000 +0200
+++ mod/progs/common/uibase/ClientGameShared.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClientGameShared.vc 3730 2008-07-19 19:31:32Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -139,7 +139,7 @@
 		}
 		C_ClearNotify();*/
 		CmdBuf_AddText("HideConsole\n");
-		LocalSound('menu/activate');
+		LocalSound(menu.ActivateSound);
 		GRoot.SetMouse(true);
 	}
 	else
@@ -159,6 +159,7 @@
 
 final void PopMenu()
 {
+	MenuScreen menu = menu_stack[menu_sp - 1];
 	menu_sp--;
 
 	if (menu_sp < 0)
@@ -167,16 +168,22 @@
 	menu_stack[menu_sp].Destroy();
 	if (menu_sp)
 	{
+		if (menu)
+		{
+			LocalSound(menu.DeactivateSound);
+		}
 		CurrentMenuScreen = menu_stack[menu_sp - 1];
 		CurrentMenuScreen.Show();
 		CurrentMenuScreen.Raise();
 		CurrentMenuScreen.SetFocus();
-		LocalSound('menu/backup');
 	}
 	else
 	{
+		if (menu)
+		{
+			LocalSound(menu.ClearMenusSound);
+		}
 		CurrentMenuScreen = none;
-		LocalSound('menu/clear');
 		GRoot.SetMouse(false);
 	}
 }
diff -Nur orig/progs/common/uibase/ConDialog.vc mod/progs/common/uibase/ConDialog.vc
--- orig/progs/common/uibase/ConDialog.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/common/uibase/ConDialog.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ConDialog.vc 4333 2010-09-17 12:59:40Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/ConDlgChoice.vc mod/progs/common/uibase/ConDlgChoice.vc
--- orig/progs/common/uibase/ConDlgChoice.vc	2008-03-01 12:12:06.000000000 +0100
+++ mod/progs/common/uibase/ConDlgChoice.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ConDlgChoice.vc 3205 2008-03-01 11:18:11Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/FinaleBackground.vc mod/progs/common/uibase/FinaleBackground.vc
--- orig/progs/common/uibase/FinaleBackground.vc	2008-07-20 12:45:01.000000000 +0200
+++ mod/progs/common/uibase/FinaleBackground.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FinaleBackground.vc 3731 2008-07-20 10:45:59Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/FinaleScreen.vc mod/progs/common/uibase/FinaleScreen.vc
--- orig/progs/common/uibase/FinaleScreen.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/common/uibase/FinaleScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: FinaleScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/HUDMessageFadeInOut.vc mod/progs/common/uibase/HUDMessageFadeInOut.vc
--- orig/progs/common/uibase/HUDMessageFadeInOut.vc	2007-11-25 20:12:52.000000000 +0100
+++ mod/progs/common/uibase/HUDMessageFadeInOut.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HUDMessageFadeInOut.vc 2895 2007-11-25 19:18:01Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/HUDMessageFadeOut.vc mod/progs/common/uibase/HUDMessageFadeOut.vc
--- orig/progs/common/uibase/HUDMessageFadeOut.vc	2007-11-25 19:42:30.000000000 +0100
+++ mod/progs/common/uibase/HUDMessageFadeOut.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HUDMessageFadeOut.vc 2893 2007-11-25 18:43:32Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/HUDMessageTypeOnFadeOut.vc mod/progs/common/uibase/HUDMessageTypeOnFadeOut.vc
--- orig/progs/common/uibase/HUDMessageTypeOnFadeOut.vc	2007-11-25 19:58:15.000000000 +0100
+++ mod/progs/common/uibase/HUDMessageTypeOnFadeOut.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HUDMessageTypeOnFadeOut.vc 2894 2007-11-25 19:03:24Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/HUDMessage.vc mod/progs/common/uibase/HUDMessage.vc
--- orig/progs/common/uibase/HUDMessage.vc	2008-04-08 00:41:29.000000000 +0200
+++ mod/progs/common/uibase/HUDMessage.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HUDMessage.vc 3464 2008-04-07 22:45:42Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/IntermissionBackground.vc mod/progs/common/uibase/IntermissionBackground.vc
--- orig/progs/common/uibase/IntermissionBackground.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/common/uibase/IntermissionBackground.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: IntermissionBackground.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuBigTextButton.vc mod/progs/common/uibase/MenuBigTextButton.vc
--- orig/progs/common/uibase/MenuBigTextButton.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/common/uibase/MenuBigTextButton.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuBigTextButton.vc 4333 2010-09-17 12:59:40Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoiceEnum.vc mod/progs/common/uibase/MenuChoiceEnum.vc
--- orig/progs/common/uibase/MenuChoiceEnum.vc	2008-07-17 18:41:35.000000000 +0200
+++ mod/progs/common/uibase/MenuChoiceEnum.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoiceEnum.vc 3702 2008-07-01 22:24:29Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoiceEpisode.vc mod/progs/common/uibase/MenuChoiceEpisode.vc
--- orig/progs/common/uibase/MenuChoiceEpisode.vc	2008-07-14 18:41:34.000000000 +0200
+++ mod/progs/common/uibase/MenuChoiceEpisode.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoiceEpisode.vc 3722 2008-07-14 16:42:23Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoice_LoadSlot.vc mod/progs/common/uibase/MenuChoice_LoadSlot.vc
--- orig/progs/common/uibase/MenuChoice_LoadSlot.vc	2007-11-21 20:08:44.000000000 +0100
+++ mod/progs/common/uibase/MenuChoice_LoadSlot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoice_LoadSlot.vc 2858 2007-11-21 19:12:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoice_OnOff.vc mod/progs/common/uibase/MenuChoice_OnOff.vc
--- orig/progs/common/uibase/MenuChoice_OnOff.vc	2007-11-21 23:36:15.000000000 +0100
+++ mod/progs/common/uibase/MenuChoice_OnOff.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoice_OnOff.vc 2871 2007-11-21 22:40:14Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoicePClass.vc mod/progs/common/uibase/MenuChoicePClass.vc
--- orig/progs/common/uibase/MenuChoicePClass.vc	2008-07-15 18:39:23.000000000 +0200
+++ mod/progs/common/uibase/MenuChoicePClass.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoicePClass.vc 3724 2008-07-15 16:40:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoice_SaveSlot.vc mod/progs/common/uibase/MenuChoice_SaveSlot.vc
--- orig/progs/common/uibase/MenuChoice_SaveSlot.vc	2007-11-21 20:08:44.000000000 +0100
+++ mod/progs/common/uibase/MenuChoice_SaveSlot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoice_SaveSlot.vc 2858 2007-11-21 19:12:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoiceSkill.vc mod/progs/common/uibase/MenuChoiceSkill.vc
--- orig/progs/common/uibase/MenuChoiceSkill.vc	2008-05-20 23:11:36.000000000 +0200
+++ mod/progs/common/uibase/MenuChoiceSkill.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoiceSkill.vc 3658 2008-05-20 21:15:23Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoiceSlider.vc mod/progs/common/uibase/MenuChoiceSlider.vc
--- orig/progs/common/uibase/MenuChoiceSlider.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/common/uibase/MenuChoiceSlider.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoiceSlider.vc 4333 2010-09-17 12:59:40Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoiceSlot.vc mod/progs/common/uibase/MenuChoiceSlot.vc
--- orig/progs/common/uibase/MenuChoiceSlot.vc	2007-11-21 19:22:11.000000000 +0100
+++ mod/progs/common/uibase/MenuChoiceSlot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoiceSlot.vc 2857 2007-11-21 18:26:05Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuChoice.vc mod/progs/common/uibase/MenuChoice.vc
--- orig/progs/common/uibase/MenuChoice.vc	2007-11-21 20:39:00.000000000 +0100
+++ mod/progs/common/uibase/MenuChoice.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuChoice.vc 2861 2007-11-21 19:42:57Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuControlKey.vc mod/progs/common/uibase/MenuControlKey.vc
--- orig/progs/common/uibase/MenuControlKey.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/common/uibase/MenuControlKey.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuControlKey.vc 4336 2010-09-17 21:54:34Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuInputLine.vc mod/progs/common/uibase/MenuInputLine.vc
--- orig/progs/common/uibase/MenuInputLine.vc	2008-07-17 18:41:35.000000000 +0200
+++ mod/progs/common/uibase/MenuInputLine.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuInputLine.vc 3702 2008-07-01 22:24:29Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuModel.vc mod/progs/common/uibase/MenuModel.vc
--- orig/progs/common/uibase/MenuModel.vc	2008-08-30 21:00:58.000000000 +0200
+++ mod/progs/common/uibase/MenuModel.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuModel.vc 3751 2008-08-26 14:23:44Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuSaveSlot.vc mod/progs/common/uibase/MenuSaveSlot.vc
--- orig/progs/common/uibase/MenuSaveSlot.vc	2008-07-17 18:41:35.000000000 +0200
+++ mod/progs/common/uibase/MenuSaveSlot.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuSaveSlot.vc 3702 2008-07-01 22:24:29Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenAdvancedVideoOptions.vc mod/progs/common/uibase/MenuScreenAdvancedVideoOptions.vc
--- orig/progs/common/uibase/MenuScreenAdvancedVideoOptions.vc	2010-12-23 20:47:55.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenAdvancedVideoOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenAdvancedVideoOptions.vc 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -157,10 +157,25 @@
 		Enum.AddItem("Linear");
 		Enum.AddItem("Linear Nearest");
 		Enum.AddItem("Linear Linear");
+		Enum.AddItem("Bilinear");
+		Enum.AddItem("Trilinear");
 		Enum.SetInitialValue(GetCvar('gl_tex_linear'));
 		Enum.ValueChanging = ChangeGlTexLinear;
 		currentY += Enum.Height;
 
+		Enum = MenuChoiceEnum(NewChild(MenuChoiceEnum));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Sprites Filter";
+		Enum.AddItem("Nearest");
+		Enum.AddItem("Linear");
+		Enum.AddItem("Linear Nearest");
+		Enum.AddItem("Linear Linear");
+		Enum.AddItem("Bilinear");
+		Enum.AddItem("Trilinear");
+		Enum.SetInitialValue(GetCvar('gl_sprite_tex_linear'));
+		Enum.ValueChanging = ChangeGlSprTexLinear;
+		currentY += Enum.Height;
+
 		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 		Enum.SetOrigin(ChoicesStartX, currentY);
 		Enum.Text = "Model Sector Lightning";
@@ -192,10 +207,24 @@
 		Enum.AddItem("Point Linear");
 		Enum.AddItem("Linear Linear");
 		Enum.AddItem("Anisotropic Linear");
+		Enum.AddItem("Point Anisotropic Linear");
 		Enum.SetInitialValue(GetCvar('d3d_tex_linear'));
 		Enum.ValueChanging = ChangeD3dTexFilter;
 		currentY += Enum.Height;
 
+		Enum = MenuChoiceEnum(NewChild(MenuChoiceEnum));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Sprites Filter";
+		Enum.AddItem("Point");
+		Enum.AddItem("Linear");
+		Enum.AddItem("Point Linear");
+		Enum.AddItem("Linear Linear");
+		Enum.AddItem("Anisotropic Linear");
+		Enum.AddItem("Point Anisotropic Linear");
+		Enum.SetInitialValue(GetCvar('d3d_sprite_tex_linear'));
+		Enum.ValueChanging = ChangeD3dSprTexFilter;
+		currentY += Enum.Height;
+
 		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 		Enum.SetOrigin(ChoicesStartX, currentY);
 		Enum.Text = "Dithering";
@@ -413,6 +442,18 @@
 
 //==========================================================================
 //
+//	ChangeGlSprTexLinear
+//
+//==========================================================================
+
+bool ChangeGlSprTexLinear(Object Sender, int newValue)
+{
+	SetCvar('gl_sprite_tex_linear', newValue);
+	return true;
+}
+
+//==========================================================================
+//
 //	ChangeGlModelLighting
 //
 //==========================================================================
@@ -461,6 +502,18 @@
 
 //==========================================================================
 //
+//	ChangeD3dSprTexFilter
+//
+//==========================================================================
+
+bool ChangeD3dSprTexFilter(Object Sender, int newValue)
+{
+	SetCvar('d3d_sprite_tex_linear', newValue);
+	return true;
+}
+
+//==========================================================================
+//
 //	ChangeD3dDither
 //
 //==========================================================================
@@ -497,8 +550,8 @@
 
 defaultproperties
 {
-	Width = 360;
-	Height = 220;
+	Width = 380;
+	Height = 260;
 	ChoicesStartX = 200;
 	ChoicesStartY = 26;
 	TitleX = 180;
diff -Nur orig/progs/common/uibase/MenuScreenClass.vc mod/progs/common/uibase/MenuScreenClass.vc
--- orig/progs/common/uibase/MenuScreenClass.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenClass.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenClass.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenControls.vc mod/progs/common/uibase/MenuScreenControls.vc
--- orig/progs/common/uibase/MenuScreenControls.vc	2008-04-19 01:14:52.000000000 +0200
+++ mod/progs/common/uibase/MenuScreenControls.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenControls.vc 3552 2008-04-18 23:17:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -28,6 +28,108 @@
 MenuControlKey Controls[15];
 int NumControls;
 
+// We'll create some arrays here for special controls
+struct alias
+{
+	string alias_name;		// Name of the alias
+	string command;			// Command to type from console
+};
+
+struct bind
+{
+	string bind_key;		// Key to bind this alias to
+	string alias_name;		// Name of the alias
+};
+
+struct menukey
+{
+	string desc;			// Description of the key for menu
+	string alias_name;		// Name of the alias
+};
+
+// Keep dynamic arrays of each of these so that we "build"
+// the special control sections in the menu
+array<alias> aliases_list;
+array<bind> dbinds_list;
+array<bind> binds_list;
+array<menukey> menukeys_list;
+
+string AltTitle;			// Alternate Title for the screen (if any)
+
+//==========================================================================
+//
+//	GenerateArrays
+//
+//  This method generates dynamic arrays of special controls from KEYCONF
+//  scripts
+//
+//==========================================================================
+
+void GenerateArrays()
+{
+	// This method parses KEYCONF special controls to be added to
+	// a special controls screen to display
+	ScriptsParser kc = ScriptsParser(SpawnObject(ScriptsParser));
+
+	kc.OpenLumpName('keyconf');
+	// Lump is present, scan it until we find a 'addkeysection'
+	while (!kc.AtEnd())
+	{
+		// We are only interested in a couple of commands, like
+		// 'addkeysection', 'bind', 'defaultbind' and 'addmenukey'
+		if (kc.Check("addkeysection"))
+		{
+			// addkeysection "Title" keysection<-(for config file)
+			kc.ExpectString();
+			AltTitle = kc.String;
+			// Ignore the config section
+			// (until we think a way to implement it)
+			kc.ExpectString();
+		}
+		if (kc.Check("alias"))
+		{
+			// Store alias name in the special array
+			aliases_list.Num = aliases_list.Num + 1;
+			kc.ExpectString();
+			aliases_list[aliases_list.Num - 1].alias_name = kc.String;
+			kc.ExpectString();
+			aliases_list[aliases_list.Num - 1].command = kc.String;
+		}
+		if (kc.Check("defaultbind"))
+		{
+			dbinds_list.Num = dbinds_list.Num + 1;
+			kc.ExpectString();
+			dbinds_list[dbinds_list.Num - 1].bind_key = kc.String;
+			kc.ExpectString();
+			dbinds_list[dbinds_list.Num - 1].alias_name = kc.String;
+		}
+		if (kc.Check("bind"))
+		{
+			binds_list.Num = binds_list.Num + 1;
+			kc.ExpectString();
+			binds_list[binds_list.Num - 1].bind_key = kc.String;
+			kc.ExpectString();
+			binds_list[binds_list.Num - 1].alias_name = kc.String;
+		}
+		if (kc.Check("addmenukey"))
+		{
+			menukeys_list.Num = menukeys_list.Num + 1;
+			kc.ExpectString();
+			menukeys_list[menukeys_list.Num - 1].desc = kc.String;
+			kc.ExpectString();
+			menukeys_list[menukeys_list.Num - 1].alias_name = kc.String;
+		}
+		kc.GetString();
+	}
+	kc.Destroy();
+}
+
+//==========================================================================
+//
+//	AddControl
+//
+//==========================================================================
+
 void AddControl(string Text, string CommandOn, string CommandOff)
 {
 	MenuControlKey newCtl;
@@ -41,6 +143,12 @@
 	NumControls++;
 }
 
+//==========================================================================
+//
+//	CreateControlKeyChoices
+//
+//==========================================================================
+
 void CreateControlKeyChoices()
 {
 	AddControl("Move foward", "+Forward", "-Forward");
@@ -61,11 +169,23 @@
 	AddControl("Mouse look", "+MouseLook", "-MouseLook");
 }
 
+//==========================================================================
+//
+//	CreateChoices
+//
+//==========================================================================
+
 void CreateChoices()
 {
 	CreateControlKeyChoices();
 }
 
+//==========================================================================
+//
+//	CursorMoved
+//
+//==========================================================================
+
 void CursorMoved()
 {
 	::CursorMoved();
diff -Nur orig/progs/common/uibase/MenuScreenEpisode.vc mod/progs/common/uibase/MenuScreenEpisode.vc
--- orig/progs/common/uibase/MenuScreenEpisode.vc	2008-07-14 18:41:34.000000000 +0200
+++ mod/progs/common/uibase/MenuScreenEpisode.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenEpisode.vc 3722 2008-07-14 16:42:23Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenJoinGame.vc mod/progs/common/uibase/MenuScreenJoinGame.vc
--- orig/progs/common/uibase/MenuScreenJoinGame.vc	2008-10-21 21:53:07.000000000 +0200
+++ mod/progs/common/uibase/MenuScreenJoinGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenJoinGame.vc 3837 2008-10-21 19:55:58Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenLoadGame.vc mod/progs/common/uibase/MenuScreenLoadGame.vc
--- orig/progs/common/uibase/MenuScreenLoadGame.vc	2007-11-21 23:33:59.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenLoadGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenLoadGame.vc 2870 2007-11-21 22:37:58Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenMasterList.vc mod/progs/common/uibase/MenuScreenMasterList.vc
--- orig/progs/common/uibase/MenuScreenMasterList.vc	2008-10-22 22:48:18.000000000 +0200
+++ mod/progs/common/uibase/MenuScreenMasterList.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMasterList.vc 3842 2008-10-22 20:51:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenMODOptions.vc mod/progs/common/uibase/MenuScreenMODOptions.vc
--- orig/progs/common/uibase/MenuScreenMODOptions.vc	1970-01-01 01:00:00.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenMODOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,285 @@
+//**************************************************************************
+//**
+//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
+//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**       #    ##    ##    #      ####     ####   ##       ##
+//**
+//**    $Id: MenuScreenSoundOptions.vc 2863 2007-11-21 20:30:32Z dj_jl $
+//**
+//**    Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**    This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**    This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+class MenuScreenMODOptions : MenuScreen;
+
+//==========================================================================
+//
+//	CreateChoices
+//
+//==========================================================================
+
+void CreateChoices()
+{
+	MenuChoiceEnum		Enum;
+	int					currentY;
+
+	currentY = ChoicesStartY;
+
+	if (GetCvar('snd_mod_player') == 1)
+	{
+		Enum = MenuChoiceEnum(NewChild(MenuChoiceEnum));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Modplug mixer";
+		Enum.AddItem("Nearest");
+		Enum.AddItem("Linear");
+		Enum.AddItem("Spline");
+		Enum.AddItem("FIR");
+		Enum.SetInitialValue(GetCvar('snd_modplug_hqmixer'));
+		Enum.ValueChanging = ChangeModplugHQMixer;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Modplug oversampling";
+		Enum.SetInitialValue(GetCvar('snd_modplug_oversampling'));
+		Enum.ValueChanging = ChangeModplugOversampling;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Modplug Noise Reduction";
+		Enum.SetInitialValue(GetCvar('snd_modplug_noise_reduction'));
+		Enum.ValueChanging = ChangeModplugNoiseReduction;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Modplug Reverb";
+		Enum.SetInitialValue(GetCvar('snd_modplug_reverb'));
+		Enum.ValueChanging = ChangeModplugReverb;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Modplug Mega Bass";
+		Enum.SetInitialValue(GetCvar('snd_modplug_megabass'));
+		Enum.ValueChanging = ChangeModplugMegaBass;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "Modplug Surround";
+		Enum.SetInitialValue(GetCvar('snd_modplug_surround'));
+		Enum.ValueChanging = ChangeModplugSurround;
+		currentY += Enum.Height + 10;
+	}
+	if (GetCvar('snd_mod_player') == 0)
+	{
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "MikMod HQ Mixer";
+		Enum.SetInitialValue(GetCvar('snd_mikmod_hqmixer'));
+		Enum.ValueChanging = ChangeMikModHQMixer;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "MikMod Float Output";
+		Enum.SetInitialValue(GetCvar('snd_mikmod_float'));
+		Enum.ValueChanging = ChangeMikModFloatOutput;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "MikMod Surround Sound";
+		Enum.SetInitialValue(GetCvar('snd_mikmod_surround'));
+		Enum.ValueChanging = ChangeMikModSurroundSound;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "MikMod Interpolation";
+		Enum.SetInitialValue(GetCvar('snd_mikmod_interpolation'));
+		Enum.ValueChanging = ChangeMikModInterpolation;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "MikMod Reverse Stereo";
+		Enum.SetInitialValue(GetCvar('snd_mikmod_reverse_stereo'));
+		Enum.ValueChanging = ChangeMikModReverseStereo;
+		currentY += Enum.Height;
+
+		Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+		Enum.SetOrigin(ChoicesStartX, currentY);
+		Enum.Text = "MikMod Noise Reduction";
+		Enum.SetInitialValue(GetCvar('snd_mikmod_lowpass'));
+		Enum.ValueChanging = ChangeMikModLowPass;
+	}
+}
+
+//==========================================================================
+//
+//	ChangeModplugHQMixer
+//
+//==========================================================================
+
+bool ChangeModplugHQMixer(Object Sender, int newValue)
+{
+	SetCvar('snd_modplug_hqmixer', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeModplugOversampling
+//
+//==========================================================================
+
+bool ChangeModplugOversampling(Object Sender, int newValue)
+{
+	SetCvar('snd_modplug_oversampling', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeModplugNoiseReduction
+//
+//==========================================================================
+
+bool ChangeModplugNoiseReduction(Object Sender, int newValue)
+{
+	SetCvar('snd_modplug_noise_reduction', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeModplugReverb
+//
+//==========================================================================
+
+bool ChangeModplugReverb(Object Sender, int newValue)
+{
+	SetCvar('snd_modplug_reverb', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeModplugMegaBass
+//
+//==========================================================================
+
+bool ChangeModplugMegaBass(Object Sender, int newValue)
+{
+	SetCvar('snd_modplug_megabass', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeModplugSurround
+//
+//==========================================================================
+
+bool ChangeModplugSurround(Object Sender, int newValue)
+{
+	SetCvar('snd_modplug_surround', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMikModHQMixer
+//
+//==========================================================================
+
+bool ChangeMikModHQMixer(Object Sender, int newValue)
+{
+	SetCvar('snd_mikmod_hqmixer', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMikModFloatOutput
+//
+//==========================================================================
+
+bool ChangeMikModFloatOutput(Object Sender, int newValue)
+{
+	SetCvar('snd_mikmod_float', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMikModSurroundSound
+//
+//==========================================================================
+
+bool ChangeMikModSurroundSound(Object Sender, int newValue)
+{
+	SetCvar('snd_mikmod_surround', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMikModInterpolation
+//
+//==========================================================================
+
+bool ChangeMikModInterpolation(Object Sender, int newValue)
+{
+	SetCvar('snd_mikmod_interpolation', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMikModReverseStereo
+//
+//==========================================================================
+
+bool ChangeMikModReverseStereo(Object Sender, int newValue)
+{
+	SetCvar('snd_mikmod_reverse_stereo', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMikModLowPass
+//
+//==========================================================================
+
+bool ChangeMikModLowPass(Object Sender, int newValue)
+{
+	SetCvar('snd_mikmod_lowpass', newValue);
+	return true;
+}
+
+defaultproperties
+{
+	Width = 350;
+	ChoicesStartX = 200;
+	ChoicesStartY = 37;
+	SelectorType = MenuSelector_SmallRight;
+	Title = "MOD OUTPUT SETTINGS";
+}
diff -Nur orig/progs/common/uibase/MenuScreenMouseOptions.vc mod/progs/common/uibase/MenuScreenMouseOptions.vc
--- orig/progs/common/uibase/MenuScreenMouseOptions.vc	2007-11-21 20:50:33.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenMouseOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMouseOptions.vc 2862 2007-11-21 19:54:27Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenSaveGame.vc mod/progs/common/uibase/MenuScreenSaveGame.vc
--- orig/progs/common/uibase/MenuScreenSaveGame.vc	2007-11-21 23:33:59.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenSaveGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenSaveGame.vc 2870 2007-11-21 22:37:58Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenScreenResolution.vc mod/progs/common/uibase/MenuScreenScreenResolution.vc
--- orig/progs/common/uibase/MenuScreenScreenResolution.vc	2010-12-31 15:23:58.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenScreenResolution.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenScreenResolution.vc 4364 2010-12-31 14:19:56Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenSinglePlayer.vc mod/progs/common/uibase/MenuScreenSinglePlayer.vc
--- orig/progs/common/uibase/MenuScreenSinglePlayer.vc	2008-07-14 18:41:34.000000000 +0200
+++ mod/progs/common/uibase/MenuScreenSinglePlayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenSinglePlayer.vc 3722 2008-07-14 16:42:23Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenSkill.vc mod/progs/common/uibase/MenuScreenSkill.vc
--- orig/progs/common/uibase/MenuScreenSkill.vc	2008-05-21 00:02:51.000000000 +0200
+++ mod/progs/common/uibase/MenuScreenSkill.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenSkill.vc 3660 2008-05-20 22:06:46Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenSList.vc mod/progs/common/uibase/MenuScreenSList.vc
--- orig/progs/common/uibase/MenuScreenSList.vc	2008-10-21 21:53:07.000000000 +0200
+++ mod/progs/common/uibase/MenuScreenSList.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenSList.vc 3837 2008-10-21 19:55:58Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuScreenSoundOptions.vc mod/progs/common/uibase/MenuScreenSoundOptions.vc
--- orig/progs/common/uibase/MenuScreenSoundOptions.vc	2007-11-21 21:26:36.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenSoundOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenSoundOptions.vc 2863 2007-11-21 20:30:32Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -35,46 +35,80 @@
 {
 	MenuChoiceSlider	Slider;
 	MenuChoiceEnum		Enum;
+	MenuTextButton		Btn;
 	int					currentY;
 
 	currentY = ChoicesStartY;
 
-	Slider = MenuChoiceSlider(NewChild(MenuChoiceSlider));
-	Slider.SetOrigin(ChoicesStartX, currentY);
-	Slider.Text = "Sound volume";
-	Slider.ValueDelta = 0.1;
-	Slider.SetInitialValue(GetCvarF('sfx_volume'));
-	Slider.ValueChanging = ChangeSoundVolume;
-	currentY += Slider.Height;
+	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+	Enum.SetOrigin(ChoicesStartX, currentY);
+	Enum.Text = "CD Music";
+	Enum.SetInitialValue(GetCvar('snd_use_cd_music'));
+	Enum.ValueChanging = ChangeCDMusic;
+	currentY += Enum.Height;
 
 	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 	Enum.SetOrigin(ChoicesStartX, currentY);
-	Enum.Text = "Swap stereo";
-	Enum.SetInitialValue(GetCvar('swap_stereo'));
-	Enum.ValueChanging = ChangeSwapStereo;
+	Enum.Text = "External Music";
+	Enum.SetInitialValue(GetCvar('snd_external_music'));
+	Enum.ValueChanging = ChangeExternamMusic;
 	currentY += Enum.Height;
 
+	Enum = MenuChoiceEnum(NewChild(MenuChoiceEnum));
+	Enum.SetOrigin(ChoicesStartX, currentY);
+	Enum.Text = "MIDI Output Device";
+	Enum.AddItem("System MIDI Device");
+	Enum.AddItem("Timidity");
+	Enum.SetInitialValue(GetCvar('snd_mid_player'));
+	Enum.ValueChanging = ChangeMIDIPlayer;
+	currentY += Enum.Height;
+
+	Enum = MenuChoiceEnum(NewChild(MenuChoiceEnum));
+	Enum.SetOrigin(ChoicesStartX, currentY);
+	Enum.Text = "MOD Music Output Device";
+	Enum.AddItem("MikMod");
+	Enum.AddItem("MODPlug");
+	Enum.SetInitialValue(GetCvar('snd_mod_player'));
+	Enum.ValueChanging = ChangeMODPlayer;
+	currentY += Enum.Height;
+
+	Btn = MenuTextButton(NewChild(MenuSmallTextButton));
+	Btn.SetOrigin(ChoicesStartX, currentY);
+	Btn.Text = "MOD Output Options";
+	Btn.Activated = ActivateMODOptions;
+	currentY += Btn.Height + 10;
+
 	Slider = MenuChoiceSlider(NewChild(MenuChoiceSlider));
 	Slider.SetOrigin(ChoicesStartX, currentY);
 	Slider.Text = "Music volume";
 	Slider.ValueDelta = 0.1;
-	Slider.SetInitialValue(GetCvarF('music_volume'));
+	Slider.SetInitialValue(GetCvarF('snd_music_volume'));
 	Slider.ValueChanging = ChangeMusicVolume;
 	currentY += Slider.Height;
 
-	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
-	Enum.SetOrigin(ChoicesStartX, currentY);
-	Enum.Text = "CD Music";
-	Enum.SetInitialValue(GetCvar('use_cd_music'));
-	Enum.ValueChanging = ChangeCDMusic;
-	currentY += Enum.Height;
+	Slider = MenuChoiceSlider(NewChild(MenuChoiceSlider));
+	Slider.SetOrigin(ChoicesStartX, currentY);
+	Slider.Text = "Sound volume";
+	Slider.ValueDelta = 0.1;
+	Slider.SetInitialValue(GetCvarF('snd_sfx_volume'));
+	Slider.ValueChanging = ChangeSoundVolume;
+	currentY += Slider.Height;
+
+	Slider = MenuChoiceSlider(NewChild(MenuChoiceSlider));
+	Slider.SetOrigin(ChoicesStartX, currentY);
+	Slider.Text = "Sound Channels";
+	Slider.MinValue = 8.0;
+	Slider.MaxValue = 256.0;
+	Slider.ValueDelta = 8.0;
+	Slider.SetInitialValue(itof(GetCvar('snd_channels')));
+	Slider.ValueChanging = ChangeSoundChannels;
+	currentY += Slider.Height;
 
 	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 	Enum.SetOrigin(ChoicesStartX, currentY);
-	Enum.Text = "External Music";
-	Enum.SetInitialValue(GetCvar('s_external_music'));
-	Enum.ValueChanging = ChangeExternamMusic;
-	currentY += Enum.Height;
+	Enum.Text = "Swap stereo";
+	Enum.SetInitialValue(GetCvar('snd_swap_stereo'));
+	Enum.ValueChanging = ChangeSwapStereo;
 }
 
 //==========================================================================
@@ -85,7 +119,7 @@
 
 bool ChangeSoundVolume(Object Sender, float newValue)
 {
-	SetCvarF('sfx_volume', newValue);
+	SetCvarF('snd_sfx_volume', newValue);
 	return true;
 }
 
@@ -97,7 +131,7 @@
 
 bool ChangeSwapStereo(Object Sender, int newValue)
 {
-	SetCvar('swap_stereo', newValue);
+	SetCvar('snd_swap_stereo', newValue);
 	return true;
 }
 
@@ -109,7 +143,7 @@
 
 bool ChangeMusicVolume(Object Sender, float newValue)
 {
-	SetCvarF('music_volume', newValue);
+	SetCvarF('snd_music_volume', newValue);
 	return true;
 }
 
@@ -121,7 +155,7 @@
 
 bool ChangeCDMusic(Object Sender, int newValue)
 {
-	SetCvar('use_cd_music', newValue);
+	SetCvar('snd_use_cd_music', newValue);
 	return true;
 }
 
@@ -133,13 +167,61 @@
 
 bool ChangeExternamMusic(Object Sender, int newValue)
 {
-	SetCvar('s_external_music', newValue);
+	SetCvar('snd_external_music', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMIDIPlayer
+//
+//==========================================================================
+
+bool ChangeMIDIPlayer(Object Sender, int newValue)
+{
+	SetCvar('snd_mid_player', newValue);
+	return true;
+}
+
+//==========================================================================
+//
+//	ChangeMODPlayer
+//
+//==========================================================================
+
+bool ChangeMODPlayer(Object Sender, int newValue)
+{
+	SetCvar('snd_mod_player', newValue);
 	return true;
 }
 
+//==========================================================================
+//
+//	ChangeSoundChannels
+//
+//==========================================================================
+
+bool ChangeSoundChannels(Object Sender, float newValue)
+{
+	SetCvar('snd_channels', ftoi(newValue));
+	return true;
+}
+
+//==========================================================================
+//
+//	ActivateMODOptions
+//
+//==========================================================================
+
+void ActivateMODOptions(Object Sender)
+{
+	ClGame.PushMenuScreen(ClGame.SpawnMenu(MenuScreenMODOptions));
+}
+
 defaultproperties
 {
-	ChoicesStartX = 160;
+	Width = 370;
+	ChoicesStartX = 210;
 	ChoicesStartY = 37;
 	SelectorType = MenuSelector_SmallRight;
 	Title = "SOUND SETTINGS";
diff -Nur orig/progs/common/uibase/MenuScreenSpecialControls.vc mod/progs/common/uibase/MenuScreenSpecialControls.vc
--- orig/progs/common/uibase/MenuScreenSpecialControls.vc	1970-01-01 01:00:00.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenSpecialControls.vc	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,81 @@
+//**************************************************************************
+//**
+//**    ##   ##    ##    ##   ##   ####     ####   ###     ###
+//**    ##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**     ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**     ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**       #    ##    ##    #      ####     ####   ##       ##
+//**
+//**    $Id: MenuScreenControls2.vc 1741 2006-09-26 23:26:48Z dj_jl $
+//**
+//**    Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**    This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**    This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+class MenuScreenSpecialControls : MenuScreenControls;
+
+//==========================================================================
+//
+//	CreateControlKeyChoices
+//
+//==========================================================================
+
+void CreateControlKeyChoices()
+{
+	int i, j;
+
+	// First, generate arrays for using for building controls list
+	GenerateArrays();
+
+	if (menukeys_list.Num > 0)
+	{
+		for (i = 0; i < menukeys_list.Num; i++)
+		{
+			// For each menukey, we must check the alias name
+			// inside of all defaultbinds and binds, to extract
+			// key binds
+			
+			// First look inside of default binds list
+			if (dbinds_list.Num > 0)
+			{
+				for (j = 0; j < dbinds_list.Num; j++)
+				{
+					if (!strcmp(menukeys_list[i].alias_name, dbinds_list[j].alias_name))
+					{
+						// The alias name is the same, so we'll use the bind
+						// for a MenuControlKey
+						AddControl(menukeys_list[i].desc, dbinds_list[j].alias_name, "");
+					}
+				}
+			}
+			// Also look inside of the binds list
+			if (binds_list.Num > 0)
+			{
+				for (j = 0; j < binds_list.Num; j++)
+				{
+					if (!strcmp(menukeys_list[i].alias_name, binds_list[j].alias_name))
+					{
+						// The alias name is the same, so we'll use the bind
+						// for a MenuControlKey
+						AddControl(menukeys_list[i].desc, binds_list[j].alias_name, "");
+					}
+				}
+			}
+		}
+	}
+}
+
+defaultproperties
+{
+}
diff -Nur orig/progs/common/uibase/MenuScreen.vc mod/progs/common/uibase/MenuScreen.vc
--- orig/progs/common/uibase/MenuScreen.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/common/uibase/MenuScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreen.vc 4333 2010-09-17 12:59:40Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -44,6 +44,10 @@
 int						TitleX;
 int						TitleY;
 
+name					ActivateSound;
+name					DeactivateSound;
+name					ClearMenusSound;
+
 //==========================================================================
 //
 //	CreateMenu
@@ -281,4 +285,8 @@
 	TitleX = 160;
 	TitleY = 24;
 	Focusable = true;
+
+	ActivateSound = 'menu/activate';
+	DeactivateSound = 'menu/backup';
+	ClearMenusSound = 'menu/clear';
 }
diff -Nur orig/progs/common/uibase/MenuScreenVideoOptions.vc mod/progs/common/uibase/MenuScreenVideoOptions.vc
--- orig/progs/common/uibase/MenuScreenVideoOptions.vc	2010-12-24 17:12:37.000000000 +0100
+++ mod/progs/common/uibase/MenuScreenVideoOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenVideoOptions.vc 4358 2010-12-24 16:12:35Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuSelector_Big.vc mod/progs/common/uibase/MenuSelector_Big.vc
--- orig/progs/common/uibase/MenuSelector_Big.vc	2007-11-21 22:50:26.000000000 +0100
+++ mod/progs/common/uibase/MenuSelector_Big.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuSelector_Big.vc 2869 2007-11-21 21:54:24Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuSelector_SmallLeft.vc mod/progs/common/uibase/MenuSelector_SmallLeft.vc
--- orig/progs/common/uibase/MenuSelector_SmallLeft.vc	2007-11-21 20:39:00.000000000 +0100
+++ mod/progs/common/uibase/MenuSelector_SmallLeft.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuSelector_SmallLeft.vc 2861 2007-11-21 19:42:57Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuSelector_SmallRight.vc mod/progs/common/uibase/MenuSelector_SmallRight.vc
--- orig/progs/common/uibase/MenuSelector_SmallRight.vc	2007-11-21 20:22:09.000000000 +0100
+++ mod/progs/common/uibase/MenuSelector_SmallRight.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuSelector_SmallRight.vc 2860 2007-11-21 19:26:04Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuSList.vc mod/progs/common/uibase/MenuSList.vc
--- orig/progs/common/uibase/MenuSList.vc	2008-10-21 21:53:07.000000000 +0200
+++ mod/progs/common/uibase/MenuSList.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuSList.vc 3837 2008-10-21 19:55:58Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuSmallTextButton.vc mod/progs/common/uibase/MenuSmallTextButton.vc
--- orig/progs/common/uibase/MenuSmallTextButton.vc	2007-11-21 23:36:15.000000000 +0100
+++ mod/progs/common/uibase/MenuSmallTextButton.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuSmallTextButton.vc 2871 2007-11-21 22:40:14Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuSpriteAnim.vc mod/progs/common/uibase/MenuSpriteAnim.vc
--- orig/progs/common/uibase/MenuSpriteAnim.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/common/uibase/MenuSpriteAnim.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuSpriteAnim.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuStaticAnim.vc mod/progs/common/uibase/MenuStaticAnim.vc
--- orig/progs/common/uibase/MenuStaticAnim.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/common/uibase/MenuStaticAnim.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuStaticAnim.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuStaticBitmap.vc mod/progs/common/uibase/MenuStaticBitmap.vc
--- orig/progs/common/uibase/MenuStaticBitmap.vc	2007-11-20 21:03:35.000000000 +0100
+++ mod/progs/common/uibase/MenuStaticBitmap.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuStaticBitmap.vc 2844 2007-11-20 20:07:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuTextButton.vc mod/progs/common/uibase/MenuTextButton.vc
--- orig/progs/common/uibase/MenuTextButton.vc	2008-05-20 21:37:50.000000000 +0200
+++ mod/progs/common/uibase/MenuTextButton.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuTextButton.vc 3655 2008-05-20 19:41:43Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/MenuTitleText.vc mod/progs/common/uibase/MenuTitleText.vc
--- orig/progs/common/uibase/MenuTitleText.vc	2007-11-20 23:09:05.000000000 +0100
+++ mod/progs/common/uibase/MenuTitleText.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuTitleText.vc 2847 2007-11-20 22:12:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/common/uibase/StatusBarShared.vc mod/progs/common/uibase/StatusBarShared.vc
--- orig/progs/common/uibase/StatusBarShared.vc	2009-12-23 11:55:18.000000000 +0100
+++ mod/progs/common/uibase/StatusBarShared.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StatusBarShared.vc 4119 2009-12-21 15:58:36Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/classes.vc mod/progs/doom/cgame/classes.vc
--- orig/progs/doom/cgame/classes.vc	2008-09-09 22:26:27.000000000 +0200
+++ mod/progs/doom/cgame/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3763 2008-09-09 20:28:42Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/ClientGame.vc mod/progs/doom/cgame/ClientGame.vc
--- orig/progs/doom/cgame/ClientGame.vc	2008-10-18 19:53:14.000000000 +0200
+++ mod/progs/doom/cgame/ClientGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClientGame.vc 3817 2008-10-18 17:56:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/IntermissionScreen.vc mod/progs/doom/cgame/IntermissionScreen.vc
--- orig/progs/doom/cgame/IntermissionScreen.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/doom/cgame/IntermissionScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: IntermissionScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -134,6 +134,7 @@
 
 void Start()
 {
+	StopAllSounds();
 	ClGame.skipintermission = false;
 	cnt = 0.0;
 	btime = 0.0;
diff -Nur orig/progs/doom/cgame/MenuScreenControls2.vc mod/progs/doom/cgame/MenuScreenControls2.vc
--- orig/progs/doom/cgame/MenuScreenControls2.vc	2006-09-27 01:32:49.000000000 +0200
+++ mod/progs/doom/cgame/MenuScreenControls2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenControls2.vc 1741 2006-09-26 23:26:48Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -37,6 +37,7 @@
 	AddControl("Toggle always run", "ToggleAlwaysRun", "");
 	AddControl("Previous weapon", "impulse 17", "");
 	AddControl("Next weapon", "impulse 18", "");
+	AddControl("Toggle Console", "ToggleConsole", "");
 }
 
 defaultproperties
diff -Nur orig/progs/doom/cgame/MenuScreenGameplayOptions.vc mod/progs/doom/cgame/MenuScreenGameplayOptions.vc
--- orig/progs/doom/cgame/MenuScreenGameplayOptions.vc	2010-11-30 12:36:14.000000000 +0100
+++ mod/progs/doom/cgame/MenuScreenGameplayOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenGameplayOptions.vc 4335 2010-09-17 15:40:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -112,7 +112,7 @@
 	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 	Enum.SetOrigin(ChoicesStartX, currentY);
 	Enum.Text = "Monsters can drop off";
-	Enum.SetInitialValue(GetCvar('compat_dropoff'));
+	Enum.SetInitialValue(GetCvar('monster_dropoff'));
 	Enum.ValueChanging = ChangeDropOff;
 	currentY += Enum.Height;
 
diff -Nur orig/progs/doom/cgame/MenuScreenHelp.vc mod/progs/doom/cgame/MenuScreenHelp.vc
--- orig/progs/doom/cgame/MenuScreenHelp.vc	2007-11-20 21:03:35.000000000 +0100
+++ mod/progs/doom/cgame/MenuScreenHelp.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenHelp.vc 2844 2007-11-20 20:07:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/MenuScreenMain.vc mod/progs/doom/cgame/MenuScreenMain.vc
--- orig/progs/doom/cgame/MenuScreenMain.vc	2007-12-08 15:38:52.000000000 +0100
+++ mod/progs/doom/cgame/MenuScreenMain.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMain.vc 2867 2007-11-21 21:09:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/MenuScreenMultiplayer.vc mod/progs/doom/cgame/MenuScreenMultiplayer.vc
--- orig/progs/doom/cgame/MenuScreenMultiplayer.vc	2007-11-21 22:05:51.000000000 +0100
+++ mod/progs/doom/cgame/MenuScreenMultiplayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMultiplayer.vc 2867 2007-11-21 21:09:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/MenuScreenNewNetGame.vc mod/progs/doom/cgame/MenuScreenNewNetGame.vc
--- orig/progs/doom/cgame/MenuScreenNewNetGame.vc	2008-05-20 21:37:50.000000000 +0200
+++ mod/progs/doom/cgame/MenuScreenNewNetGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenNewNetGame.vc 3655 2008-05-20 19:41:43Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/MenuScreenOptions.vc mod/progs/doom/cgame/MenuScreenOptions.vc
--- orig/progs/doom/cgame/MenuScreenOptions.vc	2007-12-04 00:37:52.000000000 +0100
+++ mod/progs/doom/cgame/MenuScreenOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenOptions.vc 2936 2007-12-03 22:58:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -35,6 +35,7 @@
 {
 	MenuTextButton		Btn;
 	int					currentY;
+	bool 				found = false;
 
 	currentY = ChoicesStartY;
 
@@ -50,6 +51,37 @@
 	Btn.Activated = ActivateControls2;
 	currentY += Btn.Height;
 
+	// Add "Special Controls" for MODs if keyconf lump is present
+	// and it has an "addkeysection" command
+	if (WadLumpPresent('keyconf'))
+	{
+		ScriptsParser kc = ScriptsParser(SpawnObject(ScriptsParser));
+
+		kc.OpenLumpName('keyconf');
+		// Lump is present, scan it until we find a 'addkeysection'
+		while (!kc.AtEnd())
+		{
+			if (kc.Check("addkeysection"))
+			{
+				kc.ExpectString();
+				kc.ExpectString();
+				found = true;
+			}
+			kc.GetString();
+		}
+		kc.Destroy();
+	}
+	if (found)
+	{
+		// Surely a MOD that contains KEYCONF bindings
+		// so we'll show the special controls option
+		Btn = MenuTextButton(NewChild(MenuSmallTextButton));
+		Btn.SetOrigin(ChoicesStartX, currentY);
+		Btn.Text = "Special Controls";
+		Btn.Activated = ActivateSpecialControls;
+		currentY += Btn.Height;
+	}
+		
 	Btn = MenuTextButton(NewChild(MenuSmallTextButton));
 	Btn.SetOrigin(ChoicesStartX, currentY);
 	Btn.Text = "Mouse Options";
@@ -110,6 +142,17 @@
 }
 
 //==========================================================================
+//
+//	ActivateSpecialControls
+//
+//==========================================================================
+
+void ActivateSpecialControls(Object Sender)
+{
+	ClGame.PushMenuScreen(ClGame.SpawnMenu(MenuScreenSpecialControls));
+}
+
+//==========================================================================
 //
 //	ActivateMouseOpt
 //
diff -Nur orig/progs/doom/cgame/MenuScreenPlayerSetup.vc mod/progs/doom/cgame/MenuScreenPlayerSetup.vc
--- orig/progs/doom/cgame/MenuScreenPlayerSetup.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/doom/cgame/MenuScreenPlayerSetup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenPlayerSetup.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/cgame/StatusBarScreen.vc mod/progs/doom/cgame/StatusBarScreen.vc
--- orig/progs/doom/cgame/StatusBarScreen.vc	2010-09-01 20:26:20.000000000 +0200
+++ mod/progs/doom/cgame/StatusBarScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StatusBarScreen.vc 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -349,6 +349,11 @@
 {
 	int i;
 
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
+
 	// draw something in the blank spaces
 	// check which version of Doom we are playing
 #ifdef DOOM2
@@ -357,11 +362,6 @@
 	FillRectWithFlat(0, 448, 640, 32, 'floor7_2');
 #endif
 
-	if (!cl.MO)
-	{
-		return;
-	}
-
 	//  background
 	DrawPic(ST_BGX, ST_BGY, pic_bar);
 
@@ -526,7 +526,7 @@
 
 void SB_DrawFullscreenStats()
 {
-	if (!cl.MO)
+	if (!cl || !cl.MO)
 	{
 		return;
 	}
@@ -648,6 +648,10 @@
 
 void SB_Drawer(int sb_view)
 {
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
 	if (sb_view == SB_VIEW_FULLSCREEN)
 	{
 		SB_DrawFullscreenStats();
@@ -811,7 +815,8 @@
 	if (sb_face_priority < 6)
 	{
 		// rapid firing
-		if (cl.bAttackDown && !cl.bFrozen && !cl.bTotallyFrozen)
+		if (cl.bAttackDown && !cl.bFrozen && !cl.bTotallyFrozen ||
+			(cl.Level.bFrozen && !(cl.Cheats & PlayerEx::CF_TIMEFREEZE)))
 		{
 			if (sb_face_lastattackdown == -1.0)
 			{
diff -Nur orig/progs/doom/cgame/TitleScreen.vc mod/progs/doom/cgame/TitleScreen.vc
--- orig/progs/doom/cgame/TitleScreen.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/doom/cgame/TitleScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TitleScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/CMakeLists.txt mod/progs/doom/CMakeLists.txt
--- orig/progs/doom/CMakeLists.txt	2008-09-11 22:11:38.000000000 +0200
+++ mod/progs/doom/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -4,12 +4,12 @@
 add_custom_command(OUTPUT ${OUTDIR}/game.dat
 	COMMAND mkdir ARGS -p ${OUTDIR}
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/game/classes.vc ${OUTDIR}/game.dat
-	DEPENDS vcc game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
 add_custom_target(doom_game ALL DEPENDS ${OUTDIR}/game.dat)
 add_dependencies(doom_game vcc linespec)
 
 add_custom_command(OUTPUT ${OUTDIR}/cgame.dat
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/cgame/classes.vc ${OUTDIR}/cgame.dat
-	DEPENDS vcc cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
 add_custom_target(doom_cgame ALL DEPENDS ${OUTDIR}/cgame.dat)
 add_dependencies(doom_cgame vcc doom_game uibase)
diff -Nur orig/progs/doom/game/BotPlayer.vc mod/progs/doom/game/BotPlayer.vc
--- orig/progs/doom/game/BotPlayer.vc	2009-11-15 00:45:10.000000000 +0100
+++ mod/progs/doom/game/BotPlayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BotPlayer.vc 4111 2009-11-14 23:46:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/game/classes.vc mod/progs/doom/game/classes.vc
--- orig/progs/doom/game/classes.vc	2008-10-09 22:17:50.000000000 +0200
+++ mod/progs/doom/game/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3803 2008-10-09 20:20:33Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/game/DoomLevelInfo.vc mod/progs/doom/game/DoomLevelInfo.vc
--- orig/progs/doom/game/DoomLevelInfo.vc	2009-11-10 18:34:12.000000000 +0100
+++ mod/progs/doom/game/DoomLevelInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: DoomLevelInfo.vc 3754 2008-08-30 19:00:48Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/game/MainGameInfo.vc mod/progs/doom/game/MainGameInfo.vc
--- orig/progs/doom/game/MainGameInfo.vc	2010-06-13 21:30:30.000000000 +0200
+++ mod/progs/doom/game/MainGameInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MainGameInfo.vc 4305 2010-06-12 22:08:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom/game/Player.vc mod/progs/doom/game/Player.vc
--- orig/progs/doom/game/Player.vc	2010-09-01 20:26:19.000000000 +0200
+++ mod/progs/doom/game/Player.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Player.vc 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom2/cgame.vc mod/progs/doom2/cgame.vc
--- orig/progs/doom2/cgame.vc	2008-09-10 22:20:36.000000000 +0200
+++ mod/progs/doom2/cgame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: cgame.vc 3777 2008-09-10 20:22:53Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/doom2/CMakeLists.txt mod/progs/doom2/CMakeLists.txt
--- orig/progs/doom2/CMakeLists.txt	2008-10-11 20:46:10.000000000 +0200
+++ mod/progs/doom2/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -5,6 +5,6 @@
 add_custom_command(OUTPUT ${OUTDIR}/cgame.dat
 	COMMAND mkdir ARGS -p ${OUTDIR}
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR1} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/cgame.vc ${OUTDIR}/cgame.dat -I${CMAKE_CURRENT_SOURCE_DIR}/../doom/cgame
-	DEPENDS vcc cgame.vc ../doom/cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR1}/game.dat)
+	DEPENDS vcc cgame.vc ${CMAKE_CURRENT_SOURCE_DIR}/../doom/cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR1}/game.dat)
 add_custom_target(doom2_cgame ALL DEPENDS ${OUTDIR}/cgame.dat)
 add_dependencies(doom2_cgame vcc doom_game uibase)
diff -Nur orig/progs/heretic/cgame/classes.vc mod/progs/heretic/cgame/classes.vc
--- orig/progs/heretic/cgame/classes.vc	2008-09-09 22:26:27.000000000 +0200
+++ mod/progs/heretic/cgame/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3763 2008-09-09 20:28:42Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/cgame/ClientGame.vc mod/progs/heretic/cgame/ClientGame.vc
--- orig/progs/heretic/cgame/ClientGame.vc	2008-10-18 19:53:14.000000000 +0200
+++ mod/progs/heretic/cgame/ClientGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClientGame.vc 3817 2008-10-18 17:56:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/cgame/IntermissionScreen.vc mod/progs/heretic/cgame/IntermissionScreen.vc
--- orig/progs/heretic/cgame/IntermissionScreen.vc	2009-10-30 19:02:45.000000000 +0100
+++ mod/progs/heretic/cgame/IntermissionScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: IntermissionScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -88,6 +88,7 @@
 
 void Start()
 {
+	StopAllSounds();
 	FindEpisodeAndMap(ClGame.im.LeaveMap, &im_episode, &im_map);
 	FindEpisodeAndMap(ClGame.im.EnterMap, &im_nextepisode, &im_nextmap);
 
diff -Nur orig/progs/heretic/cgame/MenuScreenControls2.vc mod/progs/heretic/cgame/MenuScreenControls2.vc
--- orig/progs/heretic/cgame/MenuScreenControls2.vc	2006-09-27 01:32:50.000000000 +0200
+++ mod/progs/heretic/cgame/MenuScreenControls2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenControls2.vc 1741 2006-09-26 23:26:48Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -37,6 +37,7 @@
 	AddControl("Toggle always run", "ToggleAlwaysRun", "");
 	AddControl("Previous weapon", "impulse 17", "");
 	AddControl("Next weapon", "impulse 18", "");
+	AddControl("Toggle Console", "ToggleConsole", "");
 }
 
 defaultproperties
diff -Nur orig/progs/heretic/cgame/MenuScreenGameplayOptions.vc mod/progs/heretic/cgame/MenuScreenGameplayOptions.vc
--- orig/progs/heretic/cgame/MenuScreenGameplayOptions.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/heretic/cgame/MenuScreenGameplayOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenGameplayOptions.vc 4335 2010-09-17 15:40:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -111,8 +111,8 @@
 
 	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 	Enum.SetOrigin(ChoicesStartX, currentY);
-	Enum.Text = "Monsters can drop off tall edges";
-	Enum.SetInitialValue(GetCvar('compat_dropoff'));
+	Enum.Text = "Monsters can drop off";
+	Enum.SetInitialValue(GetCvar('monster_dropoff'));
 	Enum.ValueChanging = ChangeDropOff;
 	currentY += Enum.Height;
 
diff -Nur orig/progs/heretic/cgame/MenuScreenHelp.vc mod/progs/heretic/cgame/MenuScreenHelp.vc
--- orig/progs/heretic/cgame/MenuScreenHelp.vc	2007-11-20 21:03:35.000000000 +0100
+++ mod/progs/heretic/cgame/MenuScreenHelp.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenHelp.vc 2844 2007-11-20 20:07:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/cgame/MenuScreenMain.vc mod/progs/heretic/cgame/MenuScreenMain.vc
--- orig/progs/heretic/cgame/MenuScreenMain.vc	2007-11-21 22:05:51.000000000 +0100
+++ mod/progs/heretic/cgame/MenuScreenMain.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMain.vc 2867 2007-11-21 21:09:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/cgame/MenuScreenMultiplayer.vc mod/progs/heretic/cgame/MenuScreenMultiplayer.vc
--- orig/progs/heretic/cgame/MenuScreenMultiplayer.vc	2007-11-21 22:05:51.000000000 +0100
+++ mod/progs/heretic/cgame/MenuScreenMultiplayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMultiplayer.vc 2867 2007-11-21 21:09:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/cgame/MenuScreenNewNetGame.vc mod/progs/heretic/cgame/MenuScreenNewNetGame.vc
--- orig/progs/heretic/cgame/MenuScreenNewNetGame.vc	2010-03-02 18:51:49.000000000 +0100
+++ mod/progs/heretic/cgame/MenuScreenNewNetGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenNewNetGame.vc 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/cgame/MenuScreenOptions.vc mod/progs/heretic/cgame/MenuScreenOptions.vc
--- orig/progs/heretic/cgame/MenuScreenOptions.vc	2007-12-04 00:37:51.000000000 +0100
+++ mod/progs/heretic/cgame/MenuScreenOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenOptions.vc 2936 2007-12-03 22:58:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -35,6 +35,7 @@
 {
 	MenuTextButton		Btn;
 	int					currentY;
+	bool				found = false;
 
 	currentY = ChoicesStartY;
 
@@ -50,6 +51,37 @@
 	Btn.Activated = ActivateControls2;
 	currentY += Btn.Height;
 
+	// Add "Special Controls" for MODs if keyconf lump is present
+	// and it has an "addkeysection" command
+	if (WadLumpPresent('keyconf'))
+	{
+		ScriptsParser kc = ScriptsParser(SpawnObject(ScriptsParser));
+
+		kc.OpenLumpName('keyconf');
+		// Lump is present, scan it until we find a 'addkeysection'
+		while (!kc.AtEnd())
+		{
+			if (kc.Check("addkeysection"))
+			{
+				kc.ExpectString();
+				kc.ExpectString();
+				found = true;
+			}
+			kc.GetString();
+		}
+		kc.Destroy();
+	}
+	if (found)
+	{
+		// Surely a MOD that contains KEYCONF bindings
+		// so we'll show the special controls option
+		Btn = MenuTextButton(NewChild(MenuSmallTextButton));
+		Btn.SetOrigin(ChoicesStartX, currentY);
+		Btn.Text = "Special Controls";
+		Btn.Activated = ActivateSpecialControls;
+		currentY += Btn.Height;
+	}
+
 	Btn = MenuTextButton(NewChild(MenuSmallTextButton));
 	Btn.SetOrigin(ChoicesStartX, currentY);
 	Btn.Text = "Mouse Options";
@@ -110,6 +142,17 @@
 }
 
 //==========================================================================
+//
+//	ActivateSpecialControls
+//
+//==========================================================================
+
+void ActivateSpecialControls(Object Sender)
+{
+	ClGame.PushMenuScreen(ClGame.SpawnMenu(MenuScreenSpecialControls));
+}
+
+//==========================================================================
 //
 //	ActivateMouseOpt
 //
diff -Nur orig/progs/heretic/cgame/MenuScreenPlayerSetup.vc mod/progs/heretic/cgame/MenuScreenPlayerSetup.vc
--- orig/progs/heretic/cgame/MenuScreenPlayerSetup.vc	2009-10-30 19:02:45.000000000 +0100
+++ mod/progs/heretic/cgame/MenuScreenPlayerSetup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenPlayerSetup.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/cgame/StatusBarScreen.vc mod/progs/heretic/cgame/StatusBarScreen.vc
--- orig/progs/heretic/cgame/StatusBarScreen.vc	2010-12-24 17:10:49.000000000 +0100
+++ mod/progs/heretic/cgame/StatusBarScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StatusBarScreen.vc 4355 2010-12-24 01:29:15Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -254,7 +254,7 @@
 	int i;
 	int health;
 
-	if (!cl.MO)
+	if (!cl || !cl.MO)
 	{
 		return;
 	}
@@ -392,7 +392,7 @@
 {
 	int i;
 
-	if (!cl.MO)
+	if (!cl || !cl.MO)
 	{
 		return;
 	}
@@ -555,6 +555,10 @@
 
 void SB_Drawer(int sb_view)
 {
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
 	if (sb_view == SB_VIEW_FULLSCREEN)
 	{
 		SB_DrawFullscreenStats();
diff -Nur orig/progs/heretic/cgame/TitleScreen.vc mod/progs/heretic/cgame/TitleScreen.vc
--- orig/progs/heretic/cgame/TitleScreen.vc	2009-10-30 19:02:45.000000000 +0100
+++ mod/progs/heretic/cgame/TitleScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TitleScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/CMakeLists.txt mod/progs/heretic/CMakeLists.txt
--- orig/progs/heretic/CMakeLists.txt	2008-09-10 18:31:11.000000000 +0200
+++ mod/progs/heretic/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -4,12 +4,12 @@
 add_custom_command(OUTPUT ${OUTDIR}/game.dat
 	COMMAND mkdir ARGS -p ${OUTDIR}
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/game/classes.vc ${OUTDIR}/game.dat
-	DEPENDS vcc game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
 add_custom_target(heretic_game ALL DEPENDS ${OUTDIR}/game.dat)
 add_dependencies(heretic_game vcc linespec)
 
 add_custom_command(OUTPUT ${OUTDIR}/cgame.dat
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/cgame/classes.vc ${OUTDIR}/cgame.dat
-	DEPENDS vcc cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
 add_custom_target(heretic_cgame ALL DEPENDS ${OUTDIR}/cgame.dat)
 add_dependencies(heretic_cgame vcc heretic_game uibase)
diff -Nur orig/progs/heretic/game/BotPlayer.vc mod/progs/heretic/game/BotPlayer.vc
--- orig/progs/heretic/game/BotPlayer.vc	2009-11-15 00:45:10.000000000 +0100
+++ mod/progs/heretic/game/BotPlayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BotPlayer.vc 4111 2009-11-14 23:46:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/game/classes.vc mod/progs/heretic/game/classes.vc
--- orig/progs/heretic/game/classes.vc	2008-10-09 22:17:50.000000000 +0200
+++ mod/progs/heretic/game/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3803 2008-10-09 20:20:33Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/game/HereticLevelInfo.vc mod/progs/heretic/game/HereticLevelInfo.vc
--- orig/progs/heretic/game/HereticLevelInfo.vc	2008-05-13 23:03:01.000000000 +0200
+++ mod/progs/heretic/game/HereticLevelInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HereticLevelInfo.vc 3624 2008-05-13 21:05:28Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/game/MainGameInfo.vc mod/progs/heretic/game/MainGameInfo.vc
--- orig/progs/heretic/game/MainGameInfo.vc	2010-06-13 21:30:28.000000000 +0200
+++ mod/progs/heretic/game/MainGameInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MainGameInfo.vc 4305 2010-06-12 22:08:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/heretic/game/Player.vc mod/progs/heretic/game/Player.vc
--- orig/progs/heretic/game/Player.vc	2010-09-01 20:26:06.000000000 +0200
+++ mod/progs/heretic/game/Player.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Player.vc 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -378,7 +378,7 @@
 	}
 	else
 	{
-		if (Actor(MO).MorphPlayer(EggFX.default.PlayerClass, 0.0,
+		if (Actor(MO).MorphPlayer(EggFX.default.PlayerClass, 40.0,
 			EggFX.default.MorphStyle, none, none, Actor(MO)))
 		{
 			cprint("CHICKEN ON");
diff -Nur orig/progs/hexen/cgame/classes.vc mod/progs/hexen/cgame/classes.vc
--- orig/progs/hexen/cgame/classes.vc	2008-09-09 22:26:27.000000000 +0200
+++ mod/progs/hexen/cgame/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3763 2008-09-09 20:28:42Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/cgame/ClientGame.vc mod/progs/hexen/cgame/ClientGame.vc
--- orig/progs/hexen/cgame/ClientGame.vc	2008-10-18 19:53:14.000000000 +0200
+++ mod/progs/hexen/cgame/ClientGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClientGame.vc 3817 2008-10-18 17:56:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/cgame/IntermissionScreen.vc mod/progs/hexen/cgame/IntermissionScreen.vc
--- orig/progs/hexen/cgame/IntermissionScreen.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/hexen/cgame/IntermissionScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: IntermissionScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -80,6 +80,7 @@
 
 void Start()
 {
+	StopAllSounds();
 	IM_InitStats();
 	IM_LoadPics();
 
diff -Nur orig/progs/hexen/cgame/MenuScreenControls2.vc mod/progs/hexen/cgame/MenuScreenControls2.vc
--- orig/progs/hexen/cgame/MenuScreenControls2.vc	2006-09-27 01:32:51.000000000 +0200
+++ mod/progs/hexen/cgame/MenuScreenControls2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenControls2.vc 1741 2006-09-26 23:26:48Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -37,6 +37,7 @@
 	AddControl("Toggle always run", "ToggleAlwaysRun", "");
 	AddControl("Previous weapon", "impulse 17", "");
 	AddControl("Next weapon", "impulse 18", "");
+	AddControl("Toggle Console", "ToggleConsole", "");
 }
 
 defaultproperties
diff -Nur orig/progs/hexen/cgame/MenuScreenGameplayOptions.vc mod/progs/hexen/cgame/MenuScreenGameplayOptions.vc
--- orig/progs/hexen/cgame/MenuScreenGameplayOptions.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/hexen/cgame/MenuScreenGameplayOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenGameplayOptions.vc 4335 2010-09-17 15:40:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -111,8 +111,8 @@
 
 	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 	Enum.SetOrigin(ChoicesStartX, currentY);
-	Enum.Text = "Monsters can drop off tall edges";
-	Enum.SetInitialValue(GetCvar('compat_dropoff'));
+	Enum.Text = "Monsters can drop off";
+	Enum.SetInitialValue(GetCvar('monster_dropoff'));
 	Enum.ValueChanging = ChangeDropOff;
 	currentY += Enum.Height;
 
@@ -130,6 +130,13 @@
 	Slider.SetInitialValue(GetCvarF('transsouls'));
 	Slider.ValueChanging = ChangeTrans;
 	currentY += Slider.Height;	
+
+	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
+	Enum.SetOrigin(ChoicesStartX, currentY);
+	Enum.Text = "Alt. Monster Behaviour";
+	Enum.SetInitialValue(GetCvar('alternate_monster_attacks'));
+	Enum.ValueChanging = ChangeMonsterAttacks;
+	currentY += Enum.Height;
 }
 
 //==========================================================================
@@ -216,6 +223,18 @@
 	return true;
 }
 
+//==========================================================================
+//
+//	ChangeMonsterAttacks
+//
+//==========================================================================
+
+bool ChangeMonsterAttacks(Object Sender, int newValue)
+{
+	SetCvar('alternate_monster_attacks', newValue);
+	return true;
+}
+
 defaultproperties
 {
 	ChoicesStartX = 180;
diff -Nur orig/progs/hexen/cgame/MenuScreenHelp.vc mod/progs/hexen/cgame/MenuScreenHelp.vc
--- orig/progs/hexen/cgame/MenuScreenHelp.vc	2007-11-20 21:03:36.000000000 +0100
+++ mod/progs/hexen/cgame/MenuScreenHelp.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenHelp.vc 2844 2007-11-20 20:07:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/cgame/MenuScreenMain.vc mod/progs/hexen/cgame/MenuScreenMain.vc
--- orig/progs/hexen/cgame/MenuScreenMain.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/hexen/cgame/MenuScreenMain.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMain.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/cgame/MenuScreenMultiplayer.vc mod/progs/hexen/cgame/MenuScreenMultiplayer.vc
--- orig/progs/hexen/cgame/MenuScreenMultiplayer.vc	2007-11-21 22:05:52.000000000 +0100
+++ mod/progs/hexen/cgame/MenuScreenMultiplayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMultiplayer.vc 2867 2007-11-21 21:09:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/cgame/MenuScreenNewNetGame.vc mod/progs/hexen/cgame/MenuScreenNewNetGame.vc
--- orig/progs/hexen/cgame/MenuScreenNewNetGame.vc	2008-05-20 21:37:50.000000000 +0200
+++ mod/progs/hexen/cgame/MenuScreenNewNetGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenNewNetGame.vc 3655 2008-05-20 19:41:43Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/cgame/MenuScreenOptions.vc mod/progs/hexen/cgame/MenuScreenOptions.vc
--- orig/progs/hexen/cgame/MenuScreenOptions.vc	2007-12-04 00:37:51.000000000 +0100
+++ mod/progs/hexen/cgame/MenuScreenOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenOptions.vc 2936 2007-12-03 22:58:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -35,6 +35,7 @@
 {
 	MenuTextButton		Btn;
 	int					currentY;
+	bool				found = false;
 
 	currentY = ChoicesStartY;
 
@@ -50,6 +51,37 @@
 	Btn.Activated = ActivateControls2;
 	currentY += Btn.Height;
 
+	// Add "Special Controls" for MODs if keyconf lump is present
+	// and it has an "addkeysection" command
+	if (WadLumpPresent('keyconf'))
+	{
+		ScriptsParser kc = ScriptsParser(SpawnObject(ScriptsParser));
+
+		kc.OpenLumpName('keyconf');
+		// Lump is present, scan it until we find a 'addkeysection'
+		while (!kc.AtEnd())
+		{
+			if (kc.Check("addkeysection"))
+			{
+				kc.ExpectString();
+				kc.ExpectString();
+				found = true;
+			}
+			kc.GetString();
+		}
+		kc.Destroy();
+	}
+	if (found)
+	{
+		// Surely a MOD that contains KEYCONF bindings
+		// so we'll show the special controls option
+		Btn = MenuTextButton(NewChild(MenuSmallTextButton));
+		Btn.SetOrigin(ChoicesStartX, currentY);
+		Btn.Text = "Special Controls";
+		Btn.Activated = ActivateSpecialControls;
+		currentY += Btn.Height;
+	}
+
 	Btn = MenuTextButton(NewChild(MenuSmallTextButton));
 	Btn.SetOrigin(ChoicesStartX, currentY);
 	Btn.Text = "Mouse Options";
@@ -110,6 +142,17 @@
 }
 
 //==========================================================================
+//
+//	ActivateSpecialControls
+//
+//==========================================================================
+
+void ActivateSpecialControls(Object Sender)
+{
+	ClGame.PushMenuScreen(ClGame.SpawnMenu(MenuScreenSpecialControls));
+}
+
+//==========================================================================
 //
 //	ActivateMouseOpt
 //
diff -Nur orig/progs/hexen/cgame/MenuScreenPlayerSetup.vc mod/progs/hexen/cgame/MenuScreenPlayerSetup.vc
--- orig/progs/hexen/cgame/MenuScreenPlayerSetup.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/hexen/cgame/MenuScreenPlayerSetup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenPlayerSetup.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/cgame/StatusBarScreen.vc mod/progs/hexen/cgame/StatusBarScreen.vc
--- orig/progs/hexen/cgame/StatusBarScreen.vc	2010-12-24 17:10:49.000000000 +0100
+++ mod/progs/hexen/cgame/StatusBarScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StatusBarScreen.vc 4355 2010-12-24 01:29:15Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -380,14 +380,14 @@
 	int sb_manaVial2;
 	int readyweapon;
 
-	SB_DrawBackground();
-	DrawPic(BAR_X + 38, BAR_Y + 1, pic_statbar);
-
-	if (!cl.MO)
+	if (!cl || !cl.MO)
 	{
 		return;
 	}
 
+	SB_DrawBackground();
+	DrawPic(BAR_X + 38, BAR_Y + 1, pic_statbar);
+
 	// Frags / health
 	if (ClGame.deathmatch)
 	{
@@ -512,6 +512,10 @@
 	int num;
 	Inventory Item;
 
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
 	SB_DrawBackground();
 	DrawPic(BAR_X + 38, BAR_Y + 1, pic_keybar);
 
@@ -563,6 +567,10 @@
 {
 	int i;
 
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
 	SB_DrawBackground();
 	DrawPic(BAR_X + 38, BAR_Y + 1, pic_invbar);
 
@@ -603,6 +611,11 @@
 	int sb_mana2;
 	int readyweapon;
 
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
+
 	//  Health
 	if (cl.Health >= 25)
 	{
@@ -819,6 +832,10 @@
 
 void SB_Drawer(int sb_view)
 {
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
 	if (sb_view == SB_VIEW_FULLSCREEN)
 	{
 		SB_DrawFullscreenStats();
diff -Nur orig/progs/hexen/cgame/TitleScreen.vc mod/progs/hexen/cgame/TitleScreen.vc
--- orig/progs/hexen/cgame/TitleScreen.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/hexen/cgame/TitleScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TitleScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/CMakeLists.txt mod/progs/hexen/CMakeLists.txt
--- orig/progs/hexen/CMakeLists.txt	2008-09-10 18:31:14.000000000 +0200
+++ mod/progs/hexen/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -4,12 +4,12 @@
 add_custom_command(OUTPUT ${OUTDIR}/game.dat
 	COMMAND mkdir ARGS -p ${OUTDIR}
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/game/classes.vc ${OUTDIR}/game.dat
-	DEPENDS vcc game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
 add_custom_target(hexen_game ALL DEPENDS ${OUTDIR}/game.dat)
 add_dependencies(hexen_game vcc linespec)
 
 add_custom_command(OUTPUT ${OUTDIR}/cgame.dat
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/cgame/classes.vc ${OUTDIR}/cgame.dat
-	DEPENDS vcc cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
 add_custom_target(hexen_cgame ALL DEPENDS ${OUTDIR}/cgame.dat)
 add_dependencies(hexen_cgame vcc hexen_game uibase)
diff -Nur orig/progs/hexen/game/BotPlayer.vc mod/progs/hexen/game/BotPlayer.vc
--- orig/progs/hexen/game/BotPlayer.vc	2009-11-15 00:45:10.000000000 +0100
+++ mod/progs/hexen/game/BotPlayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: BotPlayer.vc 4111 2009-11-14 23:46:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/game/classes.vc mod/progs/hexen/game/classes.vc
--- orig/progs/hexen/game/classes.vc	2008-10-09 22:17:50.000000000 +0200
+++ mod/progs/hexen/game/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3803 2008-10-09 20:20:33Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/game/HexenDefs.vc mod/progs/hexen/game/HexenDefs.vc
--- orig/progs/hexen/game/HexenDefs.vc	2008-09-09 22:26:27.000000000 +0200
+++ mod/progs/hexen/game/HexenDefs.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HexenDefs.vc 3763 2008-09-09 20:28:42Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/game/HexenLevelInfo.vc mod/progs/hexen/game/HexenLevelInfo.vc
--- orig/progs/hexen/game/HexenLevelInfo.vc	2008-05-16 19:49:54.000000000 +0200
+++ mod/progs/hexen/game/HexenLevelInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: HexenLevelInfo.vc 3635 2008-05-16 17:53:44Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/game/MainGameInfo.vc mod/progs/hexen/game/MainGameInfo.vc
--- orig/progs/hexen/game/MainGameInfo.vc	2008-10-09 22:17:50.000000000 +0200
+++ mod/progs/hexen/game/MainGameInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MainGameInfo.vc 3803 2008-10-09 20:20:33Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/game/PlayerSpeed.vc mod/progs/hexen/game/PlayerSpeed.vc
--- orig/progs/hexen/game/PlayerSpeed.vc	2008-04-01 13:14:40.000000000 +0200
+++ mod/progs/hexen/game/PlayerSpeed.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: PlayerSpeed.vc 3421 2008-04-01 11:16:59Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/hexen/game/Player.vc mod/progs/hexen/game/Player.vc
--- orig/progs/hexen/game/Player.vc	2010-09-01 20:26:07.000000000 +0200
+++ mod/progs/hexen/game/Player.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Player.vc 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -457,7 +457,7 @@
 	}
 	else
 	{
-		Actor(MO).MorphPlayer(PorkFX.default.PlayerClass, 0.0,
+		Actor(MO).MorphPlayer(PorkFX.default.PlayerClass, 40.0,
 			PorkFX.default.MorphStyle, none, none, Actor(MO));
 	}
 	cprint("SQUEAL!!");
@@ -478,6 +478,7 @@
 	if (MorphTime)
 	{
 		// don't change class if the player is morphed
+		cprint("CAN'T CHANGE CLASS WHILE MORPHED");
 		return;
 	}
 	if (Cmd_CheckParm("fighter"))
@@ -506,14 +507,12 @@
 	}
 
 	// Remove all weapons
-	for (Item = EntityEx(MO).Inventory; Item; )
+	for (Item = EntityEx(MO).Inventory; Item; Item = Item.Inventory)
 	{
-		Inventory Next = Item.Inventory;
 		if (Weapon(Item) || FourthWeaponHolder(Item))
 		{
 			Item.Destroy();
 		}
-		Item = Next;
 	}
 	BaseClass = pclass;
 //	PostMorphWeapon(HexenDefs::WP_FIRST);
diff -Nur orig/progs/strife/cgame/classes.vc mod/progs/strife/cgame/classes.vc
--- orig/progs/strife/cgame/classes.vc	2008-09-19 19:56:47.000000000 +0200
+++ mod/progs/strife/cgame/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3789 2008-09-19 17:58:40Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/ClientGame.vc mod/progs/strife/cgame/ClientGame.vc
--- orig/progs/strife/cgame/ClientGame.vc	2010-09-01 20:26:19.000000000 +0200
+++ mod/progs/strife/cgame/ClientGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ClientGame.vc 4326 2010-07-19 21:00:24Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/ConSlideshow1.vc mod/progs/strife/cgame/ConSlideshow1.vc
--- orig/progs/strife/cgame/ConSlideshow1.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/strife/cgame/ConSlideshow1.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ConSlideshow1.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/ConSlideshow2.vc mod/progs/strife/cgame/ConSlideshow2.vc
--- orig/progs/strife/cgame/ConSlideshow2.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/strife/cgame/ConSlideshow2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: ConSlideshow2.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/IntermissionScreen.vc mod/progs/strife/cgame/IntermissionScreen.vc
--- orig/progs/strife/cgame/IntermissionScreen.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/strife/cgame/IntermissionScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: IntermissionScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -54,6 +54,7 @@
 
 void Start()
 {
+	StopAllSounds();
 	if (!ClGame.deathmatch && !ClGame.cl.Level.bNoIntermission)
 	{
 		print("Intermission stats are not yet implemented");
diff -Nur orig/progs/strife/cgame/MenuScreenControls2.vc mod/progs/strife/cgame/MenuScreenControls2.vc
--- orig/progs/strife/cgame/MenuScreenControls2.vc	2007-11-21 23:36:15.000000000 +0100
+++ mod/progs/strife/cgame/MenuScreenControls2.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenControls2.vc 2871 2007-11-21 22:40:14Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -41,6 +41,7 @@
 	AddControl("Toggle always run", "ToggleAlwaysRun", "");
 	AddControl("Previous weapon", "impulse 17", "");
 	AddControl("Next weapon", "impulse 18", "");
+	AddControl("Toggle Console", "ToggleConsole", "");
 }
 
 defaultproperties
diff -Nur orig/progs/strife/cgame/MenuScreenGameplayOptions.vc mod/progs/strife/cgame/MenuScreenGameplayOptions.vc
--- orig/progs/strife/cgame/MenuScreenGameplayOptions.vc	2010-11-30 12:36:13.000000000 +0100
+++ mod/progs/strife/cgame/MenuScreenGameplayOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenGameplayOptions.vc 4335 2010-09-17 15:40:25Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -111,8 +111,8 @@
 
 	Enum = MenuChoiceEnum(NewChild(MenuChoice_OnOff));
 	Enum.SetOrigin(ChoicesStartX, currentY);
-	Enum.Text = "Monsters can drop off tall edges";
-	Enum.SetInitialValue(GetCvar('compat_dropoff'));
+	Enum.Text = "Monsters can drop off";
+	Enum.SetInitialValue(GetCvar('monster_dropoff'));
 	Enum.ValueChanging = ChangeDropOff;
 	currentY += Enum.Height;
 
diff -Nur orig/progs/strife/cgame/MenuScreenHelp.vc mod/progs/strife/cgame/MenuScreenHelp.vc
--- orig/progs/strife/cgame/MenuScreenHelp.vc	2007-11-20 21:03:36.000000000 +0100
+++ mod/progs/strife/cgame/MenuScreenHelp.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenHelp.vc 2844 2007-11-20 20:07:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/MenuScreenMain.vc mod/progs/strife/cgame/MenuScreenMain.vc
--- orig/progs/strife/cgame/MenuScreenMain.vc	2007-11-21 22:05:52.000000000 +0100
+++ mod/progs/strife/cgame/MenuScreenMain.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMain.vc 2867 2007-11-21 21:09:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/MenuScreenMultiplayer.vc mod/progs/strife/cgame/MenuScreenMultiplayer.vc
--- orig/progs/strife/cgame/MenuScreenMultiplayer.vc	2007-11-21 22:05:52.000000000 +0100
+++ mod/progs/strife/cgame/MenuScreenMultiplayer.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenMultiplayer.vc 2867 2007-11-21 21:09:45Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/MenuScreenNewNetGame.vc mod/progs/strife/cgame/MenuScreenNewNetGame.vc
--- orig/progs/strife/cgame/MenuScreenNewNetGame.vc	2008-05-20 21:37:50.000000000 +0200
+++ mod/progs/strife/cgame/MenuScreenNewNetGame.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenNewNetGame.vc 3655 2008-05-20 19:41:43Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/MenuScreenOptions.vc mod/progs/strife/cgame/MenuScreenOptions.vc
--- orig/progs/strife/cgame/MenuScreenOptions.vc	2007-12-04 00:37:51.000000000 +0100
+++ mod/progs/strife/cgame/MenuScreenOptions.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenOptions.vc 2936 2007-12-03 22:58:22Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -35,6 +35,7 @@
 {
 	MenuTextButton		Btn;
 	int					currentY;
+	bool				found = false;
 
 	currentY = ChoicesStartY;
 
@@ -50,6 +51,37 @@
 	Btn.Activated = ActivateControls2;
 	currentY += Btn.Height;
 
+	// Add "Special Controls" for MODs if keyconf lump is present
+	// and it has an "addkeysection" command
+	if (WadLumpPresent('keyconf'))
+	{
+		ScriptsParser kc = ScriptsParser(SpawnObject(ScriptsParser));
+
+		kc.OpenLumpName('keyconf');
+		// Lump is present, scan it until we find a 'addkeysection'
+		while (!kc.AtEnd())
+		{
+			if (kc.Check("addkeysection"))
+			{
+				kc.ExpectString();
+				kc.ExpectString();
+				found = true;
+			}
+			kc.GetString();
+		}
+		kc.Destroy();
+	}
+	if (found)
+	{
+		// Surely a MOD that contains KEYCONF bindings
+		// so we'll show the special controls option
+		Btn = MenuTextButton(NewChild(MenuSmallTextButton));
+		Btn.SetOrigin(ChoicesStartX, currentY);
+		Btn.Text = "Special Controls";
+		Btn.Activated = ActivateSpecialControls;
+		currentY += Btn.Height;
+	}
+
 	Btn = MenuTextButton(NewChild(MenuSmallTextButton));
 	Btn.SetOrigin(ChoicesStartX, currentY);
 	Btn.Text = "Mouse Options";
@@ -110,6 +142,17 @@
 }
 
 //==========================================================================
+//
+//	ActivateSpecialControls
+//
+//==========================================================================
+
+void ActivateSpecialControls(Object Sender)
+{
+	ClGame.PushMenuScreen(ClGame.SpawnMenu(MenuScreenSpecialControls));
+}
+
+//==========================================================================
 //
 //	ActivateMouseOpt
 //
diff -Nur orig/progs/strife/cgame/MenuScreenPlayerSetup.vc mod/progs/strife/cgame/MenuScreenPlayerSetup.vc
--- orig/progs/strife/cgame/MenuScreenPlayerSetup.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/strife/cgame/MenuScreenPlayerSetup.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenPlayerSetup.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/MenuScreenQuit.vc mod/progs/strife/cgame/MenuScreenQuit.vc
--- orig/progs/strife/cgame/MenuScreenQuit.vc	2009-09-01 20:04:03.000000000 +0200
+++ mod/progs/strife/cgame/MenuScreenQuit.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MenuScreenQuit.vc 4046 2009-07-31 15:05:54Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/cgame/StatusBarScreen.vc mod/progs/strife/cgame/StatusBarScreen.vc
--- orig/progs/strife/cgame/StatusBarScreen.vc	2009-11-13 21:28:36.000000000 +0100
+++ mod/progs/strife/cgame/StatusBarScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StatusBarScreen.vc 4109 2009-11-13 20:30:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -211,13 +211,12 @@
 	int NumKeys;
 	Inventory Item;
 
-	// draw something in the blank spaces
-	FillRectWithFlat(0, 448, 640, 32, 'f_pave01');
-
-	if (!cl.MO)
+	if (!cl || !cl.MO)
 	{
 		return;
 	}
+	// draw something in the blank spaces
+	FillRectWithFlat(0, 448, 640, 32, 'f_pave01');
 
 	//  background
 	DrawPic(BAR_X + 0, BAR_Y + 168, pic_invback);
@@ -418,6 +417,11 @@
 	int NumKeys;
 	Inventory Item;
 
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
+
 	// health
 	SB_DrawTallNum(70, 450, cl.Health, 0.7);
 	DrawPic(20, 465, pic_medpack, 0.7);
@@ -589,6 +593,10 @@
 
 void SB_Drawer(int sb_view)
 {
+	if (!cl || !cl.MO)
+	{
+		return;
+	}
 	if (sb_view != SB_VIEW_FULLSCREEN)
 	{
 		SB_DrawMainBar();
diff -Nur orig/progs/strife/cgame/TitleScreen.vc mod/progs/strife/cgame/TitleScreen.vc
--- orig/progs/strife/cgame/TitleScreen.vc	2009-10-30 19:02:46.000000000 +0100
+++ mod/progs/strife/cgame/TitleScreen.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: TitleScreen.vc 4082 2009-10-22 11:48:22Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/CMakeLists.txt mod/progs/strife/CMakeLists.txt
--- orig/progs/strife/CMakeLists.txt	2008-09-09 21:58:04.000000000 +0200
+++ mod/progs/strife/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -4,12 +4,12 @@
 add_custom_command(OUTPUT ${OUTDIR}/game.dat
 	COMMAND mkdir ARGS -p ${OUTDIR}
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/game/classes.vc ${OUTDIR}/game.dat
-	DEPENDS vcc game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/game/*.vc ${COMMON_PROGS_DIR}/linespec.dat)
 add_custom_target(strife_game ALL DEPENDS ${OUTDIR}/game.dat)
 add_dependencies(strife_game vcc linespec)
 
 add_custom_command(OUTPUT ${OUTDIR}/cgame.dat
 	COMMAND ${VCC} ARGS -P${COMMON_PROGS_DIR} -P${OUTDIR} ${CMAKE_CURRENT_SOURCE_DIR}/cgame/classes.vc ${OUTDIR}/cgame.dat
-	DEPENDS vcc cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
+	DEPENDS vcc ${CMAKE_CURRENT_SOURCE_DIR}/cgame/*.vc ${COMMON_PROGS_DIR}/uibase.dat ${OUTDIR}/game.dat)
 add_custom_target(strife_cgame ALL DEPENDS ${OUTDIR}/cgame.dat)
 add_dependencies(strife_cgame vcc strife_game uibase)
diff -Nur orig/progs/strife/game/classes.vc mod/progs/strife/game/classes.vc
--- orig/progs/strife/game/classes.vc	2008-10-09 22:17:50.000000000 +0200
+++ mod/progs/strife/game/classes.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: classes.vc 3803 2008-10-09 20:20:33Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/strife/game/MainGameInfo.vc mod/progs/strife/game/MainGameInfo.vc
--- orig/progs/strife/game/MainGameInfo.vc	2010-06-13 21:30:29.000000000 +0200
+++ mod/progs/strife/game/MainGameInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: MainGameInfo.vc 4305 2010-06-12 22:08:53Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -246,18 +246,18 @@
 	SetLineTrans(151, LNSPEC_DoorLockedRaise, -1, 64, 0, 10, 0, SPAC_Use, true);
 	SetLineTrans(152, LNSPEC_DoorLockedRaise, -1, 64, 0, 17, 0, SPAC_Use, true);
 	SetLineTrans(153, LNSPEC_DoorLockedRaise, -1, 64, 0, 12, 0, SPAC_Use, true);
-	SetLineTrans(154, LNSPEC_ACSLockedExecute, 0, 0, 154, -1, 9, SPAC_Use, true);
+	SetLineTrans(154, LNSPEC_ACSLockedExecute, 0, 0, 154, -1, 10, SPAC_Use, true);
 	SetLineTrans(155, LNSPEC_PlatUpWaitDownStay, -1, 32, 105, 0, 0, SPAC_Use, true);
 	SetLineTrans(156, LNSPEC_DoorLockedRaise, 0, 16, 0, 17, 0, SPAC_Use, false);
 	SetLineTrans(157, LNSPEC_DoorLockedRaise, 0, 16, 0, 12, 0, SPAC_Use, false);
-	SetLineTrans(158, LNSPEC_DoorLockedRaise, 0, 16, 0, 9, 0, SPAC_Use, false);
-	SetLineTrans(159, LNSPEC_DoorLockedRaise, 0, 16, 150, 9, 0, SPAC_Use, true);
+	SetLineTrans(158, LNSPEC_DoorLockedRaise, 0, 16, 0, 10, 0, SPAC_Use, false);
+	SetLineTrans(159, LNSPEC_DoorLockedRaise, 0, 16, 150, 10, 0, SPAC_Use, true);
 
 	SetLineTrans(160, LNSPEC_DoorLockedRaise, 0, 16, 150, 12, 0, SPAC_Use, true);
 	//  161 (Teaser governor's room)
 	SetLineTrans(162, LNSPEC_DoorLockedRaise, -1, 64, 0, 17, 0, SPAC_Use, false);
 	SetLineTrans(163, LNSPEC_DoorLockedRaise, -1, 64, 0, 12, 0, SPAC_Use, false);
-	SetLineTrans(164, LNSPEC_DoorLockedRaise, -1, 64, 0, 9, 0, SPAC_Use, false);
+	SetLineTrans(164, LNSPEC_DoorLockedRaise, -1, 64, 0, 10, 0, SPAC_Use, false);
 	SetLineTrans(165, LNSPEC_DoorLockedRaise, 0, 0, 0, 102, 0, SPAC_Use, true);
 	SetLineTrans(166, LNSPEC_DoorLockedRaise, 0, 16, 150, 6, 0, SPAC_Use, true);
 	SetLineTrans(167, LNSPEC_DoorLockedRaise, -1, 64, 0, 6, 0, SPAC_Use, false);
@@ -270,8 +270,8 @@
 	SetLineTrans(173, LNSPEC_DoorLockedRaise, -1, 16, 0, 8, 0, SPAC_Use, true);
 	SetLineTrans(174, LNSPEC_ACSExecuteWithResult, 0, 174, -1, 0, 0, SPAC_Cross, false);
 	SetLineTrans(175, LNSPEC_ACSExecuteWithResult, 0, 175, -1, 0, 0, SPAC_Cross, true);
-	SetLineTrans(176, LNSPEC_DoorLockedRaise, -1, 16, 0, 10, 0, SPAC_Use, true);
-	SetLineTrans(177, LNSPEC_ACSLockedExecute, 0, 0, 177, -1, 10, SPAC_Use, true);
+	SetLineTrans(176, LNSPEC_DoorLockedRaise, -1, 16, 0, 9, 0, SPAC_Use, true);
+	SetLineTrans(177, LNSPEC_ACSLockedExecute, 0, 0, 177, -1, 9, SPAC_Use, true);
 	SetLineTrans(178, LNSPEC_StairsGeneric, -1, 16, 16, 0, 0, SPAC_Cross, false);
 	SetLineTrans(179, LNSPEC_CeilingLowerAndCrush, -1, 8, 1, 0, 0, SPAC_Cross, false);
 
@@ -286,7 +286,7 @@
 	SetLineTrans(188, LNSPEC_ACSExecuteWithResult, 0, 188, -1, 0, 0, SPAC_Cross, true);
 	SetLineTrans(189, LNSPEC_ACSLockedExecute, 0, 0, 189, -1, 13, SPAC_Use, false);
 
-	SetLineTrans(190, LNSPEC_DoorLockedRaise, 0, 16, 150, 14, 0, SPAC_Use, true);
+	SetLineTrans(190, LNSPEC_DoorLockedRaise, 0, 16, 150, 15, 0, SPAC_Use, true);
 	SetLineTrans(191, LNSPEC_DoorLockedRaise, -1, 16, 0, 14, 0, SPAC_Use, true);
 	SetLineTrans(192, LNSPEC_DoorLockedRaise, -1, 16, 0, 16, 0, SPAC_Use, false);
 	SetLineTrans(193, LNSPEC_ACSExecuteWithResult, 0, 193, -1, 0, 0, SPAC_Cross, true);
diff -Nur orig/progs/strife/game/Player.vc mod/progs/strife/game/Player.vc
--- orig/progs/strife/game/Player.vc	2010-09-01 20:26:19.000000000 +0200
+++ mod/progs/strife/game/Player.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: Player.vc 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -124,6 +124,13 @@
 	else if (impulse >= 200 && impulse <= 205)
 	{
 		LineSpecialLevelInfo(Level).ConChoiceImpulse(impulse - 200);
+		// Check if the player is ending a conversation
+		if (impulse == 200)
+		{
+			// Give the player some time to avoid shooting if
+			// ending the conversation with the mouse
+			Buttons = 0;
+		}
 	}
 }
 
diff -Nur orig/progs/strife/game/StrifeLevelInfo.vc mod/progs/strife/game/StrifeLevelInfo.vc
--- orig/progs/strife/game/StrifeLevelInfo.vc	2008-05-18 18:46:18.000000000 +0200
+++ mod/progs/strife/game/StrifeLevelInfo.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: StrifeLevelInfo.vc 3637 2008-05-18 16:49:35Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/progs/template.vc mod/progs/template.vc
--- orig/progs/template.vc	2006-06-27 21:47:20.000000000 +0200
+++ mod/progs/template.vc	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: template.vc 1583 2006-06-27 19:05:42Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/am_map.cpp mod/source/am_map.cpp
--- orig/source/am_map.cpp	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/am_map.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: am_map.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -98,6 +98,13 @@
 #define FL(x)	((float)(x) / (float)FRACUNIT)
 #define FX(x)	(fixed_t)((x) * FRACUNIT)
 
+#define DOOUTCODE(oc, mx, my) \
+	(oc) = 0; \
+	if ((my) < 0) (oc) |= TOP; \
+	else if ((my) >= f_h) (oc) |= BOTTOM; \
+	if ((mx) < 0) (oc) |= LEFT; \
+	else if ((mx) >= f_w) (oc) |= RIGHT;
+
 typedef int fixed_t;
 
 // TYPES -------------------------------------------------------------------
@@ -384,14 +391,22 @@
 	for (i = 0; i < GClLevel->NumVertexes; i++)
 	{
 		if (GClLevel->Vertexes[i].x < min_x)
+		{
 			min_x = GClLevel->Vertexes[i].x;
+		}
 		else if (GClLevel->Vertexes[i].x > max_x)
+		{
 			max_x = GClLevel->Vertexes[i].x;
+		}
 
 		if (GClLevel->Vertexes[i].y < min_y)
+		{
 			min_y = GClLevel->Vertexes[i].y;
+		}
 		else if (GClLevel->Vertexes[i].y > max_y)
+		{
 			max_y = GClLevel->Vertexes[i].y;
+		}
 	}
 
 	max_w = max_x - min_x;
@@ -425,13 +440,21 @@
 		int pheight = (int)GTextureManager.TextureHeight(mappic);
 
 		while(mapxstart > 0)
+		{
 			mapxstart -= pwidth;
+		}
 		while(mapxstart <= -pwidth)
+		{
 			mapxstart += pwidth;
+		}
 		while(mapystart > 0)
+		{
 			mapystart -= pheight;
+		}
 		while(mapystart <= -pheight)
+		{
 			mapystart += pheight;
+		}
 	}
 }
 
@@ -507,8 +530,10 @@
 {
 	int	i;
 
-	for (i = AM_NUMMARKPOINTS; i >= 0; i--)
+	for (i = AM_NUMMARKPOINTS - 1; i >= 0; i--)
+	{
 		markpoints[i].x = -1.0; // means empty
+	}
 	markpointnum = 0;
 	return marknums[0] != -1;
 }
@@ -590,7 +615,9 @@
 	AM_findMinMaxBoundaries();
 	scale_mtof = min_scale_mtof / 0.7;
 	if (scale_mtof > max_scale_mtof)
+	{
 		scale_mtof = min_scale_mtof;
+	}
 	scale_ftom = 1.0 / scale_mtof;
 	start_scale_mtof = scale_mtof;
 }
@@ -616,7 +643,9 @@
 static void AM_Start()
 {
 	if (!stopped)
+	{
 		AM_Stop();
+	}
 	stopped = false;
 	if (lastmap != GClLevel->MapName)
 	{
@@ -688,27 +717,43 @@
 		{
 			case AM_PANRIGHTKEY: // pan right
 				if (!followplayer)
+				{
 					m_paninc.x = FTOM(F_PANINC / 2.0);
+				}
 				else
+				{
 					rc = false;
+				}
 				break;
 			case AM_PANLEFTKEY: // pan left
 				if (!followplayer)
+				{
 					m_paninc.x = -FTOM(F_PANINC / 2.0);
+				}
 				else
+				{
 					rc = false;
+				}
 				break;
 			case AM_PANUPKEY: // pan up
 				if (!followplayer)
+				{
 					m_paninc.y = FTOM(F_PANINC / 2.0);
+				}
 				else
+				{
 					rc = false;
+				}
 				break;
 			case AM_PANDOWNKEY: // pan down
 				if (!followplayer)
+				{
 					m_paninc.y = -FTOM(F_PANINC / 2.0);
+				}
 				else
+				{
 					rc = false;
+				}
 				break;
 			case AM_ZOOMOUTKEY: // zoom out
 	    		mtof_zoommul = M_ZOOMOUT;
@@ -730,7 +775,9 @@
 					AM_minOutWindowScale();
 				}
 				else
+				{
 					AM_restoreScaleAndLoc();
+				}
 				break;
 			case AM_FOLLOWKEY:
 				followplayer = !followplayer;
@@ -765,7 +812,6 @@
 				rc = false;
 		}
 	}
-
 	else if (ev->type == ev_keyup)
 	{
 		rc = false;
@@ -773,19 +819,27 @@
 		{
 			case AM_PANRIGHTKEY:
 				if (!followplayer)
+				{
 					m_paninc.x = 0.0;
+				}
 				break;
 			case AM_PANLEFTKEY:
 				if (!followplayer)
+				{
 					m_paninc.x = 0.0;
+				}
 				break;
 			case AM_PANUPKEY:
 				if (!followplayer)
+				{
 					m_paninc.y = 0.0;
+				}
 				break;
 			case AM_PANDOWNKEY:
 				if (!followplayer)
+				{
 					m_paninc.y = 0.0;
+				}
 				break;
 			case AM_ZOOMOUTKEY:
 			case AM_ZOOMINKEY:
@@ -812,11 +866,17 @@
 	scale_ftom = 1.0 / scale_mtof;
 
 	if (scale_mtof < min_scale_mtof)
+	{
 		AM_minOutWindowScale();
+	}
 	else if (scale_mtof > max_scale_mtof)
+	{
 		AM_maxOutWindowScale();
+	}
 	else
+	{
 		AM_activateNewScale();
+	}
 }
 
 //==========================================================================
@@ -892,18 +952,26 @@
 void AM_Ticker()
 {
 	if (!automapactive)
+	{
 		return;
+	}
 
 	if (followplayer)
+	{
 		AM_doFollowPlayer();
+	}
 
 	// Change the zoom if necessary
 	if (ftom_zoommul != 1.0)
+	{
 		AM_changeWindowScale();
+	}
 
 	// Change x,y location
 	if (m_paninc.x || m_paninc.y)
+	{
 		AM_changeWindowLoc();
+	}
 }
 
 //==========================================================================
@@ -930,26 +998,42 @@
 		mapystart -= dmapy>>1;
 
 		while (mapxstart >= AM_W)
+		{
 			mapxstart -= AM_W;
+		}
 		while (mapxstart < 0)
+		{
 			mapxstart += AM_W;
+		}
 		while (mapystart >= mapheight)
+		{
 			mapystart -= mapheight;
+		}
 		while (mapystart < 0)
+		{
 			mapystart += mapheight;
+		}
 	}
 	else
 	{
 		mapxstart -= MTOF(m_paninc.x) >> 1;
 		mapystart += MTOF(m_paninc.y) >> 1;
 		if (mapxstart >= AM_W)
+		{
 			mapxstart -= AM_W;
+		}
 		if (mapxstart < 0)
+		{
 			mapxstart += AM_W;
+		}
 		if (mapystart >= mapheight)
+		{
 			mapystart -= mapheight;
+		}
 		if (mapystart < 0)
+		{
 			mapystart += mapheight;
+		}
 	}
 
 	//blit the automap background to the screen.
@@ -992,39 +1076,52 @@
 	int				dx;
 	int				dy;
 
-#define DOOUTCODE(oc, mx, my) \
-	(oc) = 0; \
-	if ((my) < 0) (oc) |= TOP; \
-	else if ((my) >= f_h) (oc) |= BOTTOM; \
-	if ((mx) < 0) (oc) |= LEFT; \
-	else if ((mx) >= f_w) (oc) |= RIGHT;
-
 	// do trivial rejects and outcodes
 	if (ml->a.y > m_y2)
+	{
 		outcode1 = TOP;
+	}
 	else if (ml->a.y < m_y)
+	{
 		outcode1 = BOTTOM;
+	}
 
 	if (ml->b.y > m_y2)
+	{
 		outcode2 = TOP;
+	}
 	else if (ml->b.y < m_y)
+	{
 		outcode2 = BOTTOM;
+	}
 
 	if (outcode1 & outcode2)
+	{
 		return false; // trivially outside
+	}
 
 	if (ml->a.x < m_x)
+	{
 		outcode1 |= LEFT;
+	}
 	else if (ml->a.x > m_x2)
+	{
 		outcode1 |= RIGHT;
+	}
 
 	if (ml->b.x < m_x)
+	{
 		outcode2 |= LEFT;
+	}
 	else if (ml->b.x > m_x2)
+	{
 		outcode2 |= RIGHT;
+	}
 
 	if (outcode1 & outcode2)
+	{
 		return false; // trivially outside
+	}
 
 	// transform to frame-buffer coordinates.
 	fl->a.x = CXMTOF(ml->a.x);
@@ -1036,16 +1133,22 @@
 	DOOUTCODE(outcode2, fl->b.x, fl->b.y);
 
 	if (outcode1 & outcode2)
+	{
 		return false;
+	}
 
 	while (outcode1 | outcode2)
 	{
 		// may be partially inside box
 		// find an outside point
 		if (outcode1)
+		{
 			outside = outcode1;
+		}
 		else
+		{
 			outside = outcode2;
+		}
 	
 		// clip to each side
 		if (outside & TOP)
@@ -1089,7 +1192,9 @@
 		}
 
 		if (outcode1 & outcode2)
+		{
 			return false; // trivially outside
+		}
 	}
 
 	return true;
@@ -1122,7 +1227,9 @@
 	static fline_t fl;
 
 	if (AM_clipMline(ml, &fl))
+	{
 		AM_drawFline(&fl, colour); // draws it on frame buffer using fb coords
+	}
 }
 
 //==========================================================================
@@ -1153,8 +1260,10 @@
 	// figure out start of vertical gridlines
 	start = m_x - extx;
 	if ((FX(start - GClLevel->BlockMapOrgX)) % (MAPBLOCKUNITS << FRACBITS))
+	{
 		start += FL((MAPBLOCKUNITS << FRACBITS)
 			- ((FX(start - GClLevel->BlockMapOrgX)) % (MAPBLOCKUNITS << FRACBITS)));
+	}
 	end = minx + minlen - extx;
 
 	// draw vertical gridlines
@@ -1175,8 +1284,10 @@
 	// figure out start of horizontal gridlines
 	start = m_y - exty;
 	if ((FX(start - GClLevel->BlockMapOrgY)) % (MAPBLOCKUNITS << FRACBITS))
+	{
 		start += FL((MAPBLOCKUNITS << FRACBITS)
 			- ((FX(start - GClLevel->BlockMapOrgY)) % (MAPBLOCKUNITS << FRACBITS)));
+	}
 	end = miny + minlen - exty;
 
 	// draw horizontal gridlines
@@ -1226,7 +1337,9 @@
 		if (am_cheating || (line.flags & ML_MAPPED))
 		{
 			if ((line.flags & LINE_NEVERSEE) && !am_cheating)
+			{
 				continue;
+			}
 			if (line.special == LNSPEC_DoorLockedRaise &&
 				GetLockDef(line.arg4) &&
 				GetLockDef(line.arg4)->MapColour)
@@ -1247,9 +1360,13 @@
 			else if (line.flags & ML_SECRET) // secret door
 			{
 				if (am_cheating)
+				{
 					AM_drawMline(&l, SecretWallColour);
+				}
 				else
+				{
 					AM_drawMline(&l, WallColour);
+				}
 			}
 			else if (line.backsector->floor.minz
 				!= line.frontsector->floor.minz)
@@ -1274,7 +1391,9 @@
 		else if (cl->PlayerFlags & VBasePlayer::PF_AutomapRevealed)
 		{
 			if (!(line.flags & LINE_NEVERSEE))
+			{
 				AM_drawMline(&l, PowerWallColour);
+			}
 		}
 	}
 }
@@ -1349,9 +1468,13 @@
 	}
 
 	if (am_rotate)
+	{
 		angle = 90.0;
+	}
 	else
+	{
 		angle = cl->ViewAngles.yaw;
+	}
 
 	AM_drawLineCharacter(player_arrow, NUMPLYRLINES, 0.0, angle,
 		PlayerColour, FTOM(MTOF(cl->ViewOrg.x)), FTOM(MTOF(cl->ViewOrg.y)));
@@ -1398,22 +1521,26 @@
 	{
 		if (markpoints[i].x != -1.0)
 		{
-			//		w = LittleShort(marknums[i]->width);
-			//		h = LittleShort(marknums[i]->height);
-			w = 5; // because something's wrong with the wad, i guess
-			h = 6; // because something's wrong with the wad, i guess
+			w = LittleShort(GTextureManager.TextureWidth(marknums[i]));
+			h = LittleShort(GTextureManager.TextureHeight(marknums[i]));
+			//w = 5; // because something's wrong with the wad, i guess
+			//h = 6; // because something's wrong with the wad, i guess
 			pt.x = markpoints[i].x;
 			pt.y = markpoints[i].y;
 
 			if (am_rotate)
+			{
 				AM_rotatePoint (&pt.x, &pt.y);
+			}
 
 			fx = (int)(CXMTOF(pt.x) * fScaleXI);
 			fy = (int)((CYMTOF(pt.y) - 3.0) * fScaleXI);
 /*			fx = (int)(CXMTOF(markpoints[i].x) * fScaleXI);
 			fy = (int)(CYMTOF(markpoints[i].y) * fScaleXI);*/
 			if (fx >= f_x && fx <= f_w - w && fy >= f_y && fy <= f_h - h && marknums[i] != -1)
+			{
 				R_DrawPic(fx, fy, marknums[i]);
+			}
 		}
 	}
 }
@@ -1437,7 +1564,9 @@
 	worldTimer = (int)cl->WorldTimer;
 
 	if (!worldTimer)
+	{
 		return;
+	}
 
 	days = worldTimer / 86400;
 	worldTimer -= days * 86400;
@@ -1573,9 +1702,9 @@
 	int r, g, b;
 	char *p;
 
-	r = strtol(str, &p, 16) & 0xff;
-	g = strtol(p, &p, 16) & 0xff;
-	b = strtol(p, &p, 16) & 0xff;
+	r = strtol(str, &p, 16) & 255;
+	g = strtol(p, &p, 16) & 255;
+	b = strtol(p, &p, 16) & 255;
 	return 0xff000000 | (r << 16) | (g << 8) | b;
 }
 
@@ -1587,13 +1716,13 @@
 
 static void AM_CheckVariables()
 {
-	float		a;
-	float		b;
-	float		old_mtof_zoommul;
-
 	//	Check for screen resolution change
 	if (f_w != ScreenWidth || f_h != ScreenHeight - SB_REALHEIGHT)
 	{
+		float		a;
+		float		b;
+		float		old_mtof_zoommul;
+
 		old_mtof_zoommul = mtof_zoommul;
 		mtof_zoommul = scale_mtof / start_scale_mtof;
 
@@ -1608,7 +1737,9 @@
 
 		scale_mtof = min_scale_mtof / 0.7;
 		if (scale_mtof > max_scale_mtof)
+		{
 			scale_mtof = min_scale_mtof;
+		}
 		scale_ftom = 1.0 / scale_mtof;
 		start_scale_mtof = scale_mtof;
 
@@ -1638,7 +1769,9 @@
 void AM_Drawer()
 {
 	if (!automapactive)
+	{
 		return;
+	}
 
 	AM_CheckVariables();
 	AM_clearFB();
diff -Nur orig/source/anorm_dots.h mod/source/anorm_dots.h
--- orig/source/anorm_dots.h	2006-06-27 21:47:20.000000000 +0200
+++ mod/source/anorm_dots.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: anorm_dots.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/anorms.h mod/source/anorms.h
--- orig/source/anorms.h	2006-06-27 21:47:20.000000000 +0200
+++ mod/source/anorms.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: anorms.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/automap.h mod/source/automap.h
--- orig/source/automap.h	2006-12-05 18:51:21.000000000 +0100
+++ mod/source/automap.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: automap.h 1878 2006-12-05 09:25:14Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/avir/avir_dil.h mod/source/avir/avir_dil.h
--- orig/source/avir/avir_dil.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/avir/avir_dil.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,996 @@
+//$ nobt
+//$ nocpp
+
+/**
+ * @file avir_dil.h
+ *
+ * @brief Inclusion file for de-interleaved image resizing functions.
+ *
+ * This file includes the "CImageResizerFilterStepDIL" class which implements
+ * image resizing functions in de-interleaved mode.
+ *
+ * AVIR Copyright (c) 2015-2016 Aleksey Vaneev
+ */
+
+namespace avir {
+
+/**
+ * @brief De-interleaved filtering steps implementation class.
+ *
+ * This class implements scanline filtering functions in de-interleaved mode.
+ * This means that pixels are processed in groups.
+ *
+ * @tparam fptype Floating point type to use for storing pixel elements.
+ * SIMD types cannot be used.
+ * @tparam fptypesimd The SIMD type used to store a pack of "fptype" values.
+ */
+
+template< class fptype, class fptypesimd >
+class CImageResizerFilterStepDIL :
+	public CImageResizerFilterStep< fptype, fptype >
+{
+public:
+	using CImageResizerFilterStep< fptype, fptype > :: IsUpsample;
+	using CImageResizerFilterStep< fptype, fptype > :: ResampleFactor;
+	using CImageResizerFilterStep< fptype, fptype > :: Flt;
+	using CImageResizerFilterStep< fptype, fptype > :: FltOrig;
+	using CImageResizerFilterStep< fptype, fptype > :: FltLatency;
+	using CImageResizerFilterStep< fptype, fptype > :: Vars;
+	using CImageResizerFilterStep< fptype, fptype > :: InLen;
+	using CImageResizerFilterStep< fptype, fptype > :: InPrefix;
+	using CImageResizerFilterStep< fptype, fptype > :: InSuffix;
+	using CImageResizerFilterStep< fptype, fptype > :: InElIncr;
+	using CImageResizerFilterStep< fptype, fptype > :: OutLen;
+	using CImageResizerFilterStep< fptype, fptype > :: OutPrefix;
+	using CImageResizerFilterStep< fptype, fptype > :: OutSuffix;
+	using CImageResizerFilterStep< fptype, fptype > :: OutElIncr;
+	using CImageResizerFilterStep< fptype, fptype > :: PrefixDC;
+	using CImageResizerFilterStep< fptype, fptype > :: SuffixDC;
+	using CImageResizerFilterStep< fptype, fptype > :: RPosBuf;
+	using CImageResizerFilterStep< fptype, fptype > :: FltBank;
+	using CImageResizerFilterStep< fptype, fptype > :: EdgePixelCount;
+
+	/**
+	 * Function performs "packing" (de-interleaving) of a scanline and type
+	 * conversion. If required, the sRGB gamma correction is applied.
+	 *
+	 * @param ip0 Input scanline, pixel elements interleaved.
+	 * @param op0 Output scanline, pixel elements are grouped, "l" elements
+	 * apart.
+	 * @param l The number of pixels to "unpack".
+	 */
+
+	template< class Tin >
+	void packScanline( const Tin* const ip0, fptype* const op0,
+		const int l ) const
+	{
+		const int ElCount = Vars -> ElCount;
+		int j;
+
+		if( !Vars -> UseSRGBGamma )
+		{
+			for( j = 0; j < ElCount; j++ )
+			{
+				const Tin* ip = ip0 + j;
+				fptype* const op = op0 + j * InElIncr;
+				int i;
+
+				for( i = 0; i < l; i++ )
+				{
+					op[ i ] = (fptype) *ip;
+					ip += ElCount;
+				}
+			}
+		}
+		else
+		{
+			const fptype gm = (fptype) Vars -> InGammaMult;
+
+			for( j = 0; j < ElCount; j++ )
+			{
+				const Tin* ip = ip0 + j;
+				fptype* const op = op0 + j * InElIncr;
+				int i;
+
+				for( i = 0; i < l; i++ )
+				{
+					op[ i ] = convertSRGB2Lin( (fptype) *ip * gm );
+					ip += ElCount;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Function applies Linear to sRGB gamma correction to the specified
+	 * scanline.
+	 *
+	 * @param p Scanline.
+	 * @param l The number of pixels to de-linearize.
+	 * @param Vars0 Image resizing-related variables.
+	 */
+
+	static void applySRGBGamma( fptype* const p0, const int l,
+		const CImageResizerVars& Vars0 )
+	{
+		const int ElCount = Vars0.ElCount;
+		const fptype gm = (fptype) Vars0.OutGammaMult;
+		int j;
+
+		for( j = 0; j < ElCount; j++ )
+		{
+			fptype* const p = p0 + j * l;
+			int i;
+
+			for( i = 0; i < l; i++ )
+			{
+				p[ i ] = convertLin2SRGB( p[ i ]) * gm;
+			}
+		}
+	}
+
+	/**
+	 * Function converts vertical scanline to horizontal scanline. This
+	 * function is called by the image resizer when image is resized
+	 * vertically. This means that the vertical scanline is stored in the
+	 * same format produced by the packScanline() and maintained by other
+	 * filtering functions.
+	 *
+	 * @param ip Input vertical scanline, pixel elements are grouped, SrcLen
+	 * elements apart.
+	 * @param op Output buffer (temporary buffer used during resizing), pixel
+	 * elements are grouped, "l" elements apart.
+	 * @param SrcLen The number of pixels in the input scanline, also used to
+	 * calculate input buffer increment.
+	 * @param SrcIncr Input buffer increment to the next vertical pixel.
+	 */
+
+	void convertVtoH( const fptype* ip, fptype* op, const int SrcLen,
+		const int SrcIncr ) const
+	{
+		const int ElCount = Vars -> ElCount;
+		const int SrcElIncr = SrcIncr / ElCount;
+		const int ips1 = SrcElIncr;
+		const int ips2 = SrcElIncr * 2;
+		const int ips3 = SrcElIncr * 3;
+		const int ops1 = InElIncr;
+		const int ops2 = InElIncr * 2;
+		const int ops3 = InElIncr * 3;
+		int j;
+
+		if( ElCount == 1 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				ip += SrcIncr;
+				op++;
+			}
+		}
+		else
+		if( ElCount == 4 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				op[ ops1 ] = ip[ ips1 ];
+				op[ ops2 ] = ip[ ips2 ];
+				op[ ops3 ] = ip[ ips3 ];
+				ip += SrcIncr;
+				op++;
+			}
+		}
+		else
+		if( ElCount == 3 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				op[ ops1 ] = ip[ ips1 ];
+				op[ ops2 ] = ip[ ips2 ];
+				ip += SrcIncr;
+				op++;
+			}
+		}
+		else
+		if( ElCount == 2 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				op[ ops1 ] = ip[ ips1 ];
+				ip += SrcIncr;
+				op++;
+			}
+		}
+	}
+
+	/**
+	 * Function performs "unpacking" of a scanline and type conversion
+	 * (truncation is used when floating point is converted to integer).
+	 * The unpacking function assumes that scanline is stored in the style
+	 * produced by the packScanline() function.
+	 *
+	 * @param ip0 Input scanline, pixel elements are grouped, "l" elements
+	 * apart.
+	 * @param op0 Output scanline, pixel elements are interleaved.
+	 * @param l The number of pixels to "unpack".
+	 * @param Vars0 Image resizing-related variables. ElCount is assumed to be
+	 * equal to ElCountIO.
+	 */
+
+	template< class Tout >
+	static void unpackScanline( const fptype* const ip0, Tout* const op0,
+		const int l, const CImageResizerVars& Vars0 )
+	{
+		const int ElCount = Vars0.ElCount;
+		int j;
+
+		for( j = 0; j < ElCount; j++ )
+		{
+			const fptype* const ip = ip0 + j * l;
+			Tout* op = op0 + j;
+			int i;
+
+			for( i = 0; i < l; i++ )
+			{
+				*op = (Tout) ip[ i ];
+				op += ElCount;
+			}
+		}
+	}
+
+	/**
+	 * Function prepares input scanline buffer for *this filtering step.
+	 * Left- and right-most pixels are replicated to make sure no buffer
+	 * overrun happens. Such approach also allows to bypass any pointer
+	 * range checks.
+	 *
+	 * @param Src Source buffer.
+	 */
+
+	void prepareInBuf( fptype* Src ) const
+	{
+		if( IsUpsample || InPrefix + InSuffix == 0 )
+		{
+			return;
+		}
+
+		int j;
+
+		for( j = 0; j < Vars -> ElCount; j++ )
+		{
+			replicateArray( Src, 1, Src - InPrefix, InPrefix, 1 );
+			fptype* const Src2 = Src + InLen - 1;
+			replicateArray( Src2, 1, Src2 + 1, InSuffix, 1 );
+			Src += InElIncr;
+		}
+	}
+
+	/**
+	 * Function peforms scanline upsampling with filtering.
+	 *
+	 * @param Src Source scanline buffer (length = this -> InLen). Source
+	 * scanline increment will be equal to ElCount.
+	 * @param Dst Destination scanline buffer.
+	 */
+
+	void doUpsample( const fptype* Src, fptype* Dst ) const
+	{
+		const int elalign = Vars -> elalign;
+		const int opstep = ResampleFactor;
+		const fptype* const f = Flt;
+		const int flen = Flt.getCapacity();
+		int l;
+		int i;
+		int j;
+
+		for( j = 0; j < Vars -> ElCount; j++ )
+		{
+			const fptype* ip = Src;
+			fptype* op0 = &Dst[ -OutPrefix ];
+			memset( op0, 0, ( OutPrefix + OutLen + OutSuffix ) *
+				sizeof( fptype ));
+
+			if( FltOrig.getCapacity() > 0 )
+			{
+				// Do not perform filtering, only upsample.
+
+				op0 += OutPrefix % ResampleFactor;
+				l = OutPrefix / ResampleFactor;
+
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0 += opstep;
+					l--;
+				}
+
+				l = InLen - 1;
+
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0 += opstep;
+					ip++;
+					l--;
+				}
+
+				l = OutSuffix / ResampleFactor;
+
+				while( l >= 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0 += opstep;
+					l--;
+				}
+
+				Src += InElIncr;
+				Dst += OutElIncr;
+				continue;
+			}
+
+			l = InPrefix;
+			fptypesimd ipv = (fptypesimd) ip[ 0 ];
+
+			while( l > 0 )
+			{
+				for( i = 0; i < flen; i += elalign )
+				{
+					fptypesimd :: addu( op0 + i,
+						fptypesimd :: load( f + i ) * ipv );
+				}
+
+				op0 += opstep;
+				l--;
+			}
+
+			l = InLen - 1;
+
+			while( l > 0 )
+			{
+				ipv = (fptypesimd) ip[ 0 ];
+
+				for( i = 0; i < flen; i += elalign )
+				{
+					fptypesimd :: addu( op0 + i,
+						fptypesimd :: load( f + i ) * ipv );
+				}
+
+				ip++;
+				op0 += opstep;
+				l--;
+			}
+
+			l = InSuffix;
+			ipv = (fptypesimd) ip[ 0 ];
+
+			while( l >= 0 )
+			{
+				for( i = 0; i < flen; i += elalign )
+				{
+					fptypesimd :: addu( op0 + i,
+						fptypesimd :: load( f + i ) * ipv );
+				}
+
+				op0 += opstep;
+				l--;
+			}
+
+			const fptype* dc = SuffixDC;
+			l = SuffixDC.getCapacity();
+
+			for( i = 0; i < l; i += elalign )
+			{
+				fptypesimd :: addu( op0 + i,
+					fptypesimd :: load( dc + i ) * ipv );
+			}
+
+			ipv = (fptypesimd) Src[ 0 ];
+			op0 = Dst - InPrefix * opstep;
+			dc = PrefixDC;
+			l = PrefixDC.getCapacity();
+
+			for( i = 0; i < l; i += elalign )
+			{
+				fptypesimd :: addu( op0 + i,
+					fptypesimd :: load( dc + i ) * ipv );
+			}
+
+			Src += InElIncr;
+			Dst += OutElIncr;
+		}
+	}
+
+	/**
+	 * Function peforms scanline filtering with optional downsampling.
+	 * Function makes use of the symmetry of the filter.
+	 *
+	 * @param Src Source scanline buffer (length = this -> InLen). Source
+	 * scanline increment will be equal to 1.
+	 * @param Dst Destination scanline buffer.
+	 * @param DstIncr Destination scanline buffer increment, used for
+	 * horizontal or vertical scanline stepping.
+	 */
+
+	void doFilter( const fptype* const Src, fptype* Dst,
+		const int DstIncr ) const
+	{
+		const int ElCount = Vars -> ElCount;
+		const int elalign = Vars -> elalign;
+		const fptype* const f = &Flt[ 0 ];
+		const int flen = Flt.getCapacity();
+		const int ipstep = ResampleFactor;
+		int i;
+		int j;
+
+		if( ElCount == 1 )
+		{
+			const fptype* ip = Src - EdgePixelCount * ipstep - FltLatency;
+			fptype* op = Dst;
+			int l = OutLen;
+
+			while( l > 0 )
+			{
+				fptypesimd s = fptypesimd :: load( f ) *
+					fptypesimd :: loadu( ip );
+
+				for( i = elalign; i < flen; i += elalign )
+				{
+					s += fptypesimd :: load( f + i ) *
+						fptypesimd :: loadu( ip + i );
+				}
+
+				op[ 0 ] = s.hadd();
+				op += DstIncr;
+				ip += ipstep;
+				l--;
+			}
+		}
+		else
+		if( DstIncr == 1 )
+		{
+			for( j = 0; j < ElCount; j++ )
+			{
+				const fptype* ip = Src - EdgePixelCount * ipstep -
+					FltLatency + j * InElIncr;
+
+				fptype* op = Dst + j * OutElIncr;
+				int l = OutLen;
+
+				while( l > 0 )
+				{
+					fptypesimd s = fptypesimd :: load( f ) *
+						fptypesimd :: loadu( ip );
+
+					for( i = elalign; i < flen; i += elalign )
+					{
+						s += fptypesimd :: load( f + i ) *
+							fptypesimd :: loadu( ip + i );
+					}
+
+					op[ 0 ] = s.hadd();
+					op += DstIncr;
+					ip += ipstep;
+					l--;
+				}
+			}
+		}
+		else
+		{
+			const fptype* ip0 = Src - EdgePixelCount * ipstep - FltLatency;
+			fptype* op0 = Dst;
+			int l = OutLen;
+
+			while( l > 0 )
+			{
+				const fptype* ip = ip0;
+				fptype* op = op0;
+
+				for( j = 0; j < ElCount; j++ )
+				{
+					fptypesimd s = fptypesimd :: load( f ) *
+						fptypesimd :: loadu( ip );
+
+					for( i = elalign; i < flen; i += elalign )
+					{
+						s += fptypesimd :: load( f + i ) *
+							fptypesimd :: loadu( ip + i );
+					}
+
+					op[ 0 ] = s.hadd();
+					ip += InElIncr;
+					op += OutElIncr;
+				}
+
+				ip0 += ipstep;
+				op0 += DstIncr;
+				l--;
+			}
+		}
+	}
+
+	/**
+	 * Function performs resizing of a single scanline. This function does
+	 * not "know" about the length of the source scanline buffer. This buffer
+	 * should be padded with enough pixels so that ( SrcPos - FilterLenD2 ) is
+	 * always >= 0 and ( SrcPos + ( DstLineLen - 1 ) * k + FilterLenD2 + 1 )
+	 * does not exceed source scanline's buffer length. SrcLine's increment is
+	 * assumed to be equal to 1.
+	 *
+	 * @param SrcLine Source scanline buffer.
+	 * @param DstLine Destination (resized) scanline buffer.
+	 * @param DstLineIncr Destination scanline position increment, used for
+	 * horizontal or vertical scanline stepping.
+	 * @param xx Temporary buffer, of size FltBank -> getFilterLen(), must be
+	 * aligned by fpclass :: fpalign.
+	 */
+
+	void doResize( const fptype* SrcLine, fptype* DstLine,
+		int DstLineIncr, fptype* const xx ) const
+	{
+		const int IntFltLen = FltBank -> getFilterLen();
+		const int ElCount = Vars -> ElCount;
+		const int elalign = Vars -> elalign;
+		const typename CImageResizerFilterStep< fptype, fptype > ::
+			CResizePos* rpos = &(*RPosBuf)[ 0 ];
+
+		int DstLineLen = OutLen;
+		int i;
+		int j;
+
+#define AVIR_RESIZE_PART1 \
+			while( DstLineLen > 0 ) \
+			{ \
+				const fptypesimd x = (fptypesimd) rpos -> x; \
+				const fptype* ftp = rpos -> ftp; \
+				const fptype* ftp2 = rpos -> ftp + IntFltLen; \
+				const fptype* Src = SrcLine + rpos -> SrcOffs;
+
+#define AVIR_RESIZE_PART1nx \
+			while( DstLineLen > 0 ) \
+			{ \
+				const fptype* ftp = rpos -> ftp; \
+				const fptype* Src = SrcLine + rpos -> SrcOffs;
+
+#define AVIR_RESIZE_PART2 \
+				DstLine += DstLineIncr; \
+				rpos++; \
+				DstLineLen--; \
+			}
+
+		if( ElCount == 1 )
+		{
+			if( FltBank -> getOrder() == 1 )
+			{
+				AVIR_RESIZE_PART1
+
+				fptypesimd sum = ( fptypesimd :: load( ftp ) +
+					fptypesimd :: load( ftp2 ) * x ) *
+					fptypesimd :: loadu( Src );
+
+				for( i = elalign; i < IntFltLen; i += elalign )
+				{
+					sum += ( fptypesimd :: load( ftp + i ) +
+						fptypesimd :: load( ftp2 + i ) * x ) *
+						fptypesimd :: loadu( Src + i );
+				}
+
+				DstLine[ 0 ] = sum.hadd();
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			{
+				AVIR_RESIZE_PART1nx
+
+				fptypesimd sum = fptypesimd :: load( ftp ) *
+					fptypesimd :: loadu( Src );
+
+				for( i = elalign; i < IntFltLen; i += elalign )
+				{
+					sum += fptypesimd :: load( ftp + i ) *
+						fptypesimd :: loadu( Src + i );
+				}
+
+				DstLine[ 0 ] = sum.hadd();
+
+				AVIR_RESIZE_PART2
+			}
+		}
+		else
+		if( DstLineIncr == 1 )
+		{
+			// Horizontal-oriented processing, element loop is outer.
+
+			const int SrcIncr = InElIncr;
+			const int DstLineElIncr = OutElIncr - DstLineIncr * DstLineLen;
+
+			if( FltBank -> getOrder() == 1 )
+			{
+				for( j = 0; j < ElCount; j++ )
+				{
+					AVIR_RESIZE_PART1
+
+					for( i = 0; i < IntFltLen; i += elalign )
+					{
+						( fptypesimd :: load( ftp + i ) +
+							fptypesimd :: load( ftp2 + i ) * x ).store(
+							xx + i );
+					}
+
+					fptypesimd sum = fptypesimd :: load( xx ) *
+						fptypesimd :: loadu( Src );
+
+					for( i = elalign; i < IntFltLen; i += elalign )
+					{
+						sum += fptypesimd :: load( xx + i ) *
+							fptypesimd :: loadu( Src + i );
+					}
+
+					DstLine[ 0 ] = sum.hadd();
+
+					AVIR_RESIZE_PART2
+
+					DstLine += DstLineElIncr;
+					SrcLine += SrcIncr;
+					DstLineLen = OutLen;
+					rpos = &(*RPosBuf)[ 0 ];
+				}
+			}
+			else
+			{
+				for( j = 0; j < ElCount; j++ )
+				{
+					AVIR_RESIZE_PART1nx
+
+					fptypesimd sum = fptypesimd :: load( ftp ) *
+						fptypesimd :: loadu( Src );
+
+					for( i = elalign; i < IntFltLen; i += elalign )
+					{
+						sum += fptypesimd :: load( ftp + i ) *
+							fptypesimd :: loadu( Src + i );
+					}
+
+					DstLine[ 0 ] = sum.hadd();
+
+					AVIR_RESIZE_PART2
+
+					DstLine += DstLineElIncr;
+					SrcLine += SrcIncr;
+					DstLineLen = OutLen;
+					rpos = &(*RPosBuf)[ 0 ];
+				}
+			}
+		}
+		else
+		{
+			const int SrcIncr = InElIncr;
+			const int DstLineElIncr = OutElIncr;
+			DstLineIncr -= DstLineElIncr * ElCount;
+
+			if( FltBank -> getOrder() == 1 )
+			{
+				AVIR_RESIZE_PART1
+
+				for( i = 0; i < IntFltLen; i += elalign )
+				{
+					( fptypesimd :: load( ftp + i ) +
+						fptypesimd :: load( ftp2 + i ) * x ).store( xx + i );
+				}
+
+				for( j = 0; j < ElCount; j++ )
+				{
+					fptypesimd sum = fptypesimd :: load( xx ) *
+						fptypesimd :: loadu( Src );
+
+					for( i = elalign; i < IntFltLen; i += elalign )
+					{
+						sum += fptypesimd :: load( xx + i ) *
+							fptypesimd :: loadu( Src + i );
+					}
+
+					DstLine[ 0 ] = sum.hadd();
+					DstLine += DstLineElIncr;
+					Src += SrcIncr;
+				}
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			{
+				AVIR_RESIZE_PART1nx
+
+				for( j = 0; j < ElCount; j++ )
+				{
+					fptypesimd sum = fptypesimd :: load( ftp ) *
+						fptypesimd :: loadu( Src );
+
+					for( i = elalign; i < IntFltLen; i += elalign )
+					{
+						sum += fptypesimd :: load( ftp + i ) *
+							fptypesimd :: loadu( Src + i );
+					}
+
+					DstLine[ 0 ] = sum.hadd();
+					DstLine += DstLineElIncr;
+					Src += SrcIncr;
+				}
+
+				AVIR_RESIZE_PART2
+			}
+		}
+
+#undef AVIR_RESIZE_PART2
+#undef AVIR_RESIZE_PART1nx
+#undef AVIR_RESIZE_PART1
+	}
+};
+
+/**
+ * @brief Image resizer's default de-interleaved dithering class.
+ *
+ * This class defines an object that performs rounding, clipping and dithering
+ * operations over horizontal scanline pixels before scanline is stored in the
+ * output buffer.
+ *
+ * This ditherer implementation uses de-interlaved SIMD algorithm.
+ *
+ * @tparam fptype Floating point type to use for storing pixel data. SIMD
+ * types cannot be used.
+ * @tparam fptypesimd The SIMD type used to store a pack of "fptype" values.
+ */
+
+template< class fptype, class fptypesimd >
+class CImageResizerDithererDefDIL
+{
+public:
+	/**
+	 * Function initializes the ditherer object.
+	 *
+	 * @param aLen Scanline length in pixels to process.
+	 * @param aVars Image resizing-related variables.
+	 * @param aTrMul Bit-depth truncation multiplier. 1 - no additional
+	 * truncation.
+	 * @param aPkOut Peak output value allowed.
+	 */
+
+	void init( const int aLen, const CImageResizerVars& aVars,
+		const double aTrMul, const double aPkOut )
+	{
+		Len = aLen;
+		Vars = &aVars;
+		LenE = aLen * Vars -> ElCount;
+		TrMul0 = aTrMul;
+		PkOut0 = aPkOut;
+	}
+
+	/**
+	 * @return "True" if dithering is recursive relative to scanlines meaning
+	 * multi-threaded execution is not supported by this dithering method.
+	 */
+
+	static bool isRecursive()
+	{
+		return( false );
+	}
+
+	/**
+	 * Function performs rounding and clipping operations.
+	 *
+	 * @param ResScanline The buffer containing the final scanline.
+	 */
+
+	void dither( fptype* const ResScanline ) const
+	{
+		const int elalign = Vars -> elalign;
+		const fptypesimd c0 = 0.0;
+		const fptypesimd TrMul = (fptypesimd) TrMul0;
+		const fptypesimd PkOut = (fptypesimd) PkOut0;
+		int j;
+
+		for( j = 0; j < LenE - elalign; j += elalign )
+		{
+			const fptypesimd z0 = round(
+				fptypesimd :: loadu( ResScanline + j ) / TrMul ) * TrMul;
+
+			clamp( z0, c0, PkOut ).storeu( ResScanline + j );
+		}
+
+		const int lim = LenE - j;
+		const fptypesimd z0 = round(
+			fptypesimd :: loadu( ResScanline + j, lim ) / TrMul ) * TrMul;
+
+		clamp( z0, c0, PkOut ).storeu( ResScanline + j, lim );
+	}
+
+protected:
+	int Len; ///< Scanline's length in pixels.
+		///<
+	const CImageResizerVars* Vars; ///< Image resizing-related variables.
+		///<
+	int LenE; ///< = LenE * ElCount.
+		///<
+	double TrMul0; ///< Bit-depth truncation multiplier.
+		///<
+	double PkOut0; ///< Peak output value allowed.
+		///<
+};
+
+/**
+ * @brief Image resizer's quasi-random dithering class, de-interleaved mode.
+ *
+ * This ditherer implements a classic quasi-random dithering which looks OK
+ * and whose results are compressed by PNG well.
+ *
+ * @tparam fptype Floating point type to use for storing pixel data. SIMD
+ * types can be used.
+ */
+
+template< class fptype, class fptypesimd >
+class CImageResizerDithererQRndDIL
+{
+public:
+	/**
+	 * Function initializes the ditherer object.
+	 *
+	 * @param aLen Scanline length in pixels to process.
+	 * @param aVars Image resizing-related variables.
+	 * @param aTrMul Bit-depth truncation multiplier. 1 - no additional
+	 * truncation.
+	 * @param aPkOut Peak output value allowed.
+	 */
+
+	void init( const int aLen, const CImageResizerVars& aVars,
+		const double aTrMul, const double aPkOut )
+	{
+		Len = aLen;
+		Vars = &aVars;
+		LenE = aLen * Vars -> ElCount;
+		TrMul0 = aTrMul;
+		PkOut0 = aPkOut;
+
+		ResScanlineDith0.alloc( LenE + Vars -> ElCount, sizeof( fptype ));
+		ResScanlineDith = ResScanlineDith0 + Vars -> ElCount;
+		int i;
+
+		for( i = 0; i < LenE + Vars -> ElCount; i++ )
+		{
+			ResScanlineDith0[ i ] = 0.0;
+		}
+	}
+
+	static bool isRecursive()
+	{
+		return( true );
+	}
+
+	void dither( fptype* const ResScanline )
+	{
+		const int ea = Vars -> elalign;
+		const fptypesimd c0 = 0.0;
+		const fptypesimd TrMul = (fptypesimd) TrMul0;
+		const fptypesimd PkOut = (fptypesimd) PkOut0;
+		int j;
+
+		for( j = 0; j < LenE - ea; j += ea )
+		{
+			fptypesimd :: addu( ResScanline + j,
+				fptypesimd :: loadu( ResScanlineDith + j ));
+
+			c0.storeu( ResScanlineDith + j );
+		}
+
+		int lim = LenE - j;
+		fptypesimd :: addu( ResScanline + j,
+			fptypesimd :: loadu( ResScanlineDith + j, lim ), lim );
+
+		c0.storeu( ResScanlineDith + j, lim );
+
+		const int Len1 = Len - 1;
+		fptype* rs = ResScanline;
+		fptype* rsd = ResScanlineDith;
+		int i;
+
+		for( i = 0; i < Vars -> ElCount; i++ )
+		{
+			for( j = 0; j < Len1; j++ )
+			{
+				// Perform rounding, noise estimation and saturation.
+
+				fptype* const rsj = rs + j;
+				const fptype z0 = round( rsj[ 0 ] / TrMul ) * TrMul;
+				const fptype Noise = rsj[ 0 ] - z0;
+				rsj[ 0 ] = clamp( z0, (fptype) 0.0, PkOut );
+
+				fptype* const rsdj = rsd + j;
+				rsj[ 1 ] += Noise * (fptype) 0.4375;
+				rsdj[ 1 ] += Noise * (fptype) 0.0625;
+				rsdj[ 0 ] += Noise * (fptype) 0.3125;
+				rsdj[ -1 ] += Noise * (fptype) 0.1875;
+			}
+
+			// Process the last pixel element in scanline.
+
+			const fptype z1 = round( rs[ Len1 ] / TrMul ) * TrMul;
+			const fptype Noise2 = rs[ Len1 ] - z1;
+			rs[ Len1 ] = clamp( z1, c0, PkOut );
+
+			rsd[ Len1 ] += Noise2 * (fptype) 0.3125;
+			rsd[ Len1 - 1 ] += Noise2 * (fptype) 0.1875;
+
+			rs += Len;
+			rsd += Len;
+		}
+	}
+
+protected:
+	int Len; ///< Scanline's length in pixels.
+		///<
+	const CImageResizerVars* Vars; ///< Image resizing-related variables.
+		///<
+	int LenE; ///< = LenE * ElCount.
+		///<
+	double TrMul0; ///< Bit-depth truncation multiplier.
+		///<
+	double PkOut0; ///< Peak output value allowed.
+		///<
+	CBuffer< fptype > ResScanlineDith0; ///< Error propagation buffer for
+		///< dithering, first pixel unused.
+		///<
+	fptype* ResScanlineDith; ///< Error propagation buffer pointer which skips
+		///< the first ElCount elements.
+		///<
+};
+
+/**
+ * @brief Floating-point processing definition and abstraction class for
+ * de-interleaved processing.
+ *
+ * This class defines several constants and typedefs that point to classes
+ * that should be used by the image resizing algorithm. This implementation
+ * points to de-interleaved processing classes.
+ *
+ * @tparam afptype Floating point type to use for storing intermediate data
+ * and variables. SIMD types should not be used.
+ * @tparam afptypesimd SIMD type used to perform processing.
+ * @tparam adith Ditherer class to use during processing.
+ */
+
+template< class afptype, class afptypesimd,
+	class adith = CImageResizerDithererDefDIL< afptype, afptypesimd > >
+class fpclass_def_dil
+{
+public:
+	typedef afptype fptype; ///< Floating-point type to use during processing.
+		///<
+	typedef afptype fptypeatom; ///< Atomic type "fptype" consists of.
+		///<
+	static const int fppack = 1; ///< The number of atomic types stored in a
+		///< single "fptype" element.
+		///<
+	static const int fpalign = sizeof( afptypesimd ); ///< Suggested alignment
+		///< size in bytes. This is not a required alignment, because image
+		///< resizing algorithm cannot be made to have a strictly aligned data
+		///< access in all cases (e.g. de-interlaved interpolation cannot
+		///< perform aligned accesses).
+		///<
+	static const int elalign = sizeof( afptypesimd ) / sizeof( afptype ); ///<
+		///< Length alignment of arrays of elements. This applies to filters
+		///< and intermediate buffers: this constant forces filters and
+		///< scanlines to have a length which is a multiple of this value, for
+		///< more efficient SIMD implementation. Value different to 1 also
+		///< means image pixels are de-interleaved during processing.
+		///<
+	typedef CImageResizerFilterStepDIL< fptype, afptypesimd > CFilterStep; ///<
+		///< Filtering step class to use during processing.
+		///<
+	typedef adith CDitherer; ///< Ditherer class to use during processing.
+		///<
+	typedef fpclass_reset< afptypesimd > CReset; ///< Floating-point
+		///< processing reset implementation class.
+		///<
+};
+
+} // namespace avir
diff -Nur orig/source/avir/avir_float4_sse.h mod/source/avir/avir_float4_sse.h
--- orig/source/avir/avir_float4_sse.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/avir/avir_float4_sse.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,337 @@
+//$ nobt
+//$ nocpp
+
+/**
+ * @file avir_float4_sse.h
+ *
+ * @brief Inclusion file for the "float4" type.
+ *
+ * This file includes the "float4" SSE-based type used for SIMD variable
+ * storage and processing.
+ *
+ * AVIR Copyright (c) 2015-2016 Aleksey Vaneev
+ */
+
+#ifndef AVIR_FLOAT4_SSE_INCLUDED
+#define AVIR_FLOAT4_SSE_INCLUDED
+
+#include <xmmintrin.h>
+
+namespace avir {
+
+/**
+ * @brief SIMD packed 4-float type.
+ *
+ * This class implements a packed 4-float type that can be used to perform
+ * parallel computation using SIMD instructions on SSE-enabled processors.
+ * This class can be used as the "fptype" argument of the avir::fpclass_def
+ * class.
+ */
+
+class float4
+{
+public:
+	float4()
+	{
+	}
+
+	float4( const float4& s )
+		: value( s.value )
+	{
+	}
+
+	float4( const __m128 s )
+		: value( s )
+	{
+	}
+
+	float4( const float s )
+		: value( _mm_set1_ps( s ))
+	{
+	}
+
+	float4& operator = ( const float4& s )
+	{
+		value = s.value;
+		return( *this );
+	}
+
+	float4& operator = ( const __m128 s )
+	{
+		value = s;
+		return( *this );
+	}
+
+	float4& operator = ( const float s )
+	{
+		value = _mm_set1_ps( s );
+		return( *this );
+	}
+
+	operator float () const
+	{
+		return( _mm_cvtss_f32( value ));
+	}
+
+	/**
+	 * @param p Pointer to memory from where the value should be loaded,
+	 * should be 8-byte aligned.
+	 * @return float4 value loaded from the specified memory location.
+	 */
+
+	static float4 load( const float* const p )
+	{
+		return( _mm_load_ps( p ));
+	}
+
+	/**
+	 * @param p Pointer to memory from where the value should be loaded,
+	 * may have any alignment.
+	 * @return float4 value loaded from the specified memory location.
+	 */
+
+	static float4 loadu( const float* const p )
+	{
+		return( _mm_loadu_ps( p ));
+	}
+
+	/**
+	 * @param p Pointer to memory from where the value should be loaded,
+	 * may have any alignment.
+	 * @param lim The maximum number of elements to load, >0.
+	 * @return float4 value loaded from the specified memory location, with
+	 * elements beyond "lim" set to 0.
+	 */
+
+	static float4 loadu( const float* const p, int lim )
+	{
+		if( lim > 2 )
+		{
+			if( lim > 3 )
+			{
+				return( _mm_loadu_ps( p ));
+			}
+			else
+			{
+				return( _mm_set_ps( 0.0f, p[ 2 ], p[ 1 ], p[ 0 ]));
+			}
+		}
+		else
+		{
+			if( lim == 2 )
+			{
+				return( _mm_set_ps( 0.0f, 0.0f, p[ 1 ], p[ 0 ]));
+			}
+			else
+			{
+				return( _mm_load_ss( p ));
+			}
+		}
+	}
+
+	/**
+	 * Function stores *this value to the specified memory location.
+	 *
+	 * @param[out] p Output memory location, should be aligned.
+	 */
+
+	void store( float* const p ) const
+	{
+		_mm_store_ps( p, value );
+	}
+
+	/**
+	 * Function stores *this value to the specified memory location.
+	 *
+	 * @param[out] p Output memory location, may have any alignment.
+	 */
+
+	void storeu( float* const p ) const
+	{
+		_mm_storeu_ps( p, value );
+	}
+
+	/**
+	 * Function stores "lim" lower elements of *this value to the specified
+	 * memory location.
+	 *
+	 * @param[out] p Output memory location, may have any alignment.
+	 * @param lim The number of lower elements to store, >0.
+	 */
+
+	void storeu( float* const p, int lim ) const
+	{
+		if( lim > 2 )
+		{
+			if( lim > 3 )
+			{
+				_mm_storeu_ps( p, value );
+			}
+			else
+			{
+				_mm_storel_pi( (__m64*) p, value );
+				_mm_store_ss( p + 2, _mm_movehl_ps( value, value ));
+			}
+		}
+		else
+		{
+			if( lim == 2 )
+			{
+				_mm_storel_pi( (__m64*) p, value );
+			}
+			else
+			{
+				_mm_store_ss( p, value );
+			}
+		}
+	}
+
+	float4& operator += ( const float4& s )
+	{
+		value = _mm_add_ps( value, s.value );
+		return( *this );
+	}
+
+	float4& operator -= ( const float4& s )
+	{
+		value = _mm_sub_ps( value, s.value );
+		return( *this );
+	}
+
+	float4& operator *= ( const float4& s )
+	{
+		value = _mm_mul_ps( value, s.value );
+		return( *this );
+	}
+
+	float4& operator /= ( const float4& s )
+	{
+		value = _mm_div_ps( value, s.value );
+		return( *this );
+	}
+
+	float4 operator + ( const float4& s ) const
+	{
+		return( _mm_add_ps( value, s.value ));
+	}
+
+	float4 operator - ( const float4& s ) const
+	{
+		return( _mm_sub_ps( value, s.value ));
+	}
+
+	float4 operator * ( const float4& s ) const
+	{
+		return( _mm_mul_ps( value, s.value ));
+	}
+
+	float4 operator / ( const float4& s ) const
+	{
+		return( _mm_div_ps( value, s.value ));
+	}
+
+	/**
+	 * @return Horizontal sum of elements.
+	 */
+
+	float hadd() const
+	{
+		const __m128 v = _mm_add_ps( value, _mm_movehl_ps( value, value ));
+		const __m128 res = _mm_add_ss( v, _mm_shuffle_ps( v, v, 1 ));
+		return( _mm_cvtss_f32( res ));
+	}
+
+	/**
+	 * Function performs in-place addition of a value located in memory and
+	 * the specified value.
+	 *
+	 * @param p Pointer to value where addition happens. May be unaligned.
+	 * @param v Value to add.
+	 */
+
+	static void addu( float* const p, const float4& v )
+	{
+		( loadu( p ) + v ).storeu( p );
+	}
+
+	/**
+	 * Function performs in-place addition of a value located in memory and
+	 * the specified value. Limited to the specfied number of elements.
+	 *
+	 * @param p Pointer to value where addition happens. May be unaligned.
+	 * @param v Value to add.
+	 * @param lim The element number limit, >0.
+	 */
+
+	static void addu( float* const p, const float4& v, const int lim )
+	{
+		( loadu( p, lim ) + v ).storeu( p, lim );
+	}
+
+	__m128 value; ///< Packed value of 4 floats.
+		///<
+};
+
+/**
+ * SIMD rounding function, exact result.
+ *
+ * @param v Value to round.
+ * @return Rounded SIMD value.
+ */
+
+/*inline float4 round( const float4& v )
+{
+	unsigned int prevrm = _MM_GET_ROUNDING_MODE();
+	_MM_SET_ROUNDING_MODE( _MM_ROUND_NEAREST );
+
+	const __m128 res = _mm_cvtpi32x2_ps( _mm_cvtps_pi32( v.value ),
+		_mm_cvtps_pi32( _mm_movehl_ps( v.value, v.value )));
+
+	_MM_SET_ROUNDING_MODE( prevrm );
+
+	return( res );
+}*/
+
+/**
+ * SIMD function "clamps" (clips) the specified packed values so that they are
+ * not lesser than "minv", and not greater than "maxv".
+ *
+ * @param Value Value to clamp.
+ * @param minv Minimal allowed value.
+ * @param maxv Maximal allowed value.
+ * @return The clamped value.
+ */
+
+inline float4 clamp( const float4& Value, const float4& minv,
+	const float4& maxv )
+{
+	return( _mm_min_ps( _mm_max_ps( Value.value, minv.value ), maxv.value ));
+}
+
+/*template<>
+struct fpclass_reset< float4 >
+{
+	static void reset()
+	{
+		_mm_empty();
+	}
+};
+
+template<>
+struct fpclass_reset< const float4 >
+{
+	static void reset()
+	{
+		_mm_empty();
+	}
+};*/
+
+typedef fpclass_def< avir :: float4, float > fpclass_float4; ///<
+	///< Class that can be used as the "fpclass" template parameter of the
+	///< avir::CImageResizer class to perform calculation using default
+	///< interleaved algorithm, using SIMD float4 type.
+	///<
+
+} // namespace avir
+
+#endif // AVIR_FLOAT4_SSE_INCLUDED
diff -Nur orig/source/avir/avir_float8_avx.h mod/source/avir/avir_float8_avx.h
--- orig/source/avir/avir_float8_avx.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/avir/avir_float8_avx.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,369 @@
+//$ nobt
+//$ nocpp
+
+/**
+ * @file avir_float8_avx.h
+ *
+ * @brief Inclusion file for the "float8" type.
+ *
+ * This file includes the "float8" AVX-based type used for SIMD variable
+ * storage and processing.
+ *
+ * AVIR Copyright (c) 2015-2016 Aleksey Vaneev
+ */
+
+#ifndef AVIR_FLOAT8_AVX_INCLUDED
+#define AVIR_FLOAT8_AVX_INCLUDED
+
+#include <immintrin.h>
+#include "avir_dil.h"
+
+namespace avir {
+
+/**
+ * @brief SIMD packed 8-float type.
+ *
+ * This class implements a packed 8-float type that can be used to perform
+ * parallel computation using SIMD instructions on AVX-enabled processors.
+ * This class can be used as the "fptype" argument of the avir::fpclass_def
+ * or avir::fpclass_def_dil class.
+ */
+
+class float8
+{
+public:
+	float8()
+	{
+	}
+
+	float8( const float8& s )
+		: value( s.value )
+	{
+	}
+
+	float8( const __m256 s )
+		: value( s )
+	{
+	}
+
+	float8( const float s )
+		: value( _mm256_set1_ps( s ))
+	{
+	}
+
+	float8& operator = ( const float8& s )
+	{
+		value = s.value;
+		return( *this );
+	}
+
+	float8& operator = ( const __m256 s )
+	{
+		value = s;
+		return( *this );
+	}
+
+	float8& operator = ( const float s )
+	{
+		value = _mm256_set1_ps( s );
+		return( *this );
+	}
+
+	operator float () const
+	{
+		return( _mm_cvtss_f32( _mm256_extractf128_ps( value, 0 )));
+	}
+
+	/**
+	 * @param p Pointer to memory from where the value should be loaded,
+	 * should be 16-byte aligned.
+	 * @return float8 value loaded from the specified memory location.
+	 */
+
+	static float8 load( const float* const p )
+	{
+		return( _mm256_load_ps( p ));
+	}
+
+	/**
+	 * @param p Pointer to memory from where the value should be loaded,
+	 * may have any alignment.
+	 * @return float8 value loaded from the specified memory location.
+	 */
+
+	static float8 loadu( const float* const p )
+	{
+		return( _mm256_loadu_ps( p ));
+	}
+
+	/**
+	 * @param p Pointer to memory from where the value should be loaded,
+	 * may have any alignment.
+	 * @param lim The maximum number of elements to load, >0.
+	 * @return float8 value loaded from the specified memory location, with
+	 * elements beyond "lim" set to 0.
+	 */
+
+	static float8 loadu( const float* const p, const int lim )
+	{
+		__m128 lo;
+		__m128 hi;
+
+		if( lim > 4 )
+		{
+			lo = _mm_loadu_ps( p );
+			hi = loadu4( p + 4, lim - 4 );
+		}
+		else
+		{
+			lo = loadu4( p, lim );
+			hi = _mm_setzero_ps();
+		}
+
+		return( _mm256_insertf128_ps( _mm256_castps128_ps256( lo ), hi, 1 ));
+	}
+
+	/**
+	 * Function stores *this value to the specified memory location.
+	 *
+	 * @param[out] p Output memory location, should be aligned.
+	 */
+
+	void store( float* const p ) const
+	{
+		_mm256_store_ps( p, value );
+	}
+
+	/**
+	 * Function stores *this value to the specified memory location.
+	 *
+	 * @param[out] p Output memory location, may have any alignment.
+	 */
+
+	void storeu( float* const p ) const
+	{
+		_mm256_storeu_ps( p, value );
+	}
+
+	/**
+	 * Function stores "lim" lower elements of *this value to the specified
+	 * memory location.
+	 *
+	 * @param[out] p Output memory location, may have any alignment.
+	 * @param lim The number of lower elements to store, >0.
+	 */
+
+	void storeu( float* p, int lim ) const
+	{
+		__m128 v;
+
+		if( lim > 4 )
+		{
+			_mm_storeu_ps( p, _mm256_extractf128_ps( value, 0 ));
+			v = _mm256_extractf128_ps( value, 1 );
+			p += 4;
+			lim -= 4;
+		}
+		else
+		{
+			v = _mm256_extractf128_ps( value, 0 );
+		}
+
+		if( lim > 2 )
+		{
+			if( lim > 3 )
+			{
+				_mm_storeu_ps( p, v );
+			}
+			else
+			{
+				_mm_storel_pi( (__m64*) p, v );
+				_mm_store_ss( p + 2, _mm_movehl_ps( v, v ));
+			}
+		}
+		else
+		{
+			if( lim == 2 )
+			{
+				_mm_storel_pi( (__m64*) p, v );
+			}
+			else
+			{
+				_mm_store_ss( p, v );
+			}
+		}
+	}
+
+	float8& operator += ( const float8& s )
+	{
+		value = _mm256_add_ps( value, s.value );
+		return( *this );
+	}
+
+	float8& operator -= ( const float8& s )
+	{
+		value = _mm256_sub_ps( value, s.value );
+		return( *this );
+	}
+
+	float8& operator *= ( const float8& s )
+	{
+		value = _mm256_mul_ps( value, s.value );
+		return( *this );
+	}
+
+	float8& operator /= ( const float8& s )
+	{
+		value = _mm256_div_ps( value, s.value );
+		return( *this );
+	}
+
+	float8 operator + ( const float8& s ) const
+	{
+		return( _mm256_add_ps( value, s.value ));
+	}
+
+	float8 operator - ( const float8& s ) const
+	{
+		return( _mm256_sub_ps( value, s.value ));
+	}
+
+	float8 operator * ( const float8& s ) const
+	{
+		return( _mm256_mul_ps( value, s.value ));
+	}
+
+	float8 operator / ( const float8& s ) const
+	{
+		return( _mm256_div_ps( value, s.value ));
+	}
+
+	/**
+	 * @return Horizontal sum of elements.
+	 */
+
+	float hadd() const
+	{
+		__m128 v = _mm_add_ps( _mm256_extractf128_ps( value, 0 ),
+			_mm256_extractf128_ps( value, 1 ));
+
+		v = _mm_hadd_ps( v, v );
+		v = _mm_hadd_ps( v, v );
+		return( _mm_cvtss_f32( v ));
+	}
+
+	/**
+	 * Function performs in-place addition of a value located in memory and
+	 * the specified value.
+	 *
+	 * @param p Pointer to value where addition happens. May be unaligned.
+	 * @param v Value to add.
+	 */
+
+	static void addu( float* const p, const float8& v )
+	{
+		( loadu( p ) + v ).storeu( p );
+	}
+
+	/**
+	 * Function performs in-place addition of a value located in memory and
+	 * the specified value. Limited to the specfied number of elements.
+	 *
+	 * @param p Pointer to value where addition happens. May be unaligned.
+	 * @param v Value to add.
+	 * @param lim The element number limit, >0.
+	 */
+
+	static void addu( float* const p, const float8& v, const int lim )
+	{
+		( loadu( p, lim ) + v ).storeu( p, lim );
+	}
+
+	__m256 value; ///< Packed value of 8 floats.
+		///<
+
+private:
+	static __m128 loadu4( const float* const p, const int lim )
+	{
+		if( lim > 2 )
+		{
+			if( lim > 3 )
+			{
+				return( _mm_loadu_ps( p ));
+			}
+			else
+			{
+				return( _mm_set_ps( 0.0f, p[ 2 ], p[ 1 ], p[ 0 ]));
+			}
+		}
+		else
+		{
+			if( lim == 2 )
+			{
+				return( _mm_set_ps( 0.0f, 0.0f, p[ 1 ], p[ 0 ]));
+			}
+			else
+			{
+				return( _mm_load_ss( p ));
+			}
+		}
+	}
+};
+
+/**
+ * SIMD rounding function, exact result.
+ *
+ * @param v Value to round.
+ * @return Rounded SIMD value.
+ */
+
+inline float8 round( const float8& v )
+{
+	return( _mm256_round_ps( v.value,
+		( _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC )));
+}
+
+/**
+ * SIMD function "clamps" (clips) the specified packed values so that they are
+ * not lesser than "minv", and not greater than "maxv".
+ *
+ * @param Value Value to clamp.
+ * @param minv Minimal allowed value.
+ * @param maxv Maximal allowed value.
+ * @return The clamped value.
+ */
+
+inline float8 clamp( const float8& Value, const float8& minv,
+	const float8& maxv )
+{
+	return( _mm256_min_ps( _mm256_max_ps( Value.value, minv.value ),
+		maxv.value ));
+}
+
+template<>
+struct fpclass_reset< float8 >
+{
+	static void reset()
+	{
+		_mm_empty();
+	}
+};
+
+template<>
+struct fpclass_reset< const float8 >
+{
+	static void reset()
+	{
+		_mm_empty();
+	}
+};
+
+typedef fpclass_def_dil< float, avir :: float8 > fpclass_float8_dil; ///<
+	///< Class that can be used as the "fpclass" template parameter of the
+	///< avir::CImageResizer class to perform calculation using
+	///< de-interleaved SIMD algorithm, using SIMD float8 type.
+	///<
+
+} // namespace avir
+
+#endif // AVIR_FLOAT8_AVX_INCLUDED
diff -Nur orig/source/avir/avir.h mod/source/avir/avir.h
--- orig/source/avir/avir.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/avir/avir.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,6268 @@
+//$ nobt
+//$ nocpp
+
+/**
+ * @file avir.h
+ *
+ * @brief The "main" inclusion file with all required classes and functions.
+ *
+ * This is the "main" inclusion file for the "AVIR" image resizer. This
+ * inclusion file contains implementation of the AVIR image resizing algorithm
+ * in its entirety. Also includes several classes and functions that can be
+ * useful elsewhere.
+ *
+ * AVIR Copyright (c) 2015-2016 Aleksey Vaneev
+ *
+ * @mainpage
+ *
+ * @section intro_sec Introduction
+ *
+ * Me, Aleksey Vaneev, is happy to offer you an open source image resizing /
+ * scaling library which has reached a production level of quality, and is
+ * ready to be incorporated into any project. This library features routines
+ * for both down- and upsizing of 8- and 16-bit, 1 to 4-channel images. Image
+ * resizing routines were implemented in multi-platform C++ code, and have a
+ * high level of optimality. Beside resizing, this library offers a sub-pixel
+ * shift operation.
+ *
+ * The resizing algorithm at first produces 2X upsized image (relative to the
+ * source image size, or relative to the destination image size if downsizing
+ * is performed) and then performs interpolation using a bank of sinc
+ * function-based fractional delay filters. On the last stage a correction
+ * filter is applied which fixes smoothing introduced on previous steps.
+ *
+ * The resizing algorithm was designed to provide the best visual quality. The
+ * author even believes this algorithm provides the "ultimate" level of
+ * quality which cannot be increased further: no math exists to provide a
+ * better frequency response, better anti-aliasing quality and at the same
+ * time having less ringing artifacts: these are 3 elements that define any
+ * resizing algorithm's quality; in AVIR practice these elements have 0.95
+ * correlation to each other, so they can be represented by any single
+ * element (AVIR offers several parameter sets with varying quality).
+ * Algorithm's time performance turned out to be very good as well (for the
+ * "ultimate" image quality).
+ *
+ * An important element utilized by this algorithm is the so called Peaked
+ * Cosine window function, which is applied over sinc function in all filters.
+ * Please consult the documentation for more details.
+ *
+ * AVIR is devoted to women. Your digital photos can look good at any size!
+ *
+ * @section license License
+ *
+ * AVIR License Agreement
+ *
+ * AVIR Copyright (c) 2015-2016 Aleksey Vaneev
+ *
+ * 1. AVIR image resizing software library and its parts and associated
+ * documentation files (collectively, "AVIR") is licensed, not sold. AVIR and
+ * all rights are owned by AVIR copyright holder and are protected by
+ * copyright law and international copyright treaties. You (individual person
+ * or a company) acknowledge that no title to the intellectual property in
+ * AVIR is transferred to you. You further acknowledge that title and full
+ * ownership rights to AVIR will remain the exclusive property of AVIR
+ * copyright holder and you will not acquire any rights to AVIR except as
+ * expressly set forth in this License Agreement.
+ *
+ * 2. This License Agreement is only applicable to non-commercial and
+ * low-income commercial use of AVIR. This means that you have to sign a
+ * special license agreement with AVIR copyright holder if you or your
+ * company sells and/or licenses (directly or via resellers) software products
+ * and/or non-software products with firmware where AVIR is included or may be
+ * included, and if or when the combined sales of such products reach at your
+ * end a sum of more than 40000 (forty thousand) US dollars per year (or
+ * equivalent value in your native currency). Sales also include subscriptions
+ * where a subscribed end user may get a functioning, and/or feature-extended,
+ * and/or advertisement-free product where AVIR is included or may be
+ * included. Software products also include user-operated server-based image
+ * and video editing applications where AVIR is included or may be included.
+ * Donation-based, but otherwise free from fees, software products where AVIR
+ * is included or may be included are treated herein as non-commercial.
+ *
+ * 3. The execution of AVIR image resizing function in non-commercial,
+ * commercial and any other environments (operations) of any size and for any
+ * purpose is allowed without a fee.
+ *
+ * 4. If you have a considerable development budget, and/or make a
+ * considerable profit from donations (grants), and/or make advertising profit
+ * associated with software where AVIR is included, or if AVIR image resizing
+ * function is an important function (e.g. on a photo hosting, a social web
+ * site) which is performed using proprietary software product where AVIR is
+ * included, then consider voluntarily signing a special license agreement
+ * with AVIR copyright holder.
+ *
+ * 5. If you sublicense to a non-end user third party, or transfer rights to
+ * your software where AVIR or its parts are included, to a third party, this
+ * third party should agree to this License Agreement or sign a special
+ * license agreement with AVIR copyright holder, or remove AVIR dependence
+ * from the received software.
+ *
+ * 6. Permission is hereby granted, free of charge, to any person or company
+ * (subject to the restrictions outlined above) obtaining a copy of AVIR, to
+ * deal in AVIR without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense (except as
+ * noted above), and/or sell copies of AVIR, and to permit persons to whom
+ * AVIR is furnished to do so, subject to the following conditions:
+ * The above copyright notice and this License Agreement shall be included in
+ * all copies or portions of AVIR.
+ *
+ * 7. AVIR IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH AVIR OR THE USE OR OTHER DEALINGS IN
+ * AVIR.
+ *
+ * 8. AVIR copyright holder's e-mail: aleksey.vaneev@gmail.com
+ * AVIR copyright holder's registered address:
+ * Aleksey Vaneev
+ * 6-54 Lenin Street,
+ * Syktyvkar, Komi Republic 167000
+ * Russia
+ *
+ * Please credit the author of this library in your documentation in the
+ * following way: "AVIR image resizing algorithm designed by Aleksey Vaneev"
+ *
+ * @version 1.9
+ */
+
+#ifndef AVIR_CIMAGERESIZER_INCLUDED
+#define AVIR_CIMAGERESIZER_INCLUDED
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+namespace avir {
+
+#if !defined( M_PI )
+	/**
+	 * The macro equals to "pi" constant, fits 53-bit floating point mantissa.
+	 */
+
+	#define M_PI 3.1415926535897932
+#endif // M_PI
+
+#if !defined( M_PId2 )
+	/**
+	 * The macro equals to "pi divided by 2" constant, fits 53-bit floating
+	 * point mantissa.
+	 */
+
+	#define M_PId2 1.5707963267948966
+#endif // M_PId2
+
+/**
+ * Rounding function, based on the trunc() function. Biased result. Not
+ * suitable for numbers >= 2^31.
+ *
+ * @param d Value to round.
+ * @return Rounded value. Some bias may be introduced.
+ */
+
+template< class T >
+inline T round( const T d )
+{
+	return( d < 0.0 ? -(T) (int) ( (T) 0.5 - d ) : (T) (int) ( d + (T) 0.5 ));
+}
+
+/**
+ * Template function "clamps" (clips) the specified value so that it is not
+ * lesser than "minv", and not greater than "maxv".
+ *
+ * @param Value Value to clamp.
+ * @param minv Minimal allowed value.
+ * @param maxv Maximal allowed value.
+ * @return The clamped value.
+ */
+
+template< class T >
+inline T clamp( const T& Value, const T minv, const T maxv )
+{
+	if( Value < minv )
+	{
+		return( minv );
+	}
+	else
+	if( Value > maxv )
+	{
+		return( maxv );
+	}
+	else
+	{
+		return( Value );
+	}
+}
+
+/**
+ * Power 2.4 approximation function, designed for sRGB gamma correction.
+ *
+ * @param x Argument, in the range 0.09 to 1.
+ * @return Value raised into power 2.4, approximate.
+ */
+
+template< class T >
+inline T pow24_sRGB( const T x )
+{
+	const double x2 = x * x;
+	const double x3 = x2 * x;
+	const double x4 = x2 * x2;
+
+	return( (T) ( 0.0985766365536824 + 0.839474952656502 * x2 +
+		0.363287814061725 * x3 - 0.0125559718896615 /
+		( 0.12758338921578 + 0.290283465468235 * x ) -
+		0.231757513261358 * x - 0.0395365717969074 * x4 ));
+}
+
+/**
+ * Power 1/2.4 approximation function, designed for sRGB gamma correction.
+ *
+ * @param x Argument, in the range 0.003 to 1.
+ * @return Value raised into power 1/2.4, approximate.
+ */
+
+template< class T >
+inline T pow24i_sRGB( const T x )
+{
+	const double sx = sqrt( x );
+	const double ssx = sqrt( sx );
+	const double sssx = sqrt( ssx );
+
+	return( (T) ( 0.000213364515060263 + 0.0149409239419218 * x +
+		0.433973412731747 * sx + ssx * ( 0.659628181609715 * sssx -
+		0.0380957908841466 - 0.0706476137208521 * sx )));
+}
+
+/**
+ * Function approximately linearizes the sRGB gamma value.
+ *
+ * @param s sRGB gamma value, in the range 0 to 1.
+ * @return Linearized sRGB gamma value, approximated.
+ */
+
+template< class T >
+inline T convertSRGB2Lin( const T s )
+{
+	const T a = (T) 0.055;
+
+	if( s <= (T) 0.04045 )
+	{
+		return( s / (T) 12.92 );
+	}
+
+	return( pow24_sRGB(( s + a ) / ( (T) 1 + a )));
+}
+
+/**
+ * Function approximately de-linearizes the linear gamma value.
+ *
+ * @param s Linear gamma value, in the range 0 to 1.
+ * @return sRGB gamma value, approximated.
+ */
+
+template< class T >
+inline T convertLin2SRGB( const T s )
+{
+	const T a = (T) 0.055;
+
+	if( s <= (T) 0.0031308 )
+	{
+		return( (T) 12.92 * s );
+	}
+
+	return(( (T) 1 + a ) * pow24i_sRGB( s ) - a );
+}
+
+/**
+ * Function converts (via typecast) specified array of type T1 values of
+ * length l into array of type T2 values. If T1 is the same as T2, copy
+ * operation is performed. When copying data at overlapping address spaces,
+ * "op" should be lower than "ip".
+ *
+ * @param ip Input buffer.
+ * @param[out] op Output buffer.
+ * @param l The number of elements to copy.
+ * @param ip Input buffer pointer increment.
+ * @param op Output buffer pointer increment.
+ */
+
+template< class T1, class T2 >
+inline void copyArray( const T1* ip, T2* op, int l,
+	const int ipinc = 1, const int opinc = 1 )
+{
+	while( l > 0 )
+	{
+		*op = (T2) *ip;
+		op += opinc;
+		ip += ipinc;
+		l--;
+	}
+}
+
+/**
+ * Function adds values located in array "ip" to array "op".
+ *
+ * @param ip Input buffer.
+ * @param[out] op Output buffer.
+ * @param l The number of elements to add.
+ * @param ip Input buffer pointer increment.
+ * @param op Output buffer pointer increment.
+ */
+
+template< class T1, class T2 >
+inline void addArray( const T1* ip, T2* op, int l,
+	const int ipinc = 1, const int opinc = 1 )
+{
+	while( l > 0 )
+	{
+		*op += *ip;
+		op += opinc;
+		ip += ipinc;
+		l--;
+	}
+}
+
+/**
+ * Function that replicates a set of adjacent elements several times in a row.
+ * This operation is usually used to replicate pixels at the start or end of
+ * image's scanline.
+ *
+ * @param ip Source array.
+ * @param ipl Source array length (usually 1..4, but can be any number).
+ * @param[out] op Destination buffer.
+ * @param l Number of times the source array should be replicated (the
+ * destination buffer should be able to hold ipl * l number of elements).
+ * @param opinc Destination buffer position increment after replicating the
+ * source array. This value should be equal to at least ipl.
+ */
+
+template< class T1, class T2 >
+inline void replicateArray( const T1* const ip, const int ipl, T2* op, int l,
+	const int opinc )
+{
+	if( ipl == 1 )
+	{
+		while( l > 0 )
+		{
+			op[ 0 ] = ip[ 0 ];
+			op += opinc;
+			l--;
+		}
+	}
+	else
+	if( ipl == 4 )
+	{
+		while( l > 0 )
+		{
+			op[ 0 ] = ip[ 0 ];
+			op[ 1 ] = ip[ 1 ];
+			op[ 2 ] = ip[ 2 ];
+			op[ 3 ] = ip[ 3 ];
+			op += opinc;
+			l--;
+		}
+	}
+	else
+	if( ipl == 3 )
+	{
+		while( l > 0 )
+		{
+			op[ 0 ] = ip[ 0 ];
+			op[ 1 ] = ip[ 1 ];
+			op[ 2 ] = ip[ 2 ];
+			op += opinc;
+			l--;
+		}
+	}
+	else
+	if( ipl == 2 )
+	{
+		while( l > 0 )
+		{
+			op[ 0 ] = ip[ 0 ];
+			op[ 1 ] = ip[ 1 ];
+			op += opinc;
+			l--;
+		}
+	}
+	else
+	{
+		while( l > 0 )
+		{
+			int i;
+
+			for( i = 0; i < ipl; i++ )
+			{
+				op[ i ] = ip[ i ];
+			}
+
+			op += opinc;
+			l--;
+		}
+	}
+}
+
+/**
+ * Function calculates frequency response of the specified FIR filter at the
+ * specified circular frequency. Phase can be calculated as atan2( im, re ).
+ * Function uses computationally-efficient oscillators instead of "cos" and
+ * "sin" functions.
+ *
+ * @param flt FIR filter's coefficients.
+ * @param fltlen Number of coefficients (taps) in the filter.
+ * @param th Circular frequency [0; pi].
+ * @param[out] re0 Resulting real part of the complex frequency response.
+ * @param[out] im0 Resulting imaginary part of the complex frequency response.
+ * @param fltlat Filter's latency in samples (taps).
+ */
+
+template< class T >
+inline void calcFIRFilterResponse( const T* flt, int fltlen,
+	const double th, double& re0, double& im0, const int fltlat = 0 )
+{
+	const double sincr = 2.0 * cos( th );
+	double cvalue1;
+	double svalue1;
+
+	if( fltlat == 0 )
+	{
+		cvalue1 = 1.0;
+		svalue1 = 0.0;
+	}
+	else
+	{
+		cvalue1 = cos( -fltlat * th );
+		svalue1 = sin( -fltlat * th );
+	}
+
+	double cvalue2 = cos( -( fltlat + 1 ) * th );
+	double svalue2 = sin( -( fltlat + 1 ) * th );
+
+	double re = 0.0;
+	double im = 0.0;
+
+	while( fltlen > 0 )
+	{
+		re += cvalue1 * flt[ 0 ];
+		im += svalue1 * flt[ 0 ];
+		flt++;
+		fltlen--;
+
+		double tmp = cvalue1;
+		cvalue1 = sincr * cvalue1 - cvalue2;
+		cvalue2 = tmp;
+
+		tmp = svalue1;
+		svalue1 = sincr * svalue1 - svalue2;
+		svalue2 = tmp;
+	}
+
+	re0 = re;
+	im0 = im;
+}
+
+/**
+ * Function normalizes FIR filter so that its frequency response at DC is
+ * equal to DCGain.
+ *
+ * @param[in,out] p Filter coefficients.
+ * @param l Filter length.
+ * @param DCGain Filter's gain at DC.
+ * @param pstep "p" array step.
+ */
+
+template< class T >
+inline void normalizeFIRFilter( T* const p, const int l, const double DCGain,
+	const int pstep = 1 )
+{
+	double s = 0.0;
+	T* pp = p;
+	int i = l;
+
+	while( i > 0 )
+	{
+		s += *pp;
+		pp += pstep;
+		i--;
+	}
+
+	s = DCGain / s;
+	pp = p;
+	i = l;
+
+	while( i > 0 )
+	{
+		*pp = (T) ( *pp * s );
+		pp += pstep;
+		i--;
+	}
+}
+
+/**
+ * @brief Memory buffer class for element array storage, with capacity
+ * tracking.
+ *
+ * Allows easier handling of memory blocks allocation and automatic
+ * deallocation for arrays (buffers) consisting of elements of specified
+ * class. Tracks buffer's capacity in "int" variable; unsuitable for
+ * allocation of very large memory blocks (with more than 2 billion elements).
+ *
+ * This class manages memory space only - it does not perform element class
+ * construction (initialization) operations. Buffer's required memory address
+ * alignment specification is supported.
+ *
+ * Uses standard library to allocate and deallocate memory.
+ *
+ * @tparam T Buffer element's type.
+ */
+
+template< class T >
+class CBuffer
+{
+public:
+	CBuffer()
+		: Data( NULL )
+		, DataAligned( NULL )
+		, Capacity( 0 )
+		, Alignment( 0 )
+	{
+	}
+
+	/**
+	 * Constructor creates the buffer with the specified capacity.
+	 *
+	 * @param aCapacity Buffer's capacity.
+	 * @param aAlignment Buffer's required memory address alignment. 0 - use
+	 * stdlib's default alignment.
+	 */
+
+	CBuffer( const int aCapacity, const int aAlignment = 0 )
+	{
+		allocinit( aCapacity, aAlignment );
+	}
+
+	CBuffer( const CBuffer& Source )
+	{
+		allocinit( Source.Capacity, Source.Alignment );
+		memcpy( DataAligned, Source.DataAligned, Capacity * sizeof( T ));
+	}
+
+	~CBuffer()
+	{
+		freeData();
+	}
+
+	CBuffer& operator = ( const CBuffer& Source )
+	{
+		alloc( Source.Capacity, Source.Alignment );
+		memcpy( DataAligned, Source.DataAligned, Capacity * sizeof( T ));
+		return( *this );
+	}
+
+	/**
+	 * Function allocates memory so that the specified number of elements
+	 * can be stored in *this buffer object.
+	 *
+	 * @param aCapacity Storage for this number of elements to allocate.
+	 * @param aAlignment Buffer's required memory address alignment,
+	 * power-of-2 values only. 0 - use stdlib's default alignment.
+	 */
+
+	void alloc( const int aCapacity, const int aAlignment = 0 )
+	{
+		freeData();
+		allocinit( aCapacity, aAlignment );
+	}
+
+	/**
+	 * Function deallocates any previously allocated buffer.
+	 */
+
+	void free()
+	{
+		freeData();
+		Data = NULL;
+		DataAligned = NULL;
+		Capacity = 0;
+		Alignment = 0;
+	}
+
+	/**
+	 * @return The capacity of the element buffer.
+	 */
+
+	int getCapacity() const
+	{
+		return( Capacity );
+	}
+
+	/**
+	 * Function "forces" *this buffer to have an arbitary capacity. Calling
+	 * this function invalidates all further operations except deleting *this
+	 * object. This function should not be usually used at all. Function can
+	 * be used to "model" certain buffer capacity without calling a costly
+	 * memory allocation function.
+	 *
+	 * @param NewCapacity A new "forced" capacity.
+	 */
+
+	void forceCapacity( const int NewCapacity )
+	{
+		Capacity = NewCapacity;
+	}
+
+	/**
+	 * Function reallocates *this buffer to a larger size so that it will be
+	 * able to hold the specified number of elements. Downsizing is not
+	 * performed. Alignment is not changed.
+	 *
+	 * @param NewCapacity New (increased) capacity.
+	 * @param DoDataCopy "True" if data in the buffer should be retained.
+	 */
+
+	void increaseCapacity( const int NewCapacity,
+		const bool DoDataCopy = true )
+	{
+		if( NewCapacity < Capacity )
+		{
+			return;
+		}
+
+		if( DoDataCopy )
+		{
+			const int PrevCapacity = Capacity;
+			T* const PrevData = Data;
+			T* const PrevDataAligned = DataAligned;
+
+			allocinit( NewCapacity, Alignment );
+			memcpy( DataAligned, PrevDataAligned, PrevCapacity * sizeof( T ));
+
+			:: free( PrevData );
+		}
+		else
+		{
+			:: free( Data );
+			allocinit( NewCapacity, Alignment );
+		}
+	}
+
+	/**
+	 * Function "truncates" (reduces) capacity of the buffer without
+	 * reallocating it. Alignment is not changed.
+	 *
+	 * @param NewCapacity New required capacity.
+	 */
+
+	void truncateCapacity( const int NewCapacity )
+	{
+		if( NewCapacity >= Capacity )
+		{
+			return;
+		}
+
+		Capacity = NewCapacity;
+	}
+
+	/**
+	 * Function increases capacity so that the specified number of
+	 * elements can be stored. This function increases the previous capacity
+	 * value by third the current capacity value until space for the required
+	 * number of elements is available. Alignment is not changed.
+	 *
+	 * @param ReqCapacity Required capacity.
+	 */
+
+	void updateCapacity( const int ReqCapacity )
+	{
+		if( ReqCapacity <= Capacity )
+		{
+			return;
+		}
+
+		int NewCapacity = Capacity;
+
+		while( NewCapacity < ReqCapacity )
+		{
+			NewCapacity += NewCapacity / 3 + 1;
+		}
+
+		increaseCapacity( NewCapacity );
+	}
+
+	operator T* () const
+	{
+		return( DataAligned );
+	}
+
+private:
+	T* Data; ///< Element buffer pointer.
+		///<
+	T* DataAligned; ///< Memory address-aligned element buffer pointer.
+		///<
+	int Capacity; ///< Element buffer capacity.
+		///<
+	int Alignment; ///< Memory address alignment in use. 0 - use stdlib's
+		///< default alignment.
+		///<
+
+	/**
+	 * Internal element buffer allocation function used during object
+	 * construction.
+	 *
+	 * @param aCapacity Storage for this number of elements to allocate.
+	 * @param aAlignment Buffer's required memory address alignment. 0 - use
+	 * stdlib's default alignment.
+	 */
+
+	void allocinit( const int aCapacity, const int aAlignment )
+	{
+		if( aAlignment == 0 )
+		{
+			Data = (T*) :: malloc( aCapacity * sizeof( T ));
+			DataAligned = Data;
+			Alignment = 0;
+		}
+		else
+		{
+			Data = (T*) :: malloc( aCapacity * sizeof( T ) + aAlignment );
+			DataAligned = alignptr( Data, aAlignment );
+			Alignment = aAlignment;
+		}
+
+		Capacity = aCapacity;
+	}
+
+	/**
+	 * Function frees a previously allocated Data buffer.
+	 */
+
+	void freeData()
+	{
+		:: free( Data );
+	}
+
+	/**
+	 * Function modifies the specified pointer so that it becomes memory
+	 * address-aligned.
+	 *
+	 * @param ptr Pointer to align.
+	 * @param align Alignment in bytes to apply.
+	 * @return Pointer aligned to align bytes. Works with power-of-2
+	 * alignments only. If no alignment is necessary, "align" bytes will be
+	 * added to the pointer value.
+	 */
+
+	template< class Tp >
+	inline Tp alignptr( const Tp ptr, const uintptr_t align )
+	{
+		return( (Tp) ( (uintptr_t) ptr + align -
+			( (uintptr_t) ptr & ( align - 1 ))) );
+	}
+};
+
+/**
+ * Function optimizes the length of the symmetric-odd FIR filter by removing
+ * left- and rightmost elements that are below specific threshold.
+ *
+ * Synthetic test shows that filter gets optimized in 2..3% of cases and in
+ * each such case optimization reduces filter length by 6..8%. Optimization,
+ * however, may skew the results of algorithm modeling and complexity
+ * calculation leading to a choice of a less optimal algorithm.
+ *
+ * @param[in,out] Flt Buffer that contains filter being optimized.
+ * @param[in,out] FltLatency Variable that holds the current latency of the
+ * filter. May be adjusted on function return.
+ * @param Threshold Threshold level.
+ */
+
+template< class T >
+inline void optimizeFIRFilter( CBuffer< T >& Flt, int& FltLatency,
+	T const Threshold = (T) 0.00001 )
+{
+	int i;
+
+	for( i = 0; i <= FltLatency; i++ )
+	{
+		if( fabs( Flt[ i ]) >= Threshold || i == FltLatency )
+		{
+			if( i > 0 )
+			{
+				const int NewCapacity = Flt.getCapacity() - i * 2;
+				copyArray( &Flt[ i ], &Flt[ 0 ], NewCapacity );
+				Flt.truncateCapacity( NewCapacity );
+				FltLatency -= i;
+			}
+
+			break;
+		}
+	}
+}
+
+/**
+ * @brief Array of structured objects.
+ *
+ * Implements allocation of a linear array of objects of class T (which are
+ * initialized), addressable via operator[]. Each object is created via the
+ * "operator new". New object insertions are quick since implementation uses
+ * prior space allocation (capacity), thus not requiring frequent memory block
+ * reallocations.
+ *
+ * @tparam T Array element's type.
+ */
+
+template< class T >
+class CStructArray
+{
+public:
+	CStructArray()
+		: ItemCount( 0 )
+	{
+	}
+
+	CStructArray( const CStructArray& Source )
+		: ItemCount( 0 )
+		, Items( Source.getItemCount() )
+	{
+		while( ItemCount < Source.getItemCount() )
+		{
+			Items[ ItemCount ] = new T( Source[ ItemCount ]);
+			ItemCount++;
+		}
+	}
+
+	~CStructArray()
+	{
+		clear();
+	}
+
+	CStructArray& operator = ( const CStructArray& Source )
+	{
+		clear();
+
+		const int NewCount = Source.ItemCount;
+		Items.updateCapacity( NewCount );
+
+		while( ItemCount < NewCount )
+		{
+			Items[ ItemCount ] = new T( Source[ ItemCount ]);
+			ItemCount++;
+		}
+
+		return( *this );
+	}
+
+	T& operator []( const int Index )
+	{
+		return( *Items[ Index ]);
+	}
+
+	const T& operator []( const int Index ) const
+	{
+		return( *Items[ Index ]);
+	}
+
+	/**
+	 * Function creates a new object of type T with the default constructor
+	 * and adds this object to the array.
+	 *
+	 * @return Reference to a newly added object.
+	 */
+
+	T& add()
+	{
+		if( ItemCount == Items.getCapacity() )
+		{
+			Items.increaseCapacity( ItemCount * 3 / 2 + 1 );
+		}
+
+		Items[ ItemCount ] = new T();
+		ItemCount++;
+
+		return( (*this)[ ItemCount - 1 ]);
+	}
+
+	/**
+	 * Function changes number of allocated items. New items are created with
+	 * the default constructor. If NewCount is below the current item count,
+	 * items that are above NewCount range will be destructed.
+	 *
+	 * @param NewCount New requested item count.
+	 */
+
+	void setItemCount( const int NewCount )
+	{
+		if( NewCount > ItemCount )
+		{
+			Items.increaseCapacity( NewCount );
+
+			while( ItemCount < NewCount )
+			{
+				Items[ ItemCount ] = new T();
+				ItemCount++;
+			}
+		}
+		else
+		{
+			while( ItemCount > NewCount )
+			{
+				ItemCount--;
+				delete Items[ ItemCount ];
+			}
+		}
+	}
+
+	/**
+	 * Function erases all items of *this array.
+	 */
+
+	void clear()
+	{
+		while( ItemCount > 0 )
+		{
+			ItemCount--;
+			delete Items[ ItemCount ];
+		}
+	}
+
+	/**
+	 * @return The number of allocated items.
+	 */
+
+	int getItemCount() const
+	{
+		return( ItemCount );
+	}
+
+private:
+	int ItemCount; ///< The number of items available in the array.
+		///<
+	CBuffer< T* > Items; ///< Element buffer.
+		///<
+};
+
+/**
+ * @brief Sine signal generator class.
+ *
+ * Class implements sine signal generator without biasing, with
+ * constructor-based initalization only. This generator uses oscillator
+ * instead of "sin" function.
+ */
+
+class CSineGen
+{
+public:
+	/**
+	 * Constructor initializes *this sine signal generator.
+	 *
+	 * @param si Sine function increment, in radians.
+	 * @param ph Starting phase, in radians. Add 0.5 * M_PI for cosine
+	 * function.
+	 */
+
+	CSineGen( const double si, const double ph )
+		: svalue1( sin( ph ))
+		, svalue2( sin( ph - si ))
+		, sincr( 2.0 * cos( si ))
+	{
+	}
+
+	/**
+	 * @return The next value of the sine function, without biasing.
+	 */
+
+	double generate()
+	{
+		const double res = svalue1;
+
+		svalue1 = sincr * res - svalue2;
+		svalue2 = res;
+
+		return( res );
+	}
+
+private:
+	double svalue1; ///< Current sine value.
+		///<
+	double svalue2; ///< Previous sine value.
+		///<
+	double sincr; ///< Sine value increment.
+		///<
+};
+
+/**
+ * @brief Peaked Cosine window function generator class.
+ *
+ * Class implements Peaked Cosine window function generator. Generates the
+ * right-handed half of the window function. The Alpha parameter of this
+ * window function offers the control of the balance between the early and
+ * later taps of the filter. E.g. at Alpha=1 both early and later taps are
+ * attenuated, but at Alpha=4 mostly later taps are attenuated. This offers a
+ * great control over ringing artifacts produced by a low-pass filter in image
+ * processing, without compromising achieved image sharpness.
+ */
+
+class CDSPWindowGenPeakedCosine
+{
+public:
+	/**
+	 * Constructor initializes *this window function generator.
+	 *
+	 * @param aAlpha Alpha parameter, affects the peak shape (peak
+	 * augmentation) of the window function. Should be >= 1.0.
+	 * @param aLen2 Half filter's length (non-truncated).
+	 */
+
+	CDSPWindowGenPeakedCosine( const double aAlpha, const double aLen2 )
+		: Alpha( aAlpha )
+		, Len2( aLen2 )
+		, wn( 0 )
+		, w1( M_PId2 / Len2, M_PI * 0.5 )
+	{
+	}
+
+	/**
+	 * @return The next Peaked Cosine window function coefficient.
+	 */
+
+	double generate()
+	{
+		const double h = pow( wn / Len2, Alpha );
+		wn++;
+
+		return( w1.generate() * ( 1.0 - h ));
+	}
+
+private:
+	double Alpha; ///< Alpha parameter, affects the peak shape of window.
+		///<
+	double Len2; ///< Half length of the window function.
+		///<
+	int wn; ///< Window function integer position. 0 - center of the
+		///< window function.
+		///<
+	CSineGen w1; ///< Sine-wave generator.
+		///<
+};
+
+/**
+ * @brief FIR filter-based equalizer generator.
+ *
+ * Class implements an object used to generate symmetric-odd FIR filters with
+ * the specified frequency response (aka paragraphic equalizer). The
+ * calculated filter is windowed by the Peaked Cosine window function.
+ *
+ * In image processing, due to short length of filters being used (6-8 taps)
+ * the resulting frequency response of the filter is approximate and may be
+ * mathematically imperfect, but still adequate to the visual requirements.
+ *
+ * On a side note, this equalizer generator can be successfully used for audio
+ * signal equalization as well: for example, it is used in almost the same
+ * form in Voxengo Marvel GEQ equalizer plug-in.
+ *
+ * Filter generation is based on decomposition of frequency range into
+ * spectral bands, with each band represented by linear and ramp "kernels".
+ * When the filter is built, these kernels are combined together with
+ * different weights that approximate the required frequency response.
+ */
+
+class CDSPFIREQ
+{
+public:
+	/**
+	 * Function initializes *this object with the required parameters. The
+	 * gain of frequencies beyond the MinFreq..MaxFreq range are controlled by
+	 * the first and the last band's gain.
+	 *
+	 * @param SampleRate Processing sample rate (use 2 for image processing).
+	 * @param aFilterLength Required filter length in samples (taps). The
+	 * actual filter length is truncated to an integer value.
+	 * @param aBandCount Number of band crossover points required to control,
+	 * including bands at MinFreq and MaxFreq.
+	 * @param MinFreq Minimal frequency that should be controlled.
+	 * @param MaxFreq Maximal frequency that should be controlled.
+	 * @param IsLogBands "True" if the bands should be spaced logarithmically.
+	 * @param WFAlpha Peaked Cosine window function's Alpha parameter.
+	 */
+
+	void init( const double SampleRate, const double aFilterLength,
+		const int aBandCount, const double MinFreq, const double MaxFreq,
+		const bool IsLogBands, const double WFAlpha )
+	{
+		FilterLength = aFilterLength;
+		BandCount = aBandCount;
+
+		CenterFreqs.alloc( BandCount );
+
+		z = (int) ceil( FilterLength * 0.5 );
+		zi = z + ( z & 1 );
+		z2 = z * 2;
+
+		CBuffer< double > oscbuf( z2 );
+		initOscBuf( oscbuf );
+
+		CBuffer< double > winbuf( z );
+		initWinBuf( winbuf, WFAlpha );
+
+		UseFirstVirtBand = ( MinFreq > 0.0 );
+		const int k = zi * ( BandCount + ( UseFirstVirtBand ? 1 : 0 ));
+		Kernels1.alloc( k );
+		Kernels2.alloc( k );
+
+		double m; // Frequency step multiplier.
+		double mo; // Frequency step offset (addition).
+
+		if( IsLogBands )
+		{
+			m = exp( log( MaxFreq / MinFreq ) / ( BandCount - 1 ));
+			mo = 0.0;
+		}
+		else
+		{
+			m = 1.0;
+			mo = ( MaxFreq - MinFreq ) / ( BandCount - 1 );
+		}
+
+		double f = MinFreq;
+		double x1 = 0.0;
+		double x2;
+		int si;
+
+		if( UseFirstVirtBand )
+		{
+			si = 0;
+		}
+		else
+		{
+			si = 1;
+			CenterFreqs[ 0 ] = 0.0;
+			f = f * m + mo;
+		}
+
+		double* kernbuf1 = &Kernels1[ 0 ];
+		double* kernbuf2 = &Kernels2[ 0 ];
+		int i;
+
+		for( i = si; i < BandCount; i++ )
+		{
+			x2 = f * 2.0 / SampleRate;
+			CenterFreqs[ i ] = x2;
+
+			fillBandKernel( x1, x2, kernbuf1, kernbuf2, oscbuf, winbuf );
+
+			kernbuf1 += zi;
+			kernbuf2 += zi;
+			x1 = x2;
+			f = f * m + mo;
+		}
+
+		if( x1 < 1.0 )
+		{
+			UseLastVirtBand = true;
+			fillBandKernel( x1, 1.0, kernbuf1, kernbuf2, oscbuf, winbuf );
+		}
+		else
+		{
+			UseLastVirtBand = false;
+		}
+	}
+
+	/**
+	 * @return Filter's length, in samples (taps).
+	 */
+
+	int getFilterLength() const
+	{
+		return( z2 - 1 );
+	}
+
+	/**
+	 * @return Filter's latency (group delay), in samples (taps).
+	 */
+
+	int getFilterLatency() const
+	{
+		return( z - 1 );
+	}
+
+	/**
+	 * Function creates symmetric-odd FIR filter with the specified gain
+	 * levels at band crossover points.
+	 *
+	 * @param BandGains Array of linear gain levels, count=BandCount specified
+	 * in the init() function.
+	 * @param[out] Filter Output filter buffer, length = getFilterLength().
+	 */
+
+	void buildFilter( const double* const BandGains, double* const Filter )
+	{
+		const double* kernbuf1 = &Kernels1[ 0 ];
+		const double* kernbuf2 = &Kernels2[ 0 ];
+		double x1 = 0.0;
+		double y1 = BandGains[ 0 ];
+		double x2;
+		double y2;
+
+		int i;
+		int si;
+
+		if( UseFirstVirtBand )
+		{
+			si = 1;
+			x2 = CenterFreqs[ 0 ];
+			y2 = y1;
+		}
+		else
+		{
+			si = 2;
+			x2 = CenterFreqs[ 1 ];
+			y2 = BandGains[ 1 ];
+		}
+
+		copyBandKernel( Filter, kernbuf1, kernbuf2, y1 - y2,
+			x1 * y2 - x2 * y1 );
+
+		kernbuf1 += zi;
+		kernbuf2 += zi;
+		x1 = x2;
+		y1 = y2;
+
+		for( i = si; i < BandCount; i++ )
+		{
+			x2 = CenterFreqs[ i ];
+			y2 = BandGains[ i ];
+
+			addBandKernel( Filter, kernbuf1, kernbuf2, y1 - y2,
+				x1 * y2 - x2 * y1 );
+
+			kernbuf1 += zi;
+			kernbuf2 += zi;
+			x1 = x2;
+			y1 = y2;
+		}
+
+		if( UseLastVirtBand )
+		{
+			addBandKernel( Filter, kernbuf1, kernbuf2, y1 - y2,
+				x1 * y2 - y1 );
+		}
+
+		for( i = 0; i < z - 1; i++ )
+		{
+			Filter[ z + i ] = Filter[ z - 2 - i ];
+		}
+	}
+
+	/**
+	 * Function calculates filter's length (in samples) and latency depending
+	 * on the required non-truncated filter length.
+	 *
+	 * @param aFilterLength Required filter length in samples (non-truncated).
+	 * @param[out] Latency Resulting latency (group delay) of the filter,
+	 * in samples (taps).
+	 * @return Filter length in samples (taps).
+	 */
+
+	static int calcFilterLength( const double aFilterLength, int& Latency )
+	{
+		const int l = (int) ceil( aFilterLength * 0.5 );
+		Latency = l - 1;
+
+		return( l * 2 - 1 );
+	}
+
+private:
+	double FilterLength; ///< Length of filter.
+		///<
+	int z; ///< Equals (int) ceil( FilterLength * 0.5 ).
+		///<
+	int zi; ///< Equals "z" if z is even, or z + 1 if z is odd. Used as a
+		///< Kernels1 and Kernels2 size multiplier and kernel buffer increment
+		///< to make sure each kernel buffer is 16-byte aligned.
+		///<
+	int z2; ///< Equals z * 2.
+		///<
+	int BandCount; ///< Number of controllable bands.
+		///<
+	CBuffer< double > CenterFreqs; ///< Center frequencies for all bands,
+		///< normalized to 0.0-1.0 range.
+		///<
+	CBuffer< double > Kernels1; ///< Half-length kernel buffers for each
+		///< spectral band (linear part).
+		///<
+	CBuffer< double > Kernels2; ///< Half-length kernel buffers for each
+		///< spectral band (ramp part).
+		///<
+	bool UseFirstVirtBand; ///< "True" if the first virtual band
+		///< (between 0.0 and MinFreq) should be used. The first virtual band
+		///< won't be used if MinFreq equals 0.0.
+		///<
+	bool UseLastVirtBand; ///< "True" if the last virtual band (between
+		///< MaxFreq and SampleRate * 0.5) should be used. The last virtual
+		///< band won't be used if MaxFreq * 2.0 equals SampleRate.
+		///<
+
+	/**
+	 * Function initializes the "oscbuf" used in the fillBandKernel()
+	 * function.
+	 *
+	 * @param oscbuf Oscillator buffer, length = z * 2.
+	 */
+
+	void initOscBuf( double* oscbuf ) const
+	{
+		int i = z;
+
+		while( i > 0 )
+		{
+			oscbuf[ 0 ] = 0.0;
+			oscbuf[ 1 ] = 1.0;
+			oscbuf += 2;
+			i--;
+		}
+	}
+
+	/**
+	 * Function initializes window function buffer. This function generates
+	 * Peaked Cosine window function.
+	 *
+	 * @param winbuf Windowing buffer.
+	 * @param Alpha Peaked Cosine alpha parameter.
+	 */
+
+	void initWinBuf( double* winbuf, const double Alpha ) const
+	{
+		CDSPWindowGenPeakedCosine wf( Alpha, FilterLength * 0.5 );
+		int i;
+
+		for( i = 1; i <= z; i++ )
+		{
+			winbuf[ z - i ] = wf.generate();
+		}
+	}
+
+	/**
+	 * Function fills first half of symmetric-odd FIR kernel for the band.
+	 * This function should be called successively for adjacent bands.
+	 * Previous band's x2 should be equal to current band's x1. A band kernel
+	 * consists of 2 elements: linear kernel and ramp kernel.
+	 *
+	 * @param x1 Band's left corner frequency (0..1).
+	 * @param x2 Band's right corner frequency (0..1).
+	 * @param kernbuf1 Band kernel buffer 1 (linear part), length = z.
+	 * @param kernbuf2 Band kernel buffer 2 (ramp part), length = z.
+	 * @param oscbuf Oscillation buffer. Before the first call of the
+	 * fillBandKernel() should be initialized with the call of the
+	 * initOscBuf() function.
+	 * @param winbuf Buffer that contains windowing function.
+	 */
+
+	void fillBandKernel( const double x1, const double x2, double* kernbuf1,
+		double* kernbuf2, double* oscbuf, const double* const winbuf )
+	{
+		const double s2_incr = M_PI * x2;
+		const double s2_coeff = 2.0 * cos( s2_incr );
+
+		double s2_value1 = sin( s2_incr * ( -z + 1 ));
+		double c2_value1 = sin( s2_incr * ( -z + 1 ) + M_PI * 0.5 );
+		oscbuf[ 0 ] = sin( s2_incr * -z );
+		oscbuf[ 1 ] = sin( s2_incr * -z + M_PI * 0.5 );
+
+		int ks;
+
+		for( ks = 1; ks < z; ks++ )
+		{
+			const int ks2 = ks * 2;
+			const double s1_value1 = oscbuf[ ks2 ];
+			const double c1_value1 = oscbuf[ ks2 + 1 ];
+			oscbuf[ ks2 ] = s2_value1;
+			oscbuf[ ks2 + 1 ] = c2_value1;
+
+			const double x = M_PI * ( ks - z );
+			const double v0 = winbuf[ ks - 1 ] / (( x1 - x2 ) * x );
+
+			kernbuf1[ ks - 1 ] = ( x2 * s2_value1 - x1 * s1_value1 +
+				( c2_value1 - c1_value1 ) / x ) * v0;
+
+			kernbuf2[ ks - 1 ] = ( s2_value1 - s1_value1 ) * v0;
+
+			s2_value1 = s2_coeff * s2_value1 - oscbuf[ ks2 - 2 ];
+			c2_value1 = s2_coeff * c2_value1 - oscbuf[ ks2 - 1 ];
+		}
+
+		kernbuf1[ z - 1 ] = ( x2 * x2 - x1 * x1 ) / ( x1 - x2 ) * 0.5;
+		kernbuf2[ z - 1 ] = -1.0;
+	}
+
+	/**
+	 * Function copies band kernel's elements to the output buffer.
+	 *
+	 * @param outbuf Output buffer.
+	 * @param kernbuf1 Kernel buffer 1 (linear part).
+	 * @param kernbuf2 Kernel buffer 2 (ramp part).
+	 * @param c Multiplier for linear kernel element.
+	 * @param d Multiplier for ramp kernel element.
+	 */
+
+	void copyBandKernel( double* outbuf, const double* const kernbuf1,
+		const double* const kernbuf2, const double c, const double d ) const
+	{
+		int ks;
+
+		for( ks = 0; ks < z; ks++ )
+		{
+			outbuf[ ks ] = c * kernbuf1[ ks ] + d * kernbuf2[ ks ];
+		}
+	}
+
+	/**
+	 * Function adds band kernel's elements to the output buffer.
+	 *
+	 * @param outbuf Output buffer.
+	 * @param kernbuf1 Kernel buffer 1 (linear part).
+	 * @param kernbuf2 Kernel buffer 2 (ramp part).
+	 * @param c Multiplier for linear kernel element.
+	 * @param d Multiplier for ramp kernel element.
+	 */
+
+	void addBandKernel( double* outbuf, const double* const kernbuf1,
+		const double* const kernbuf2, const double c, const double d ) const
+	{
+		int ks;
+
+		for( ks = 0; ks < z; ks++ )
+		{
+			outbuf[ ks ] += c * kernbuf1[ ks ] + d * kernbuf2[ ks ];
+		}
+	}
+};
+
+/**
+ * @brief Low-pass filter windowed by Peaked Cosine window function.
+ *
+ * This class implements calculation of linear-phase symmetric-odd FIR
+ * low-pass filter windowed by the Peaked Cosine window function, for image
+ * processing applications.
+ */
+
+class CDSPPeakedCosineLPF
+{
+public:
+	int fl2; ///< Half filter's length, excluding the peak value. This value
+		///< can be also used as filter's latency in samples (taps).
+		///<
+	int FilterLen; ///< Filter's length in samples (taps).
+		///<
+
+	/**
+	 * Constructor initalizes *this object.
+	 *
+	 * @param aLen2 Half-length (non-truncated) of low-pass filter, in samples
+	 * (taps).
+	 * @param aFreq2 Low-pass filter's corner frequency [0; pi].
+	 * @param aAlpha Peaked Cosine window function Alpha parameter.
+	 */
+
+	CDSPPeakedCosineLPF( const double aLen2, const double aFreq2,
+		const double aAlpha )
+		: fl2( (int) ceil( aLen2 ) - 1 )
+		, FilterLen( fl2 + fl2 + 1 )
+		, Len2( aLen2 )
+		, Freq2( aFreq2 )
+		, Alpha( aAlpha )
+	{
+	}
+
+	/**
+	 * Function generates a linear-phase low-pass filter windowed by Peaked
+	 * Cosine window function.
+	 *
+	 * @param[out] op Output buffer, length = FilterLen (fl2 * 2 + 1).
+	 * @param DCGain Required gain at DC. The resulting filter will be
+	 * normalized to achieve this DC gain.
+	 */
+
+	template< class T >
+	void generateLPF( T* op, const double DCGain )
+	{
+		CDSPWindowGenPeakedCosine wf( Alpha, Len2 );
+		CSineGen f2( Freq2, 0.0 );
+
+		op += fl2;
+		T* op2 = op;
+		f2.generate();
+		int t = 1;
+
+		*op = (T) ( Freq2 * wf.generate() / M_PI );
+		double s = *op;
+
+		while( t <= fl2 )
+		{
+			const double v = f2.generate() * wf.generate() / t / M_PI;
+			op++;
+			op2--;
+			*op = (T) v;
+			*op2 = (T) v;
+			s += *op + *op2;
+			t++;
+		}
+
+		t = FilterLen;
+		s = DCGain / s;
+
+		while( t > 0 )
+		{
+			*op2 = (T) ( *op2 * s );
+			op2++;
+			t--;
+		}
+	}
+
+private:
+	double Len2; ///< Half-length (non-truncated) of low-pass filter, in
+		///< samples (taps).
+		///<
+	double Freq2; ///< Low-pass filter's corner frequency.
+		///<
+	double Alpha; ///< Peaked Cosine window function Alpha parameter.
+		///<
+};
+
+/**
+ * @brief Buffer class for parametrized low-pass filter.
+ *
+ * This class extends the CBuffer< double > class by adding several variables
+ * that define a symmetric-odd FIR low-pass filter windowed by Peaked Cosine
+ * window function. This class can be used to compare filters without
+ * comparing their buffer contents.
+ */
+
+class CFltBuffer : public CBuffer< double >
+{
+public:
+	double Len2; ///< Half-length (non-truncated) of low-pass filters, in
+		///< samples (taps).
+		///<
+	double Freq; ///< Low-pass filter's corner frequency.
+		///<
+	double Alpha; ///< Peaked Cosine window function Alpha parameter.
+		///<
+	double DCGain; ///< DC gain applied to the filter.
+		///<
+
+	CFltBuffer()
+		: CBuffer< double >()
+		, Len2( 0.0 )
+		, Freq( 0.0 )
+		, Alpha( 0.0 )
+		, DCGain( 0.0 )
+	{
+	}
+
+	/**
+	 * @param b2 Filter buffer to compare *this object to.
+	 * @return Operator returns "true" if both filters have same parameters.
+	 */
+
+	bool operator == ( const CFltBuffer& b2 ) const
+	{
+		return( Len2 == b2.Len2 && Freq == b2.Freq && Alpha == b2.Alpha &&
+			DCGain == b2.DCGain );
+	}
+};
+
+/**
+ * @brief Sinc function-based fractional delay filter bank.
+ *
+ * Class implements storage and initialization of a bank of sinc
+ * function-based fractional delay filters, expressed as 1st order polynomial
+ * interpolation coefficients. The filters are produced from a single "long"
+ * windowed low-pass filter. Also supports 0th-order ("nearest neighbor")
+ * interpolation.
+ *
+ * This class also supports multiplication of each fractional delay filter by
+ * an external filter (usually a low-pass filter).
+ *
+ * @tparam fptype Specifies storage type of the filter coefficients bank. The
+ * filters are initially calculated using the "double" precision.
+ */
+
+template< class fptype >
+class CDSPFracFilterBankLin
+{
+public:
+	CDSPFracFilterBankLin()
+		: Order( -1 )
+	{
+	}
+
+	/**
+	 * Copy constructor copies a limited set of parameters of the source
+	 * filter bank. The actual filters are not copied. Such copying is used
+	 * during filtering steps "modeling" stage. A further init() function
+	 * call is required.
+	 *
+	 * @param s Source filter bank.
+	 */
+
+	void copyInitParams( const CDSPFracFilterBankLin& s )
+	{
+		WFLen2 = s.WFLen2;
+		WFFreq = s.WFFreq;
+		WFAlpha = s.WFAlpha;
+		FracCount = s.FracCount;
+		Order = s.Order;
+		Alignment = s.Alignment;
+		SrcFilterLen = s.SrcFilterLen;
+		FilterLen = s.FilterLen;
+		FilterSize = s.FilterSize;
+		IsSrcTableBuilt = false;
+		ExtFilter = s.ExtFilter;
+		TableFillFlags.alloc( s.TableFillFlags.getCapacity() );
+		int i;
+
+		// Copy table fill flags, but shifted so that further initialization
+		// is still possible (such feature should not be used, though).
+
+		for( i = 0; i < TableFillFlags.getCapacity(); i++ )
+		{
+			TableFillFlags[ i ] = (uint8_t) ( s.TableFillFlags[ i ] << 2 );
+		}
+	}
+
+	/**
+	 * Operator compares *this filter bank and another filter bank and returns
+	 * "true" if their parameters are equal. Alignment is not taken into
+	 * account.
+	 *
+	 * @param s Filter bank to compare to.
+	 * @return "True" if compared banks have equal parameters.
+	 */
+
+	bool operator == ( const CDSPFracFilterBankLin& s ) const
+	{
+		return( Order == s.Order && WFLen2 == s.WFLen2 &&
+			WFFreq == s.WFFreq && WFAlpha == s.WFAlpha &&
+			FracCount == s.FracCount && ExtFilter == s.ExtFilter );
+	}
+
+	/**
+	 * Function initializes (builds) the filter bank based on the supplied
+	 * parameters. If the supplied parameters are equal to previously defined
+	 * parameters, function does nothing (alignment is assumed to be never
+	 * changing between the init() function calls).
+	 *
+	 * @param ReqFracCount Required number of fractional delays in the filter
+	 * bank. The minimal value is 2.
+	 * @param ReqOrder Required order of the interpolation polynomial
+	 * (0 or 1).
+	 * @param BaseLen Low-pass filter's base length, in samples (taps).
+	 * Affects the actual length of the filter and its overall steepness.
+	 * @param Cutoff Low-pass filter's normalized cutoff frequency [0; 1].
+	 * @param aWFAlpha Peaked Cosine window function's Alpha parameter.
+	 * @param aExtFilter External filter to apply to each fractional delay
+	 * filter.
+	 * @param aAlignment Memory alignment of the filter bank, power-of-2
+	 * value. 0 - use default stdlib alignment.
+	 * @param FltLenAlign Filter's length alignment, power-of-2 value.
+	 */
+
+	void init( const int ReqFracCount, const int ReqOrder,
+		const double BaseLen, const double Cutoff, const double aWFAlpha,
+		const CFltBuffer& aExtFilter, const int aAlignment = 0,
+		const int FltLenAlign = 1 )
+	{
+		double NewWFLen2 = 0.5 * BaseLen * ReqFracCount;
+		double NewWFFreq = M_PI * Cutoff / ReqFracCount;
+		double NewWFAlpha = aWFAlpha;
+
+		if( ReqOrder == Order && NewWFLen2 == WFLen2 && NewWFFreq == WFFreq &&
+			NewWFAlpha == WFAlpha && ReqFracCount == FracCount &&
+			aExtFilter == ExtFilter )
+		{
+			IsInitRequired = false;
+			return;
+		}
+
+		WFLen2 = NewWFLen2;
+		WFFreq = NewWFFreq;
+		WFAlpha = NewWFAlpha;
+		FracCount = ReqFracCount;
+		Order = ReqOrder;
+		Alignment = aAlignment;
+		ExtFilter = aExtFilter;
+
+		CDSPPeakedCosineLPF p( WFLen2, WFFreq, WFAlpha );
+		SrcFilterLen = ( p.fl2 / ReqFracCount + 1 ) * 2;
+
+		const int ElementSize = ReqOrder + 1;
+		FilterLen = SrcFilterLen;
+
+		if( ExtFilter.getCapacity() > 0 )
+		{
+			FilterLen += ExtFilter.getCapacity() - 1;
+		}
+
+		FilterLen = ( FilterLen + FltLenAlign - 1 ) & ~( FltLenAlign - 1 );
+		FilterSize = FilterLen * ElementSize;
+		IsSrcTableBuilt = false;
+		IsInitRequired = true;
+	}
+
+	/**
+	 * @return The length of each fractional delay filter, in samples (taps).
+	 * Always an even value.
+	 */
+
+	int getFilterLen() const
+	{
+		return( FilterLen );
+	}
+
+	/**
+	 * @return The number of fractional filters in use by *this bank.
+	 */
+
+	int getFracCount() const
+	{
+		return( FracCount );
+	}
+
+	/**
+	 * @return The order of the interpolation polynomial.
+	 */
+
+	int getOrder() const
+	{
+		return( Order );
+	}
+
+	/**
+	 * Function returns the pointer to the specified interpolation table
+	 * filter.
+	 *
+	 * @param i Filter (fractional delay) index, in the range 0 to
+	 * ReqFracCount - 1, inclusive.
+	 * @return Pointer to filter. Higher order polynomial coefficients are
+	 * stored after after previous order coefficients, separated by FilterLen
+	 * elements.
+	 */
+
+	const fptype* getFilter( const int i )
+	{
+		if( !IsSrcTableBuilt )
+		{
+			buildSrcTable();
+		}
+
+		fptype* const Res = &Table[ i * FilterSize ];
+
+		if(( TableFillFlags[ i ] & 2 ) == 0 )
+		{
+			createFilter( i );
+			TableFillFlags[ i ] |= 2;
+
+			if( Order > 0 )
+			{
+				createFilter( i + 1 );
+				const fptype* const Res2 = Res + FilterSize;
+				fptype* const op = Res + FilterLen;
+				int j;
+
+				// Create higher-order interpolation coefficients (linear
+				// interpolation).
+
+				for( j = 0; j < FilterLen; j++ )
+				{
+					op[ j ] = Res2[ j ] - Res[ j ];
+				}
+			}
+		}
+
+		return( Res );
+	}
+
+	/**
+	 * Function makes sure all fractional delay filters were created.
+	 */
+
+	void createAllFilters()
+	{
+		int i;
+
+		for( i = 0; i < FracCount; i++ )
+		{
+			getFilter( i );
+		}
+	}
+
+	/**
+	 * Function returns an approximate initialization complexity, expressed in
+	 * the number of multiply-add operations. This includes fractional delay
+	 * filters calculation and multiplication by an external filter. This
+	 * function can only be called after the init() function.
+	 *
+	 * @param FracUseMap Fractional delays use map, each element corresponds
+	 * to a single fractional delay, will be compared to the internal table
+	 * fill flags. This map should include 0 and 1 values only.
+	 * @return The complexity of the initialization, expressed in the number
+	 * of multiply-add operations.
+	 */
+
+	int calcInitComplexity( const CBuffer< uint8_t >& FracUseMap ) const
+	{
+		const int FltInitCost = 65; // Cost to initialize a single sample
+			// of the fractional delay filter.
+		const int FltUseCost = FilterLen * Order +
+			SrcFilterLen * ExtFilter.getCapacity(); // Cost to use a single
+			// fractional delay filter.
+		const int ucb[ 2 ] = { 0, FltUseCost };
+		int ic;
+		int i;
+
+		if( IsInitRequired )
+		{
+			ic = FracCount * SrcFilterLen * FltInitCost;
+
+			for( i = 0; i < FracCount; i++ )
+			{
+				ic += ucb[ FracUseMap[ i ]];
+			}
+		}
+		else
+		{
+			ic = 0;
+
+			for( i = 0; i < FracCount; i++ )
+			{
+				if( FracUseMap[ i ] != 0 )
+				{
+					ic += ucb[ TableFillFlags[ i ] == 0 ? 1 : 0 ];
+				}
+			}
+		}
+
+		return( ic );
+	}
+
+private:
+	static const int InterpPoints = 2; ///< The maximal number of points the
+		///< interpolation is based on.
+		///<
+	double WFLen2; ///< Window function's Len2 parameter.
+		///<
+	double WFFreq; ///< Window function's Freq parameter.
+		///<
+	double WFAlpha; ///< Window function's Alpha parameter.
+		///<
+	int FracCount; ///< The required number of fractional delay filters.
+		///<
+	int Order; ///< The order of the interpolation polynomial.
+		///<
+	int Alignment; ///< The required filter table alignment.
+		///<
+	int SrcFilterLen; ///< Length of the "source" filters. This is always an
+		///< even value.
+		///<
+	int FilterLen; ///< Specifies the number of samples (taps) each fractional
+		///< delay filter has. This is always an even value, adjusted by the
+		///< FltLenAlign.
+		///<
+	int FilterSize; ///< The size of a single filter element, equals
+		///< FilterLen * ElementSize.
+		///<
+	bool IsInitRequired; ///< "True" if SrcTable filter table initialization
+		///< is required. This value is available only after the call to the
+		///< init() function.
+		///<
+	CBuffer< fptype > Table; ///< Interpolation table, size equals to
+		///< ReqFracCount * FilterLen * ElementSize.
+		///<
+	CBuffer< uint8_t > TableFillFlags; ///< Contains ReqFracCount + 1
+		///< elements. Bit 0 of every element is 1 if Table already contains
+		///< the filter from SrcTable filtered by ExtFilter. Bit 1 of every
+		///< element means higher order coefficients were filled for the
+		///< filter.
+		///<
+	CFltBuffer ExtFilter; ///< External filter that should be applied to every
+		///< fractional delay filter. Can be empty. Half of this filter's
+		///< capacity is used as latency (group delay) value of the filter.
+		///<
+	CBuffer< double > SrcTable; ///< Source table of delay filters, contains
+		///< ReqFracCount + 1 elements. This table is used to fill the Table
+		///< with the actual filters, filtered by an external filter.
+		///<
+	bool IsSrcTableBuilt; ///< "True" if the SrcTable was built already. This
+		///< variable is set to "false" in the init() function.
+		///<
+
+	/**
+	 * Function builds source table used in the createFilter() function.
+	 */
+
+	void buildSrcTable()
+	{
+		IsSrcTableBuilt = true;
+		IsInitRequired = false;
+
+		CDSPPeakedCosineLPF p( WFLen2, WFFreq, WFAlpha );
+
+		const int BufLen = SrcFilterLen * FracCount + InterpPoints - 1;
+		const int BufOffs = InterpPoints / 2 - 1;
+		const int BufCenter = SrcFilterLen * FracCount / 2 + BufOffs;
+
+		CBuffer< double > Buf( BufLen );
+		memset( Buf, 0, ( BufCenter - p.fl2 ) * sizeof( double ));
+		int i = BufLen - BufCenter - p.fl2 - 1;
+		memset( &Buf[ BufLen - i ], 0, i * sizeof( double ));
+
+		p.generateLPF( &Buf[ BufCenter - p.fl2 ], FracCount );
+
+		SrcTable.alloc(( FracCount + 1 ) * SrcFilterLen );
+		TableFillFlags.alloc( FracCount + 1 );
+		int j;
+		double* op0 = SrcTable;
+
+		for( i = FracCount; i >= 0; i-- )
+		{
+			TableFillFlags[ i ] = 0;
+			double* p = Buf + BufOffs + i;
+
+			for( j = 0; j < SrcFilterLen; j++ )
+			{
+				op0[ 0 ] = p[ 0 ];
+				op0++;
+				p += FracCount;
+			}
+		}
+
+		Table.alloc(( FracCount + 1 ) * FilterSize, Alignment );
+	}
+
+	/**
+	 * Function creates the specified filter in the Table by copying it from
+	 * the SrcTable and filtering by ExtFilter. Function does nothing if
+	 * filter was already created.
+	 *
+	 * @param k Filter index to create, in the range 0 to FracCount,
+	 * inclusive.
+	 */
+
+	void createFilter( const int k )
+	{
+		if( TableFillFlags[ k ] != 0 )
+		{
+			return;
+		}
+
+		TableFillFlags[ k ] |= 1;
+		const int ExtFilterLatency = ExtFilter.getCapacity() / 2;
+		const int ResLatency = ExtFilterLatency + SrcFilterLen / 2;
+		int ResLen = SrcFilterLen;
+
+		if( ExtFilter.getCapacity() > 0 )
+		{
+			ResLen += ExtFilter.getCapacity() - 1;
+		}
+
+		const int ResOffs = FilterLen / 2 - ResLatency;
+		fptype* op = &Table[ k * FilterSize ];
+		int i;
+
+		for( i = 0; i < ResOffs; i++ )
+		{
+			op[ i ] = 0.0;
+		}
+
+		for( i = ResOffs + ResLen; i < FilterLen; i++ )
+		{
+			op[ i ] = 0.0;
+		}
+
+		op += ResOffs;
+		const double* const srcflt = &SrcTable[ k * SrcFilterLen ];
+
+		if( ExtFilter.getCapacity() == 0 )
+		{
+			for( i = 0; i < ResLen; i++ )
+			{
+				op[ i ] = (fptype) srcflt[ i ];
+			}
+
+			return;
+		}
+
+		// Perform convolution of extflt and srcflt.
+
+		const double* const extflt = &ExtFilter[ 0 ];
+		int j;
+
+		for( j = 0; j < ResLen; j++ )
+		{
+			int k = 0;
+			int l = j - ExtFilter.getCapacity() + 1;
+			int r = l + ExtFilter.getCapacity();
+
+			if( l < 0 )
+			{
+				k -= l;
+				l = 0;
+			}
+
+			if( r > SrcFilterLen )
+			{
+				r = SrcFilterLen;
+			}
+
+			const double* const extfltb = extflt + k;
+			const double* const srcfltb = srcflt + l;
+			double s = 0.0;
+			l = r - l;
+
+			for( i = 0; i < l; i++ )
+			{
+				s += extfltb[ i ] * srcfltb[ i ];
+			}
+
+			op[ j ] = (fptype) s;
+		}
+	}
+};
+
+/**
+ * @brief Thread pool for multi-threaded image resizing operation.
+ *
+ * This base class is used to organize a multi-threaded image resizing
+ * operation. The thread pool should consist of threads that initially wait
+ * for a signal. Upon receiving a signal (via the startAllWorkloads()
+ * function) each previously added thread should execute its workload's
+ * process() function once, and return to the wait signal state again. The
+ * thread pool should be also able to efficiently wait for all workloads to
+ * finish via the waitAllWorkloadsToFinish() function.
+ *
+ * The image resizing algorithm makes calls to functions of this class.
+ */
+
+class CImageResizerThreadPool
+{
+public:
+	CImageResizerThreadPool()
+	{
+	}
+
+	virtual ~CImageResizerThreadPool()
+	{
+	}
+
+	/**
+	 * @brief Thread pool's workload object class.
+	 *
+	 * This class should be used as a base class for objects that perform the
+	 * actual work spread over several threads.
+	 */
+
+	class CWorkload
+	{
+	public:
+		virtual ~CWorkload()
+		{
+		}
+
+		/**
+		 * Function that gets called from the thread when thread pool's
+		 * startAllWorkloads() function is called.
+		 */
+
+		virtual void process() = 0;
+	};
+
+	/**
+	 * @return The suggested number of workloads (and their associated
+	 * threads) to add. The minimal value this function can return is 1. The
+	 * usual value may depend on the number of physical and virtual cores
+	 * present in the system, and on other considerations.
+	 */
+
+	virtual int getSuggestedWorkloadCount() const
+	{
+		return( 1 );
+	}
+
+	/**
+	 * Function adds a new workload (and possibly thread) to the thread pool.
+	 * The caller decides how many parallel workloads (and threads) it
+	 * requires, but this number will not exceed the value returned by the
+	 * getSuggestedWorkloadCount() function. It is implementation-specific how
+	 * many workloads to associate with a single thread. But for efficiency
+	 * reasons each workload should be associated with its own thread.
+	 *
+	 * Note that the same set of workload objects will be processed each time
+	 * the startAllWorkloads() function is called. This means that workload
+	 * objects are added only once. The caller changes the state of the
+	 * workload objects and then calls the startAllWorkloads() function to
+	 * process them.
+	 *
+	 * @param Workload Workload object whose process() function will be called
+	 * from within the thread when the startAllWorkloads() function is called.
+	 */
+
+	virtual void addWorkload( CWorkload* const Workload )
+	{
+	}
+
+	/**
+	 * Function starts all workloads associated with threads previously added
+	 * via the addWorkload() function. It is assumed that this function
+	 * performs the necessary "memory barrier" (or "cache sync") kind of
+	 * operation so that all threads catch up the prior changes made to the
+	 * workload objects during their wait state.
+	 */
+
+	virtual void startAllWorkloads()
+	{
+	}
+
+	/**
+	 * Function waits for all workloads to finish.
+	 */
+
+	virtual void waitAllWorkloadsToFinish()
+	{
+	}
+
+	/**
+	 * Function removes all workloads previously added via the addWorkload()
+	 * function. This function gets called only after the
+	 * waitAllWorkloadsToFinish() function call.
+	 */
+
+	virtual void removeAllWorkloads()
+	{
+	}
+};
+
+/**
+ * @brief Resizing algorithm parameters structure.
+ *
+ * This structure holds all selectable parameters used by the resizing
+ * algorithm at various stages, for both downsizing and upsizing. There are no
+ * other parameters exist that can optimize the performance of the resizing
+ * algorithm. Filter length parameters can take fractional values.
+ *
+ * Beside quality, these parameters (except Alpha parameters) directly affect
+ * the computative cost of the resizing algorithm. It is possible to trade
+ * the visual quality for computative cost.
+ *
+ * Anti-alias filtering during downsizing can be defined as a considerable
+ * reduction of contrast of smallest features of an image. Unfortunately, such
+ * de-contrasting partially affects features of all sizes thus producing a
+ * non-linearity of frequency response. All pre-defined parameter sets are
+ * described by 3 values separated by slashes. The first value is the
+ * de-contrasting factor of small features (which are being removed) while
+ * the second value is the de-contrasting factor of large features (which
+ * should remain intact), with value of 1 equating to "no contrast change".
+ * The third value is the optimization score (see below), with value of 0
+ * equating to the "perfect" linearity of frequency response.
+ *
+ * The pre-defined parameter sets offered by this library were auto-optimized
+ * for the given LPFltBaseLen, IntFltLen and CorrFltAlpha values. The
+ * optimization goal was to minimize the score: the sum of squares of the
+ * difference between original and processed images (which was not actually
+ * resized, k=1). The original image was a 0.5 megapixel uniformly-distributed
+ * white-noise image with pixel intensities in the 0-1 range. Such goal
+ * converges very well and produces filtering system with the flattest
+ * frequency response possible for the given constraints. With this goal,
+ * increasing the LPFltBaseLen value reduces the general amount of aliasing
+ * artifacts.
+ */
+
+struct CImageResizerParams
+{
+	double CorrFltAlpha; ///< Alpha parameter of the Peaked Cosine window
+		///< function used on the correction filter. The "usable" values are
+		///< in the narrow range 1.0 to 1.5.
+		///<
+	double CorrFltLen; ///< Correction filter's length in samples (taps). The
+		///< "usable" range is narrow, 5.5 to 8, as to minimize the
+		///< "overcorrection" which is mathematically precise, but visually
+		///< unacceptable.
+		///<
+	double IntFltAlpha; ///< Alpha parameter of the Peaked Cosine window
+		///< function used on the interpolation low-pass filter. The "usable"
+		///< values are in the range 1.5 to 2.5.
+		///<
+	double IntFltCutoff; ///< Interpolation low-pass filter's cutoff frequency
+		///< (normalized, [0; 1]). The "usable" range is 0.6 to 0.8.
+		///<
+	double IntFltLen; ///< Interpolation low-pass filter's length in samples
+		///< (taps). The length value should be at least 18 or otherwise a
+		///< "dark grid" artifact will be introduced if a further sharpening
+		///< is applied. IntFltLen together with other IntFlt parameters
+		///< should be tuned in a way that produces the flattest frequency
+		///< response in 0-0.5 normalized frequency range (this range is due
+		///< to 2X upsampling).
+		///<
+	double LPFltAlpha; ///< Alpha parameter of the Peaked Cosine window
+		///< function used on the low-pass filter. The "usable" values are
+		///< in the range 1.5 to 6.5.
+		///<
+	double LPFltBaseLen; ///< Base length of the low-pass (aka anti-aliasing
+		///< or reconstruction) filter, in samples (taps), further adjusted by
+		///< the actual cutoff frequency, upsampling and downsampling factors.
+		///< The "usable" range is between 6 and 9.
+		///<
+	double LPFltCutoffMult; ///< Low-pass filter's cutoff frequency
+		///< multiplier. This value can be both below and above 1.0 as
+		///< low-pass filters are inserted on downsampling and upsampling
+		///< steps and always have corner frequency equal to or below 0.5pi.
+		///< This multiplier shifts low-pass filter's corner frequency towards
+		///< lower (if below 1.0) or higher (if above 1.0) frequencies. This
+		///< multiplier can be way below 1.0 since any additional
+		///< high-frequency damping will be partially corrected by the
+		///< correction filter. The "usable" range is 0.3 to 1.0.
+		///<
+
+	CImageResizerParams()
+		: HBFltAlpha( 1.75395 )
+		, HBFltCutoff( 0.40356 )
+		, HBFltLen( 22.00000 )
+	{
+	}
+
+	double HBFltAlpha; ///< Half-band filter's Alpha. Assigned internally.
+		///<
+	double HBFltCutoff; ///< Half-band filter's cutoff point [0; 1]. Assigned
+		///< internally.
+		///<
+	double HBFltLen; ///< Length of the half-band low-pass filter. Assigned
+		///< internally. Internally used to perform 2X or higher downsampling.
+		///< These filter parameters should be treated as "technical" and do
+		///< not require adjustment as they were tuned to suit all
+		///< combinations of other parameters. This half-band filter provides
+		///< a wide transition band (for minimal ringing artifacts) and a high
+		///< stop-band attenuation (for minimal aliasing).
+		///<
+};
+
+/**
+ * @brief The default set of resizing algorithm parameters
+ * (10.01/1.029/0.019169).
+ *
+ * This is the default set of resizing parameters that was designed to deliver
+ * a sharp image while still providing a low amount of ringing artifacts, and
+ * having a reasonable computational cost.
+ */
+
+struct CImageResizerParamsDef : public CImageResizerParams
+{
+	CImageResizerParamsDef()
+	{
+		CorrFltAlpha = 1.0;//10.01/1.88/1.029(522.43)/0.019169:258648,446808
+		CorrFltLen = 6.30770;
+		IntFltAlpha = 2.27825;
+		IntFltCutoff = 0.75493;
+		IntFltLen = 18.0;
+		LPFltAlpha = 3.40127;
+		LPFltBaseLen = 7.78;
+		LPFltCutoffMult = 0.78797;
+	}
+};
+
+/**
+ * @brief Set of resizing algorithm parameters for lower-ringing performance
+ * (8.86/1.046/0.010168).
+ *
+ * This set of resizing algorithm parameters offers a lower-ringing
+ * performance in comparison to the default setting, at the expense of higher
+ * aliasing artifacts and a slightly reduced contrast.
+ */
+
+struct CImageResizerParamsLow : public CImageResizerParams
+{
+	CImageResizerParamsLow()
+	{
+		CorrFltAlpha = 1.0;//8.86/1.92/1.046(871.54)/0.010168:258647,442252
+		CorrFltLen = 6.09757;
+		IntFltAlpha = 2.36704;
+		IntFltCutoff = 0.74674;
+		IntFltLen = 18.0;
+		LPFltAlpha = 2.19427;
+		LPFltBaseLen = 7.66;
+		LPFltCutoffMult = 0.75380;
+	}
+};
+
+/**
+ * @brief Set of resizing algorithm parameters for low-ringing performance
+ * (7.86/1.065/0.000106).
+ *
+ * This set of resizing algorithm parameters offers a very low-ringing
+ * performance at the expense of higher aliasing artifacts and a slightly
+ * reduced contrast.
+ */
+
+struct CImageResizerParamsLR : public CImageResizerParams
+{
+	CImageResizerParamsLR()
+	{
+		CorrFltAlpha = 1.0;//7.86/1.96/1.065(73865.02)/0.000106:258636,437381
+		CorrFltLen = 5.87671;
+		IntFltAlpha = 2.25322;
+		IntFltCutoff = 0.74090;
+		IntFltLen = 18.0;
+		LPFltAlpha = 1.79306;
+		LPFltBaseLen = 7.00;
+		LPFltCutoffMult = 0.68881;
+	}
+};
+
+/**
+ * @brief Set of resizing algorithm parameters for low-aliasing
+ * resizing (11.81/1.012/0.038379).
+ *
+ * This set of resizing algorithm parameters offers a considerable
+ * anti-aliasing performance with a good frequency response linearity (and
+ * contrast). This is an intermediate setting between the default and Ultra
+ * parameters.
+ */
+
+struct CImageResizerParamsHigh : public CImageResizerParams
+{
+	CImageResizerParamsHigh()
+	{
+		CorrFltAlpha = 1.0;//11.81/1.83/1.012(307.84)/0.038379:258660,452719
+		CorrFltLen = 6.80909;
+		IntFltAlpha = 2.44917;
+		IntFltCutoff = 0.75856;
+		IntFltLen = 18.0;
+		LPFltAlpha = 4.39527;
+		LPFltBaseLen = 8.18;
+		LPFltCutoffMult = 0.79172;
+	}
+};
+
+/**
+ * @brief Set of resizing algorithm parameters for ultra low-aliasing
+ * resizing (13.65/1.001/0.000483).
+ *
+ * This set of resizing algorithm parameters offers a very considerable
+ * anti-aliasing performance with a good frequency response linearity (and
+ * contrast). This set of parameters is computationally expensive and may
+ * produce ringing artifacts on sharp features.
+ */
+
+struct CImageResizerParamsUltra : public CImageResizerParams
+{
+	CImageResizerParamsUltra()
+	{
+		CorrFltAlpha = 1.0;//13.65/1.79/1.001(28288.41)/0.000483:258658,457974
+		CorrFltLen = 7.48060;
+		IntFltAlpha = 1.93750;
+		IntFltCutoff = 0.75462;
+		IntFltLen = 18.0;
+		LPFltAlpha = 5.55209;
+		LPFltBaseLen = 8.34;
+		LPFltCutoffMult = 0.78002;
+	}
+};
+
+/**
+ * @brief Image resizing variables class.
+ * 
+ * This is an utility "catch all" class that defines various variables used
+ * during image resizing. Several variables that are explicitly initialized in
+ * this class' constructor are also used as additional "input" variables to
+ * the image resizing function. These variables will not be changed by the
+ * avir::CImageResizer<>::resizeImage() function.
+ */
+
+class CImageResizerVars
+{
+public:
+	int ElCount; ///< The number of "fptype" elements used to store 1 pixel.
+		///<
+	int ElCountIO; ///< The number of source and destination image's elements
+		///< used to store 1 pixel.
+		///<
+	int fppack; ///< The number of atomic types stored in a single "fptype"
+		///< element.
+		///<
+	int fpalign; ///< Suggested alignment size in bytes. This is not a
+		///< required alignment, because image resizing algorithm cannot be
+		///< made to have a strictly aligned data access in all cases (e.g.
+		///< de-interlaved interpolation cannot perform aligned accesses).
+		///<
+	int elalign; ///< Length alignment of arrays of elements. This applies to
+		///< filters and intermediate buffers: this constant forces filters
+		///< and scanlines to have a length which is a multiple of this value,
+		///< for more efficient SIMD implementation. Value different to 1
+		///< also means image pixels are de-interleaved during processing.
+		///<
+	int BufLen[ 2 ]; ///< Intermediate buffers' lengths in "fptype" elements.
+	int BufOffs[ 2 ]; ///< Offsets into the intermediate buffers, used to
+		///< provide prefix elements required during processing so that no
+		///< "out of range" access happens. This offset is a multiple of
+		///< ElCount if pixels are stored in interleaved form.
+		///<
+	double k; ///< Resizing step coefficient, updated to reflect the actually
+		///< used coefficient during resizing.
+		///<
+	double o; ///< Starting pixel offset inside the source image, updated to
+		///< reflect the actually used offset during resizing.
+		///<
+	int ResizeStep; ///< Index of the resizing step in the latest filtering
+		///< steps array.
+		///<
+	double InGammaMult; ///< Input gamma multiplier, used to convert input
+		///< data to 0 to 1 range. 0.0 if no gamma is in use.
+		///<
+	double OutGammaMult; ///< Output gamma multiplier, used to convert data to
+		///< 0 to 255/65535 range. 0.0 if no gamma is in use.
+		///<
+
+	double ox; ///< Start X pixel offset within source image (can be
+		///< negative). Positive offset moves image to the left.
+		///<
+	double oy; ///< Start Y pixel offset within source image (can be
+		///< negative). Positive offset moves image to the top.
+		///<
+	CImageResizerThreadPool* ThreadPool; ///< Thread pool to be used by the
+		///< image resizing function. Set to NULL to use single-threaded
+		///< processing.
+		///<
+	bool UseSRGBGamma; ///< Perform sRGB gamma linearization (correction).
+		///<
+	int BuildMode; ///< The build mode to use, for debugging purposes. Set to
+		///< -1 to select a minimal-complexity mode automatically. All build
+		///< modes deliver similar results with minor deviations.
+		///<
+	int RndSeed; ///< Random seed parameter. This parameter may be incremented
+		///< after each random generator initialization. The use of this
+		///< variable depends on the ditherer implementation.
+		///<
+
+	CImageResizerVars()
+		: ox( 0.0 )
+		, oy( 0.0 )
+		, ThreadPool( NULL )
+		, UseSRGBGamma( false )
+		, BuildMode( -1 )
+		, RndSeed( 0 )
+	{
+	}
+};
+
+/**
+ * @brief Image resizer's filtering step class.
+ *
+ * Class defines data to perform a single filtering step over a whole
+ * horizontal or vertical scanline. Resizing consists of 1 or more steps that
+ * may be performed before the actual resizing takes place. Filtering may also
+ * follow a resizing step. Each step must ensure that scanline data contains
+ * enough pixels to perform the next step (which may be resizing) without
+ * exceeding scanline's bounds.
+ *
+ * A derived class must implement several "const" and "static" functions that
+ * are used to perform the actual filtering in interleaved or de-interleaved
+ * mode.
+ *
+ * @tparam fptype Floating point type to use for storing pixel elements. SIMD
+ * types can be used: in this case each element may hold a whole pixel.
+ * @tparam fptypeatom The atomic type the "fptype" consists of.
+ */
+
+template< class fptype, class fptypeatom >
+class CImageResizerFilterStep
+{
+public:
+	bool IsUpsample; ///< "True" if this step is an upsampling step, "false"
+		///< if downsampling step. Should be set to "false" if ResampleFactor
+		///< equals 0.
+		///<
+	int ResampleFactor; ///< Resample factor (>=1). If 0, this is a resizing
+		///< step. This value should be >1 if IsUpsample equals "true".
+		///<
+	CBuffer< fptype > Flt; ///< Filter to use at this step.
+		///<
+	CFltBuffer FltOrig; ///< Originally-designed filter. This buffer may not
+		///< be assigned. Assigned by filters that precede the resizing step
+		///< if such filter is planned to be embedded into the interpolation
+		///< filter as "external" filter. If IsUpsample=true and this filter
+		///< buffer is not empty, the upsampling step will not itself apply
+		///< any filtering over upsampled input scanline.
+		///<
+	double DCGain; ///< DC gain which was applied to the filter. Not defined
+		///< if ResampleFactor = 0.
+		///<
+	int FltLatency; ///< Filter's latency (group delay, shift) in pixels.
+		///<
+	const CImageResizerVars* Vars; ///< Image resizing-related variables.
+		///<
+	int InLen; ///< Input scanline's length in pixels.
+		///<
+	int InBuf; ///< Input buffer index, 0 or 1.
+		///<
+	int InPrefix; ///< Required input prefix pixels. These prefix pixels will
+		///< be filled with source scanline's first pixel value. If IsUpsample
+		///< is "true", this is the additional number of times the first pixel
+		///< will be filtered before processing scanline, this number is also
+		///< reflected in the OutPrefix.
+		///<
+	int InSuffix; ///< Required input suffix pixels. These suffix pixels will
+		///< be filled with source scanline's last pixel value. If IsUpsample
+		///< is "true", this is the additional number of times the last pixel
+		///< will be filtered before processing scanline, this number is also
+		///< reflected in the OutSuffix.
+		///<
+	int InElIncr; ///< Pixel element increment within the input buffer, used
+		///< during de-interleaved processing: in this case each image's
+		///< channel is stored independently, InElIncr elements apart.
+		///<
+	int OutLen; ///< Length of the resulting scanline.
+		///<
+	int OutBuf; ///< Output buffer index. 0 or 1; 2 for the last step.
+		///<
+	int OutPrefix; ///< Required output prefix pixels. These prefix pixels
+		///< will not be pre-filled with any values. Value is valid only if
+		///< IsUpsample equals "true".
+		///<
+	int OutSuffix; ///< Required input suffix pixels. These suffix pixels will
+		///< not be pre-filled with any values. Value is valid only if
+		///< IsUpsample equals "true".
+		///<
+	int OutElIncr; ///< Pixel element increment within the output buffer, used
+		///< during de-interleaved processing. Equals to the InBufElIncr of
+		///< the next step.
+		///<
+	CBuffer< fptype > PrefixDC; ///< DC component fluctuations added at the
+		///< start of the resulting scanline, used when IsUpsample equals
+		///< "true".
+		///<
+	CBuffer< fptype > SuffixDC; ///< DC component fluctuations added at the
+		///< end of the resulting scanline, used when IsUpsample equals
+		///< "true".
+		///<
+	int EdgePixelCount; ///< The number of edge pixels added. Affects the
+		///< initial position within the input scanline, used to produce edge
+		///< pixels. This variable is used and should be defined when
+		///< IsUpsample=false and ResampleFactor>0. When assigning this
+		///< variable it is also necessary to update InPrefix, OutLen and
+		///< Vars.o variables.
+		///<
+	static const int EdgePixelCountDef = 3; ///< The default number of pixels
+		///< additionally produced at scanline edges during filtering. This is
+		///< required to reduce edge artifacts.
+		///<
+
+	/**
+	 * @brief Resizing position structure.
+	 *
+	 * Structure holds resizing position and pointer to fractional delay
+	 * filter.
+	 */
+
+	struct CResizePos
+	{
+		int SrcPosInt; ///< Source scanline position.
+			///<
+		int fti; ///< Fractional delay filter index.
+			///<
+		const fptype* ftp; ///< Fractional delay filter pointer.
+			///<
+		fptypeatom x; ///< Interpolation coefficient between delay filters.
+			///<
+		int SrcOffs; ///< Source scanline offset.
+			///<
+	};
+
+	/**
+	 * @brief Resizing positions buffer class.
+	 *
+	 * This class combines buffer together with variables that define resizing
+	 * stepping.
+	 */
+
+	class CRPosBuf : public CBuffer< CResizePos >
+	{
+	public:
+		double k; ///< Resizing step.
+			///<
+		double o; ///< Resizing offset.
+			///<
+		int FracCount; ///< The number of fractional delay filters in a filter
+			///< bank used together with this buffer.
+			///<
+	};
+
+	/**
+	 * @brief Resizing positions buffer array class.
+	 *
+	 * This class combines structure array of the CRPosBuf class objects with
+	 * the function that locates or creates buffer with the required resizing
+	 * stepping.
+	 */
+
+	class CRPosBufArray : public CStructArray< CRPosBuf >
+	{
+	public:
+		using CStructArray< CRPosBuf > :: add;
+		using CStructArray< CRPosBuf > :: getItemCount;
+
+		/**
+		 * Function returns the resizing positions buffer with the required
+		 * stepping. If no such buffer exists, it is created.
+		 *
+		 * @param k Resizing step.
+		 * @param o Resizing offset.
+		 * @param FracCount The number of fractional delay filters in a filter
+		 * bank used together with this buffer.
+		 * @return Reference to the CRPosBuf object.
+		 */
+
+		CRPosBuf& getRPosBuf( const double k, const double o,
+			const int FracCount )
+		{
+			int i;
+
+			for( i = 0; i < getItemCount(); i++ )
+			{
+				CRPosBuf& Buf = (*this)[ i ];
+
+				if( Buf.k == k && Buf.o == o && Buf.FracCount == FracCount )
+				{
+					return( Buf );
+				}
+			}
+
+			CRPosBuf& NewBuf = add();
+			NewBuf.k = k;
+			NewBuf.o = o;
+			NewBuf.FracCount = FracCount;
+
+			return( NewBuf );
+		}
+	};
+
+	CRPosBuf* RPosBuf; ///< Resizing positions buffer. Used when
+		///< ResampleFactor equals 0 (resizing step).
+		///<
+	CDSPFracFilterBankLin< fptype >* FltBank; ///< Filter bank in use by *this
+		///< resizing step.
+		///<
+};
+
+/**
+ * @brief Interleaved filtering steps implementation class.
+ *
+ * This class implements scanline filtering functions in interleaved mode.
+ * This means that each pixel is processed independently, not in groups.
+ *
+ * @tparam fptype Floating point type to use for storing pixel elements. SIMD
+ * types can be used: in this case each element may hold a whole pixel.
+ * @tparam fptypeatom The atomic type the "fptype" consists of.
+ */
+
+template< class fptype, class fptypeatom >
+class CImageResizerFilterStepINL :
+	public CImageResizerFilterStep< fptype, fptypeatom >
+{
+public:
+	using CImageResizerFilterStep< fptype, fptypeatom > :: IsUpsample;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: ResampleFactor;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: Flt;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: FltOrig;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: FltLatency;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: Vars;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: InLen;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: InPrefix;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: InSuffix;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: OutLen;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: OutPrefix;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: OutSuffix;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: PrefixDC;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: SuffixDC;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: RPosBuf;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: FltBank;
+	using CImageResizerFilterStep< fptype, fptypeatom > :: EdgePixelCount;
+
+	/**
+	 * Function performs "packing" of a scanline and type conversion.
+	 * Scanline, depending on the "fptype" can be potentially stored as a
+	 * packed SIMD values having a certain atomic type. If required, the sRGB
+	 * gamma correction is applied.
+	 *
+	 * @param ip Input scanline.
+	 * @param op0 Output scanline.
+	 * @param l0 The number of pixels to "unpack".
+	 */
+
+	template< class Tin >
+	void packScanline( const Tin* ip, fptype* const op0, const int l0 ) const
+	{
+		const int ElCount = Vars -> ElCount;
+		const int ElCountIO = Vars -> ElCountIO;
+		fptype* op = op0;
+		int l = l0;
+
+		if( !Vars -> UseSRGBGamma )
+		{
+			if( ElCountIO == 1 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = (fptypeatom) ip[ 0 ];
+					op += ElCount;
+					ip++;
+					l--;
+				}
+			}
+			else
+			if( ElCountIO == 4 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = (fptypeatom) ip[ 0 ];
+					v[ 1 ] = (fptypeatom) ip[ 1 ];
+					v[ 2 ] = (fptypeatom) ip[ 2 ];
+					v[ 3 ] = (fptypeatom) ip[ 3 ];
+					op += ElCount;
+					ip += 4;
+					l--;
+				}
+			}
+			else
+			if( ElCountIO == 3 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = (fptypeatom) ip[ 0 ];
+					v[ 1 ] = (fptypeatom) ip[ 1 ];
+					v[ 2 ] = (fptypeatom) ip[ 2 ];
+					op += ElCount;
+					ip += 3;
+					l--;
+				}
+			}
+			else
+			if( ElCountIO == 2 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = (fptypeatom) ip[ 0 ];
+					v[ 1 ] = (fptypeatom) ip[ 1 ];
+					op += ElCount;
+					ip += 2;
+					l--;
+				}
+			}
+		}
+		else
+		{
+			const fptypeatom gm = (fptypeatom) Vars -> InGammaMult;
+
+			if( ElCountIO == 1 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = convertSRGB2Lin( (fptypeatom) ip[ 0 ] * gm );
+					op += ElCount;
+					ip++;
+					l--;
+				}
+			}
+			else
+			if( ElCountIO == 4 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = convertSRGB2Lin( (fptypeatom) ip[ 0 ] * gm );
+					v[ 1 ] = convertSRGB2Lin( (fptypeatom) ip[ 1 ] * gm );
+					v[ 2 ] = convertSRGB2Lin( (fptypeatom) ip[ 2 ] * gm );
+					v[ 3 ] = convertSRGB2Lin( (fptypeatom) ip[ 3 ] * gm );
+					op += ElCount;
+					ip += 4;
+					l--;
+				}
+			}
+			else
+			if( ElCountIO == 3 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = convertSRGB2Lin( (fptypeatom) ip[ 0 ] * gm );
+					v[ 1 ] = convertSRGB2Lin( (fptypeatom) ip[ 1 ] * gm );
+					v[ 2 ] = convertSRGB2Lin( (fptypeatom) ip[ 2 ] * gm );
+					op += ElCount;
+					ip += 3;
+					l--;
+				}
+			}
+			else
+			if( ElCountIO == 2 )
+			{
+				while( l > 0 )
+				{
+					fptypeatom* v = (fptypeatom*) op;
+					v[ 0 ] = convertSRGB2Lin( (fptypeatom) ip[ 0 ] * gm );
+					v[ 1 ] = convertSRGB2Lin( (fptypeatom) ip[ 1 ] * gm );
+					op += ElCount;
+					ip += 2;
+					l--;
+				}
+			}
+		}
+
+		const int ZeroCount = ElCount * Vars -> fppack - ElCountIO;
+		op = op0;
+		l = l0;
+
+		if( ZeroCount == 1 )
+		{
+			while( l > 0 )
+			{
+				fptypeatom* v = (fptypeatom*) op + ElCountIO;
+				v[ 0 ] = (fptypeatom) 0;
+				op += ElCount;
+				l--;
+			}
+		}
+		else
+		if( ZeroCount == 2 )
+		{
+			while( l > 0 )
+			{
+				fptypeatom* v = (fptypeatom*) op + ElCountIO;
+				v[ 0 ] = (fptypeatom) 0;
+				v[ 1 ] = (fptypeatom) 0;
+				op += ElCount;
+				l--;
+			}
+		}
+		else
+		if( ZeroCount == 3 )
+		{
+			while( l > 0 )
+			{
+				fptypeatom* v = (fptypeatom*) op + ElCountIO;
+				v[ 0 ] = (fptypeatom) 0;
+				v[ 1 ] = (fptypeatom) 0;
+				v[ 2 ] = (fptypeatom) 0;
+				op += ElCount;
+				l--;
+			}
+		}
+	}
+
+	/**
+	 * Function applies Linear to sRGB gamma correction to the specified
+	 * scanline.
+	 *
+	 * @param p Scanline.
+	 * @param l The number of pixels to de-linearize.
+	 * @param Vars0 Image resizing-related variables.
+	 */
+
+	static void applySRGBGamma( fptype* p, int l,
+		const CImageResizerVars& Vars0 )
+	{
+		const int ElCount = Vars0.ElCount;
+		const int ElCountIO = Vars0.ElCountIO;
+		const fptypeatom gm = (fptypeatom) Vars0.OutGammaMult;
+
+		if( ElCountIO == 1 )
+		{
+			while( l > 0 )
+			{
+				fptypeatom* v = (fptypeatom*) p;
+				v[ 0 ] = convertLin2SRGB( v[ 0 ]) * gm;
+				p += ElCount;
+				l--;
+			}
+		}
+		else
+		if( ElCountIO == 4 )
+		{
+			while( l > 0 )
+			{
+				fptypeatom* v = (fptypeatom*) p;
+				v[ 0 ] = convertLin2SRGB( v[ 0 ]) * gm;
+				v[ 1 ] = convertLin2SRGB( v[ 1 ]) * gm;
+				v[ 2 ] = convertLin2SRGB( v[ 2 ]) * gm;
+				v[ 3 ] = convertLin2SRGB( v[ 3 ]) * gm;
+				p += ElCount;
+				l--;
+			}
+		}
+		else
+		if( ElCountIO == 3 )
+		{
+			while( l > 0 )
+			{
+				fptypeatom* v = (fptypeatom*) p;
+				v[ 0 ] = convertLin2SRGB( v[ 0 ]) * gm;
+				v[ 1 ] = convertLin2SRGB( v[ 1 ]) * gm;
+				v[ 2 ] = convertLin2SRGB( v[ 2 ]) * gm;
+				p += ElCount;
+				l--;
+			}
+		}
+		else
+		if( ElCountIO == 2 )
+		{
+			while( l > 0 )
+			{
+				fptypeatom* v = (fptypeatom*) p;
+				v[ 0 ] = convertLin2SRGB( v[ 0 ]) * gm;
+				v[ 1 ] = convertLin2SRGB( v[ 1 ]) * gm;
+				p += ElCount;
+				l--;
+			}
+		}
+	}
+
+	/**
+	 * Function converts vertical scanline to horizontal scanline. This
+	 * function is called by the image resizer when image is resized
+	 * vertically. This means that the vertical scanline is stored in the
+	 * same format produced by the packScanline() and maintained by other
+	 * filtering functions.
+	 *
+	 * @param ip Input vertical scanline.
+	 * @param op Output buffer (temporary buffer used during resizing).
+	 * @param SrcLen The number of pixels in the input scanline, also used to
+	 * calculate input buffer increment.
+	 * @param SrcIncr Input buffer increment to the next vertical pixel.
+	 */
+
+	void convertVtoH( const fptype* ip, fptype* op, const int SrcLen,
+		const int SrcIncr ) const
+	{
+		const int ElCount = Vars -> ElCount;
+		int j;
+
+		if( ElCount == 1 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				ip += SrcIncr;
+				op++;
+			}
+		}
+		else
+		if( ElCount == 4 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				op[ 1 ] = ip[ 1 ];
+				op[ 2 ] = ip[ 2 ];
+				op[ 3 ] = ip[ 3 ];
+				ip += SrcIncr;
+				op += 4;
+			}
+		}
+		else
+		if( ElCount == 3 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				op[ 1 ] = ip[ 1 ];
+				op[ 2 ] = ip[ 2 ];
+				ip += SrcIncr;
+				op += 3;
+			}
+		}
+		else
+		if( ElCount == 2 )
+		{
+			for( j = 0; j < SrcLen; j++ )
+			{
+				op[ 0 ] = ip[ 0 ];
+				op[ 1 ] = ip[ 1 ];
+				ip += SrcIncr;
+				op += 2;
+			}
+		}
+	}
+
+	/**
+	 * Function performs "unpacking" of a scanline and type conversion
+	 * (truncation is used when floating point is converted to integer).
+	 * Scanline, depending on the "fptype" can be potentially stored as a
+	 * packed SIMD values having a certain atomic type. The unpacking function
+	 * assumes that scanline is stored in the style produced by the
+	 * packScanline() function.
+	 *
+	 * @param ip Input scanline.
+	 * @param op Output scanline.
+	 * @param l The number of pixels to "unpack".
+	 * @param Vars0 Image resizing-related variables.
+	 */
+
+	template< class Tout >
+	static void unpackScanline( const fptype* ip, Tout* op, int l,
+		const CImageResizerVars& Vars0 )
+	{
+		const int ElCount = Vars0.ElCount;
+		const int ElCountIO = Vars0.ElCountIO;
+
+		if( ElCountIO == 1 )
+		{
+			while( l > 0 )
+			{
+				const fptypeatom* v = (const fptypeatom*) ip;
+				op[ 0 ] = (Tout) v[ 0 ];
+				ip += ElCount;
+				op++;
+				l--;
+			}
+		}
+		else
+		if( ElCountIO == 4 )
+		{
+			while( l > 0 )
+			{
+				const fptypeatom* v = (const fptypeatom*) ip;
+				op[ 0 ] = (Tout) v[ 0 ];
+				op[ 1 ] = (Tout) v[ 1 ];
+				op[ 2 ] = (Tout) v[ 2 ];
+				op[ 3 ] = (Tout) v[ 3 ];
+				ip += ElCount;
+				op += 4;
+				l--;
+			}
+		}
+		else
+		if( ElCountIO == 3 )
+		{
+			while( l > 0 )
+			{
+				const fptypeatom* v = (const fptypeatom*) ip;
+				op[ 0 ] = (Tout) v[ 0 ];
+				op[ 1 ] = (Tout) v[ 1 ];
+				op[ 2 ] = (Tout) v[ 2 ];
+				ip += ElCount;
+				op += 3;
+				l--;
+			}
+		}
+		else
+		if( ElCountIO == 2 )
+		{
+			while( l > 0 )
+			{
+				const fptypeatom* v = (const fptypeatom*) ip;
+				op[ 0 ] = (Tout) v[ 0 ];
+				op[ 1 ] = (Tout) v[ 1 ];
+				ip += ElCount;
+				op += 2;
+				l--;
+			}
+		}
+	}
+
+	/**
+	 * Function prepares input scanline buffer for *this filtering step.
+	 * Left- and right-most pixels are replicated to make sure no buffer
+	 * overrun happens. Such approach also allows to bypass any pointer
+	 * range checks.
+	 *
+	 * @param Src Source buffer.
+	 */
+
+	void prepareInBuf( fptype* Src ) const
+	{
+		if( IsUpsample || InPrefix + InSuffix == 0 )
+		{
+			return;
+		}
+
+		const int ElCount = Vars -> ElCount;
+		replicateArray( Src, ElCount, Src - ElCount, InPrefix, -ElCount );
+
+		Src += ( InLen - 1 ) * ElCount;
+		replicateArray( Src, ElCount, Src + ElCount, InSuffix, ElCount );
+	}
+
+	/**
+	 * Function peforms scanline upsampling with filtering.
+	 *
+	 * @param Src Source scanline buffer (length = this -> InLen). Source
+	 * scanline increment will be equal to ElCount.
+	 * @param Dst Destination scanline buffer.
+	 */
+
+	void doUpsample( const fptype* const Src, fptype* const Dst ) const
+	{
+		const int ElCount = Vars -> ElCount;
+		fptype* op0 = &Dst[ -OutPrefix * ElCount ];
+		memset( op0, 0, ( OutPrefix + OutLen + OutSuffix ) * ElCount *
+			sizeof( fptype ));
+
+		const fptype* ip = Src;
+		const int opstep = ElCount * ResampleFactor;
+		int l;
+
+		if( FltOrig.getCapacity() > 0 )
+		{
+			// Do not perform filtering, only upsample.
+
+			op0 += ( OutPrefix % ResampleFactor ) * ElCount;
+			l = OutPrefix / ResampleFactor;
+
+			if( ElCount == 1 )
+			{
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0 += opstep;
+					l--;
+				}
+
+				l = InLen - 1;
+
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0 += opstep;
+					ip += ElCount;
+					l--;
+				}
+
+				l = OutSuffix / ResampleFactor;
+
+				while( l >= 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0 += opstep;
+					l--;
+				}
+			}
+			else
+			if( ElCount == 4 )
+			{
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0[ 2 ] = ip[ 2 ];
+					op0[ 3 ] = ip[ 3 ];
+					op0 += opstep;
+					l--;
+				}
+
+				l = InLen - 1;
+
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0[ 2 ] = ip[ 2 ];
+					op0[ 3 ] = ip[ 3 ];
+					op0 += opstep;
+					ip += ElCount;
+					l--;
+				}
+
+				l = OutSuffix / ResampleFactor;
+
+				while( l >= 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0[ 2 ] = ip[ 2 ];
+					op0[ 3 ] = ip[ 3 ];
+					op0 += opstep;
+					l--;
+				}
+			}
+			else
+			if( ElCount == 3 )
+			{
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0[ 2 ] = ip[ 2 ];
+					op0 += opstep;
+					l--;
+				}
+
+				l = InLen - 1;
+
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0[ 2 ] = ip[ 2 ];
+					op0 += opstep;
+					ip += ElCount;
+					l--;
+				}
+
+				l = OutSuffix / ResampleFactor;
+
+				while( l >= 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0[ 2 ] = ip[ 2 ];
+					op0 += opstep;
+					l--;
+				}
+			}
+			else
+			if( ElCount == 2 )
+			{
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0 += opstep;
+					l--;
+				}
+
+				l = InLen - 1;
+
+				while( l > 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0 += opstep;
+					ip += ElCount;
+					l--;
+				}
+
+				l = OutSuffix / ResampleFactor;
+
+				while( l >= 0 )
+				{
+					op0[ 0 ] = ip[ 0 ];
+					op0[ 1 ] = ip[ 1 ];
+					op0 += opstep;
+					l--;
+				}
+			}
+
+			return;
+		}
+
+		const fptype* const f = Flt;
+		const int flen = Flt.getCapacity();
+		fptype* op;
+		int i;
+
+		if( ElCount == 1 )
+		{
+			l = InPrefix;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op++;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+
+			l = InLen - 1;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op++;
+				}
+
+				ip += ElCount;
+				op0 += opstep;
+				l--;
+			}
+
+			l = InSuffix;
+
+			while( l >= 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op++;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 4 )
+		{
+			l = InPrefix;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op[ 2 ] += f[ i ] * ip[ 2 ];
+					op[ 3 ] += f[ i ] * ip[ 3 ];
+					op += 4;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+
+			l = InLen - 1;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op[ 2 ] += f[ i ] * ip[ 2 ];
+					op[ 3 ] += f[ i ] * ip[ 3 ];
+					op += 4;
+				}
+
+				ip += ElCount;
+				op0 += opstep;
+				l--;
+			}
+
+			l = InSuffix;
+
+			while( l >= 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op[ 2 ] += f[ i ] * ip[ 2 ];
+					op[ 3 ] += f[ i ] * ip[ 3 ];
+					op += 4;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 3 )
+		{
+			l = InPrefix;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op[ 2 ] += f[ i ] * ip[ 2 ];
+					op += 3;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+
+			l = InLen - 1;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op[ 2 ] += f[ i ] * ip[ 2 ];
+					op += 3;
+				}
+
+				ip += ElCount;
+				op0 += opstep;
+				l--;
+			}
+
+			l = InSuffix;
+
+			while( l >= 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op[ 2 ] += f[ i ] * ip[ 2 ];
+					op += 3;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 2 )
+		{
+			l = InPrefix;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op += 2;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+
+			l = InLen - 1;
+
+			while( l > 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op += 2;
+				}
+
+				ip += ElCount;
+				op0 += opstep;
+				l--;
+			}
+
+			l = InSuffix;
+
+			while( l >= 0 )
+			{
+				op = op0;
+
+				for( i = 0; i < flen; i++ )
+				{
+					op[ 0 ] += f[ i ] * ip[ 0 ];
+					op[ 1 ] += f[ i ] * ip[ 1 ];
+					op += 2;
+				}
+
+				op0 += opstep;
+				l--;
+			}
+		}
+
+		op = op0;
+		const fptype* dc = SuffixDC;
+		l = SuffixDC.getCapacity();
+
+		if( ElCount == 1 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				dc++;
+				op++;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 4 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				op[ 1 ] += ip[ 1 ] * dc[ 0 ];
+				op[ 2 ] += ip[ 2 ] * dc[ 0 ];
+				op[ 3 ] += ip[ 3 ] * dc[ 0 ];
+				dc++;
+				op += 4;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 3 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				op[ 1 ] += ip[ 1 ] * dc[ 0 ];
+				op[ 2 ] += ip[ 2 ] * dc[ 0 ];
+				dc++;
+				op += 3;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 2 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				op[ 1 ] += ip[ 1 ] * dc[ 0 ];
+				dc++;
+				op += 2;
+				l--;
+			}
+		}
+
+		ip = Src;
+		op = Dst - InPrefix * opstep;
+		dc = PrefixDC;
+		l = PrefixDC.getCapacity();
+
+		if( ElCount == 1 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				dc++;
+				op++;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 4 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				op[ 1 ] += ip[ 1 ] * dc[ 0 ];
+				op[ 2 ] += ip[ 2 ] * dc[ 0 ];
+				op[ 3 ] += ip[ 3 ] * dc[ 0 ];
+				dc++;
+				op += 4;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 3 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				op[ 1 ] += ip[ 1 ] * dc[ 0 ];
+				op[ 2 ] += ip[ 2 ] * dc[ 0 ];
+				dc++;
+				op += 3;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 2 )
+		{
+			while( l > 0 )
+			{
+				op[ 0 ] += ip[ 0 ] * dc[ 0 ];
+				op[ 1 ] += ip[ 1 ] * dc[ 0 ];
+				dc++;
+				op += 2;
+				l--;
+			}
+		}
+	}
+
+	/**
+	 * Function peforms scanline filtering with optional downsampling.
+	 * Function makes use of the symmetry of the filter.
+	 *
+	 * @param Src Source scanline buffer (length = this -> InLen). Source
+	 * scanline increment will be equal to ElCount.
+	 * @param Dst Destination scanline buffer.
+	 * @param DstIncr Destination scanline buffer increment, used for
+	 * horizontal or vertical scanline stepping.
+	 */
+
+	void doFilter( const fptype* const Src, fptype* Dst,
+		const int DstIncr ) const
+	{
+		const int ElCount = Vars -> ElCount;
+		const fptype* const f = &Flt[ FltLatency ];
+		const int flen = FltLatency + 1;
+		const int ipstep = ElCount * ResampleFactor;
+		const fptype* ip = Src - EdgePixelCount * ipstep;
+		const fptype* ip1;
+		const fptype* ip2;
+		int l = OutLen;
+		int i;
+
+		if( ElCount == 1 )
+		{
+			while( l > 0 )
+			{
+				fptype s = f[ 0 ] * ip[ 0 ];
+				ip1 = ip;
+				ip2 = ip;
+
+				for( i = 1; i < flen; i++ )
+				{
+					ip1++;
+					ip2--;
+					s += f[ i ] * ( ip1[ 0 ] + ip2[ 0 ]);
+				}
+
+				Dst[ 0 ] = s;
+				Dst += DstIncr;
+				ip += ipstep;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 4 )
+		{
+			while( l > 0 )
+			{
+				fptype s1 = f[ 0 ] * ip[ 0 ];
+				fptype s2 = f[ 0 ] * ip[ 1 ];
+				fptype s3 = f[ 0 ] * ip[ 2 ];
+				fptype s4 = f[ 0 ] * ip[ 3 ];
+				ip1 = ip;
+				ip2 = ip;
+
+				for( i = 1; i < flen; i++ )
+				{
+					ip1 += 4;
+					ip2 -= 4;
+					s1 += f[ i ] * ( ip1[ 0 ] + ip2[ 0 ]);
+					s2 += f[ i ] * ( ip1[ 1 ] + ip2[ 1 ]);
+					s3 += f[ i ] * ( ip1[ 2 ] + ip2[ 2 ]);
+					s4 += f[ i ] * ( ip1[ 3 ] + ip2[ 3 ]);
+				}
+
+				Dst[ 0 ] = s1;
+				Dst[ 1 ] = s2;
+				Dst[ 2 ] = s3;
+				Dst[ 3 ] = s4;
+				Dst += DstIncr;
+				ip += ipstep;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 3 )
+		{
+			while( l > 0 )
+			{
+				fptype s1 = f[ 0 ] * ip[ 0 ];
+				fptype s2 = f[ 0 ] * ip[ 1 ];
+				fptype s3 = f[ 0 ] * ip[ 2 ];
+				ip1 = ip;
+				ip2 = ip;
+
+				for( i = 1; i < flen; i++ )
+				{
+					ip1 += 3;
+					ip2 -= 3;
+					s1 += f[ i ] * ( ip1[ 0 ] + ip2[ 0 ]);
+					s2 += f[ i ] * ( ip1[ 1 ] + ip2[ 1 ]);
+					s3 += f[ i ] * ( ip1[ 2 ] + ip2[ 2 ]);
+				}
+
+				Dst[ 0 ] = s1;
+				Dst[ 1 ] = s2;
+				Dst[ 2 ] = s3;
+				Dst += DstIncr;
+				ip += ipstep;
+				l--;
+			}
+		}
+		else
+		if( ElCount == 2 )
+		{
+			while( l > 0 )
+			{
+				fptype s1 = f[ 0 ] * ip[ 0 ];
+				fptype s2 = f[ 0 ] * ip[ 1 ];
+				ip1 = ip;
+				ip2 = ip;
+
+				for( i = 1; i < flen; i++ )
+				{
+					ip1 += 2;
+					ip2 -= 2;
+					s1 += f[ i ] * ( ip1[ 0 ] + ip2[ 0 ]);
+					s2 += f[ i ] * ( ip1[ 1 ] + ip2[ 1 ]);
+				}
+
+				Dst[ 0 ] = s1;
+				Dst[ 1 ] = s2;
+				Dst += DstIncr;
+				ip += ipstep;
+				l--;
+			}
+		}
+	}
+
+	/**
+	 * Function performs resizing of a single scanline. This function does
+	 * not "know" about the length of the source scanline buffer. This buffer
+	 * should be padded with enough pixels so that ( SrcPos - FilterLenD2 ) is
+	 * always >= 0 and ( SrcPos + ( DstLineLen - 1 ) * k + FilterLenD2 + 1 )
+	 * does not exceed source scanline's buffer length. SrcLine's increment is
+	 * assumed to be equal to ElCount.
+	 *
+	 * @param SrcLine Source scanline buffer.
+	 * @param DstLine Destination (resized) scanline buffer.
+	 * @param DstLineIncr Destination scanline position increment, used for
+	 * horizontal or vertical scanline stepping.
+	 * @param xx Temporary buffer, of size FltBank -> getFilterLen(), must be
+	 * aligned by fpclass :: fpalign.
+	 */
+
+	void doResize( const fptype* SrcLine, fptype* DstLine,
+		const int DstLineIncr, fptype* const ) const
+	{
+		const int IntFltLen = FltBank -> getFilterLen();
+		const int ElCount = Vars -> ElCount;
+		const typename CImageResizerFilterStep< fptype, fptypeatom > ::
+			CResizePos* rpos = &(*RPosBuf)[ 0 ];
+
+		int DstLineLen = OutLen;
+
+#define AVIR_RESIZE_PART1 \
+			while( DstLineLen > 0 ) \
+			{ \
+				const fptype x = (fptype) rpos -> x; \
+				const fptype* ftp = rpos -> ftp; \
+				const fptype* Src = SrcLine + rpos -> SrcOffs; \
+				int l = IntFltLen;
+
+#define AVIR_RESIZE_PART1nx \
+			while( DstLineLen > 0 ) \
+			{ \
+				const fptype* ftp = rpos -> ftp; \
+				const fptype* Src = SrcLine + rpos -> SrcOffs; \
+				int l = IntFltLen;
+
+#define AVIR_RESIZE_PART2 \
+				DstLineLen--; \
+				DstLine += DstLineIncr; \
+				rpos++; \
+			}
+
+		if( FltBank -> getOrder() == 1 )
+		{
+			if( ElCount == 1 )
+			{
+				AVIR_RESIZE_PART1
+
+				fptype sum = 0.0;
+
+				while( l > 0 )
+				{
+					sum += ( ftp[ 0 ] + ftp[ IntFltLen ] * x ) * Src[ 0 ];
+					ftp++;
+					Src++;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum;
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			if( ElCount == 4 )
+			{
+				AVIR_RESIZE_PART1
+
+				fptype sum[ 4 ];
+				sum[ 0 ] = 0.0;
+				sum[ 1 ] = 0.0;
+				sum[ 2 ] = 0.0;
+				sum[ 3 ] = 0.0;
+
+				while( l > 0 )
+				{
+					const fptype xx = ftp[ 0 ] + ftp[ IntFltLen ] * x;
+					sum[ 0 ] += xx * Src[ 0 ];
+					sum[ 1 ] += xx * Src[ 1 ];
+					sum[ 2 ] += xx * Src[ 2 ];
+					sum[ 3 ] += xx * Src[ 3 ];
+					ftp++;
+					Src += 4;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum[ 0 ];
+				DstLine[ 1 ] = sum[ 1 ];
+				DstLine[ 2 ] = sum[ 2 ];
+				DstLine[ 3 ] = sum[ 3 ];
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			if( ElCount == 3 )
+			{
+				AVIR_RESIZE_PART1
+
+				fptype sum[ 3 ];
+				sum[ 0 ] = 0.0;
+				sum[ 1 ] = 0.0;
+				sum[ 2 ] = 0.0;
+
+				while( l > 0 )
+				{
+					const fptype xx = ftp[ 0 ] + ftp[ IntFltLen ] * x;
+					sum[ 0 ] += xx * Src[ 0 ];
+					sum[ 1 ] += xx * Src[ 1 ];
+					sum[ 2 ] += xx * Src[ 2 ];
+					ftp++;
+					Src += 3;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum[ 0 ];
+				DstLine[ 1 ] = sum[ 1 ];
+				DstLine[ 2 ] = sum[ 2 ];
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			if( ElCount == 2 )
+			{
+				AVIR_RESIZE_PART1
+
+				fptype sum[ 2 ];
+				sum[ 0 ] = 0.0;
+				sum[ 1 ] = 0.0;
+
+				while( l > 0 )
+				{
+					const fptype xx = ftp[ 0 ] + ftp[ IntFltLen ] * x;
+					sum[ 0 ] += xx * Src[ 0 ];
+					sum[ 1 ] += xx * Src[ 1 ];
+					ftp++;
+					Src += 2;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum[ 0 ];
+				DstLine[ 1 ] = sum[ 1 ];
+
+				AVIR_RESIZE_PART2
+			}
+		}
+		else
+		{
+			if( ElCount == 1 )
+			{
+				AVIR_RESIZE_PART1nx
+
+				fptype sum = 0.0;
+
+				while( l > 0 )
+				{
+					sum += ftp[ 0 ] * Src[ 0 ];
+					ftp++;
+					Src++;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum;
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			if( ElCount == 4 )
+			{
+				AVIR_RESIZE_PART1nx
+
+				fptype sum[ 4 ];
+				sum[ 0 ] = 0.0;
+				sum[ 1 ] = 0.0;
+				sum[ 2 ] = 0.0;
+				sum[ 3 ] = 0.0;
+
+				while( l > 0 )
+				{
+					const fptype xx = ftp[ 0 ];
+					sum[ 0 ] += xx * Src[ 0 ];
+					sum[ 1 ] += xx * Src[ 1 ];
+					sum[ 2 ] += xx * Src[ 2 ];
+					sum[ 3 ] += xx * Src[ 3 ];
+					ftp++;
+					Src += 4;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum[ 0 ];
+				DstLine[ 1 ] = sum[ 1 ];
+				DstLine[ 2 ] = sum[ 2 ];
+				DstLine[ 3 ] = sum[ 3 ];
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			if( ElCount == 3 )
+			{
+				AVIR_RESIZE_PART1nx
+
+				fptype sum[ 3 ];
+				sum[ 0 ] = 0.0;
+				sum[ 1 ] = 0.0;
+				sum[ 2 ] = 0.0;
+
+				while( l > 0 )
+				{
+					const fptype xx = ftp[ 0 ];
+					sum[ 0 ] += xx * Src[ 0 ];
+					sum[ 1 ] += xx * Src[ 1 ];
+					sum[ 2 ] += xx * Src[ 2 ];
+					ftp++;
+					Src += 3;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum[ 0 ];
+				DstLine[ 1 ] = sum[ 1 ];
+				DstLine[ 2 ] = sum[ 2 ];
+
+				AVIR_RESIZE_PART2
+			}
+			else
+			if( ElCount == 2 )
+			{
+				AVIR_RESIZE_PART1nx
+
+				fptype sum[ 2 ];
+				sum[ 0 ] = 0.0;
+				sum[ 1 ] = 0.0;
+
+				while( l > 0 )
+				{
+					const fptype xx = ftp[ 0 ];
+					sum[ 0 ] += xx * Src[ 0 ];
+					sum[ 1 ] += xx * Src[ 1 ];
+					ftp++;
+					Src += 2;
+					l--;
+				}
+
+				DstLine[ 0 ] = sum[ 0 ];
+				DstLine[ 1 ] = sum[ 1 ];
+
+				AVIR_RESIZE_PART2
+			}
+		}
+	}
+#undef AVIR_RESIZE_PART2
+#undef AVIR_RESIZE_PART1nx
+#undef AVIR_RESIZE_PART1
+};
+
+/**
+ * @brief Image resizer's default dithering class.
+ *
+ * This class defines an object that performs rounding, clipping and dithering
+ * operations over horizontal scanline pixels before scanline is stored in the
+ * output buffer.
+ *
+ * The ditherer should expect the same storage order of the pixels in a
+ * scanline as used in the "filtering step" class. So, a separate ditherer
+ * class should be defined for each scanline pixel storage style. The default
+ * ditherer implements a simple rounding without dithering: it can be used for
+ * an efficient dithering method which can be multi-threaded.
+ *
+ * @tparam fptype Floating point type to use for storing pixel data. SIMD
+ * types can be used.
+ */
+
+template< class fptype >
+class CImageResizerDithererDefINL
+{
+public:
+	/**
+	 * Function initializes the ditherer object.
+	 *
+	 * @param aLen Scanline length in pixels to process.
+	 * @param aVars Image resizing-related variables.
+	 * @param aTrMul Bit-depth truncation multiplier. 1 - no additional
+	 * truncation.
+	 * @param aPkOut Peak output value allowed.
+	 */
+
+	void init( const int aLen, const CImageResizerVars& aVars,
+		const double aTrMul, const double aPkOut )
+	{
+		Len = aLen;
+		Vars = &aVars;
+		LenE = aLen * Vars -> ElCount;
+		TrMul0 = aTrMul;
+		PkOut0 = aPkOut;
+	}
+
+	/**
+	 * @return "True" if dithering is recursive relative to scanlines meaning
+	 * multi-threaded execution is not supported by this dithering method.
+	 */
+
+	static bool isRecursive()
+	{
+		return( false );
+	}
+
+	/**
+	 * Function performs rounding and clipping operations.
+	 *
+	 * @param ResScanline The buffer containing the final scanline.
+	 */
+
+	void dither( fptype* const ResScanline ) const
+	{
+		const fptype c0 = 0.0;
+		const fptype TrMul = (fptype) TrMul0;
+		const fptype PkOut = (fptype) PkOut0;
+		int j;
+
+		for( j = 0; j < LenE; j++ )
+		{
+			const fptype z0 = round( ResScanline[ j ] / TrMul ) * TrMul;
+			ResScanline[ j ] = clamp( z0, c0, PkOut );
+		}
+	}
+
+protected:
+	int Len; ///< Scanline's length in pixels.
+		///<
+	const CImageResizerVars* Vars; ///< Image resizing-related variables.
+		///<
+	int LenE; ///< = LenE * ElCount.
+		///<
+	double TrMul0; ///< Bit-depth truncation multiplier.
+		///<
+	double PkOut0; ///< Peak output value allowed.
+		///<
+};
+
+/**
+ * @brief Image resizer's quasi-random dithering class, interleaved mode.
+ *
+ * This ditherer implements a classic quasi-random dithering which looks OK
+ * and whose results are compressed by PNG well.
+ *
+ * @tparam fptype Floating point type to use for storing pixel data. SIMD
+ * types can be used.
+ */
+
+template< class fptype >
+class CImageResizerDithererQRndINL :
+	public CImageResizerDithererDefINL< fptype >
+{
+public:
+	/**
+	 * Function initializes the ditherer object.
+	 *
+	 * @param aLen Scanline length in pixels to process.
+	 * @param aVars Image resizing-related variables.
+	 * @param aTrMul Bit-depth truncation multiplier. 1 - no additional
+	 * truncation.
+	 * @param aPkOut Peak output value allowed.
+	 */
+
+	void init( const int aLen, const CImageResizerVars& aVars,
+		const double aTrMul, const double aPkOut )
+	{
+		CImageResizerDithererDefINL< fptype > :: init( aLen, aVars, aTrMul,
+			aPkOut );
+
+		ResScanlineDith0.alloc( LenE + Vars -> ElCount, sizeof( fptype ));
+		ResScanlineDith = ResScanlineDith0 + Vars -> ElCount;
+		int i;
+
+		for( i = 0; i < LenE + Vars -> ElCount; i++ )
+		{
+			ResScanlineDith0[ i ] = 0.0;
+		}
+	}
+
+	static bool isRecursive()
+	{
+		return( true );
+	}
+
+	void dither( fptype* const ResScanline )
+	{
+		const int ElCount = Vars -> ElCount;
+		const fptype c0 = 0.0;
+		const fptype TrMul = (fptype) TrMul0;
+		const fptype PkOut = (fptype) PkOut0;
+		int j;
+
+		for( j = 0; j < LenE; j++ )
+		{
+			ResScanline[ j ] += ResScanlineDith[ j ];
+			ResScanlineDith[ j ] = 0.0;
+		}
+
+		for( j = 0; j < LenE - ElCount; j++ )
+		{
+			// Perform rounding, noise estimation and saturation.
+
+			const fptype z0 = round( ResScanline[ j ] / TrMul ) * TrMul;
+			const fptype Noise = ResScanline[ j ] - z0;
+			ResScanline[ j ] = clamp( z0, c0, PkOut );
+
+			ResScanline[ j + ElCount ] += Noise * (fptype) 0.4375;
+			ResScanlineDith[ j + ElCount ] += Noise * (fptype) 0.0625;
+			ResScanlineDith[ j ] += Noise * (fptype) 0.3125;
+			ResScanlineDith[ j - ElCount ] += Noise * (fptype) 0.1875;
+		}
+
+		while( j < LenE )
+		{
+			const fptype z0 = round( ResScanline[ j ] / TrMul ) * TrMul;
+			const fptype Noise = ResScanline[ j ] - z0;
+			ResScanline[ j ] = clamp( z0, c0, PkOut );
+
+			ResScanlineDith[ j ] += Noise * (fptype) 0.3125;
+			ResScanlineDith[ j - ElCount ] += Noise * (fptype) 0.1875;
+			j++;
+		}
+	}
+
+protected:
+	using CImageResizerDithererDefINL< fptype > :: Len;
+	using CImageResizerDithererDefINL< fptype > :: Vars;
+	using CImageResizerDithererDefINL< fptype > :: LenE;
+	using CImageResizerDithererDefINL< fptype > :: TrMul0;
+	using CImageResizerDithererDefINL< fptype > :: PkOut0;
+
+	CBuffer< fptype > ResScanlineDith0; ///< Error propagation buffer for
+		///< dithering, first pixel unused.
+		///<
+	fptype* ResScanlineDith; ///< Error propagation buffer pointer which skips
+		///< the first ElCount elements.
+		///<
+};
+
+/**
+ * @brief Floating-point processing state reset class.
+ *
+ * This class implements type-dependent floating-point processing reset
+ * function which gets called at the end of the image resizing function. Such
+ * reset is usually required to switch from SSE to FPU mode, or otherwise to
+ * switch to a mode most probably expected by the caller. Default
+ * implementation does nothing.
+ */
+
+template< class fptype >
+struct fpclass_reset
+{
+	/**
+	 * Function performs floating-point processing state reset.
+	 */
+
+	static void reset()
+	{
+	}
+};
+
+/**
+ * @brief Floating-point processing definition and abstraction class.
+ *
+ * This class defines several constants and typedefs that point to classes
+ * that should be used by the image resizing algorithm. Such "definition
+ * class" can be used to define alternative scanline processing algorithms
+ * (e.g. SIMD) and image scanline packing styles used during processing. This
+ * class also offers an abstraction layer for dithering, rounding and
+ * clamping (saturation) operation.
+ * 
+ * The fpclass_def class can be used to define processing using both SIMD and
+ * non-SIMD types, but using algorithms that are operate on interleaved pixels
+ * and non-SIMD optimized themselves.
+ *
+ * @tparam afptype Floating point type to use for storing intermediate data
+ * and variables. For variables that are not used in intensive calculations
+ * the "double" type is always used. On the latest Intel processors (like
+ * i7-4770K) there is almost no performance difference between "double" and
+ * "float". Image quality differences between "double" and "float" are not
+ * apparent on 8-bit images. At the same time the "float" uses half amount of
+ * working memory the "double" type uses. SIMD types can be used. The
+ * functions round() and clamp() in the "avir" or other visible namespace
+ * should be available for the specified type. SIMD types allow to perform
+ * resizing of images with more than 4 channels, to be exact 4 * SIMD element
+ * number (e.g. 16 for float4), without modification of the image resizing
+ * algorithm required.
+ * @tparam afptypeatom The atomic type the "afptype" consists of.
+ * @tparam adith Ditherer class to use during processing.
+ */
+
+template< class afptype, class afptypeatom = afptype,
+	class adith = CImageResizerDithererDefINL< afptype > >
+class fpclass_def
+{
+public:
+	typedef afptype fptype; ///< Floating-point type to use during processing.
+		///<
+	typedef afptypeatom fptypeatom; ///< Atomic type "fptype" consists of.
+		///<
+	static const int fppack = sizeof( fptype ) / sizeof( fptypeatom ); ///<
+		///< The number of atomic types stored in a single "fptype" element.
+		///<
+	static const int fpalign = sizeof( fptype ); ///< Suggested alignment size
+		///< in bytes. This is not a required alignment, because image
+		///< resizing algorithm cannot be made to have a strictly aligned data
+		///< access at all steps (e.g. interpolation cannot perform aligned
+		///< accesses).
+		///<
+	static const int elalign = 1; ///< Length alignment of arrays of elements.
+		///< This applies to filters and intermediate buffers: this constant
+		///< forces filters and scanlines to have a length which is a multiple
+		///< of this value, for more efficient SIMD implementation. Value
+		///< different to 1 also means image pixels are de-interleaved during
+		///< processing.
+		///<
+	typedef CImageResizerFilterStepINL< fptype, fptypeatom > CFilterStep; ///<
+		///< Filtering step class to use during processing.
+		///<
+	typedef adith CDitherer; ///< Ditherer class to use during processing.
+		///<
+	typedef fpclass_reset< fptype > CReset; ///< Floating-point processing
+		///< reset implementation class.
+		///<
+};
+
+/**
+ * @brief Image resizer class.
+ *
+ * The object of this class can be used to resize 1-4 channel images to any
+ * required size. Resizing is performed by utilizing interpolated sinc
+ * fractional delay filters plus (if necessary) a cascade of built-in
+ * sinc function-based 2X upsampling or 2X downsampling stages, followed by a
+ * correction filtering.
+ *
+ * Object of this class can be allocated on stack.
+ *
+ * @tparam fpclass Floating-point processing definition class to use. See
+ * avir::fpclass_def for more details.
+ */
+
+template< class fpclass = fpclass_def< float > >
+class CImageResizer
+{
+public:
+	/**
+	 * Constructor initializes the resizer.
+	 *
+	 * @param aResBitDepth Required bit depth of resulting image (4-16). If
+	 * integer value output is used (e.g. uint8_t), the bit depth also affects
+	 * rounding: for example, if aResBitDepth=6 and "Tout" is uint8_t, the
+	 * result will be rounded to 6 most significant bits (2 least significant
+	 * bits truncated, with dithering applied). The source image may have any
+	 * real bit-depth: if this image was correctly dithered, during downsizing
+	 * its bit-depth will increase proportionally to the downsizing factor.
+	 * @param aSrcBitDepth Source image's real bit-depth. Set to 0 to use
+	 * aResBitDepth.
+	 * @param aParams Resizing algorithm's parameters to use. Leave out for
+	 * default values. Can be useful when performing automatic optimization of
+	 * parameters.
+	 */
+
+	CImageResizer( const int aResBitDepth = 8, const int aSrcBitDepth = 0,
+		const CImageResizerParams& aParams = CImageResizerParamsDef() )
+		: Params( aParams )
+		, ResBitDepth( aResBitDepth )
+	{
+		SrcBitDepth = ( aSrcBitDepth == 0 ? ResBitDepth : aSrcBitDepth );
+
+		initFilterBank( FixedFilterBank, 1.0, false, CFltBuffer() );
+		FixedFilterBank.createAllFilters();
+	}
+
+	/**
+	 * Function resizes image.
+	 *
+	 * @param SrcBuf Source image buffer.
+	 * @param SrcWidth Source image width.
+	 * @param SrcHeight Source image height.
+	 * @param SrcScanlineSize Physical size of source scanline in elements. If
+	 * this value is below 1, SrcWidth * ElCountIO will be used as the
+	 * physical source scanline size.
+	 * @param[out] NewBuf Buffer to accept the resized image. Can be equal to
+	 * SrcBuf if the size of the resized image is smaller or equal to source
+	 * image in size.
+	 * @param NewWidth New image width.
+	 * @param NewHeight New image height.
+	 * @param ElCountIO The number of elements (channels) used to store each
+	 * source and destination pixel (1-4).
+	 * @param k Resizing step (one output pixel corresponds to "k" input
+	 * pixels). A downsizing factor if > 1.0; upsizing factor if <= 1.0.
+	 * Multiply by -1 if you would like to bypass "ox" and "oy" adjustment
+	 * which is done by default to produce a centered image. If step value
+	 * equals 0, the step size will be chosen automatically and independently
+	 * for horizontal and vertical resizing.
+	 * @param[in,out] aVars Pointer to variables to be passed to the image
+	 * resizing function. Can be NULL. Only variables that are initialized in
+	 * default constructor are accepted by this function. These variables will
+	 * not be changed by this function. All other variables can be modified by
+	 * this function. The access to this object is not thread-safe, each
+	 * concurrent instance of this function should use a separate aVars
+	 * object.
+	 * @tparam Tin Input buffer element's type. Can be uint8_t (0-255 value
+	 * range), uint16_t (0-65535 value range), float (0.0-1.0 value range),
+	 * double (0.0-1.0 value range). Larger integer types are treated as
+	 * uint16_t. Signed integer types are unsupported.
+	 * @tparam Tout Output buffer element's type. Can be uint8_t (0-255 value
+	 * range), uint16_t (0-65535 value range), float (0.0-1.0 value range),
+	 * double (0.0-1.0 value range). Larger integer types are treated as
+	 * uint16_t. Signed integer types are unsupported.
+	 */
+
+	template< class Tin, class Tout >
+	void resizeImage( const Tin* const SrcBuf, const int SrcWidth,
+		const int SrcHeight, int SrcScanlineSize, Tout* const NewBuf,
+		const int NewWidth, const int NewHeight, const int ElCountIO,
+		const double k, CImageResizerVars* const aVars = NULL ) const
+	{
+		if( SrcWidth == 0 || SrcHeight == 0 )
+		{
+			memset( NewBuf, 0, NewWidth * NewHeight * sizeof( Tout ));
+			return;
+		}
+		else
+		if( NewWidth == 0 || NewHeight == 0 )
+		{
+			return;
+		}
+
+		CImageResizerVars DefVars;
+		CImageResizerVars& Vars = ( aVars == NULL ? DefVars : *aVars );
+
+		CImageResizerThreadPool DefThreadPool;
+		CImageResizerThreadPool& ThreadPool = ( Vars.ThreadPool == NULL ?
+			DefThreadPool : *Vars.ThreadPool );
+
+		// Define resizing steps, also optionally modify offsets so that
+		// resizing produces a "centered" image.
+
+		double kx;
+		double ky;
+		double ox = Vars.ox;
+		double oy = Vars.oy;
+
+		if( k == 0.0 )
+		{
+			if( NewWidth > SrcWidth )
+			{
+				kx = (double) SrcWidth /
+					( NewWidth + ( (double) NewWidth / SrcWidth - 1.0 ));
+			}
+			else
+			{
+				kx = (double) SrcWidth / NewWidth;
+				ox += ( kx - 1.0 ) * 0.5;
+			}
+
+			if( NewHeight > SrcHeight )
+			{
+				ky = (double) SrcHeight /
+					( NewHeight + ( (double) NewHeight / SrcHeight - 1.0 ));
+			}
+			else
+			{
+				ky = (double) SrcHeight / NewHeight;
+				oy += ( ky - 1.0 ) * 0.5;
+			}
+		}
+		else
+		if( k > 0.0 )
+		{
+			kx = k;
+			ky = k;
+
+			if( k > 1.0 )
+			{
+				const double ko = ( k - 1.0 ) * 0.5;
+				ox += ko;
+				oy += ko;
+			}
+		}
+		else
+		{
+			kx = -k;
+			ky = -k;
+		}
+
+		// Evaluate pre-multipliers used on the output stage.
+
+		const bool IsInFloat = ( (Tin) 0.4 != 0 );
+		const bool IsOutFloat = ( (Tout) 0.4 != 0 );
+		double OutMul; // Output multiplier.
+
+		if( Vars.UseSRGBGamma )
+		{
+			if( IsInFloat )
+			{
+				Vars.InGammaMult = 1.0;
+			}
+			else
+			{
+				Vars.InGammaMult =
+					1.0 / ( sizeof( Tin ) == 1 ? 255.0 : 65535.0 );
+			}
+
+			if( IsOutFloat )
+			{
+				Vars.OutGammaMult = 1.0;
+			}
+			else
+			{
+				Vars.OutGammaMult = ( sizeof( Tout ) == 1 ? 255.0 : 65535.0 );
+			}
+
+			OutMul = 1.0;
+		}
+		else
+		{
+			if( IsOutFloat )
+			{
+				OutMul = 1.0;
+			}
+			else
+			{
+				OutMul = ( sizeof( Tout ) == 1 ? 255.0 : 65535.0 );
+			}
+
+			if( !IsInFloat )
+			{
+				OutMul /= ( sizeof( Tin ) == 1 ? 255.0 : 65535.0 );
+			}
+		}
+
+		// Fill widely-used variables.
+
+		const int ElCount = ( ElCountIO + fpclass :: fppack - 1 ) /
+			fpclass :: fppack;
+
+		const int NewWidthE = NewWidth * ElCount;
+
+		if( SrcScanlineSize < 1 )
+		{
+			SrcScanlineSize = SrcWidth * ElCountIO;
+		}
+
+		Vars.ElCount = ElCount;
+		Vars.ElCountIO = ElCountIO;
+		Vars.fppack = fpclass :: fppack;
+		Vars.fpalign = fpclass :: fpalign;
+		Vars.elalign = fpclass :: elalign;
+
+		// Horizontal scanline filtering and resizing.
+
+		CDSPFracFilterBankLin< fptype > FltBank;
+		CFilterSteps FltSteps;
+		typename CFilterStep :: CRPosBufArray RPosBufArray;
+		CBuffer< uint8_t > UsedFracMap;
+
+		// Perform the filtering steps modeling at various modes, find the
+		// most efficient mode for both horizontal and vertical resizing.
+
+		int UseBuildMode = 1;
+		const int BuildModeCount =
+			( FixedFilterBank.getOrder() == 0 ? 4 : 2 );
+
+		int m;
+
+		if( Vars.BuildMode >= 0 )
+		{
+			UseBuildMode = Vars.BuildMode;
+		}
+		else
+		{
+			int BestScore = 0x7FFFFFFF;
+
+			for( m = 0; m < BuildModeCount; m++ )
+			{
+				CDSPFracFilterBankLin< fptype > TmpBank;
+				CFilterSteps TmpSteps;
+				Vars.k = kx;
+				Vars.o = ox;
+				buildFilterSteps( TmpSteps, Vars, TmpBank, OutMul, m, true );
+				updateFilterStepBuffers( TmpSteps, Vars, RPosBufArray,
+					SrcWidth, NewWidth );
+
+				fillUsedFracMap( TmpSteps[ Vars.ResizeStep ], UsedFracMap );
+				const int c = calcComplexity( TmpSteps, Vars, UsedFracMap,
+					SrcHeight );
+
+				if( c < BestScore )
+				{
+					UseBuildMode = m;
+					BestScore = c;
+				}
+			}
+		}
+
+		// Perform the actual filtering steps building.
+
+		Vars.k = kx;
+		Vars.o = ox;
+		buildFilterSteps( FltSteps, Vars, FltBank, OutMul, UseBuildMode,
+			false );
+
+		updateFilterStepBuffers( FltSteps, Vars, RPosBufArray, SrcWidth,
+			NewWidth );
+
+		updateBufLenAndRPosPtrs( FltSteps, Vars, NewWidth );
+
+		const int ThreadCount = ThreadPool.getSuggestedWorkloadCount();
+			// Includes the current thread.
+
+		CStructArray< CThreadData< Tin, Tout > > td;
+		td.setItemCount( ThreadCount );
+		int i;
+
+		for( i = 0; i < ThreadCount; i++ )
+		{
+			if( i > 0 )
+			{
+				ThreadPool.addWorkload( &td[ i ]);
+			}
+
+			td[ i ].init( i, ThreadCount, FltSteps, Vars );
+
+			td[ i ].initScanlineQueue( td[ i ].sopResizeH, SrcHeight,
+				SrcWidth );
+		}
+
+		CBuffer< fptype > FltBuf( NewWidthE * SrcHeight, fpclass :: fpalign );
+			// Temporary buffer that receives horizontally-filtered and
+			// resized image.
+
+		for( i = 0; i < SrcHeight; i++ )
+		{
+			td[ i % ThreadCount ].addScanlineToQueue(
+				(void*) &SrcBuf[ i * SrcScanlineSize ],
+				&FltBuf[ i * NewWidthE ]);
+		}
+
+		ThreadPool.startAllWorkloads();
+		td[ 0 ].processScanlineQueue();
+		ThreadPool.waitAllWorkloadsToFinish();
+
+		// Vertical scanline filtering and resizing, reuse previously defined
+		// filtering steps if possible.
+
+		const int PrevUseBuildMode = UseBuildMode;
+
+		if( Vars.BuildMode >= 0 )
+		{
+			UseBuildMode = Vars.BuildMode;
+		}
+		else
+		{
+			CImageResizerVars TmpVars( Vars );
+			int BestScore = 0x7FFFFFFF;
+
+			for( m = 0; m < BuildModeCount; m++ )
+			{
+				CDSPFracFilterBankLin< fptype > TmpBank;
+				TmpBank.copyInitParams( FltBank );
+				CFilterSteps TmpSteps;
+				TmpVars.k = ky;
+				TmpVars.o = oy;
+				buildFilterSteps( TmpSteps, TmpVars, TmpBank, 1.0, m, true );
+				updateFilterStepBuffers( TmpSteps, TmpVars, RPosBufArray,
+					SrcHeight, NewHeight );
+
+				fillUsedFracMap( TmpSteps[ TmpVars.ResizeStep ],
+					UsedFracMap );
+
+				const int c = calcComplexity( TmpSteps, TmpVars, UsedFracMap,
+					NewWidth );
+
+				if( c < BestScore )
+				{
+					UseBuildMode = m;
+					BestScore = c;
+				}
+			}
+		}
+
+		Vars.k = ky;
+		Vars.o = oy;
+
+		if( UseBuildMode == PrevUseBuildMode && ky == kx )
+		{
+			if( OutMul != 1.0 )
+			{
+				modifyCorrFilterDCGain( FltSteps, 1.0 / OutMul );
+			}
+		}
+		else
+		{
+			buildFilterSteps( FltSteps, Vars, FltBank, 1.0, UseBuildMode,
+				false );
+		}
+
+		updateFilterStepBuffers( FltSteps, Vars, RPosBufArray, SrcHeight,
+			NewHeight );
+
+		updateBufLenAndRPosPtrs( FltSteps, Vars, NewWidth );
+
+		if( IsOutFloat && sizeof( FltBuf[ 0 ]) == sizeof( Tout ) &&
+			fpclass :: elalign == 1 )
+		{
+			// In-place output.
+
+			for( i = 0; i < ThreadCount; i++ )
+			{
+				td[ i ].initScanlineQueue( td[ i ].sopResizeV, NewWidth,
+					SrcHeight, NewWidthE, NewWidthE );
+			}
+
+			for( i = 0; i < NewWidth; i++ )
+			{
+				td[ i % ThreadCount ].addScanlineToQueue(
+					&FltBuf[ i * ElCount ], (fptype*) &NewBuf[ i * ElCount ]);
+			}
+
+			ThreadPool.startAllWorkloads();
+			td[ 0 ].processScanlineQueue();
+			ThreadPool.waitAllWorkloadsToFinish();
+			ThreadPool.removeAllWorkloads();
+
+			fpclass :: CReset :: reset();
+			return;
+		}
+
+		CBuffer< fptype > ResBuf( NewWidthE * NewHeight, fpclass :: fpalign );
+
+		for( i = 0; i < ThreadCount; i++ )
+		{
+			td[ i ].initScanlineQueue( td[ i ].sopResizeV, NewWidth,
+				SrcHeight, NewWidthE, NewWidthE );
+		}
+
+		const int im = ( fpclass :: elalign == 1 ? ElCount : 1 );
+
+		for( i = 0; i < NewWidth; i++ )
+		{
+			td[ i % ThreadCount ].addScanlineToQueue( &FltBuf[ i * im ],
+				&ResBuf[ i * im ]);
+		}
+
+		ThreadPool.startAllWorkloads();
+		td[ 0 ].processScanlineQueue();
+		ThreadPool.waitAllWorkloadsToFinish();
+
+		if( IsOutFloat )
+		{
+			// Perform output, but skip dithering.
+
+			for( i = 0; i < ThreadCount; i++ )
+			{
+				td[ i ].initScanlineQueue( td[ i ].sopUnpackH,
+					NewHeight, NewWidth );
+			}
+
+			for( i = 0; i < NewHeight; i++ )
+			{
+				td[ i % ThreadCount ].addScanlineToQueue(
+					&ResBuf[ i * NewWidthE ],
+					&NewBuf[ i * NewWidth * ElCountIO ]);
+			}
+
+			ThreadPool.startAllWorkloads();
+			td[ 0 ].processScanlineQueue();
+			ThreadPool.waitAllWorkloadsToFinish();
+			ThreadPool.removeAllWorkloads();
+
+			fpclass :: CReset :: reset();
+			return;
+		}
+
+		// Perform output with dithering (for integer output only).
+
+		int TruncBits; // The number of lower bits to truncate and dither.
+		double PkOut;
+
+		if( sizeof( Tout ) == 1 )
+		{
+			TruncBits = 8 - ResBitDepth;
+			PkOut = 255.0;
+		}
+		else
+		{
+			TruncBits = 16 - ResBitDepth;
+			PkOut = 65535.0;
+		}
+
+		const double TrMul = (fptype) ( TruncBits > 0 ? 1 << TruncBits : 1 );
+
+		if( CDitherer :: isRecursive() )
+		{
+			td[ 0 ].getDitherer().init( NewWidth, Vars, TrMul, PkOut );
+
+			if( Vars.UseSRGBGamma )
+			{
+				for( i = 0; i < NewHeight; i++ )
+				{
+					fptype* const ResScanline = &ResBuf[ i * NewWidthE ];
+
+					CFilterStep :: applySRGBGamma( ResScanline, NewWidth,
+						Vars );
+
+					td[ 0 ].getDitherer().dither( ResScanline );
+
+					CFilterStep :: unpackScanline( ResScanline,
+						&NewBuf[ i * NewWidth * ElCountIO ], NewWidth, Vars );
+				}
+			}
+			else
+			{
+				for( i = 0; i < NewHeight; i++ )
+				{
+					fptype* const ResScanline = &ResBuf[ i * NewWidthE ];
+
+					td[ 0 ].getDitherer().dither( ResScanline );
+
+					CFilterStep :: unpackScanline( ResScanline,
+						&NewBuf[ i * NewWidth * ElCountIO ], NewWidth, Vars );
+				}
+			}
+		}
+		else
+		{
+			for( i = 0; i < ThreadCount; i++ )
+			{
+				td[ i ].initScanlineQueue( td[ i ].sopDitherAndUnpackH,
+					NewHeight, NewWidth );
+
+				td[ i ].getDitherer().init( NewWidth, Vars, TrMul, PkOut );
+			}
+
+			for( i = 0; i < NewHeight; i++ )
+			{
+				td[ i % ThreadCount ].addScanlineToQueue(
+					&ResBuf[ i * NewWidthE ],
+					&NewBuf[ i * NewWidth * ElCountIO ]);
+			}
+
+			ThreadPool.startAllWorkloads();
+			td[ 0 ].processScanlineQueue();
+			ThreadPool.waitAllWorkloadsToFinish();
+		}
+
+		ThreadPool.removeAllWorkloads();
+
+		fpclass :: CReset :: reset();
+	}
+
+private:
+	typedef typename fpclass :: fptype fptype; ///< Floating-point type to use
+		///< during processing.
+		///<
+	typedef typename fpclass :: CFilterStep CFilterStep; ///< Filtering step
+		///< class to use during processing.
+		///<
+	typedef typename fpclass :: CDitherer CDitherer; ///< Ditherer class to
+		///< use during processing.
+		///<
+	CImageResizerParams Params; ///< Algorithm's parameters currently in use.
+		///<
+	int SrcBitDepth; ///< Bit resolution of the source image.
+		///<
+	int ResBitDepth; ///< Bit resolution of the resulting image.
+		///<
+	CDSPFracFilterBankLin< fptype > FixedFilterBank; ///< Fractional delay
+		///< filter bank with fixed characteristics, mainly for upsizing
+		///< cases.
+		///<
+
+	/**
+	 * @brief Filtering steps array.
+	 *
+	 * The object of this class stores filtering steps together.
+	 */
+
+	typedef CStructArray< CFilterStep > CFilterSteps;
+
+	/**
+	 * Function initializes the filter bank in the specified resizing step
+	 * according to the source and resulting image bit depths.
+	 *
+	 * @param FltBank Filter bank to initialize.
+	 * @param CutoffMult Cutoff multiplier, 0 to 1. 1 corresponds to 0.5pi
+	 * cutoff point.
+	 * @param ForceHiOrder "True" if a high-order interpolation should be
+	 * forced which requires considerably less resources for initialization.
+	 * @param ExtFilter External filter to apply to interpolation filter.
+	 */
+
+	void initFilterBank( CDSPFracFilterBankLin< fptype >& FltBank,
+		const double CutoffMult, const bool ForceHiOrder,
+		const CFltBuffer& ExtFilter ) const
+	{
+		const int IntBitDepth = ( ResBitDepth > SrcBitDepth ? ResBitDepth :
+			SrcBitDepth );
+
+		const double SNR = -6.02 * ( IntBitDepth + 3 );
+		int UseOrder;
+		int FracCount; // The number of fractional delay filters sampled by
+			// the filter bank. This variable affects the signal-to-noise
+			// ratio at interpolation stage. Theoretically, 8-bit image
+			// resizing requires 66.2 dB SNR or 11. 16-bit resizing requires
+			// 114.4 dB SNR or 150.
+
+		if( ForceHiOrder || IntBitDepth > 8 )
+		{
+			UseOrder = 1; // -146 dB max
+			FracCount = (int) ceil( 0.23134052 * exp( -0.058062929 * SNR ));
+		}
+		else
+		{
+			UseOrder = 0; // -72 dB max
+			FracCount = (int) ceil( 0.33287686 * exp( -0.11334583 * SNR ));
+		}
+
+		if( FracCount < 2 )
+		{
+			FracCount = 2;
+		}
+
+		FltBank.init( FracCount, UseOrder, Params.IntFltLen / CutoffMult,
+			Params.IntFltCutoff * CutoffMult, Params.IntFltAlpha, ExtFilter,
+			fpclass :: fpalign, fpclass :: elalign );
+	}
+
+	/**
+	 * Function allocates filter buffer taking "fpclass" alignments into
+	 * account. The allocated buffer may be larger than the requested size: in
+	 * this case the additional elements will be zeroed by this function.
+	 *
+	 * @param Flt Filter buffer.
+	 * @param ReqCapacity The required filter buffer's capacity.
+	 * @param IsModel "True" if filtering steps modeling is performed without
+	 * actual filter allocation.
+	 * @param FltExt If non-NULL this variable will receive the number of
+	 * elements the filter was extended by.
+	 */
+
+	static void allocFilter( CBuffer< fptype >& Flt, const int ReqCapacity,
+		const bool IsModel = false, int* const FltExt = NULL )
+	{
+		int UseCapacity = ( ReqCapacity + fpclass :: elalign - 1 ) &
+			~( fpclass :: elalign - 1 );
+
+		int Ext = UseCapacity - ReqCapacity;
+
+		if( FltExt != NULL )
+		{
+			*FltExt = Ext;
+		}
+
+		if( IsModel )
+		{
+			Flt.forceCapacity( UseCapacity );
+			return;
+		}
+
+		Flt.alloc( UseCapacity, fpclass :: fpalign );
+
+		while( Ext > 0 )
+		{
+			Ext--;
+			Flt[ ReqCapacity + Ext ] = 0.0;
+		}
+	}
+
+	/**
+	 * Function assigns filter parameters to the specified filtering step
+	 * object.
+	 *
+	 * @param fs Filtering step to assign parameter to. This step cannot be
+	 * the last step if ResampleFactor greater than 1 was specified.
+	 * @param IsUpsample "True" if upsampling step. Should be set to "false"
+	 * if FltCutoff is negative.
+	 * @param ResampleFactor Resampling factor of this filter (>=1).
+	 * @param FltCutoff Filter cutoff point. This value will be divided by the
+	 * ResampleFactor if IsUpsample equals "true". If zero value was
+	 * specified, the "half-band" predefined filter will be created. In this
+	 * case the ResampleFactor will modify the filter cutoff point.
+	 * @param DCGain DC gain to apply to the filter. Assigned to filtering
+	 * step's DCGain variable.
+	 * @param UseFltOrig "True" if the originally-designed filter should be
+	 * left in filtering step's FltOrig buffer. Otherwise it will be freed.
+	 * @param IsModel "True" if filtering steps modeling is performed without
+	 * actual filter building.
+	 */
+
+	void assignFilterParams( CFilterStep& fs, const bool IsUpsample,
+		const int ResampleFactor, const double FltCutoff, const double DCGain,
+		const bool UseFltOrig, const bool IsModel ) const
+	{
+		double FltAlpha;
+		double Len2;
+		double Freq;
+
+		if( FltCutoff == 0.0 )
+		{
+			const double m = 2.0 / ResampleFactor;
+			FltAlpha = Params.HBFltAlpha;
+			Len2 = 0.5 * Params.HBFltLen / m;
+			Freq = M_PI * Params.HBFltCutoff * m;
+		}
+		else
+		{
+			FltAlpha = Params.LPFltAlpha;
+			Len2 = 0.25 * Params.LPFltBaseLen / FltCutoff;
+			Freq = M_PI * Params.LPFltCutoffMult * FltCutoff;
+		}
+
+		if( IsUpsample )
+		{
+			Len2 *= ResampleFactor;
+			Freq /= ResampleFactor;
+			fs.DCGain = DCGain * ResampleFactor;
+		}
+		else
+		{
+			fs.DCGain = DCGain;
+		}
+
+		fs.FltOrig.Len2 = Len2;
+		fs.FltOrig.Freq = Freq;
+		fs.FltOrig.Alpha = FltAlpha;
+		fs.FltOrig.DCGain = fs.DCGain;
+
+		CDSPPeakedCosineLPF w( Len2, Freq, FltAlpha );
+
+		fs.IsUpsample = IsUpsample;
+		fs.ResampleFactor = ResampleFactor;
+		fs.FltLatency = w.fl2;
+
+		int FltExt; // Filter's extension due to fpclass :: elalign.
+
+		if( IsModel )
+		{
+			allocFilter( fs.Flt, w.FilterLen, true, &FltExt );
+
+			if( UseFltOrig )
+			{
+				// Allocate a real buffer even in modeling mode since this
+				// filter may be copied by the filter bank.
+
+				fs.FltOrig.alloc( w.FilterLen );
+				memset( &fs.FltOrig[ 0 ], 0,
+					w.FilterLen * sizeof( fs.FltOrig[ 0 ]));
+			}
+		}
+		else
+		{
+			fs.FltOrig.alloc( w.FilterLen );
+
+			w.generateLPF( &fs.FltOrig[ 0 ], 1.0 );
+			optimizeFIRFilter( fs.FltOrig, fs.FltLatency );
+			normalizeFIRFilter( &fs.FltOrig[ 0 ], fs.FltOrig.getCapacity(),
+				fs.DCGain );
+
+			allocFilter( fs.Flt, fs.FltOrig.getCapacity(), false, &FltExt );
+			copyArray( &fs.FltOrig[ 0 ], &fs.Flt[ 0 ],
+				fs.FltOrig.getCapacity() );
+
+			if( !UseFltOrig )
+			{
+				fs.FltOrig.free();
+			}
+		}
+
+		if( IsUpsample )
+		{
+			int l = fs.Flt.getCapacity() - fs.FltLatency - ResampleFactor -
+				FltExt;
+
+			allocFilter( fs.PrefixDC, l, IsModel );
+			allocFilter( fs.SuffixDC, fs.FltLatency, IsModel );
+
+			if( IsModel )
+			{
+				return;
+			}
+
+			// Create prefix and suffix "tails" used during upsampling.
+
+			const fptype* ip = &fs.Flt[ fs.FltLatency + ResampleFactor ];
+			copyArray( ip, &fs.PrefixDC[ 0 ], l );
+
+			while( true )
+			{
+				ip += ResampleFactor;
+				l -= ResampleFactor;
+
+				if( l <= 0 )
+				{
+					break;
+				}
+
+				addArray( ip, &fs.PrefixDC[ 0 ], l );
+			}
+
+			l = fs.FltLatency;
+			fptype* op = &fs.SuffixDC[ 0 ];
+			copyArray( &fs.Flt[ 0 ], op, l );
+
+			while( true )
+			{
+				op += ResampleFactor;
+				l -= ResampleFactor;
+
+				if( l <= 0 )
+				{
+					break;
+				}
+
+				addArray( &fs.Flt[ 0 ], op, l );
+			}
+		}
+		else
+		if( !UseFltOrig )
+		{
+			fs.EdgePixelCount = fs.EdgePixelCountDef;
+		}
+	}
+
+	/**
+	 * Function adds a correction filter that tries to achieve a linear
+	 * frequency response at all frequencies. The actual resulting response
+	 * may feature a slight damping of the highest frequencies since a
+	 * suitably short correction filter cannot fix steep high-frequency
+	 * damping.
+	 *
+	 * This function assumes that the resizing step is currently the last
+	 * step, even if it was not inserted yet: this allows placement of the
+	 * correction filter both before and after the resizing step.
+	 *
+	 * @param Steps Filtering steps.
+	 * @param bw Resulting bandwidth relative to the original bandwidth (which
+	 * is 1.0), usually 1/k. Should be <= 1.0.
+	 * @param IsPreCorrection "True" if the filtering step was already created
+	 * and it is first in the Steps array. "True" also adds edge pixels to
+	 * reduce edge artifacts.
+	 * @param IsModel "True" if filtering steps modeling is performed without
+	 * actual filter building.
+	 */
+
+	void addCorrectionFilter( CFilterSteps& Steps, const double bw,
+		const bool IsPreCorrection, const bool IsModel ) const
+	{
+		CFilterStep& fs = ( IsPreCorrection ? Steps[ 0 ] : Steps.add() );
+		fs.IsUpsample = false;
+		fs.ResampleFactor = 1;
+		fs.DCGain = 1.0;
+		fs.EdgePixelCount = ( IsPreCorrection ? fs.EdgePixelCountDef : 0 );
+
+		if( IsModel )
+		{
+			allocFilter( fs.Flt, CDSPFIREQ :: calcFilterLength(
+				Params.CorrFltLen, fs.FltLatency ), true );
+
+			return;
+		}
+
+		const int BinCount = 65; // Frequency response bins to control.
+		const int BinCount1 = BinCount - 1;
+		double curbw = 1.0; // Bandwidth of the filter at the current step.
+		int i;
+		int j;
+		double re;
+		double im;
+
+		CBuffer< double > Bins( BinCount ); // Adjustment introduced by all
+			// steps at all frequencies of interest.
+
+		for( j = 0; j < BinCount; j++ )
+		{
+			Bins[ j ] = 1.0;
+		}
+
+		const int si = ( IsPreCorrection ? 1 : 0 );
+
+		for( i = si; i < Steps.getItemCount() - ( si ^ 1 ); i++ )
+		{
+			const CFilterStep& fs = Steps[ i ];
+
+			if( fs.IsUpsample )
+			{
+				curbw *= fs.ResampleFactor;
+
+				if( fs.FltOrig.getCapacity() > 0 )
+				{
+					continue;
+				}
+			}
+
+			const double dcg = 1.0 / fs.DCGain; // DC gain correction.
+			const fptype* Flt;
+			int FltLen;
+
+			if( fs.ResampleFactor == 0 )
+			{
+				Flt = fs.FltBank -> getFilter( 0 );
+				FltLen = fs.FltBank -> getFilterLen();
+			}
+			else
+			{
+				Flt = &fs.Flt[ 0 ];
+				FltLen = fs.Flt.getCapacity();
+			}
+
+			// Calculate frequency response adjustment introduced by the
+			// filter at this step, within the bounds of bandwidth of
+			// interest.
+
+			for( j = 0; j < BinCount; j++ )
+			{
+				const double th = M_PI * bw / curbw * j / BinCount1;
+
+				calcFIRFilterResponse( Flt, FltLen, th, re, im );
+
+				Bins[ j ] /= sqrt( re * re + im * im ) * dcg;
+			}
+
+			if( !fs.IsUpsample && fs.ResampleFactor > 1 )
+			{
+				curbw /= fs.ResampleFactor;
+			}
+		}
+
+		// Calculate filter.
+
+		CDSPFIREQ EQ;
+		EQ.init( bw * 2.0, Params.CorrFltLen, BinCount, 0.0, bw, false,
+			Params.CorrFltAlpha );
+
+		fs.FltLatency = EQ.getFilterLatency();
+
+		CBuffer< double > Filter( EQ.getFilterLength() );
+		EQ.buildFilter( Bins, &Filter[ 0 ]);
+		normalizeFIRFilter( &Filter[ 0 ], Filter.getCapacity(), 1.0 );
+		optimizeFIRFilter( Filter, fs.FltLatency );
+		normalizeFIRFilter( &Filter[ 0 ], Filter.getCapacity(), 1.0 );
+
+		allocFilter( fs.Flt, Filter.getCapacity() );
+		copyArray( &Filter[ 0 ], &fs.Flt[ 0 ], Filter.getCapacity() );
+
+		// Print a theoretically achieved final frequency response at various
+		// feature sizes (from DC to 1 pixel). Values above 255 means features
+		// become brighter, values below 255 means features become dimmer.
+
+/*		const double sbw = ( bw > 1.0 ? 1.0 / bw : 1.0 );
+
+		for( j = 0; j < BinCount; j++ )
+		{
+			const double th = M_PI * sbw * j / BinCount1;
+
+			calcFIRFilterResponse( &fs.Flt[ 0 ], fs.Flt.getCapacity(),
+				th, re, im );
+
+			printf( "%f\n", sqrt( re * re + im * im ) / Bins[ j ] * 255 );
+		}
+
+		printf( "***\n" );*/
+	}
+
+	/**
+	 * Function adds a sharpening filter if image is being upsized. Such
+	 * sharpening allows to spot interpolation filter's stop-band attenuation:
+	 * if attenuation is too weak, a "dark grid" and other artifacts may
+	 * become visible.
+	 *
+	 * It is assumed that 40 decibel stop-band attenuation should be
+	 * considered a required minimum: this allows application of (deliberately
+	 * strong) 64X sharpening without spotting any artifacts.
+	 *
+	 * @param Steps Filtering steps.
+	 * @param bw Resulting bandwidth relative to the original bandwidth (which
+	 * is 1.0), usually 1/k.
+	 * @param IsModel "True" if filtering steps modeling is performed without
+	 * actual filter building.
+	 */
+
+	static void addSharpenTest( CFilterSteps& Steps, const double bw,
+		const bool IsModel )
+	{
+		if( bw <= 1.0 )
+		{
+			return;
+		}
+
+		const double FltLen = 10.0 * bw;
+
+		CFilterStep& fs = Steps.add();
+		fs.IsUpsample = false;
+		fs.ResampleFactor = 1;
+		fs.DCGain = 1.0;
+		fs.EdgePixelCount = 0;
+
+		if( IsModel )
+		{
+			allocFilter( fs.Flt, CDSPFIREQ :: calcFilterLength( FltLen,
+				fs.FltLatency ), true );
+
+			return;
+		}
+
+		const int BinCount = 200;
+		CBuffer< double > Bins( BinCount );
+		int Thresh = (int) round( BinCount / bw * 1.75 );
+
+		if( Thresh > BinCount )
+		{
+			Thresh = BinCount;
+		}
+
+		int j;
+
+		for( j = 0; j < Thresh; j++ )
+		{
+			Bins[ j ] = 1.0;
+		}
+
+		for( j = Thresh; j < BinCount; j++ )
+		{
+			Bins[ j ] = 256.0;
+		}
+
+		CDSPFIREQ EQ;
+		EQ.init( bw * 2.0, FltLen, BinCount, 0.0, bw, false, 1.7 );
+
+		fs.FltLatency = EQ.getFilterLatency();
+
+		CBuffer< double > Filter( EQ.getFilterLength() );
+		EQ.buildFilter( Bins, &Filter[ 0 ]);
+		normalizeFIRFilter( &Filter[ 0 ], Filter.getCapacity(), 1.0 );
+		optimizeFIRFilter( Filter, fs.FltLatency );
+		normalizeFIRFilter( &Filter[ 0 ], Filter.getCapacity(), 1.0 );
+
+		allocFilter( fs.Flt, Filter.getCapacity() );
+		copyArray( &Filter[ 0 ], &fs.Flt[ 0 ], Filter.getCapacity() );
+
+/*		for( j = 0; j < BinCount; j++ )
+		{
+			const double th = M_PI * j / ( BinCount - 1 );
+			double re;
+			double im;
+
+			calcFIRFilterResponse( &fs.Flt[ 0 ], fs.Flt.getCapacity(),
+				th, re, im );
+
+			printf( "%f\n", sqrt( re * re + im * im ));
+		}
+
+		printf( "***\n" );*/
+	}
+
+	/**
+	 * Function builds sequence of filtering steps depending on the specified
+	 * resizing coefficient. The last steps included are always the resizing
+	 * step then (possibly) the correction step.
+	 *
+	 * @param Steps Array that receives filtering steps.
+	 * @param[out] Vars Variables object.
+	 * @param FltBank Filter bank to initialize and use.
+	 * @param DCGain The overall DC gain to apply. This DC gain is applied to
+	 * the first filtering step only (upsampling or filtering step).
+	 * @param ModeFlags Build mode flags to use. This is a bitmap of switches
+	 * that enable or disable certain algorithm features.
+	 * @param IsModel "True" if filtering steps modeling is performed without
+	 * the actual filter allocation and building.
+	 */
+
+	void buildFilterSteps( CFilterSteps& Steps, CImageResizerVars& Vars,
+		CDSPFracFilterBankLin< fptype >& FltBank, const double DCGain,
+		const int ModeFlags, const bool IsModel ) const
+	{
+		Steps.clear();
+
+		const bool DoFltAndIntCombo = (( ModeFlags & 1 ) != 0 ); // Do filter
+			// and interpolator combining.
+		const bool ForceHiOrderInt = (( ModeFlags & 2 ) != 0 ); // Force use
+			// of a higher-order interpolation.
+		const bool UseHalfband = (( ModeFlags & 4 ) != 0 ); // Use half-band
+			// filter.
+
+		const double bw = 1.0 / Vars.k; // Resulting bandwidth.
+		const int UpsampleFactor = ( (int) floor( Vars.k ) < 2 ? 2 : 1 );
+		double IntCutoffMult; // Interpolation filter cutoff multiplier.
+		CFilterStep* ReuseStep; // If not NULL, resizing step should use
+			// this step object instead of creating a new one.
+		CFilterStep* ExtFltStep; // Use FltOrig of this step as the external
+			// filter to applied to the interpolator.
+		bool IsPreCorrection; // "True" if the correction filter is applied
+			// first.
+		double FltCutoff; // Cutoff frequency of the first filtering step.
+		double corrbw; ///< Bandwidth at the correction step.
+
+		if( Vars.k <= 1.0 )
+		{
+			IsPreCorrection = true;
+			FltCutoff = 1.0;
+			corrbw = 1.0;
+			Steps.add();
+		}
+		else
+		{
+			IsPreCorrection = false;
+			FltCutoff = bw;
+			corrbw = bw;
+		}
+
+		// Add 1 upsampling or several downsampling filters.
+
+		if( UpsampleFactor > 1 )
+		{
+			CFilterStep& fs = Steps.add();
+			assignFilterParams( fs, true, UpsampleFactor, FltCutoff, DCGain,
+				DoFltAndIntCombo, IsModel );
+
+			IntCutoffMult = FltCutoff * 2.0 / UpsampleFactor;
+			ReuseStep = NULL;
+			ExtFltStep = ( DoFltAndIntCombo ? &fs : NULL );
+		}
+		else
+		{
+			int DownsampleFactor;
+
+			while( true )
+			{
+				DownsampleFactor = (int) floor( 0.5 / FltCutoff );
+				bool DoHBFltAdd;
+
+				if( DownsampleFactor > 16 )
+				{
+					// Add half-band filter unconditionally in order to keep
+					// filter lengths lower for more precise frequency
+					// response and less edge artifacts.
+
+					DoHBFltAdd = true;
+					DownsampleFactor = 16;
+				}
+				else
+				{
+					DoHBFltAdd = ( UseHalfband && DownsampleFactor > 1 );
+				}
+
+				if( DoHBFltAdd )
+				{
+					assignFilterParams( Steps.add(), false, DownsampleFactor,
+						0.0, 1.0, false, IsModel );
+
+					FltCutoff *= DownsampleFactor;
+				}
+				else
+				{
+					if( DownsampleFactor < 1 )
+					{
+						DownsampleFactor = 1;
+					}
+
+					break;
+				}
+			}
+
+			CFilterStep& fs = Steps.add();
+			assignFilterParams( fs, false, DownsampleFactor, FltCutoff,
+				DCGain, DoFltAndIntCombo, IsModel );
+
+			IntCutoffMult = FltCutoff / 0.5;
+
+			if( DoFltAndIntCombo )
+			{
+				ReuseStep = &fs;
+				ExtFltStep = &fs;
+			}
+			else
+			{
+				IntCutoffMult *= DownsampleFactor;
+				ReuseStep = NULL;
+				ExtFltStep = NULL;
+			}
+		}
+
+		// Insert resizing and correction steps.
+
+		CFilterStep& fs = ( ReuseStep == NULL ? Steps.add() : *ReuseStep );
+
+		Vars.ResizeStep = Steps.getItemCount() - 1;
+		fs.IsUpsample = false;
+		fs.ResampleFactor = 0;
+		fs.DCGain = ( ExtFltStep == NULL ? 1.0 : ExtFltStep -> DCGain );
+
+		initFilterBank( FltBank, IntCutoffMult, ForceHiOrderInt,
+			( ExtFltStep == NULL ? fs.FltOrig : ExtFltStep -> FltOrig ));
+
+		if( FltBank == FixedFilterBank )
+		{
+			fs.FltBank = (CDSPFracFilterBankLin< fptype >*) &FixedFilterBank;
+		}
+		else
+		{
+			fs.FltBank = &FltBank;
+		}
+
+		addCorrectionFilter( Steps, corrbw, IsPreCorrection, IsModel );
+
+		//addSharpenTest( Steps, bw, IsModel );
+	}
+
+	/**
+	 * Function extends *this upsampling step so that it produces more
+	 * upsampled pixels that cover the prefix and suffix needs of the next
+	 * step. After the call to this function the InPrefix and InSuffix
+	 * variables of the next step will be set to zero.
+	 *
+	 * @param fs Upsampling filtering step.
+	 * @param NextStep The next step structure.
+	 */
+
+	static void extendUpsample( CFilterStep& fs, CFilterStep& NextStep )
+	{
+		fs.InPrefix = ( NextStep.InPrefix + fs.ResampleFactor - 1 ) /
+			fs.ResampleFactor;
+
+		fs.OutPrefix += fs.InPrefix * fs.ResampleFactor;
+		NextStep.InPrefix = 0;
+
+		fs.InSuffix = ( NextStep.InSuffix + fs.ResampleFactor - 1 ) /
+			fs.ResampleFactor;
+
+		fs.OutSuffix += fs.InSuffix * fs.ResampleFactor;
+		NextStep.InSuffix = 0;
+	}
+
+	/**
+	 * Function fills resizing step's RPosBuf array, excluding the actual
+	 * "ftp" pointers and "SrcOffs" offsets.
+	 *
+	 * This array should be cleared if the resizing step or offset were
+	 * changed. Otherwise this function only fills the elements required to
+	 * cover resizing step's OutLen.
+	 *
+	 * This function is called by the updateFilterStepBuffers() function.
+	 *
+	 * @param fs Resizing step.
+	 * @param Vars Variables object.
+	 */
+
+	static void fillRPosBuf( CFilterStep& fs, const CImageResizerVars& Vars )
+	{
+		const int PrevLen = fs.RPosBuf -> getCapacity();
+
+		if( fs.OutLen > PrevLen )
+		{
+			fs.RPosBuf -> increaseCapacity( fs.OutLen );
+		}
+
+		typename CFilterStep :: CResizePos* rpos = &(*fs.RPosBuf)[ PrevLen ];
+		const int FracCount = fs.FltBank -> getFracCount();
+		const double o = Vars.o;
+		const double k = Vars.k;
+		int i;
+
+		for( i = PrevLen; i < fs.OutLen; i++ )
+		{
+			const double SrcPos = o + k * i;
+			const int SrcPosInt = (int) floor( SrcPos );
+			double x = ( SrcPos - SrcPosInt ) * FracCount;
+			const int fti = (int) x;
+			rpos -> x = (typename fpclass :: fptypeatom) ( x - fti );
+			rpos -> fti = fti;
+			rpos -> SrcPosInt = SrcPosInt;
+			rpos++;
+		}
+	}
+
+	/**
+	 * Function updates filtering step buffer lengths depending on the
+	 * specified source and new scanline lengths. This function should be
+	 * called after the buildFilterSteps() function.
+	 *
+	 * @param Steps Array that receives filtering steps.
+	 * @param[out] Vars Variables object, will receive buffer size and length.
+	 * This function expects "k" and "o" variable values that will be
+	 * adjusted by this function.
+	 * @param RPosBufArray Resizing position buffers array, used to obtain
+	 * buffer to initialize and use (will be reused if it is already fully or
+	 * partially filled).
+	 * @param SrcLen Source scanline's length in pixels.
+	 * @param NewLen New scanline's length in pixels.
+	 */
+
+	static void updateFilterStepBuffers( CFilterSteps& Steps,
+		CImageResizerVars& Vars,
+		typename CFilterStep :: CRPosBufArray& RPosBufArray, int SrcLen,
+		const int NewLen )
+	{
+		int upstep = -1;
+		int InBuf = 0;
+		int i;
+
+		for( i = 0; i < Steps.getItemCount(); i++ )
+		{
+			CFilterStep& fs = Steps[ i ];
+
+			fs.Vars = &Vars;
+			fs.InLen = SrcLen;
+			fs.InBuf = InBuf;
+			fs.OutBuf = ( InBuf + 1 ) & 1;
+
+			if( fs.IsUpsample )
+			{
+				upstep = i;
+				Vars.k *= fs.ResampleFactor;
+				Vars.o *= fs.ResampleFactor;
+				fs.InPrefix = 0;
+				fs.InSuffix = 0;
+				fs.OutLen = fs.InLen * fs.ResampleFactor;
+				fs.OutPrefix = fs.FltLatency;
+				fs.OutSuffix = fs.Flt.getCapacity() - fs.FltLatency -
+					fs.ResampleFactor;
+
+				int l0 = fs.OutPrefix + fs.OutLen + fs.OutSuffix;
+				int l = fs.InLen * fs.ResampleFactor +
+					fs.SuffixDC.getCapacity();
+
+				if( l > l0 )
+				{
+					fs.OutSuffix += l - l0;
+				}
+
+				l0 = fs.OutLen + fs.OutSuffix;
+
+				if( fs.PrefixDC.getCapacity() > l0 )
+				{
+					fs.OutSuffix += fs.PrefixDC.getCapacity() - l0;
+				}
+			}
+			else
+			if( fs.ResampleFactor == 0 )
+			{
+				const int FilterLenD2 = fs.FltBank -> getFilterLen() / 2;
+				const int FilterLenD21 = FilterLenD2 - 1;
+
+				const int ResizeLPix = (int) floor( Vars.o ) - FilterLenD21;
+				fs.InPrefix = ( ResizeLPix < 0 ? -ResizeLPix : 0 );
+				const int ResizeRPix = (int) floor( Vars.o +
+					( NewLen - 1 ) * Vars.k ) + FilterLenD2 + 1;
+
+				fs.InSuffix = ( ResizeRPix > fs.InLen ?
+					ResizeRPix - fs.InLen : 0 );
+
+				fs.OutLen = NewLen;
+				fs.RPosBuf = &RPosBufArray.getRPosBuf( Vars.k, Vars.o,
+					fs.FltBank -> getFracCount() );
+
+				fillRPosBuf( fs, Vars );
+			}
+			else
+			{
+				Vars.k /= fs.ResampleFactor;
+				Vars.o /= fs.ResampleFactor;
+				Vars.o += fs.EdgePixelCount;
+
+				fs.InPrefix = fs.FltLatency;
+				fs.InSuffix = fs.Flt.getCapacity() - fs.FltLatency - 1;
+
+				// Additionally extend OutLen to produce more precise edge
+				// pixels.
+
+				fs.OutLen = ( fs.InLen + fs.ResampleFactor - 1 ) /
+					fs.ResampleFactor + fs.EdgePixelCount;
+
+				fs.InSuffix += ( fs.OutLen - 1 ) * fs.ResampleFactor + 1 -
+					fs.InLen;
+
+				fs.InPrefix += fs.EdgePixelCount * fs.ResampleFactor;
+				fs.OutLen += fs.EdgePixelCount;
+			}
+
+			InBuf = fs.OutBuf;
+			SrcLen = fs.OutLen;
+		}
+
+		Steps[ Steps.getItemCount() - 1 ].OutBuf = 2;
+
+		if( upstep != -1 )
+		{
+			extendUpsample( Steps[ upstep ], Steps[ upstep + 1 ]);
+		}
+	}
+
+	/**
+	 * Function calculates an optimal intermediate buffer length that will
+	 * cover all needs of the specified filtering steps. This function should
+	 * be called after the updateFilterStepBuffers() function.
+	 *
+	 * Function also updates resizing step's RPosBuf pointers to the filter
+	 * bank and SrcOffs values.
+	 *
+	 * @param Steps Filtering steps.
+	 * @param[out] Vars Variables object, will receive buffer size and length.
+	 * @param ResElIncr Resulting (final) element increment, used to produce
+	 * de-interleaved result. For horizontal processing this value is equal
+	 * to last step's OutLen, for vertical processing this value is equal to
+	 * resulting image's width.
+	 */
+
+	static void updateBufLenAndRPosPtrs( CFilterSteps& Steps,
+		CImageResizerVars& Vars, const int ResElIncr )
+	{
+		int MaxPrefix[ 2 ] = { 0, 0 };
+		int MaxLen[ 2 ] = { 0, 0 };
+		int i;
+
+		for( i = 0; i < Steps.getItemCount(); i++ )
+		{
+			CFilterStep& fs = Steps[ i ];
+			const int ib = fs.InBuf;
+
+			if( fs.InPrefix > MaxPrefix[ ib ])
+			{
+				MaxPrefix[ ib ] = fs.InPrefix;
+			}
+
+			int l = fs.InLen + fs.InSuffix;
+
+			if( l > MaxLen[ ib ])
+			{
+				MaxLen[ ib ] = l;
+			}
+
+			fs.InElIncr = fs.InPrefix + l;
+
+			if( fs.OutBuf == 2 )
+			{
+				break;
+			}
+
+			const int ob = fs.OutBuf;
+
+			if( fs.IsUpsample )
+			{
+				if( fs.OutPrefix > MaxPrefix[ ob ])
+				{
+					MaxPrefix[ ob ] = fs.OutPrefix;
+				}
+
+				l = fs.OutLen + fs.OutSuffix;
+
+				if( l > MaxLen[ ob ])
+				{
+					MaxLen[ ob ] = l;
+				}
+			}
+			else
+			{
+				if( fs.OutLen > MaxLen[ ob ])
+				{
+					MaxLen[ ob ] = fs.OutLen;
+				}
+			}
+		}
+
+		// Update OutElIncr values of all steps.
+
+		for( i = 0; i < Steps.getItemCount(); i++ )
+		{
+			CFilterStep& fs = Steps[ i ];
+
+			if( fs.OutBuf == 2 )
+			{
+				fs.OutElIncr = ResElIncr;
+				break;
+			}
+
+			CFilterStep& fs2 = Steps[ i + 1 ];
+
+			if( fs.IsUpsample )
+			{
+				fs.OutElIncr = fs.OutPrefix + fs.OutLen + fs.OutSuffix;
+
+				if( fs.OutElIncr > fs2.InElIncr )
+				{
+					fs2.InElIncr = fs.OutElIncr;
+				}
+				else
+				{
+					fs.OutElIncr = fs2.InElIncr;
+				}
+			}
+			else
+			{
+				fs.OutElIncr = fs2.InElIncr;
+			}
+		}
+
+		// Update temporary buffer's length.
+
+		for( i = 0; i < 2; i++ )
+		{
+			Vars.BufLen[ i ] = MaxPrefix[ i ] + MaxLen[ i ];
+			Vars.BufOffs[ i ] = MaxPrefix[ i ];
+
+			if( Vars.elalign == 1 )
+			{
+				Vars.BufOffs[ i ] *= Vars.ElCount;
+			}
+
+			Vars.BufLen[ i ] *= Vars.ElCount;
+		}
+
+		// Update RPosBuf pointers and SrcOffs.
+
+		CFilterStep& fs = Steps[ Vars.ResizeStep ];
+		typename CFilterStep :: CResizePos* rpos = &(*fs.RPosBuf)[ 0 ];
+		const int em = ( fpclass :: elalign == 1 ? Vars.ElCount : 1 );
+		const int FilterLenD21 = fs.FltBank -> getFilterLen() / 2 - 1;
+
+		for( i = 0; i < fs.OutLen; i++ )
+		{
+			rpos -> ftp = fs.FltBank -> getFilter( rpos -> fti );
+			rpos -> SrcOffs = ( rpos -> SrcPosInt - FilterLenD21 ) * em;
+			rpos++;
+		}
+	}
+
+	/**
+	 * Function modifies the overall (DC) gain of the correction filter in the
+	 * pre-built filtering steps array.
+	 *
+	 * @param Steps Filtering steps.
+	 * @param m Multiplier to apply to the correction filter.
+	 */
+
+	void modifyCorrFilterDCGain( CFilterSteps& Steps, const double m ) const
+	{
+		CBuffer< fptype >* Flt;
+		const int z = Steps.getItemCount() - 1;
+
+		if( !Steps[ z ].IsUpsample && Steps[ z ].ResampleFactor == 1 )
+		{
+			Flt = &Steps[ z ].Flt;
+		}
+		else
+		{
+			Flt = &Steps[ 0 ].Flt;
+		}
+
+		int i;
+
+		for( i = 0; i < Flt -> getCapacity(); i++ )
+		{
+			(*Flt)[ i ] = (fptype) ( (double) (*Flt)[ i ] * m );
+		}
+	}
+
+	/**
+	 * Function builds a map of used fractional delay filters based on the
+	 * resizing positions buffer.
+	 *
+	 * @param fs Resizing step.
+	 * @param[out] UsedFracMap Map of used fractional delay filters.
+	 */
+
+	static void fillUsedFracMap( const CFilterStep& fs,
+		CBuffer< uint8_t >& UsedFracMap )
+	{
+		const int FracCount = fs.FltBank -> getFracCount();
+		UsedFracMap.increaseCapacity( FracCount, false );
+		memset( &UsedFracMap[ 0 ], 0, FracCount * sizeof( UsedFracMap[ 0 ]));
+
+		typename CFilterStep :: CResizePos* rpos = &(*fs.RPosBuf)[ 0 ];
+		int i;
+
+		for( i = 0; i < fs.OutLen; i++ )
+		{
+			UsedFracMap[ rpos -> fti ] |= 1;
+			rpos++;
+		}
+	}
+
+	/**
+	 * Function calculates the overall filtering steps complexity per
+	 * scanline. Each complexity unit corresponds to a single multiply-add
+	 * operation. Data copy and pointer math operations are not included in
+	 * this calculation, it is assumed that they correlate to the multiply-add
+	 * operations. Calculation also does not include final rounding, dithering
+	 * and clamping operations since they cannot be optimized out anyway.
+	 *
+	 * Calculation of the CRPosBuf buffer is not included since it cannot be
+	 * avoided.
+	 *
+ 	 * This function should be called after the updateFilterStepBuffers()
+	 * function.
+	 *
+	 * @param Steps Filtering steps array.
+	 * @param Vars Variables object.
+	 * @param UsedFracMap The map of used fractional delay filters.
+	 * @param ScanlineCount Scanline count.
+	 */
+
+	static int calcComplexity( const CFilterSteps& Steps,
+		const CImageResizerVars& Vars, const CBuffer< uint8_t >& UsedFracMap,
+		const int ScanlineCount )
+	{
+		int fcnum; // Filter complexity multiplier numerator.
+		int fcdenom; // Filter complexity multiplier denominator.
+
+		if( Vars.elalign > 1 )
+		{
+			fcnum = 1;
+			fcdenom = 1;
+		}
+		else
+		{
+			// In interleaved processing mode, filters require 1 less
+			// multiplication per 2 multiply-add instructions.
+
+			fcnum = 3;
+			fcdenom = 4;
+		}
+
+		int s = 0; // Complexity per one scanline.
+		int s2 = 0; // Complexity per all scanlines.
+		int i;
+
+		for( i = 0; i < Steps.getItemCount(); i++ )
+		{
+			const CFilterStep& fs = Steps[ i ];
+
+			s2 += 65 * fs.Flt.getCapacity(); // Filter creation complexity.
+
+			if( fs.IsUpsample )
+			{
+				if( fs.FltOrig.getCapacity() > 0 )
+				{
+					continue;
+				}
+
+				s += ( fs.Flt.getCapacity() *
+					( fs.InPrefix + fs.InLen + fs.InSuffix ) +
+					fs.SuffixDC.getCapacity() + fs.PrefixDC.getCapacity() ) *
+					Vars.ElCount;
+			}
+			else
+			if( fs.ResampleFactor == 0 )
+			{
+				s += fs.FltBank -> getFilterLen() *
+					( fs.FltBank -> getOrder() + Vars.ElCount ) * fs.OutLen;
+
+				s2 += fs.FltBank -> calcInitComplexity( UsedFracMap );
+			}
+			else
+			{
+				s += fs.Flt.getCapacity() * Vars.ElCount * fs.OutLen *
+					fcnum / fcdenom;
+			}
+		}
+
+		return( s + s2 / ScanlineCount );
+	}
+
+	/**
+	 * @brief Thread-isolated data used for scanline processing.
+	 *
+	 * This structure holds data necessary for image's horizontal or vertical
+	 * scanline processing, including scanline processing queue.
+	 *
+	 * @tparam Tin Source element data type. Intermediate buffers store data
+	 * in floating point format.
+	 * @tparam Tout Destination element data type. Intermediate buffers store
+	 * data in floating point format.
+	 */
+
+	template< class Tin, class Tout >
+	class CThreadData : public CImageResizerThreadPool :: CWorkload
+	{
+	public:
+		virtual void process()
+		{
+			processScanlineQueue();
+		}
+
+		/**
+		 * This enumeration lists possible scanline operations.
+		 */
+
+		enum EScanlineOperation
+		{
+			sopResizeH, ///< Resize horizontal scanline.
+				///<
+			sopResizeV, ///< Resize vertical scanline.
+				///<
+			sopDitherAndUnpackH, ///< Dither and unpack horizontal scanline.
+				///<
+			sopUnpackH ///< Unpack horizontal scanline.
+				///<
+		};
+
+		/**
+		 * Function initializes *this thread data object and assigns certain
+		 * variables provided by the higher level code.
+		 *
+		 * @param aThreadIndex Index of this thread data (0-based).
+		 * @param aThreadCount Total number of threads used during processing.
+		 * @param aSteps Filtering steps.
+		 * @param aVars Image resizer variables.
+		 */
+
+		void init( const int aThreadIndex, const int aThreadCount,
+			const CFilterSteps& aSteps, const CImageResizerVars& aVars )
+		{
+			ThreadIndex = aThreadIndex;
+			ThreadCount = aThreadCount;
+			Steps = &aSteps;
+			Vars = &aVars;
+		}
+
+		/**
+		 * Function initializes scanline processing queue, and updates
+		 * capacities of intermediate buffers.
+		 *
+		 * @param aOp Operation to perform over scanline.
+		 * @param TotalLines The total number of scanlines that will be
+		 * processed by all threads.
+		 * @param aSrcLen Source scanline length in pixels.
+		 * @param aSrcIncr Source scanline buffer increment. Ignored in
+		 * horizontal scanline processing.
+		 * @param aResIncr Resulting scanline buffer increment. Ignored in
+		 * horizontal scanline processing.
+		 */
+
+		void initScanlineQueue( const EScanlineOperation aOp,
+			const int TotalLines, const int aSrcLen, const int aSrcIncr = 0,
+			const int aResIncr = 0 )
+		{
+			const int l = Vars -> BufLen[ 0 ] + Vars -> BufLen[ 1 ];
+
+			if( Bufs.getCapacity() < l )
+			{
+				Bufs.alloc( l, fpclass :: fpalign );
+			}
+
+			BufPtrs[ 0 ] = Bufs + Vars -> BufOffs[ 0 ];
+			BufPtrs[ 1 ] = Bufs + Vars -> BufLen[ 0 ] + Vars -> BufOffs[ 1 ];
+
+			int j;
+			int ml = 0;
+
+			for( j = 0; j < Steps -> getItemCount(); j++ )
+			{
+				const CFilterStep& fs = (*Steps)[ j ];
+
+				if( fs.ResampleFactor == 0 &&
+					ml < fs.FltBank -> getFilterLen() )
+				{
+					ml = fs.FltBank -> getFilterLen();
+				}
+			}
+
+			TmpFltBuf.alloc( ml, fpclass :: fpalign );
+			ScanlineOp = aOp;
+			SrcLen = aSrcLen;
+			SrcIncr = aSrcIncr;
+			ResIncr = aResIncr;
+			QueueLen = 0;
+			Queue.increaseCapacity(( TotalLines + ThreadCount - 1 ) /
+				ThreadCount, false );
+		}
+
+		/**
+		 * Function adds a scanline to the queue buffer. The
+		 * initScanlineQueue() function should be called before calling this
+		 * function. The number of calls to this add function should not
+		 * exceed the TotalLines spread over all threads.
+		 *
+		 * @param SrcBuf Source scanline buffer.
+		 * @param ResBuf Resulting scanline buffer.
+		 */
+
+		void addScanlineToQueue( void* const SrcBuf, void* const ResBuf )
+		{
+			Queue[ QueueLen ].SrcBuf = SrcBuf;
+			Queue[ QueueLen ].ResBuf = ResBuf;
+			QueueLen++;
+		}
+
+		/**
+		 * Function processes all queued scanlines.
+		 */
+
+		void processScanlineQueue()
+		{
+			int i;
+
+			switch( ScanlineOp )
+			{
+				case sopResizeH:
+				{
+					for( i = 0; i < QueueLen; i++ )
+					{
+						resizeScanlineH( (Tin*) Queue[ i ].SrcBuf,
+							(fptype*) Queue[ i ].ResBuf );
+					}
+
+					break;
+				}
+
+				case sopResizeV:
+				{
+					for( i = 0; i < QueueLen; i++ )
+					{
+						resizeScanlineV( (fptype*) Queue[ i ].SrcBuf,
+							(fptype*) Queue[ i ].ResBuf );
+					}
+
+					break;
+				}
+
+				case sopDitherAndUnpackH:
+				{
+					if( Vars -> UseSRGBGamma )
+					{
+						for( i = 0; i < QueueLen; i++ )
+						{
+							CFilterStep :: applySRGBGamma(
+								(fptype*) Queue[ i ].SrcBuf, SrcLen, *Vars );
+
+							Ditherer.dither( (fptype*) Queue[ i ].SrcBuf );
+
+							CFilterStep :: unpackScanline(
+								(fptype*) Queue[ i ].SrcBuf,
+								(Tout*) Queue[ i ].ResBuf, SrcLen, *Vars );
+						}
+					}
+					else
+					{
+						for( i = 0; i < QueueLen; i++ )
+						{
+							Ditherer.dither( (fptype*) Queue[ i ].SrcBuf );
+
+							CFilterStep :: unpackScanline(
+								(fptype*) Queue[ i ].SrcBuf,
+								(Tout*) Queue[ i ].ResBuf, SrcLen, *Vars );
+						}
+					}
+
+					break;
+				}
+
+				case sopUnpackH:
+				{
+					if( Vars -> UseSRGBGamma )
+					{
+						for( i = 0; i < QueueLen; i++ )
+						{
+							CFilterStep :: applySRGBGamma(
+								(fptype*) Queue[ i ].SrcBuf, SrcLen, *Vars );
+
+							CFilterStep :: unpackScanline(
+								(fptype*) Queue[ i ].SrcBuf,
+								(Tout*) Queue[ i ].ResBuf, SrcLen, *Vars );
+						}
+					}
+					else
+					{
+						for( i = 0; i < QueueLen; i++ )
+						{
+							CFilterStep :: unpackScanline(
+								(fptype*) Queue[ i ].SrcBuf,
+								(Tout*) Queue[ i ].ResBuf, SrcLen, *Vars );
+						}
+					}
+
+					break;
+				}
+			}
+		}
+
+		/**
+		 * Function returns ditherer object associated with *this thread data
+		 * object.
+		 */
+
+		CDitherer& getDitherer()
+		{
+			return( Ditherer );
+		}
+
+	private:
+		int ThreadIndex; ///< Thread index.
+			///<
+		int ThreadCount; ///< Thread count.
+			///<
+		const CFilterSteps* Steps; ///< Filtering steps.
+			///<
+		const CImageResizerVars* Vars; ///< Image resizer variables.
+			///<
+		CBuffer< fptype > Bufs; ///< Flip-flop intermediate buffers.
+			///<
+		fptype* BufPtrs[ 3 ]; ///< Flip-flop buffer pointers (referenced by
+			///< filtering step's InBuf and OutBuf indices).
+			///<
+		CBuffer< fptype > TmpFltBuf; ///< Temporary buffer used in the
+			///< doResize() function, aligned by fpclass :: fpalign.
+			///<
+		EScanlineOperation ScanlineOp; ///< Operation to perform over
+			///< scanline.
+			///<
+		int SrcLen; ///< Source scanline length in the last queue.
+			///<
+		int SrcIncr; ///< Source scanline buffer increment in the last queue.
+			///<
+		int ResIncr; ///< Resulting scanline buffer increment in the last
+			///< queue.
+			///<
+		CDitherer Ditherer; ///< Ditherer object to use.
+			///<
+
+		/**
+		 * @brief Scanline processing queue item.
+		 *
+		 * Scanline processing queue item.
+		 */
+
+		struct CQueueItem
+		{
+			void* SrcBuf; ///< Source scanline buffer, will by typecasted to
+				///< Tin or fptype*.
+				///<
+			void* ResBuf; ///< Resulting scanline buffer, will by typecasted
+				///< to Tout or fptype*.
+				///<
+		};
+
+		CBuffer< CQueueItem > Queue; ///< Scanline processing queue.
+			///<
+		int QueueLen; ///< Queue length.
+			///<
+
+		/**
+		 * Function resizes a single horizontal scanline.
+		 *
+		 * @param SrcBuf Source scanline buffer. Can be either horizontal or
+		 * vertical.
+		 * @param ResBuf Resulting scanline buffer.
+		 */
+
+		void resizeScanlineH( const Tin* const SrcBuf, fptype* const ResBuf )
+		{
+			(*Steps)[ 0 ].packScanline( SrcBuf, BufPtrs[ 0 ], SrcLen );
+			BufPtrs[ 2 ] = ResBuf;
+			int j;
+
+			for( j = 0; j < Steps -> getItemCount(); j++ )
+			{
+				const CFilterStep& fs = (*Steps)[ j ];
+				fs.prepareInBuf( BufPtrs[ fs.InBuf ]);
+				const int DstIncr =
+					( Vars -> elalign == 1 ? Vars -> ElCount : 1 );
+
+				if( fs.ResampleFactor != 0 )
+				{
+					if( fs.IsUpsample )
+					{
+						fs.doUpsample( BufPtrs[ fs.InBuf ],
+							BufPtrs[ fs.OutBuf ]);
+					}
+					else
+					{
+						fs.doFilter( BufPtrs[ fs.InBuf ],
+							BufPtrs[ fs.OutBuf ], DstIncr );
+					}
+				}
+				else
+				{
+					fs.doResize( BufPtrs[ fs.InBuf ], BufPtrs[ fs.OutBuf ],
+						DstIncr, TmpFltBuf );
+				}
+			}
+		}
+
+		/**
+		 * Function resizes a single vertical scanline.
+		 *
+		 * @param SrcBuf Source scanline buffer. Can be either horizontal or
+		 * vertical.
+		 * @param ResBuf Resulting scanline buffer.
+		 */
+
+		void resizeScanlineV( const fptype* const SrcBuf,
+			fptype* const ResBuf )
+		{
+			(*Steps)[ 0 ].convertVtoH( SrcBuf, BufPtrs[ 0 ], SrcLen,
+				SrcIncr );
+
+			BufPtrs[ 2 ] = ResBuf;
+			int j;
+
+			for( j = 0; j < Steps -> getItemCount(); j++ )
+			{
+				const CFilterStep& fs = (*Steps)[ j ];
+				fs.prepareInBuf( BufPtrs[ fs.InBuf ]);
+				const int DstIncr = ( fs.OutBuf == 2 ? ResIncr :
+					( Vars -> elalign == 1 ? Vars -> ElCount : 1 ));
+
+				if( fs.ResampleFactor != 0 )
+				{
+					if( fs.IsUpsample )
+					{
+						fs.doUpsample( BufPtrs[ fs.InBuf ],
+							BufPtrs[ fs.OutBuf ]);
+					}
+					else
+					{
+						fs.doFilter( BufPtrs[ fs.InBuf ],
+							BufPtrs[ fs.OutBuf ], DstIncr );
+					}
+				}
+				else
+				{
+					fs.doResize( BufPtrs[ fs.InBuf ], BufPtrs[ fs.OutBuf ],
+						DstIncr, TmpFltBuf );
+				}
+			}
+		}
+	};
+};
+
+} // namespace avir
+
+#endif // AVIR_CIMAGERESIZER_INCLUDED
diff -Nur orig/source/avir/LICENSE mod/source/avir/LICENSE
--- orig/source/avir/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/avir/LICENSE	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,74 @@
+AVIR License Agreement (for AVIR image resizing software library version 1.9)
+
+AVIR Copyright (c) 2015-2016 Aleksey Vaneev
+
+1. AVIR image resizing software library and its parts and associated
+documentation files (collectively, "AVIR") is licensed, not sold. AVIR and
+all rights are owned by AVIR copyright holder and are protected by
+copyright law and international copyright treaties. You (individual person
+or a company) acknowledge that no title to the intellectual property in
+AVIR is transferred to you. You further acknowledge that title and full
+ownership rights to AVIR will remain the exclusive property of AVIR
+copyright holder and you will not acquire any rights to AVIR except as
+expressly set forth in this License Agreement.
+
+2. This License Agreement is only applicable to non-commercial and
+low-income commercial use of AVIR. This means that you have to sign a
+special license agreement with AVIR copyright holder if you or your
+company sells and/or licenses (directly or via resellers) software products
+and/or non-software products with firmware where AVIR is included or may be
+included, and if or when the combined sales of such products reach at your
+end a sum of more than 40000 (forty thousand) US dollars per year (or
+equivalent value in your native currency). Sales also include subscriptions
+where a subscribed end user may get a functioning, and/or feature-extended,
+and/or advertisement-free product where AVIR is included or may be
+included. Software products also include user-operated server-based image
+and video editing applications where AVIR is included or may be included.
+Donation-based, but otherwise free from fees, software products where AVIR
+is included or may be included are treated herein as non-commercial.
+
+3. The execution of AVIR image resizing function in non-commercial,
+commercial and any other environments (operations) of any size and for any
+purpose is allowed without a fee.
+
+4. If you have a considerable development budget, and/or make a
+considerable profit from donations (grants), and/or make advertising profit
+associated with software where AVIR is included, or if AVIR image resizing
+function is an important function (e.g. on a photo hosting, a social web
+site) which is performed using proprietary software product where AVIR is
+included, then consider voluntarily signing a special license agreement
+with AVIR copyright holder.
+
+5. If you sublicense to a non-end user third party, or transfer rights to
+your software where AVIR or its parts are included, to a third party, this
+third party should agree to this License Agreement or sign a special
+license agreement with AVIR copyright holder, or remove AVIR dependence
+from the received software.
+
+6. Permission is hereby granted, free of charge, to any person or company
+(subject to the restrictions outlined above) obtaining a copy of AVIR, to
+deal in AVIR without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense (except as
+noted above), and/or sell copies of AVIR, and to permit persons to whom
+AVIR is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this License Agreement shall be included in
+all copies or portions of AVIR.
+
+7. AVIR IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF OR IN CONNECTION WITH AVIR OR THE USE OR OTHER DEALINGS IN
+AVIR.
+
+8. AVIR copyright holder's e-mail: aleksey.vaneev@gmail.com
+AVIR copyright holder's registered address:
+Aleksey Vaneev
+6-54 Lenin Street,
+Syktyvkar, Komi Republic 167000
+Russia
+
+Please credit the author of this library in your documentation in the
+following way: "AVIR image resizing algorithm designed by Aleksey Vaneev"
diff -Nur orig/source/avir/README.md mod/source/avir/README.md
--- orig/source/avir/README.md	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/avir/README.md	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,252 @@
+# AVIR #
+## Introduction ##
+Me, Aleksey Vaneev, is happy to offer you an open source image resizing /
+scaling library which has reached a production level of quality, and is
+ready to be incorporated into any project. This library features routines
+for both down- and upsizing of 8- and 16-bit, 1 to 4-channel images. Image
+resizing routines were implemented in multi-platform C++ code, and have a
+high level of optimality. Beside resizing, this library offers a sub-pixel
+shift operation. Built-in sRGB gamma correction is available.
+
+The resizing algorithm at first produces 2X upsized image (relative to the
+source image size, or relative to the destination image size if downsizing is
+performed) and then performs interpolation using a bank of sinc function-based
+fractional delay filters. On the last stage a correction filter is applied
+which fixes smoothing introduced on previous steps.
+
+The resizing algorithm was designed to provide the best visual quality. The
+author even believes this algorithm provides the "ultimate" level of
+quality which cannot be increased further: no math exists to provide a
+better frequency response, better anti-aliasing quality and at the same
+time having less ringing artifacts: these are 3 elements that define any
+resizing algorithm's quality; in AVIR practice these elements have 0.95
+correlation to each other, so they can be represented by any single
+element (AVIR offers several parameter sets with varying quality).
+Algorithm's time performance turned out to be very good as well (for the
+"ultimate" image quality).
+
+An important element utilized by this algorithm is the so called Peaked Cosine
+window function, which is applied over sinc function in all filters. Please
+consult the documentation for more details.
+
+*AVIR is devoted to women. Your digital photos can look good at any size!*
+
+## Requirements ##
+C++ compiler and system with efficient "float" floating point (24-bit
+mantissa) type support. This library can also internally use the "double" and
+SIMD floating point types during resizing if needed. This library does not
+have dependencies beside the standard C library.
+
+## Links ##
+* [Documentation](http://avaneev.atspace.cc/avir/Documentation/)
+
+## Usage Information ##
+The image resizer is represented by the **avir::CImageResizer<>** class, which
+is a single front-end class for the whole library. You do not basically need
+to use nor understand any other classes beside this class.
+
+The code of the library resides in the "avir" C++ namespace, effectively
+isolating it from all other code. The code is thread-safe. You need just
+a single resizer object per running application, at any time, even when
+resizing images concurrently.
+
+To resize images in your application, simply add 3 lines of code:
+* # include "avir.h"
+* avir :: CImageResizer<> ImageResizer( 8 );
+* ImageResizer.resizeImage( InBuf, 640, 480, 0, OutBuf, 1024, 768, 3, 0 );
+(multi-threaded operation requires additional coding, see the documentation)
+
+For low-ringing performance:
+* avir :: CImageResizer<> ImageResizer( 8, 0, avir :: CImageResizerParamsLR() );
+
+To use the built-in gamma correction, an object of the avir::CImageResizerVars
+class with its variable UseSRGBGamma set to "true" should be supplied to the
+resizeImage() function. Note that the gamma correction is applied to all
+channels (e.g. alpha-channel) in the current implementation.
+
+The library is able to process images of any bit depth: this includes 8-bit,
+16-bit, float and double types. Larger integer and signed integer types are
+not supported. Supported source and destination image sizes are up to 2.1
+gigapixels (46300x46300 or equivalent dimensions, e.g. 53467x40100).
+
+The code of this library was commented in the [Doxygen](http://www.doxygen.org/)
+style. To generate the documentation locally you may run the
+"doxygen ./other/avirdoxy.txt" command from the library's directory. Note that
+the code was suitably documented allowing you to make modifications, and to
+gain full understanding of the algorithm.
+
+Preliminary tests show that this library can resize 8-bit RGB 5184x3456
+(17.9 Mpixel) image down to 1920x1280 (2.5 Mpixel) image in 566 milliseconds,
+utilizing a single thread, on a typical Intel Core i7-4770K processor-based
+system without overclocking. This scales down to 195 milliseconds if 4 threads
+are utilized. This time can be reduced further down to 148 milliseconds by
+utilizing SIMD floating point processing. This library's performance has a big
+potential to grow together with evolving processor architectures as currently
+performance is clearly limited by memory bandwidth, not by algorithm's
+mathematical operations and overhead.
+
+Multi-threaded operation is not provided by this library "out of the box".
+The multi-threaded infrastructure is available, but requires additional
+system-specific interfacing code for engagement.
+
+## SIMD Usage Information ##
+This library is capable of using SIMD floating point types for internal
+variables. This means that up to 4 color channels can be processed in
+parallel. For example, this gives 40% performance boost when resizing
+3-channel images. Since the default interleaved processing algorithm itself
+remains non-SIMD, the use of SIMD internal types is not practical for
+1-channel image resizing (due to overhead). SIMD internal type can be used
+this way:
+* # include "avir_float4_sse.h"
+* avir :: CImageResizer< avir :: fpclass_float4 > ImageResizer( 8 );
+
+For 1-channel and 2-channel image resizing when AVX instructions are allowed
+it is reasonable to utilize de-interleaved SIMD processing algorithm. While it
+gives no performance benefit if the "float4" SSE processing type is used, it
+offers around 35% performance boost if the "float8" AVX processing type is
+used (given dithering is not performed, or otherwise performance is reduced at
+dithering stage since recursive dithering cannot be parallelized). The
+internal type remains non-SIMD "float". De-interleaved algorithm can be used
+this way:
+* # include "avir_float8_avx.h"
+* avir :: CImageResizer< avir :: fpclass_float8_dil > ImageResizer( 8 );
+
+## Notes ##
+This library was tested for compatibility with [GNU C++](http://gcc.gnu.org/),
+[Microsoft Visual C++](http://www.microsoft.com/visualstudio/eng/products/visual-studio-express-products)
+and [Intel C++](http://software.intel.com/en-us/c-compilers) compilers, on 32-
+and 64-bit Windows, Mac OS X and CentOS Linux. The code was also tested with
+Dr.Memory/Win32 for the absence of uninitialized or unaddressable memory
+accesses.
+
+All code is fully "inline", without the need to compile any source files. The
+memory footprint of the library itself is very modest, except that the size of
+the temporary image buffers depends on the input and output image sizes, and
+is proportionally large.
+
+The "heart" of resizing algorithm's quality resides in the parameters defined
+via the **avir::CImageResizerParams** structure. While the default set of
+parameters that offers a good quality was already provided, there is
+(probably) still a place for improvement exists, and the default parameters
+may change in a future update. If you need to recall an exact set of
+parameters, simply save them locally for a later use.
+
+When the algorithm is run with no resizing applied (k=1), the result of
+resizing will not be an exact, but a very close copy of the source image. The
+reason for such inexactness is that the image is always low-pass filtered at
+first to reduce aliasing during subsequent resizing, and at last filtered by a
+correction filter. Such approach allows algorithm to maintain a stable level
+of quality regardless of the resizing "k" factor used.
+
+This library includes a binary command line tool "imageresize" for major
+desktop platforms. This tool was designed to be used as a demonstration of
+library's performance and as a reference, it uses 4 threads and float4 SIMD
+internal type during processing. This tool uses the following libraries:
+* turbojpeg Copyright (c) 2009-2013 D. R. Commander
+* libpng Copyright (c) 1998-2013 Glenn Randers-Pehrson
+* zlib Copyright (c) 1995-2013 Jean-loup Gailly and Mark Adler
+
+## Interpolation Discussion ##
+The use of certain low-pass filters and 2X upsampling in this library is
+hardly debatable, because they are needed to attain a certain anti-aliasing
+effect and keep ringing artifacts low. But the use of sinc function-based
+interpolation filter that is 18 taps-long (may be higher, up to 36 taps in
+practice) can be questioned, because even in 0th order case such
+interpolation filter requires 18 multiply-add operations. Comparatively, an
+optimal Hermit or cubic interpolation spline requires 8 multiply and 11 add
+operations.
+
+One of the reasons 18-tap filter is preferred, is because due to memory
+bandwidth limitations using a lower-order filter does not provide any
+significant performance increase (e.g. 14-tap filter is less than 5% more
+efficient overall). At the same time, in comparison to cubic spline, 18-tap
+filter embeds a low-pass filter that rejects signal above 0.5*pi (provides
+additional anti-aliasing filtering), and this filter has a consistent shape at
+all fractional offsets. Splines have a varying low-pass filter shape at
+different fractional offsets (e.g. no low-pass filtering at 0.0 offset,
+and maximal low-pass filtering at 0.5 offset). 18-tap filter also offers a
+superior stop-band attenuation which almost guarantees absence of artifacts if
+the image is considerably sharpened afterwards.
+
+## Why 2X upsizing in AVIR? ##
+Classic approaches to image resizing do not perform an additional 2X upsizing.
+So, why such upsizing is needed at all in AVIR? Indeed, image resizing can be
+implemented using a single interpolation filter which is applied to the source
+image directly. However, such approach has limitations:
+
+First of all, speaking about non-2X-upsized resizing, during upsizing the
+interpolation filter has to be tuned to a frequency close to pi (Nyquist) in
+order to reduce high-frequency smoothing: this reduces the space left for
+filter optimization. Beside that, during downsizing, a filter that performs
+well and predictable when tuned to frequencies close to the Nyquist frequency,
+may become distorted in its spectral shape when it is tuned to lower
+frequencies. That is why it is usually a good idea to have filter's stop-band
+begin below Nyquist so that the transition band's shape remains stable at any
+lower-frequency setting. At the same time, this requirement complicates a
+further corrective filtering, because correction filter may become too steep
+at the point where the stop-band beings.
+
+Secondly, speaking about non-2X-upsized resizing, filter has to be very short
+(with a base length of 5-7 taps, further multiplied by the resizing factor) or
+otherwise the ringing artifacts will be very strong: it is a general rule that
+the steeper the filter is around signal frequencies being removed the higher
+the ringing artifacts. That is why it is preferred to move steep transitions
+into the spectral area with a quieter signal. A short filter also means it
+cannot provide a strong "beyond-Nyquist" stop-band attenuation, so an
+interpolated image will look a bit edgy or not very clean due to stop-band
+artifacts.
+
+To sum up, only additional controlled 2X upsizing provides enough spectral
+space to design interpolation filter without visible ringing artifacts yet
+providing a strong stop-band attenuation and stable spectral characteristics
+(good at any resizing "k" factor). Moreover, 2X upsizing becomes very
+important in maintaining a good resizing quality when downsizing and upsizing
+by small "k" factors, in the range 0.5 to 2: resizing approaches that do not
+perform 2X upsizing usually cannot design a good interpolation filter for such
+factors just because there is not enough spectral space available.
+
+## Why Peaked Cosine in AVIR? ##
+First of all, AVIR is a general solution to image resizing problem. That is
+why it should not be directly compared to "spline interpolation" or "Lanczos
+resampling", because the latter two are only means to design interpolation
+filters, and they can be implemented in a variety of ways, even in sub-optimal
+ways. Secondly, with only a minimal effort AVIR can be changed to use any
+existing interpolation formula and any window function, but this is just not
+needed.
+
+An effort was made to compare Peaked Cosine to Lanczos window function, and
+here is the author's opinion. Peaked Cosine has two degrees of freedom whereas
+Lanczos has one degree of freedom. While both functions can be used with
+acceptable results, Peaked Cosine window function used in automatic parameter
+optimization really pushes the limits of frequency response linearity,
+anti-aliasing strength (stop-band attenuation) and low-ringing performance
+which Lanczos cannot usually achieve. This is true at least when using a
+general-purpose downhill simplex optimization method. Lanczos window has good
+(but not better) characteristics in several special cases which makes it of
+limited use in a general solution such as AVIR.
+
+Among other window functions (Kaiser, Gaussian, Cauchy, Poisson, generalized
+cosine windows) there are no better candidates as well. It looks like Peaked
+Cosine function's scalability (it retains stable, almost continously-variable
+spectral characteristics at any window parameter values), and its ability to
+create "desirable" pass-band ripple in the frequency response near the cutoff
+point contribute to its better overall quality. Somehow Peaked Cosine window
+function optimization manages to converge to reasonable states in most cases
+(that is why AVIR library comes with a set of equally robust, but distinctive
+parameter sets) whereas all other window functions tend to produce
+unpredictable optimization results.
+
+The only disadvantage of Peaked Cosine window function is that usable filters
+windowed by this function tend to be longer than "usual" (with Kaiser window
+being the "golden standard" for filter length per decibel of stop-band
+attenuation). This is a price that should be paid for stable spectral
+characteristics.
+
+## Users ##
+This library is used by:
+
+  * [Contaware.com](http://www.contaware.com/)
+
+Please drop me a note at aleksey.vaneev@gmail.com and I will include a link to
+your software product to the list of users. This list is important at
+maintaining confidence in this library among the interested parties.
diff -Nur orig/source/build.h mod/source/build.h
--- orig/source/build.h	2010-12-30 20:22:28.000000000 +0100
+++ mod/source/build.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: build.h 4360 2010-12-30 19:22:35Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -24,14 +24,16 @@
 //**************************************************************************
 
 #define VERSION_MAJOR	1
-#define VERSION_MINOR	33
+#define VERSION_MINOR	34
 #define VERSION_RELEASE	0
-#define VERSION_TEXT	"1.33"
+#define VERSION_TEXT	"1.34"
+#define SPECIAL_VERSION_TEXT ""
+#define REVISION GIT_DESCRIPTION
 
 // The version as seen in the Windows resource
-#define RC_FILEVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_RELEASE,SVN_REVISION_NUMBER
+#define RC_FILEVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_RELEASE
 #define RC_PRODUCTVERSION VERSION_MAJOR,VERSION_MINOR,VERSION_RELEASE,0
-#define RC_FILEVERSION2 VERSION_TEXT " (r" SVN_REVISION_STRING ")"
+#define RC_FILEVERSION2 VERSION_TEXT " (r" REVISION ", " GIT_HASH ")"
 #define RC_PRODUCTVERSION2 VERSION_TEXT
 
 #if !defined CLIENT && !defined SERVER
diff -Nur orig/source/chat.cpp mod/source/chat.cpp
--- orig/source/chat.cpp	2007-11-21 00:58:08.000000000 +0100
+++ mod/source/chat.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: chat.cpp 2851 2007-11-20 23:26:27Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/chat.h mod/source/chat.h
--- orig/source/chat.h	2006-12-05 18:51:21.000000000 +0100
+++ mod/source/chat.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: chat.h 1878 2006-12-05 09:25:14Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/cheats.cpp mod/source/cheats.cpp
--- orig/source/cheats.cpp	2010-03-02 18:51:43.000000000 +0100
+++ mod/source/cheats.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cheats.cpp 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -340,3 +340,23 @@
 		Player->eventCheat_Anubis();
 	}
 }
+
+//==========================================================================
+//
+//  Freeze_f
+//
+//==========================================================================
+
+COMMAND(Freeze)
+{
+	if (Source == SRC_Command)
+	{
+		ForwardToServer();
+		return;
+	}
+
+	if (CheatAllowed(Player))
+	{
+		Player->eventCheat_Freeze();
+	}
+}
diff -Nur orig/source/client.h mod/source/client.h
--- orig/source/client.h	2008-12-03 20:52:30.000000000 +0100
+++ mod/source/client.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: client.h 3889 2008-12-03 19:57:05Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/cl_local.h mod/source/cl_local.h
--- orig/source/cl_local.h	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/cl_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cl_local.h 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/cl_main.cpp mod/source/cl_main.cpp
--- orig/source/cl_main.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/cl_main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cl_main.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/CMakeLists.txt mod/source/CMakeLists.txt
--- orig/source/CMakeLists.txt	2010-12-17 16:08:42.000000000 +0100
+++ mod/source/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -1,3 +1,4 @@
+add_subdirectory(gme)
 add_subdirectory(timidity)
 
 option(WITH_ALLEGRO "Use Allegro library")
@@ -7,6 +8,7 @@
 option(WITH_VORBIS "Enable Vorbis support" ON)
 option(WITH_LIBMAD "Enable MP3 support" ON)
 option(WITH_MIKMOD "Enable MikMod support" ON)
+option(WITH_MODPLUG "Enable ModPlug support" ON)
 option(WITH_FLAC "Enable FLAC support" ON)
 
 option(ENABLE_CLIENT "Build client executable" ON)
@@ -173,6 +175,7 @@
 	server.h
 	snd_data.cpp
 	snd_local.h
+	snd_gme.cpp
 	snd_main.cpp
 	snd_qmus2mid.cpp
 	snd_reverbs.cpp
@@ -294,6 +297,11 @@
 	snd_mikmod.cpp
 )
 
+#-- ModPlug files --
+set(MAIN_MODPLUG_SOURCES
+	snd_modplug.cpp
+)
+
 #-- FLAC files --
 set(MAIN_FLAC_SOURCES
 	snd_flac.cpp
@@ -490,7 +498,7 @@
 #---------------------------------------
 
 add_custom_target( revision_check ALL
-	COMMAND updaterevision ${PROJECT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR}/svnrev.h
+	COMMAND updaterevision /usr/bin ${PROJECT_SOURCE_DIR}/ ${CMAKE_CURRENT_BINARY_DIR}/gitrev.h
 	WORKING_DIRECTORY ${UPDATEREVISION_EXE}
 	DEPENDS updaterevision )
 
@@ -505,7 +513,7 @@
 if(ENABLE_CLIENT)
 
 set(MAIN_SOURCES ${MAIN_COMMON_SOURCES})
-set(MAIN_LIBS glbsp libglvis timidity core ${ZLIB_LIBRARY} ${NET_LIBRARIES})
+set(MAIN_LIBS glbsp libglvis timidity gme core ${ZLIB_LIBRARY} ${NET_LIBRARIES})
 set(MAIN_COMPILE_FLAGS "")
 
 #
@@ -763,6 +771,23 @@
 endif(WITH_MIKMOD)
 
 #
+#  **** Check for ModPlug ****
+#
+
+if(WITH_MODPLUG)
+	FIND_PACKAGE ( PkgConfig REQUIRED )
+	PKG_CHECK_MODULES ( MODPLUG libmodplug )
+		if(MODPLUG_LIBRARIES)
+			message(STATUS "Found MODPLUG: ${MODPLUG_LIBRARIES}")
+			include_directories(${MODPLUG_INCLUDE_DIRS})
+			set(MAIN_SOURCES ${MAIN_SOURCES} ${MAIN_MODPLUG_SOURCES})
+			set(MAIN_LIBS ${MODPLUG_LIBRARIES} ${MAIN_LIBS})
+		else(MODPLUG_LIBRARIES)
+			message(STATUS "Could NOT find MODPLUG libraries")
+		endif(MODPLUG_LIBRARIES)
+endif(WITH_MODPLUG)
+
+#
 #  **** Check for FLAC ****
 #
 
@@ -790,7 +815,7 @@
 	set_target_properties(vavoom PROPERTIES COMPILE_FLAGS ${MAIN_COMPILE_FLAGS})
 endif (MAIN_COMPILE_FLAGS)
 target_link_libraries(vavoom ${MAIN_LIBS})
-add_dependencies(vavoom core timidity glbsp libglvis)
+add_dependencies(vavoom core timidity gme glbsp libglvis)
 
 install(TARGETS vavoom DESTINATION ${BINDIR})
 
diff -Nur orig/source/cmd.cpp mod/source/cmd.cpp
--- orig/source/cmd.cpp	2010-11-30 12:36:12.000000000 +0100
+++ mod/source/cmd.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cmd.cpp 4336 2010-09-17 21:54:34Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -130,9 +130,9 @@
 	//	Add configuration file execution
 	GCmdBuf << "exec startup.vs\n";
 
-	//	Add consloe commands from command line
-	// These are params, that start with + and continues untill the end
-	// or untill next param, that starts with - or +
+	//	Add console commands from command line
+	// These are params, that start with + and continue until the end
+	// or until next param that starts with - or +
 	for (int i = 1; i < GArgs.Count(); i++)
 	{
 		if (in_cmd)
@@ -192,8 +192,14 @@
 	{
 		VAlias* Next = a->Next;
 		delete a;
-		a = NULL;
-		a = Next;
+		if (Next)
+		{
+			a = Next;
+		}
+		else
+		{
+			a = NULL;
+		}
 	}
 	AutoCompleteTable.Clear();
 	Args.Clear();
diff -Nur orig/source/cmd.h mod/source/cmd.h
--- orig/source/cmd.h	2008-05-30 19:19:50.000000000 +0200
+++ mod/source/cmd.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cmd.h 3675 2008-05-30 17:26:31Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/common.h mod/source/common.h
--- orig/source/common.h	2010-04-03 21:55:10.000000000 +0200
+++ mod/source/common.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: common.h 4211 2010-04-03 19:59:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/console.cpp mod/source/console.cpp
--- orig/source/console.cpp	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/console.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: console.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/console.h mod/source/console.h
--- orig/source/console.h	2008-12-01 21:19:11.000000000 +0100
+++ mod/source/console.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: console.h 3883 2008-12-01 20:23:04Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/cvar.cpp mod/source/cvar.cpp
--- orig/source/cvar.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/cvar.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cvar.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/cvar.h mod/source/cvar.h
--- orig/source/cvar.h	2006-06-28 21:36:14.000000000 +0200
+++ mod/source/cvar.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cvar.h 1585 2006-06-28 19:37:15Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/d3d_draw.cpp mod/source/d3d_draw.cpp
--- orig/source/d3d_draw.cpp	2008-03-29 21:26:11.000000000 +0100
+++ mod/source/d3d_draw.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: d3d_draw.cpp 3402 2008-03-29 18:48:10Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/d3d_local.h mod/source/d3d_local.h
--- orig/source/d3d_local.h	2010-12-17 16:07:02.000000000 +0100
+++ mod/source/d3d_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: d3d_local.h 4349 2010-12-17 15:07:11Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -162,7 +162,7 @@
 		const TVec&);
 	void DrawAliasModel(const TVec&, const TAVec&, const TVec&, const TVec&,
 		VMeshModel*, int, int, VTexture*, VTextureTranslation*, int, vuint32,
-		vuint32, float, bool, bool, float, bool);
+		vuint32, float, bool, bool, float, bool, bool, bool);
 	bool StartPortal(VPortal*, bool);
 	void EndPortal(VPortal*, bool);
 
@@ -194,25 +194,27 @@
 	void DrawWorldAmbientPass();
 	void BeginShadowVolumesPass();
 	void BeginLightShadowVolumes();
-	void RenderSurfaceShadowVolume(surface_t*, TVec&, float);
+	void RenderSurfaceShadowVolume(surface_t*, TVec&, float, bool);
 	void BeginLightPass(TVec&, float, vuint32);
-	void DrawSurfaceLight(surface_t*);
+	void DrawSurfaceLight(surface_t*, TVec&, float, bool);
 	void DrawWorldTexturesPass();
 	void DrawWorldFogPass();
 	void EndFogPass();
 	void DrawAliasModelAmbient(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool);
+		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool,
+		bool, bool);
 	void DrawAliasModelTextures(const TVec&, const TAVec&, const TVec&,
 		const TVec&, VMeshModel*, int, int, VTexture*, VTextureTranslation*, int,
-		float, bool);
+		float, float, bool, bool, bool);
 	void BeginModelsLightPass(TVec&, float, vuint32);
 	void DrawAliasModelLight(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, float, bool);
+		const TVec&, VMeshModel*, int, int, VTexture*, float, float, bool, bool);
 	void BeginModelsShadowsPass(TVec&, float);
 	void DrawAliasModelShadow(const TVec&, const TAVec&, const TVec&,
 		const TVec&, VMeshModel*, int, int, float, bool, const TVec&, float);
 	void DrawAliasModelFog(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool);
+		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool,
+		bool);
 
 private:
 	bool Reset();
@@ -275,6 +277,11 @@
 	D3DTEXTUREFILTERTYPE		minfilter;
 	D3DTEXTUREFILTERTYPE		mipfilter;
 
+	//	Sprite Texture filters.
+	D3DTEXTUREFILTERTYPE		spr_magfilter;
+	D3DTEXTUREFILTERTYPE		spr_minfilter;
+	D3DTEXTUREFILTERTYPE		spr_mipfilter;
+
 	//	Textures.
 	LPDIRECT3DTEXTURE9			particle_texture;
     int                         tscount;
@@ -291,12 +298,14 @@
 	static VCvarI device;
 	static VCvarI clear;
 	static VCvarI tex_linear;
+	static VCvarI sprite_tex_linear;
 	static VCvarI dither;
 	static VCvarI blend_sprites;
 	static VCvarF maxdist;
 	static VCvarI model_lighting;
 	static VCvarI specular_highlights;
 	static VCvarI avoid_input_lag;
+	static VCvarI multisampling_sample;
 };
 
 // PUBLIC FUNCTION PROTOTYPES ----------------------------------------------
diff -Nur orig/source/d3d_main.cpp mod/source/d3d_main.cpp
--- orig/source/d3d_main.cpp	2010-12-17 15:50:09.000000000 +0100
+++ mod/source/d3d_main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: d3d_main.cpp 4348 2010-12-17 14:50:18Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -47,12 +47,14 @@
 VCvarI VDirect3DDrawer::device("d3d_device", "0", CVAR_Archive);
 VCvarI VDirect3DDrawer::clear("d3d_clear", "0", CVAR_Archive);
 VCvarI VDirect3DDrawer::tex_linear("d3d_tex_linear", "2", CVAR_Archive);
+VCvarI VDirect3DDrawer::sprite_tex_linear("d3d_sprite_tex_linear", "2", CVAR_Archive);
 VCvarI VDirect3DDrawer::dither("d3d_dither", "0", CVAR_Archive);
 VCvarI VDirect3DDrawer::blend_sprites("d3d_blend_sprites", "0", CVAR_Archive);
 VCvarF VDirect3DDrawer::maxdist("d3d_maxdist", "8192.0", CVAR_Archive);
 VCvarI VDirect3DDrawer::model_lighting("d3d_model_lighting", "0", CVAR_Archive);
 VCvarI VDirect3DDrawer::specular_highlights("d3d_specular_highlights", "1", CVAR_Archive);
 VCvarI VDirect3DDrawer::avoid_input_lag("d3d_avoid_input_lag", "1", CVAR_Archive);
+VCvarI VDirect3DDrawer::multisampling_sample("d3d_multisampling_sample", "2", CVAR_Archive);
 
 // PRIVATE DATA DEFINITIONS ------------------------------------------------
 
@@ -188,8 +190,9 @@
 		WindowRect.right = Width;
 		WindowRect.top = 0;
 		WindowRect.bottom = Height;
-		AdjustWindowRectEx(&WindowRect, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
-			FALSE, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE);
+		AdjustWindowRectEx(&WindowRect, (WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX) |
+			WS_CLIPCHILDREN | WS_CLIPSIBLINGS, FALSE, WS_EX_APPWINDOW |
+			WS_EX_WINDOWEDGE);
 		SetWindowPos(hwnd, HWND_TOP, 0, 0, WindowRect.right - WindowRect.left,
 			WindowRect.bottom - WindowRect.top, SWP_NOMOVE);
 	}
@@ -254,14 +257,17 @@
 
 	if (avoid_input_lag)
 	{
-		if (SUCCEEDED(RenderDevice->CreateOffscreenPlainSurface(16, 16, D3DFMT_A8R8G8B8,
+		if (SUCCEEDED(RenderDevice->CreateOffscreenPlainSurface(16, 16, BPP == 32 ? D3DFMT_A8R8G8B8 : D3DFMT_A1R5G5B5,
 			D3DPOOL_DEFAULT, &DXBlockSurface[0], 0)))
 		{
-			if (!SUCCEEDED(RenderDevice->CreateOffscreenPlainSurface(16, 16, D3DFMT_A8R8G8B8,
+			if (!SUCCEEDED(RenderDevice->CreateOffscreenPlainSurface(16, 16, BPP == 32 ? D3DFMT_A8R8G8B8 : D3DFMT_A1R5G5B5,
 				D3DPOOL_DEFAULT, &DXBlockSurface[1], 0)))
 			{
-				DXBlockSurface[0]->Release();
-				DXBlockSurface[0] = NULL;
+				if (DXBlockSurface[0] != NULL)
+				{
+					DXBlockSurface[0]->Release();
+					DXBlockSurface[0] = NULL;
+				}
 			}
 		}
 	}
@@ -286,7 +292,7 @@
 	RenderDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
 	
 	RenderDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
-	RenderDevice->SetRenderState(D3DRS_ALPHAREF, 170);
+	RenderDevice->SetRenderState(D3DRS_ALPHAREF, 85);
 
 	RenderDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
 	RenderDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
@@ -332,9 +338,9 @@
 		}
 		case 2:
 		{
-			magfilter = D3DTEXF_LINEAR;
-			minfilter = D3DTEXF_LINEAR;
-			mipfilter = D3DTEXF_POINT;
+			magfilter = D3DTEXF_POINT;
+			minfilter = D3DTEXF_POINT;
+			mipfilter = D3DTEXF_LINEAR;
 			break;
 		}
 		case 3:
@@ -351,6 +357,13 @@
 			mipfilter = D3DTEXF_LINEAR;
 			break;
 		}
+		case 5:
+		{
+			magfilter = D3DTEXF_POINT;
+			minfilter = D3DTEXF_ANISOTROPIC;
+			mipfilter = D3DTEXF_LINEAR;
+			break;
+		}
 		default:
 		{
 			magfilter = D3DTEXF_POINT;
@@ -586,7 +599,6 @@
 {
 	guard(VDirect3DDrawer::Update);
 	D3DLOCKED_RECT lr;
-	volatile int dummy;
 
 	// End the scene.
 	RenderDevice->EndScene();
@@ -597,7 +609,6 @@
 		dblock ^= 1;
 		if(!FAILED((DXBlockSurface[dblock]->LockRect(&lr, 0, D3DLOCK_READONLY))))
 		{
-			dummy = *(int*)lr.pBits;
 			DXBlockSurface[dblock]->UnlockRect();
 		}
 	}
@@ -669,11 +680,18 @@
 	//	Allocate buffer
 	void* dst = Z_Malloc(ScreenWidth * ScreenHeight * sizeof(rgb_t));
 
-	LPDIRECT3DSURFACE9 surf;
-	RenderDevice->GetRenderTarget(0, &surf);
+    //  GetRenderTarget method cannot retrieve data from a surface that is 
+	//  contained by a texture resource created with D3DUSAGE_RENDERTARGET
+	//  because such a texture must be assigned to D3DPOOL_DEFAULT memory
+	//  and is therefore not lockable. In this case, use instead
+	//  IDirect3DDevice9::GetRenderTargetData to copy texture data
+	//  from device memory to system memory.
+	IDirect3DSurface9* rend;
+	IDirect3DSurface9* surf;
+	RenderDevice->GetRenderTarget (0, &rend);
 
 	D3DSURFACE_DESC desc;
-	surf->GetDesc(&desc);
+	rend->GetDesc(&desc);
 
 	//	Decode pixel format
 	int scr_rbits;
@@ -708,6 +726,7 @@
 			scr_pixbytes = 2;
 			break;
 		}
+		case D3DFMT_A1R5G5B5:
 		case D3DFMT_X1R5G5B5:
 		{
 			scr_rbits = 5;
@@ -726,10 +745,13 @@
 			return NULL;
 		}
 	}
+	RenderDevice->CreateOffscreenPlainSurface(ScreenWidth, ScreenHeight, D3DFMT_X8R8G8B8, D3DPOOL_SYSTEMMEM, &surf, NULL);
+	RenderDevice->GetRenderTargetData(rend, surf);
 
 	D3DLOCKED_RECT lrect;
 	if (FAILED(surf->LockRect(&lrect, NULL, D3DLOCK_READONLY)))
 	{
+		Z_Free(dst);
 		Sys_Error("ReadScreen: Failed to lock screen");
 	}
 
@@ -749,6 +771,7 @@
 
 	surf->UnlockRect();
 	surf->Release();
+	rend->Release();
 
 	*bpp = 24;
 	*bot2top = false;
@@ -765,11 +788,20 @@
 void VDirect3DDrawer::ReadBackScreen(int Width, int Height, rgba_t* Dest)
 {
 	guard(VDirect3DDrawer::ReadBackScreen);
-	LPDIRECT3DSURFACE9 surf;
-	RenderDevice->GetRenderTarget(0, &surf);
+    //  GetRenderTarget method cannot retrieve data from a surface that is 
+	//  contained by a texture resource created with D3DUSAGE_RENDERTARGET
+	//  because such a texture must be assigned to D3DPOOL_DEFAULT memory
+	//  and is therefore not lockable. In this case, use instead
+	//  IDirect3DDevice9::GetRenderTargetData to copy texture data
+	//  from device memory to system memory.
+	IDirect3DSurface9* rend;
+	IDirect3DSurface9* surf;
+	RenderDevice->GetRenderTarget (0, &rend);
+//	LPDIRECT3DSURFACE9 surf;
+//	RenderDevice->GetRenderTarget(0, &surf);
 
 	D3DSURFACE_DESC desc;
-	surf->GetDesc(&desc);
+	rend->GetDesc(&desc);
 
 	//	Decode pixel format
 	int scr_rbits;
@@ -804,6 +836,7 @@
 			scr_pixbytes = 2;
 			break;
 		}
+		case D3DFMT_A1R5G5B5:
 		case D3DFMT_X1R5G5B5:
 		{
 			scr_rbits = 5;
@@ -821,6 +854,8 @@
 			return;
 		}
 	}
+	RenderDevice->CreateOffscreenPlainSurface(ScreenWidth, ScreenHeight, D3DFMT_X8R8G8B8, D3DPOOL_SYSTEMMEM, &surf, NULL);
+	RenderDevice->GetRenderTargetData(rend, surf);
 
 	D3DLOCKED_RECT lrect;
 	if (FAILED(surf->LockRect(&lrect, NULL, D3DLOCK_READONLY)))
@@ -845,6 +880,7 @@
 
 	surf->UnlockRect();
 	surf->Release();
+	rend->Release();
 	unguard;
 }
 
@@ -904,22 +940,24 @@
 void VDirect3DDrawer::DrawWorldAmbientPass() {}
 void VDirect3DDrawer::BeginShadowVolumesPass() {}
 void VDirect3DDrawer::BeginLightShadowVolumes() {}
-void VDirect3DDrawer::RenderSurfaceShadowVolume(surface_t*, TVec&, float) {}
+void VDirect3DDrawer::RenderSurfaceShadowVolume(surface_t*, TVec&, float, bool) {}
 void VDirect3DDrawer::BeginLightPass(TVec&, float, vuint32) {}
-void VDirect3DDrawer::DrawSurfaceLight(surface_t*) {}
+void VDirect3DDrawer::DrawSurfaceLight(surface_t*, TVec&, float, bool) {}
 void VDirect3DDrawer::DrawWorldTexturesPass() {}
 void VDirect3DDrawer::DrawWorldFogPass() {}
 void VDirect3DDrawer::EndFogPass() {}
 void VDirect3DDrawer::DrawAliasModelAmbient(const TVec&, const TAVec&, const TVec&,
-	const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool) {}
+	const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool,
+	bool, bool) {}
 void VDirect3DDrawer::DrawAliasModelTextures(const TVec&, const TAVec&, const TVec&,
 	const TVec&, VMeshModel*, int, int, VTexture*, VTextureTranslation*, int,
-	float, bool) {}
+	float, float, bool, bool, bool) {}
 void VDirect3DDrawer::BeginModelsLightPass(TVec&, float, vuint32) {}
 void VDirect3DDrawer::DrawAliasModelLight(const TVec&, const TAVec&, const TVec&,
-	const TVec&, VMeshModel*, int, int, VTexture*, float, bool) {}
+	const TVec&, VMeshModel*, int, int, VTexture*, float, float, bool, bool) {}
 void VDirect3DDrawer::BeginModelsShadowsPass(TVec&, float) {}
 void VDirect3DDrawer::DrawAliasModelShadow(const TVec&, const TAVec&, const TVec&,
 	const TVec&, VMeshModel*, int, int, float, bool, const TVec&, float) {}
 void VDirect3DDrawer::DrawAliasModelFog(const TVec&, const TAVec&, const TVec&,
-	const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool) {}
+	const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool,
+	bool) {}
diff -Nur orig/source/d3d_poly.cpp mod/source/d3d_poly.cpp
--- orig/source/d3d_poly.cpp	2010-12-17 16:07:02.000000000 +0100
+++ mod/source/d3d_poly.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: d3d_poly.cpp 4349 2010-12-17 15:07:11Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -102,6 +102,12 @@
 	{
 		for (surf = RendLev->HorizonPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			DoHorizonPolygon(surf);
 		}
 	}
@@ -114,6 +120,12 @@
 		RenderDevice->SetRenderState(D3DRS_COLORWRITEENABLE, 0);
 		for (surf = RendLev->SkyPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			for (i = 0; i < surf->count; i++)
 			{
 				out[i] = MyD3DVertex(surf->verts[i], 0, 0, 0);
@@ -129,6 +141,12 @@
 	{
 		for (surf = RendLev->SimpleSurfsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			texinfo_t *tex = surf->texinfo;
 			SetTexture(tex->Tex, tex->ColourMap);
 
@@ -167,6 +185,7 @@
 		RenderDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 1);
 		RenderDevice->SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
 		RenderDevice->SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
+		RenderDevice->SetSamplerState(1, D3DSAMP_MIPFILTER, D3DTEXF_NONE);
 
 		for (lb = 0; lb < NUM_BLOCK_SURFS; lb++)
 		{
@@ -191,6 +210,11 @@
 			for (cache = RendLev->light_chain[lb]; cache; cache = cache->chain)
 			{
 				surf = cache->surf;
+				if (surf->plane->PointOnSide(vieworg))
+				{
+					//	Viewer is in back side or on plane
+					continue;
+				}
 				tex = surf->texinfo;
 				SetTexture(tex->Tex, tex->ColourMap);
 				SetFade(surf->Fade);
@@ -244,6 +268,11 @@
 			for (cache = RendLev->light_chain[lb]; cache; cache = cache->chain)
 			{
 				surf = cache->surf;
+				if (surf->plane->PointOnSide(vieworg))
+				{
+					//	Viewer is in back side or on plane
+					continue;
+				}
 				tex = surf->texinfo;
 				SetFade(surf->Fade);
 				for (i = 0; i < surf->count; i++)
@@ -259,9 +288,6 @@
 			}
 		}
 
-		RenderDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, magfilter);
-		RenderDevice->SetSamplerState(0, D3DSAMP_MINFILTER, minfilter);
-		RenderDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, mipfilter);
 		RenderDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
 		RenderDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
 		RenderDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
@@ -305,6 +331,11 @@
 			for (cache = RendLev->add_chain[lb]; cache; cache = cache->addchain)
 			{
 				surf = cache->surf;
+				if (surf->plane->PointOnSide(vieworg))
+				{
+					//	Viewer is in back side or on plane
+					continue;
+				}
 				tex = surf->texinfo;
 				for (i = 0; i < surf->count; i++)
 				{
@@ -319,9 +350,6 @@
 			}
 		}
 
-		RenderDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, magfilter);
-		RenderDevice->SetSamplerState(0, D3DSAMP_MINFILTER, minfilter);
-		RenderDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, mipfilter);
 		RenderDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
 		RenderDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
 		RenderDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
@@ -454,14 +482,14 @@
 	if (HaveMultiTexture && Texture2->Type != TEXTYPE_Null)
 	{
 		RenderDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
+
+		SetTexture(Texture2, CMap);
+		TexStage = 1;
 		RenderDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_BLENDTEXTUREALPHA);
 		RenderDevice->SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
 		RenderDevice->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);
 		RenderDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 1);
-
 		SetTexture(Texture1, CMap);
-		TexStage = 1;
-		SetTexture(Texture2, CMap);
 		TexStage = 0;
 		for (i = 0; i < surf->count; i++)
 		{
@@ -475,7 +503,9 @@
 		RenderDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, surf->count - 2, out, sizeof(MyD3DVertex));
 
 		RenderDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
+		TexStage = 1;
 		RenderDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
+		TexStage = 0;
 	}
 	else
 	{
@@ -517,12 +547,17 @@
 	bool Additive)
 {
 	guard(VDirect3DDrawer::DrawMaskedPolygon);
+	if (surf->plane->PointOnSide(vieworg))
+	{
+		//	Viewer is in back side or on plane
+		return;
+	}
 	MyD3DVertex	out[256];
 	int			l;
 
 	texinfo_t* tex = surf->texinfo;
 	SetTexture(tex->Tex, tex->ColourMap);
-
+	
 	if (surf->lightmap != NULL ||
 		surf->dlightframe == r_dlightframecount)
 	{
@@ -567,7 +602,7 @@
 	if (blend_sprites || Additive || Alpha < 1.0)
 	{
 		RenderDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
-		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 0);
+		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 85);
 	}
 	if (Additive)
 	{
@@ -580,7 +615,7 @@
 	if (blend_sprites || Additive || Alpha < 1.0)
 	{
 		RenderDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
-		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 170);
+		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 85);
 	}
 	if (Additive)
 	{
@@ -605,6 +640,55 @@
 
 	SetSpriteLump(Tex, Translation, CMap);
 
+	//	Setup texture filtering
+	switch (sprite_tex_linear)
+	{
+		case 1:
+		{
+			spr_magfilter = D3DTEXF_LINEAR;
+			spr_minfilter = D3DTEXF_LINEAR;
+			spr_mipfilter = D3DTEXF_NONE;
+			break;
+		}
+		case 2:
+		{
+			spr_magfilter = D3DTEXF_POINT;
+			spr_minfilter = D3DTEXF_POINT;
+			spr_mipfilter = D3DTEXF_LINEAR;
+			break;
+		}
+		case 3:
+		{
+			spr_magfilter = D3DTEXF_LINEAR;
+			spr_minfilter = D3DTEXF_LINEAR;
+			spr_mipfilter = D3DTEXF_LINEAR;
+			break;
+		}
+		case 4:
+		{
+			spr_magfilter = D3DTEXF_ANISOTROPIC;
+			spr_minfilter = D3DTEXF_ANISOTROPIC;
+			spr_mipfilter = D3DTEXF_LINEAR;
+			break;
+		}
+		case 5:
+		{
+			spr_magfilter = D3DTEXF_POINT;
+			spr_minfilter = D3DTEXF_ANISOTROPIC;
+			spr_mipfilter = D3DTEXF_LINEAR;
+			break;
+		}
+		default:
+		{
+			spr_magfilter = D3DTEXF_POINT;
+			spr_minfilter = D3DTEXF_POINT;
+			spr_mipfilter = D3DTEXF_NONE;
+		}
+	}
+	RenderDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, spr_magfilter);
+	RenderDevice->SetSamplerState(0, D3DSAMP_MINFILTER, spr_minfilter);
+	RenderDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, spr_mipfilter);
+
 	int l = ((int)(Alpha * 255) << 24) | (light & 0x00ffffff);
 	for (int i = 0; i < 4; i++)
 	{
@@ -615,23 +699,23 @@
 	}
 	SetFade(Fade);
 
+	RenderDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
 	if (blend_sprites || Additive || Alpha < 1.0)
 	{
 		RenderDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
-		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 0);
+		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 28);
 	}
 	if (Additive)
 	{
 		RenderDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
 	}
-	RenderDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
 
 	RenderDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, out, sizeof(MyD3DVertex));
 
 	if (blend_sprites || Additive || Alpha < 1.0)
 	{
 		RenderDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
-		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 170);
+		RenderDevice->SetRenderState(D3DRS_ALPHAREF, 85);
 	}
 	if (Additive)
 	{
@@ -651,7 +735,8 @@
 	const TVec& Offset, const TVec& Scale, VMeshModel* Mdl, int frame,
 	int nextframe, VTexture* Skin, VTextureTranslation* Trans, int CMap,
 	vuint32 light, vuint32 Fade, float Alpha, bool Additive,
-	bool is_view_model, float Inter, bool Interpolate)
+	bool is_view_model, float Inter, bool Interpolate, bool ForceDepthUse,
+	bool AllowTransparency)
 {
 	guard(VDirect3DDrawer::DrawAliasModel);
 	mframe_t			*pframedesc;
@@ -837,7 +922,7 @@
 	{
 		RenderDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
 	}
-	RenderDevice->SetRenderState(D3DRS_ALPHAREF, 170);
+	RenderDevice->SetRenderState(D3DRS_ALPHAREF, 85);
 	RenderDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
 
 	RenderDevice->SetTransform(D3DTS_WORLD, &IdentityMatrix);
@@ -872,6 +957,7 @@
 				pbuf[j][i].a = byte(ptex[j][i] * 255);
 			}
 		}
+		VTexture::SmoothEdges((vuint8 *)pbuf, 8, 8, (vuint8 *)pbuf);
 		particle_texture = CreateSurface(8, 8, 16, false);
 		UploadTextureImage(particle_texture, 0, 8, 8, &pbuf[0][0]);
 	}
@@ -911,7 +997,7 @@
 	guard(VDirect3DDrawer::EndParticles);
 	RenderDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
 	RenderDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
-	RenderDevice->SetRenderState(D3DRS_ALPHAREF, 170);
+	RenderDevice->SetRenderState(D3DRS_ALPHAREF, 85);
 	unguard;
 }
 
@@ -996,9 +1082,15 @@
 	for (int i = 0; i < Portal->Surfs.Num(); i++)
 	{
 		const surface_t* Surf = Portal->Surfs[i];
-		for (int i = 0; i < Surf->count; i++)
+		if (Surf->plane->PointOnSide(vieworg))
+		{
+			// Viewer is in the back side or on plane
+			continue;
+		}
+
+		for (int j = 0; j < Surf->count; j++)
 		{
-			out[i] = MyD3DVertex(Surf->verts[i], 0, 0, 0);
+			out[j] = MyD3DVertex(Surf->verts[j], 0, 0, 0);
 		}
 	    RenderDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, Surf->count - 2,
             out, sizeof(MyD3DVertex));
diff -Nur orig/source/d3d_tex.cpp mod/source/d3d_tex.cpp
--- orig/source/d3d_tex.cpp	2010-12-15 23:20:47.000000000 +0100
+++ mod/source/d3d_tex.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: d3d_tex.cpp 4341 2010-12-15 22:20:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -171,7 +171,22 @@
 void VDirect3DDrawer::SetTexture(VTexture* Tex, int CMap)
 {
 	guard(VDirect3DDrawer::SetTexture);
+	if (RenderDevice)
+	{
+		RenderDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, magfilter);
+		RenderDevice->SetSamplerState(0, D3DSAMP_MINFILTER, minfilter);
+		if (Tex->Type == TEXTYPE_WallPatch || Tex->Type == TEXTYPE_Wall ||
+			Tex->Type == TEXTYPE_Flat)
+		{
+			RenderDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_NONE);
+		}
+		else
+		{
+			RenderDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, mipfilter);
+		}
+	}
 	SetSpriteLump(Tex, NULL, CMap);
+
 	if (RenderDevice)
 	{
 		RenderDevice->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
@@ -239,6 +254,20 @@
 	int CMap)
 {
 	guard(VDirect3DDrawer::SetPic);
+	if (RenderDevice)
+	{
+		RenderDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, magfilter);
+		RenderDevice->SetSamplerState(0, D3DSAMP_MINFILTER, minfilter);
+		if (Tex->Type == TEXTYPE_Skin /*|| Tex->Type == TEXTYPE_FontChar*/)
+		{
+			RenderDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, mipfilter);
+		}
+		else
+		{
+			RenderDevice->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_NONE);
+		}
+	}
+
 	SetSpriteLump(Tex, Trans, CMap);
 	unguard;
 }
@@ -377,7 +406,7 @@
 	guard(VDirect3DDrawer::UploadTexture);
 	int						w, h;
 	vuint8					*image;
-	vuint8					stackbuf[256 * 128 * 4];
+	vuint8					*stackbuf = (vuint8 *)Z_Malloc(256 * 128 * 4);
 	LPDIRECT3DTEXTURE9		surf;
 	UINT					level;
 
@@ -407,9 +436,14 @@
 	if (w != width || h != height)
 	{
 		// Smooth transparent edges
-		VTexture::SmoothEdges((vuint8*)data, width, height, (vuint8*)data);
+		VTexture::SmoothEdges(image, w, h, image);
 		//	Must rescale image to get "top" mipmap texture image
-		VTexture::ResampleTexture(width, height, (vuint8*)data, w, h, image);
+		VTexture::ResampleTexture(width, height, (vuint8*)data, w, h, image, multisampling_sample);
+		/*avir::CImageResizerParamsUltra Params;
+		avir::CImageResizer<avir::fpclass_float4> ImageResizer(8, 16, Params);
+		ImageResizer.resizeImage((vuint8*)data, width, height, 0, image, w, h, 4, 0);*/
+		// Smooth transparent edges
+		VTexture::SmoothEdges(image, w, h, image);
 	}
 	else
 	{
@@ -433,6 +467,7 @@
 	{
 		Z_Free(image);
 	}
+	Z_Free(stackbuf);
 	return surf;
 	unguard;
 }
diff -Nur orig/source/debug.cpp mod/source/debug.cpp
--- orig/source/debug.cpp	2010-04-03 17:08:25.000000000 +0200
+++ mod/source/debug.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: debug.cpp 4203 2010-04-03 15:12:56Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/debug.h mod/source/debug.h
--- orig/source/debug.h	2006-06-27 21:47:24.000000000 +0200
+++ mod/source/debug.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: debug.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/drawer.h mod/source/drawer.h
--- orig/source/drawer.h	2010-12-17 16:36:07.000000000 +0100
+++ mod/source/drawer.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: drawer.h 4350 2010-12-17 15:36:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -157,7 +157,7 @@
 		const TVec&, const TVec&, const TVec&) = 0;
 	virtual void DrawAliasModel(const TVec&, const TAVec&, const TVec&,
 		const TVec&, VMeshModel*, int, int, VTexture*, VTextureTranslation*, int,
-		vuint32, vuint32, float, bool, bool, float, bool) = 0;
+		vuint32, vuint32, float, bool, bool, float, bool, bool, bool) = 0;
 	virtual bool StartPortal(VPortal*, bool) = 0;
 	virtual void EndPortal(VPortal*, bool) = 0;
 
@@ -189,25 +189,27 @@
 	virtual void DrawWorldAmbientPass() = 0;
 	virtual void BeginShadowVolumesPass() = 0;
 	virtual void BeginLightShadowVolumes() = 0;
-	virtual void RenderSurfaceShadowVolume(surface_t*, TVec&, float) = 0;
+	virtual void RenderSurfaceShadowVolume(surface_t*, TVec&, float, bool) = 0;
 	virtual void BeginLightPass(TVec&, float, vuint32) = 0;
-	virtual void DrawSurfaceLight(surface_t*) = 0;
+	virtual void DrawSurfaceLight(surface_t*, TVec&, float, bool) = 0;
 	virtual void DrawWorldTexturesPass() = 0;
 	virtual void DrawWorldFogPass() = 0;
 	virtual void EndFogPass() = 0;
 	virtual void DrawAliasModelAmbient(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool) = 0;
+		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool,
+		bool, bool) = 0;
 	virtual void DrawAliasModelTextures(const TVec&, const TAVec&, const TVec&,
 		const TVec&, VMeshModel*, int, int, VTexture*, VTextureTranslation*, int,
-		float, bool) = 0;
+		float, float, bool, bool, bool) = 0;
 	virtual void BeginModelsLightPass(TVec&, float, vuint32) = 0;
 	virtual void DrawAliasModelLight(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, float, bool) = 0;
+		const TVec&, VMeshModel*, int, int, VTexture*, float, float, bool, bool) = 0;
 	virtual void BeginModelsShadowsPass(TVec&, float) = 0;
 	virtual void DrawAliasModelShadow(const TVec&, const TAVec&, const TVec&,
 		const TVec&, VMeshModel*, int, int, float, bool, const TVec&, float) = 0;
 	virtual void DrawAliasModelFog(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool) = 0;
+		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool,
+		bool) = 0;
 };
 
 //	Drawer types, menu system uses these numbers.
diff -Nur orig/source/files.cpp mod/source/files.cpp
--- orig/source/files.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/files.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: files.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/files.h mod/source/files.h
--- orig/source/files.h	2006-12-16 12:55:35.000000000 +0100
+++ mod/source/files.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: files.h 1907 2006-12-16 11:58:56Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/finale.cpp mod/source/finale.cpp
--- orig/source/finale.cpp	2008-11-26 21:59:16.000000000 +0100
+++ mod/source/finale.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: finale.cpp 3874 2008-11-26 21:03:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/finale.h mod/source/finale.h
--- orig/source/finale.h	2008-11-13 22:56:03.000000000 +0100
+++ mod/source/finale.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: finale.h 3864 2008-11-13 21:59:15Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/fmd2defs.h mod/source/fmd2defs.h
--- orig/source/fmd2defs.h	2006-06-27 21:47:24.000000000 +0200
+++ mod/source/fmd2defs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fmd2defs.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/fs_dir.cpp mod/source/fs_dir.cpp
--- orig/source/fs_dir.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/fs_dir.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fs_dir.cpp 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/fs_local.h mod/source/fs_local.h
--- orig/source/fs_local.h	2009-03-17 20:00:52.000000000 +0100
+++ mod/source/fs_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fs_local.h 4012 2009-03-17 19:03:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/fs_wad.cpp mod/source/fs_wad.cpp
--- orig/source/fs_wad.cpp	2009-11-13 19:28:31.000000000 +0100
+++ mod/source/fs_wad.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fs_wad.cpp 4102 2009-11-13 00:22:29Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -443,7 +443,9 @@
 		gwaname = GwaDir + "/" + Name.ExtractFileName();
 	}
 	else
+	{
 		gwaname = Name;
+	}
 	gwaname = gwaname.StripExtension() + ".gwa";
 
 	// Build GL nodes
diff -Nur orig/source/fs_zip.cpp mod/source/fs_zip.cpp
--- orig/source/fs_zip.cpp	2010-06-04 23:20:23.000000000 +0200
+++ mod/source/fs_zip.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fs_zip.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/fwaddefs.h mod/source/fwaddefs.h
--- orig/source/fwaddefs.h	2006-06-27 21:47:25.000000000 +0200
+++ mod/source/fwaddefs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fwaddefs.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/gamedefs.h mod/source/gamedefs.h
--- orig/source/gamedefs.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/source/gamedefs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gamedefs.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/gl_agl.cpp mod/source/gl_agl.cpp
--- orig/source/gl_agl.cpp	2010-12-17 15:27:47.000000000 +0100
+++ mod/source/gl_agl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_agl.cpp 4346 2010-12-17 14:27:56Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -91,14 +91,12 @@
 	int Width = AWidth;
 	int Height = AHeight;
 	int BPP = ABPP;
-	bool default_mode = false;
 	if (!Width || !Height)
 	{
 		//	Set defaults
 		Width = 640;
 		Height = 480;
 		BPP = 16;
-		default_mode = true;
 	}
 
 	if (BPP == 15)
diff -Nur orig/source/gl_draw.cpp mod/source/gl_draw.cpp
--- orig/source/gl_draw.cpp	2010-05-08 10:52:27.000000000 +0200
+++ mod/source/gl_draw.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_draw.cpp 4222 2010-05-02 14:54:34Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -198,8 +198,8 @@
 	if (HaveShaders)
 	{
 		p_glUseProgramObjectARB(DrawFixedColProgram);
-		p_glUniform4fARB(DrawFixedColColourLoc, ((colour >> 16) & 0xff) / 255.0,
-			((colour >> 8) & 0xff) / 255.0, (colour & 0xff) / 255.0, 1.0);
+		p_glUniform4fARB(DrawFixedColColourLoc, (GLfloat)(((colour >> 16) & 255) / 255.0),
+			(GLfloat)(((colour >> 8) & 255) / 255.0), (GLfloat)((colour & 255) / 255.0), 1.0);
 	}
 	else
 	{
diff -Nur orig/source/gl_local.h mod/source/gl_local.h
--- orig/source/gl_local.h	2010-12-17 16:07:02.000000000 +0100
+++ mod/source/gl_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_local.h 4349 2010-12-17 15:07:11Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -370,9 +370,9 @@
 	void DrawWorldAmbientPass();
 	void BeginShadowVolumesPass();
 	void BeginLightShadowVolumes();
-	void RenderSurfaceShadowVolume(surface_t *surf, TVec& LightPos, float Radius);
+	void RenderSurfaceShadowVolume(surface_t *, TVec&, float, bool);
 	void BeginLightPass(TVec&, float, vuint32);
-	void DrawSurfaceLight(surface_t*);
+	void DrawSurfaceLight(surface_t*, TVec&, float, bool);
 	void DrawWorldTexturesPass();
 	void DrawWorldFogPass();
 	void EndFogPass();
@@ -384,19 +384,21 @@
 		const TVec&);
 	void DrawAliasModel(const TVec&, const TAVec&, const TVec&, const TVec&,
 		VMeshModel*, int, int, VTexture*, VTextureTranslation*, int, vuint32,
-		vuint32, float, bool, bool, float, bool);
+		vuint32, float, bool, bool, float, bool, bool, bool);
 	void DrawAliasModelAmbient(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool);
+		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool,
+		bool, bool);
 	void DrawAliasModelTextures(const TVec&, const TAVec&, const TVec&, const TVec&,
-		VMeshModel*, int, int, VTexture*, VTextureTranslation*, int, float, bool);
+		VMeshModel*, int, int, VTexture*, VTextureTranslation*, int, float, float, bool,
+		bool, bool);
 	void BeginModelsLightPass(TVec&, float, vuint32);
 	void DrawAliasModelLight(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, float, bool);
+		const TVec&, VMeshModel*, int, int, VTexture*, float, float, bool, bool);
 	void BeginModelsShadowsPass(TVec&, float);
 	void DrawAliasModelShadow(const TVec&, const TAVec&, const TVec&,
 		const TVec&, VMeshModel*, int, int, float, bool, const TVec&, float);
 	void DrawAliasModelFog(const TVec&, const TAVec&, const TVec&,
-		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, bool);
+		const TVec&, VMeshModel*, int, int, VTexture*, vuint32, float, float, bool, bool);
 	bool StartPortal(VPortal*, bool);
 	void EndPortal(VPortal*, bool);
 
@@ -447,6 +449,10 @@
 	GLenum					ClampToEdge;
 	GLfloat					max_anisotropy;
 
+	GLenum					spr_maxfilter;
+	GLenum					spr_minfilter;
+	GLenum					spr_mipfilter;
+
 	int						lastgamma;
 	int						CurrentFade;
 
@@ -547,7 +553,10 @@
 	GLint					SurfModelFogEndLoc;
 	GLint					SurfModelVert2Loc;
 	GLint					SurfModelTexCoordLoc;
+	GLint					ShadowsModelAlphaLoc;
 	GLint					SurfModelLightValLoc;
+	GLint					SurfModelViewOrigin;
+	GLint					SurfModelAllowTransparency;
 
 	GLhandleARB				SurfPartProgram;
 	GLint					SurfPartTexCoordLoc;
@@ -555,6 +564,13 @@
 
 	GLhandleARB				ShadowsAmbientProgram;
 	GLint					ShadowsAmbientLightLoc;
+	GLint					ShadowsAmbientSAxisLoc;
+	GLint					ShadowsAmbientTAxisLoc;
+	GLint					ShadowsAmbientSOffsLoc;
+	GLint					ShadowsAmbientTOffsLoc;
+	GLint					ShadowsAmbientTexIWLoc;
+	GLint					ShadowsAmbientTexIHLoc;
+	GLint					ShadowsAmbientTextureLoc;
 
 	GLhandleARB				ShadowsLightProgram;
 	GLint					ShadowsLightLightPosLoc;
@@ -562,6 +578,15 @@
 	GLint					ShadowsLightLightColourLoc;
 	GLint					ShadowsLightSurfNormalLoc;
 	GLint					ShadowsLightSurfDistLoc;
+	GLint					ShadowsLightSAxisLoc;
+	GLint					ShadowsLightTAxisLoc;
+	GLint					ShadowsLightSOffsLoc;
+	GLint					ShadowsLightTOffsLoc;
+	GLint					ShadowsLightTexIWLoc;
+	GLint					ShadowsLightTexIHLoc;
+	GLint					ShadowsLightTextureLoc;
+	GLint					ShadowsLightAlphaLoc;
+	GLint					ShadowsLightViewOrigin;
 
 	GLhandleARB				ShadowsTextureProgram;
 	GLint					ShadowsTextureTexCoordLoc;
@@ -572,15 +597,27 @@
 	GLint					ShadowsModelAmbientTextureLoc;
 	GLint					ShadowsModelAmbientLightLoc;
 	GLint					ShadowsModelAmbientModelToWorldMatLoc;
+	GLint					ShadowsModelAmbientNormalToWorldMatLoc;
 	GLint					ShadowsModelAmbientVert2Loc;
+	GLint					ShadowsModelAmbientVertNormalLoc;
+	GLint					ShadowsModelAmbientVert2NormalLoc;
 	GLint					ShadowsModelAmbientTexCoordLoc;
+	GLint					ShadowsModelAmbientAlphaLoc;
+	GLint					ShadowsModelAmbientViewOrigin;
+	GLint					ShadowsModelAmbientAllowTransparency;
 
 	GLhandleARB				ShadowsModelTexturesProgram;
 	GLint					ShadowsModelTexturesInterLoc;
 	GLint					ShadowsModelTexturesTextureLoc;
+	GLint					ShadowsModelTexturesAlphaLoc;
 	GLint					ShadowsModelTexturesModelToWorldMatLoc;
+	GLint					ShadowsModelTexturesNormalToWorldMatLoc;
 	GLint					ShadowsModelTexturesVert2Loc;
+	GLint					ShadowsModelTexturesVertNormalLoc;
+	GLint					ShadowsModelTexturesVert2NormalLoc;
 	GLint					ShadowsModelTexturesTexCoordLoc;
+	GLint					ShadowsModelTexturesViewOrigin;
+	GLint					ShadowsModelTexturesAllowTransparency;
 
 	GLhandleARB				ShadowsModelLightProgram;
 	GLint					ShadowsModelLightInterLoc;
@@ -594,6 +631,8 @@
 	GLint					ShadowsModelLightVertNormalLoc;
 	GLint					ShadowsModelLightVert2NormalLoc;
 	GLint					ShadowsModelLightTexCoordLoc;
+	GLint					ShadowsModelLightViewOrigin;
+	GLint					ShadowsModelLightAllowTransparency;
 
 	GLhandleARB				ShadowsModelShadowProgram;
 	GLint					ShadowsModelShadowInterLoc;
@@ -601,6 +640,7 @@
 	GLint					ShadowsModelShadowModelToWorldMatLoc;
 	GLint					ShadowsModelShadowVert2Loc;
 	GLint					ShadowsModelShadowOffsetLoc;
+	GLint					ShadowsModelShadowViewOrigin;
 
 	GLhandleARB				ShadowsFogProgram;
 	GLint					ShadowsFogFogTypeLoc;
@@ -620,11 +660,15 @@
 	GLint					ShadowsModelFogFogEndLoc;
 	GLint					ShadowsModelFogVert2Loc;
 	GLint					ShadowsModelFogTexCoordLoc;
+	GLint					ShadowsModelFogAlphaLoc;
+	GLint					ShadowsModelFogViewOrigin;
+	GLint					ShadowsModelFogAllowTransparency;
 
 	//
 	//	Console variables
 	//
 	static VCvarI tex_linear;
+	static VCvarI sprite_tex_linear;
 	static VCvarI clear;
 	static VCvarI blend_sprites;
 	static VCvarI ext_multitexture;
@@ -635,6 +679,7 @@
 	static VCvarF maxdist;
 	static VCvarI model_lighting;
 	static VCvarI specular_highlights;
+	static VCvarI multisampling_sample;
 
 	//	Extensions
 	bool CheckExtension(const char*);
@@ -785,8 +830,8 @@
 
 	static void SetColour(vuint32 c)
 	{
-		glColor4ub(byte((c >> 16) & 0xff), byte((c >> 8) & 0xff),
-			byte(c & 0xff), byte(c >> 24));
+		glColor4ub(byte((c >> 16) & 255), byte((c >> 8) & 255),
+			byte(c & 255), byte(c >> 24));
 	}
 };
 
diff -Nur orig/source/gl_main.cpp mod/source/gl_main.cpp
--- orig/source/gl_main.cpp	2010-12-17 15:50:09.000000000 +0100
+++ mod/source/gl_main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_main.cpp 4348 2010-12-17 14:50:18Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -46,6 +46,7 @@
 // PUBLIC DATA DEFINITIONS -------------------------------------------------
 
 VCvarI VOpenGLDrawer::tex_linear("gl_tex_linear", "2", CVAR_Archive);
+VCvarI VOpenGLDrawer::sprite_tex_linear("gl_sprite_tex_linear", "2", CVAR_Archive);
 VCvarI VOpenGLDrawer::clear("gl_clear", "0", CVAR_Archive);
 VCvarI VOpenGLDrawer::blend_sprites("gl_blend_sprites", "0", CVAR_Archive);
 VCvarI VOpenGLDrawer::ext_multitexture("gl_ext_multitexture", "1", CVAR_Archive);
@@ -56,6 +57,7 @@
 VCvarF VOpenGLDrawer::maxdist("gl_maxdist", "8192.0", CVAR_Archive);
 VCvarI VOpenGLDrawer::model_lighting("gl_model_lighting", "0", CVAR_Archive);
 VCvarI VOpenGLDrawer::specular_highlights("gl_specular_highlights", "1", CVAR_Archive);
+VCvarI VOpenGLDrawer::multisampling_sample("gl_multisampling_sample", "2", CVAR_Archive);
 
 // PRIVATE DATA DEFINITIONS ------------------------------------------------
 
@@ -420,7 +422,7 @@
 	GenerateTextures();
 
 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	glAlphaFunc(GL_GREATER, 0.666);
+	glAlphaFunc(GL_GREATER, 0.333);
 	glShadeModel(GL_FLAT);
 
 	glDepthFunc(GL_LEQUAL);
@@ -539,7 +541,10 @@
 		SurfModelFogEndLoc = p_glGetUniformLocationARB(SurfModelProgram, "FogEnd");
 		SurfModelVert2Loc = p_glGetAttribLocationARB(SurfModelProgram, "Vert2");
 		SurfModelTexCoordLoc = p_glGetAttribLocationARB(SurfModelProgram, "TexCoord");
+		ShadowsModelAlphaLoc = p_glGetUniformLocationARB(SurfModelProgram, "InAlpha");
 		SurfModelLightValLoc = p_glGetAttribLocationARB(SurfModelProgram, "LightVal");
+		SurfModelViewOrigin = p_glGetUniformLocationARB(SurfModelProgram, "ViewOrigin");
+		SurfModelAllowTransparency = p_glGetUniformLocationARB(SurfModelProgram, "AllowTransparency");
 
 		VertexShader = LoadShader(GL_VERTEX_SHADER_ARB, "glshaders/surf_part.vs");
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/surf_part.fs");
@@ -551,6 +556,13 @@
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/shadows_ambient.fs");
 		ShadowsAmbientProgram = CreateProgram(VertexShader, FragmentShader);
 		ShadowsAmbientLightLoc = p_glGetUniformLocationARB(ShadowsAmbientProgram, "Light");
+		ShadowsAmbientSAxisLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "SAxis");
+		ShadowsAmbientTAxisLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TAxis");
+		ShadowsAmbientSOffsLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "SOffs");
+		ShadowsAmbientTOffsLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TOffs");
+		ShadowsAmbientTexIWLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TexIW");
+		ShadowsAmbientTexIHLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TexIH");
+		ShadowsAmbientTextureLoc = p_glGetUniformLocationARB(ShadowsAmbientProgram, "Texture");
 
 		VertexShader = LoadShader(GL_VERTEX_SHADER_ARB, "glshaders/shadows_light.vs");
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/shadows_light.fs");
@@ -560,6 +572,15 @@
 		ShadowsLightLightColourLoc = p_glGetUniformLocationARB(ShadowsLightProgram, "LightColour");
 		ShadowsLightSurfNormalLoc = p_glGetAttribLocationARB(ShadowsLightProgram, "SurfNormal");
 		ShadowsLightSurfDistLoc = p_glGetAttribLocationARB(ShadowsLightProgram, "SurfDist");
+		ShadowsLightSAxisLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "SAxis");
+		ShadowsLightTAxisLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TAxis");
+		ShadowsLightSOffsLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "SOffs");
+		ShadowsLightTOffsLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TOffs");
+		ShadowsLightTexIWLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TexIW");
+		ShadowsLightTexIHLoc = p_glGetUniformLocationARB(SurfSimpleProgram, "TexIH");
+		ShadowsLightTextureLoc = p_glGetUniformLocationARB(ShadowsAmbientProgram, "Texture");
+		ShadowsLightAlphaLoc = p_glGetUniformLocationARB(ShadowsLightProgram, "InAlpha");
+		ShadowsLightViewOrigin = p_glGetUniformLocationARB(ShadowsLightProgram, "ViewOrigin");
 
 		VertexShader = LoadShader(GL_VERTEX_SHADER_ARB, "glshaders/shadows_texture.vs");
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/shadows_texture.fs");
@@ -574,8 +595,14 @@
 		ShadowsModelAmbientTextureLoc = p_glGetUniformLocationARB(ShadowsModelAmbientProgram, "Texture");
 		ShadowsModelAmbientLightLoc = p_glGetUniformLocationARB(ShadowsModelAmbientProgram, "Light");
 		ShadowsModelAmbientModelToWorldMatLoc = p_glGetUniformLocationARB(ShadowsModelAmbientProgram, "ModelToWorldMat");
+		ShadowsModelAmbientNormalToWorldMatLoc = p_glGetUniformLocationARB(ShadowsModelAmbientProgram, "NormalToWorldMat");
 		ShadowsModelAmbientVert2Loc = p_glGetAttribLocationARB(ShadowsModelAmbientProgram, "Vert2");
+		ShadowsModelAmbientVertNormalLoc = p_glGetAttribLocationARB(ShadowsModelAmbientProgram, "VertNormal");
+		ShadowsModelAmbientVert2NormalLoc = p_glGetAttribLocationARB(ShadowsModelAmbientProgram, "Vert2Normal");
 		ShadowsModelAmbientTexCoordLoc = p_glGetAttribLocationARB(ShadowsModelAmbientProgram, "TexCoord");
+		ShadowsModelAmbientAlphaLoc = p_glGetUniformLocationARB(ShadowsModelAmbientProgram, "InAlpha");
+		ShadowsModelAmbientViewOrigin = p_glGetUniformLocationARB(ShadowsModelAmbientProgram, "ViewOrigin");
+		ShadowsModelAmbientAllowTransparency = p_glGetUniformLocationARB(ShadowsModelAmbientProgram, "AllowTransparency");
 
 		VertexShader = LoadShader(GL_VERTEX_SHADER_ARB, "glshaders/shadows_model_textures.vs");
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/shadows_model_textures.fs");
@@ -583,8 +610,14 @@
 		ShadowsModelTexturesInterLoc = p_glGetUniformLocationARB(ShadowsModelTexturesProgram, "Inter");
 		ShadowsModelTexturesTextureLoc = p_glGetUniformLocationARB(ShadowsModelTexturesProgram, "Texture");
 		ShadowsModelTexturesModelToWorldMatLoc = p_glGetUniformLocationARB(ShadowsModelTexturesProgram, "ModelToWorldMat");
+		ShadowsModelTexturesNormalToWorldMatLoc = p_glGetUniformLocationARB(ShadowsModelTexturesProgram, "NormalToWorldMat");
 		ShadowsModelTexturesVert2Loc = p_glGetAttribLocationARB(ShadowsModelTexturesProgram, "Vert2");
 		ShadowsModelTexturesTexCoordLoc = p_glGetAttribLocationARB(ShadowsModelTexturesProgram, "TexCoord");
+		ShadowsModelTexturesVertNormalLoc = p_glGetAttribLocationARB(ShadowsModelTexturesProgram, "VertNormal");
+		ShadowsModelTexturesVert2NormalLoc = p_glGetAttribLocationARB(ShadowsModelTexturesProgram, "Vert2Normal");
+		ShadowsModelTexturesAlphaLoc = p_glGetUniformLocationARB(ShadowsModelTexturesProgram, "InAlpha");
+		ShadowsModelTexturesViewOrigin = p_glGetUniformLocationARB(ShadowsModelTexturesProgram, "ViewOrigin");
+		ShadowsModelTexturesAllowTransparency = p_glGetUniformLocationARB(ShadowsModelTexturesProgram, "AllowTransparency");
 
 		VertexShader = LoadShader(GL_VERTEX_SHADER_ARB, "glshaders/shadows_model_light.vs");
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/shadows_model_light.fs");
@@ -600,6 +633,8 @@
 		ShadowsModelLightVertNormalLoc = p_glGetAttribLocationARB(ShadowsModelLightProgram, "VertNormal");
 		ShadowsModelLightVert2NormalLoc = p_glGetAttribLocationARB(ShadowsModelLightProgram, "Vert2Normal");
 		ShadowsModelLightTexCoordLoc = p_glGetAttribLocationARB(ShadowsModelLightProgram, "TexCoord");
+		ShadowsModelLightViewOrigin = p_glGetUniformLocationARB(ShadowsModelLightProgram, "ViewOrigin");
+		ShadowsModelLightAllowTransparency = p_glGetUniformLocationARB(ShadowsModelLightProgram, "AllowTransparency");
 
 		VertexShader = LoadShader(GL_VERTEX_SHADER_ARB, "glshaders/shadows_model_shadow.vs");
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/shadows_model_shadow.fs");
@@ -609,6 +644,7 @@
 		ShadowsModelShadowModelToWorldMatLoc = p_glGetUniformLocationARB(ShadowsModelShadowProgram, "ModelToWorldMat");
 		ShadowsModelShadowVert2Loc = p_glGetAttribLocationARB(ShadowsModelShadowProgram, "Vert2");
 		ShadowsModelShadowOffsetLoc = p_glGetAttribLocationARB(ShadowsModelShadowProgram, "Offset");
+		ShadowsModelShadowViewOrigin = p_glGetUniformLocationARB(ShadowsModelShadowProgram, "ViewOrigin");
 
 		VertexShader = LoadShader(GL_VERTEX_SHADER_ARB, "glshaders/shadows_fog.vs");
 		FragmentShader = LoadShader(GL_FRAGMENT_SHADER_ARB, "glshaders/shadows_fog.fs");
@@ -632,6 +668,9 @@
 		ShadowsModelFogFogEndLoc = p_glGetUniformLocationARB(ShadowsModelFogProgram, "FogEnd");
 		ShadowsModelFogVert2Loc = p_glGetAttribLocationARB(ShadowsModelFogProgram, "Vert2");
 		ShadowsModelFogTexCoordLoc = p_glGetAttribLocationARB(ShadowsModelFogProgram, "TexCoord");
+		ShadowsModelFogAlphaLoc = p_glGetUniformLocationARB(ShadowsModelFogProgram, "InAlpha");
+		ShadowsModelFogViewOrigin = p_glGetUniformLocationARB(ShadowsModelFogProgram, "ViewOrigin");
+		ShadowsModelFogAllowTransparency = p_glGetUniformLocationARB(ShadowsModelFogProgram, "AllowTransparency");
 	}
 	unguard;
 }
@@ -728,7 +767,7 @@
 		{
 			maxfilter = GL_LINEAR;
 			minfilter = GL_LINEAR;
-			mipfilter = GL_LINEAR;
+			mipfilter = GL_NEAREST;
 			break;
 		}
 		case 2:
@@ -745,6 +784,20 @@
 			mipfilter = GL_LINEAR_MIPMAP_LINEAR;
 			break;
 		}
+		case 4: // BILINEAR
+		{
+			maxfilter = GL_NEAREST;
+			minfilter = GL_LINEAR_MIPMAP_NEAREST;
+			mipfilter = GL_LINEAR_MIPMAP_NEAREST;
+			break;
+		}
+		case 5: // TRILINEAR
+		{
+			maxfilter = GL_NEAREST;
+			minfilter = GL_LINEAR_MIPMAP_LINEAR;
+			mipfilter = GL_LINEAR_MIPMAP_LINEAR;
+			break;
+		}
 		default:
 		{
 			maxfilter = GL_NEAREST;
@@ -926,19 +979,19 @@
 		{
 			p_glUseProgramObjectARB(DrawFixedColProgram);
 			p_glUniform4fARB(DrawFixedColColourLoc,
-				(float)((cl->CShift >> 16) & 0xff) / 255.0,
-				(float)((cl->CShift >> 8) & 0xff) / 255.0,
-				(float)(cl->CShift & 0xff) / 255.0,
-				(float)((cl->CShift >> 24) & 0xff) / 255.0);
+				(float)((cl->CShift >> 16) & 255) / 255.0,
+				(float)((cl->CShift >> 8) & 255) / 255.0,
+				(float)(cl->CShift & 255) / 255.0,
+				(float)((cl->CShift >> 24) & 255) / 255.0);
 		}
 		else
 		{
 			glDisable(GL_ALPHA_TEST);
 			glDisable(GL_TEXTURE_2D);
-			glColor4f((float)((cl->CShift >> 16) & 0xff) / 255.0,
-					(float)((cl->CShift >> 8) & 0xff) / 255.0,
-					(float)(cl->CShift & 0xff) / 255.0,
-					(float)((cl->CShift >> 24) & 0xff) / 255.0);
+			glColor4f((float)((cl->CShift >> 16) & 255) / 255.0,
+					(float)((cl->CShift >> 8) & 255) / 255.0,
+					(float)(cl->CShift & 255) / 255.0,
+					(float)((cl->CShift >> 24) & 255) / 255.0);
 		}
 		glEnable(GL_BLEND);
 
@@ -991,6 +1044,7 @@
 	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 	glReadPixels(0, ScreenHeight - Height, Width, Height, GL_RGBA, GL_UNSIGNED_BYTE, Dest);
 	rgba_t* Temp = new rgba_t[Width];
+
 	for (int i = 0; i < Height / 2; i++)
 	{
 		memcpy(Temp, Dest + i * Width, Width * sizeof(rgba_t));
@@ -1023,10 +1077,10 @@
 		static GLenum fogMode[4] = { GL_LINEAR, GL_LINEAR, GL_EXP, GL_EXP2 };
 		float fogColour[4];
 
-		fogColour[0] = float((NewFade >> 16) & 0xff) / 255.0;
-		fogColour[1] = float((NewFade >> 8) & 0xff) / 255.0;
-		fogColour[2] = float(NewFade & 0xff) / 255.0;
-		fogColour[3] = float((NewFade >> 24) & 0xff) / 255.0;
+		fogColour[0] = float((NewFade >> 16) & 255) / 255.0;
+		fogColour[1] = float((NewFade >> 8) & 255) / 255.0;
+		fogColour[2] = float(NewFade & 255) / 255.0;
+		fogColour[3] = float((NewFade >> 24) & 255) / 255.0;
 		glFogi(GL_FOG_MODE, fogMode[r_fog & 3]);
 		glFogfv(GL_FOG_COLOR, fogColour);
 		if (NewFade == FADE_LIGHT)
diff -Nur orig/source/gl_model.cpp mod/source/gl_model.cpp
--- orig/source/gl_model.cpp	2010-05-31 00:10:27.000000000 +0200
+++ mod/source/gl_model.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_model.cpp 4286 2010-05-30 22:16:52Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -29,6 +29,10 @@
 
 // MACROS ------------------------------------------------------------------
 
+#define outv(idx, offs) \
+			p_glVertexAttrib1fARB(ShadowsModelShadowOffsetLoc, offs); \
+			glArrayElement(index ## idx);
+
 // TYPES -------------------------------------------------------------------
 
 // EXTERNAL FUNCTION PROTOTYPES --------------------------------------------
@@ -197,7 +201,7 @@
 	const TVec& Offset, const TVec& Scale, VMeshModel* Mdl, int frame, int nextframe,
 	VTexture* Skin, VTextureTranslation* Trans, int CMap, vuint32 light,
 	vuint32 Fade, float Alpha, bool Additive, bool is_view_model, float Inter,
-	bool Interpolate)
+	bool Interpolate, bool ForceDepthUse, bool AllowTransparency)
 {
 	guard(VOpenGLDrawer::DrawAliasModel);
 	if (is_view_model)
@@ -209,9 +213,9 @@
 	//
 	// get lighting information
 	//
-	float shadelightr = ((light >> 16) & 0xff) / 510.0;
-	float shadelightg = ((light >> 8) & 0xff) / 510.0;
-	float shadelightb = (light & 0xff) / 510.0;
+	float shadelightr = ((light >> 16) & 255) / 255.0;
+	float shadelightg = ((light >> 8) & 255) / 255.0;
+	float shadelightb = (light & 255) / 255.0;
 	float* shadedots = r_avertexnormal_dots[((int)(angles.yaw * (SHADEDOT_QUANT / 360.0))) & (SHADEDOT_QUANT - 1)];
 
 	//
@@ -267,19 +271,33 @@
 
 	SetPic(Skin, Trans, CMap);
 
+	glEnable(GL_ALPHA_TEST);
+	glShadeModel(GL_SMOOTH);
+	glAlphaFunc(GL_GREATER, 0.0);
+	glEnable(GL_BLEND);
+
 	if (HaveShaders)
 	{
 		p_glUseProgramObjectARB(SurfModelProgram);
 		p_glUniform1iARB(SurfModelTextureLoc, 0);
 		p_glUniform1iARB(SurfModelFogTypeLoc, r_fog & 3);
 
+		if (Alpha < 1.0)
+		{
+			p_glUniform1fARB(ShadowsModelAlphaLoc, Alpha);
+		}
+		else
+		{
+			p_glUniform1fARB(ShadowsModelAlphaLoc, 1.0);
+		}
+
 		if (Fade)
 		{
 			p_glUniform1iARB(SurfModelFogEnabledLoc, GL_TRUE);
 			p_glUniform4fARB(SurfModelFogColourLoc,
 				((Fade >> 16) & 255) / 255.0,
 				((Fade >> 8) & 255) / 255.0,
-				(Fade & 255) / 255.0, 1.0);
+				(Fade & 255) / 255.0, Alpha);
 			p_glUniform1fARB(SurfModelFogDensityLoc, Fade == FADE_LIGHT ? 0.3 : r_fog_density);
 			p_glUniform1fARB(SurfModelFogStartLoc, Fade == FADE_LIGHT ? 1.0 : r_fog_start);
 			p_glUniform1fARB(SurfModelFogEndLoc, Fade == FADE_LIGHT ? 1024.0 * r_fade_factor : r_fog_end);
@@ -288,6 +306,15 @@
 		{
 			p_glUniform1iARB(SurfModelFogEnabledLoc, GL_FALSE);
 		}
+
+		if (AllowTransparency)
+		{
+			p_glUniform1iARB(SurfModelAllowTransparency, GL_TRUE);
+		}
+		else
+		{
+			p_glUniform1iARB(SurfModelAllowTransparency, GL_FALSE);
+		}
 		p_glUniform1fARB(SurfModelInterLoc, Inter);
 	}
 	else
@@ -297,11 +324,8 @@
 			SetColour((light & 0x00ffffff) | (int(255 * Alpha) << 24));
 		}
 		SetFade(Fade);
-		glEnable(GL_ALPHA_TEST);
-		glShadeModel(GL_SMOOTH);
-		glAlphaFunc(GL_GREATER, 0.0);
 	}
-	glEnable(GL_BLEND);
+
 	if (Additive)
 	{
 		glBlendFunc(GL_SRC_ALPHA, GL_ONE);
@@ -321,14 +345,23 @@
 		p_glEnableVertexAttribArrayARB(SurfModelVert2Loc);
 		p_glVertexAttribPointerARB(SurfModelTexCoordLoc, 2, GL_FLOAT, GL_FALSE, 0, 0);
 		p_glEnableVertexAttribArrayARB(SurfModelTexCoordLoc);
+		p_glUniform3fARB(SurfModelViewOrigin, vieworg.x, vieworg.y, vieworg.z);
 		p_glVertexAttrib4fARB(SurfModelLightValLoc,
 			((light >> 16) & 255) / 255.0,
 			((light >> 8) & 255) / 255.0,
 			(light & 255) / 255.0, Alpha);
 
 		p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, Mdl->IndexBuffer);
+		if (Alpha < 1.0 && !ForceDepthUse || AllowTransparency)
+		{
+			glDepthMask(GL_FALSE);
+		}
 		p_glDrawRangeElementsEXT(GL_TRIANGLES, 0, Mdl->STVerts.Num() - 1,
 			Mdl->Tris.Num() * 3, GL_UNSIGNED_SHORT, 0);
+		if (Alpha < 1.0 && !ForceDepthUse || AllowTransparency)
+		{
+			glDepthMask(GL_TRUE);
+		}
 		p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
 
 		p_glDisableVertexAttribArrayARB(0);
@@ -346,6 +379,10 @@
 		{
 			// get the vertex count and primitive type
 			int count = *order++;
+			if (Alpha < 1.0 && !ForceDepthUse)
+			{
+				glDepthMask(GL_FALSE);
+			}
 			if (count < 0)
 			{
 				count = -count;
@@ -355,6 +392,10 @@
 			{
 				glBegin(GL_TRIANGLE_STRIP);
 			}
+			if (Alpha < 1.0 && !ForceDepthUse)
+			{
+				glDepthMask(GL_TRUE);
+			}
 
 			do
 			{
@@ -412,14 +453,10 @@
 			glEnd();
 		}
 	}
-
-	if (!HaveShaders)
-	{
-		glShadeModel(GL_FLAT);
-		glAlphaFunc(GL_GREATER, 0.666);
-		glDisable(GL_ALPHA_TEST);
-	}
 	glDisable(GL_BLEND);
+	glShadeModel(GL_FLAT);
+	glAlphaFunc(GL_GREATER, 0.333);
+	glDisable(GL_ALPHA_TEST);
 	if (Additive)
 	{
 		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
@@ -441,7 +478,8 @@
 
 void VOpenGLDrawer::DrawAliasModelAmbient(const TVec &origin, const TAVec &angles,
 	const TVec& Offset, const TVec& Scale, VMeshModel* Mdl, int frame, int nextframe,
-	VTexture* Skin, vuint32 light, float Inter, bool Interpolate)
+	VTexture* Skin, vuint32 light, float Alpha, float Inter, bool Interpolate,
+	bool ForceDepth, bool AllowTransparency)
 {
 	guard(VOpenGLDrawer::DrawAliasModelAmbient);
 	UploadModel(Mdl);
@@ -452,6 +490,18 @@
 
 	VMatrix4 RotationMatrix;
 	AliasSetUpTransform(origin, angles, Offset, Scale, RotationMatrix);
+	VMatrix4 normalmatrix;
+	AliasSetUpNormalTransform(angles, Scale, normalmatrix);
+	float NormalMat[3][3];
+	NormalMat[0][0] = normalmatrix[0][0];
+	NormalMat[0][1] = normalmatrix[0][1];
+	NormalMat[0][2] = normalmatrix[0][2];
+	NormalMat[1][0] = normalmatrix[1][0];
+	NormalMat[1][1] = normalmatrix[1][1];
+	NormalMat[1][2] = normalmatrix[1][2];
+	NormalMat[2][0] = normalmatrix[2][0];
+	NormalMat[2][1] = normalmatrix[2][1];
+	NormalMat[2][2] = normalmatrix[2][2];
 
 	p_glUseProgramObjectARB(ShadowsModelAmbientProgram);
 	p_glUniform1iARB(ShadowsModelAmbientTextureLoc, 0);
@@ -459,26 +509,64 @@
 	p_glUniform4fARB(ShadowsModelAmbientLightLoc,
 		((light >> 16) & 255) / 255.0,
 		((light >> 8) & 255) / 255.0,
-		(light & 255) / 255.0, 1);
+		(light & 255) / 255.0, Alpha);
 	p_glUniformMatrix4fvARB(ShadowsModelAmbientModelToWorldMatLoc, 1, GL_FALSE, RotationMatrix[0]);
+	p_glUniformMatrix3fvARB(ShadowsModelAmbientNormalToWorldMatLoc, 1, GL_FALSE, NormalMat[0]);
 
 	p_glBindBufferARB(GL_ARRAY_BUFFER_ARB, Mdl->VertsBuffer);
 	p_glVertexAttribPointerARB(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)FrameDesc->VertsOffset);
 	p_glEnableVertexAttribArrayARB(0);
+	p_glVertexAttribPointerARB(ShadowsModelAmbientVertNormalLoc, 3, GL_FLOAT, GL_FALSE, 0,
+		(void*)FrameDesc->NormalsOffset);
+	p_glEnableVertexAttribArrayARB(ShadowsModelAmbientVertNormalLoc);
 	p_glVertexAttribPointerARB(ShadowsModelAmbientVert2Loc, 3, GL_FLOAT, GL_FALSE, 0,
 		(void*)NextFrameDesc->VertsOffset);
 	p_glEnableVertexAttribArrayARB(ShadowsModelAmbientVert2Loc);
+	p_glVertexAttribPointerARB(ShadowsModelAmbientVert2NormalLoc, 3, GL_FLOAT, GL_FALSE, 0,
+		(void*)NextFrameDesc->NormalsOffset);
+	p_glEnableVertexAttribArrayARB(ShadowsModelAmbientVert2NormalLoc);
 	p_glVertexAttribPointerARB(ShadowsModelAmbientTexCoordLoc, 2, GL_FLOAT, GL_FALSE, 0, 0);
 	p_glEnableVertexAttribArrayARB(ShadowsModelAmbientTexCoordLoc);
+	p_glUniform3fARB(ShadowsModelAmbientViewOrigin, vieworg.x, vieworg.y, vieworg.z);
+	if (Alpha < 1.0)
+	{
+		p_glUniform1fARB(ShadowsModelAmbientAlphaLoc, Alpha);
+	}
+	else
+	{
+		p_glUniform1fARB(ShadowsModelAmbientAlphaLoc, 1.0);
+	}
+
+	p_glUniform1iARB(ShadowsModelAmbientAllowTransparency, GL_FALSE);
+
+	glEnable(GL_ALPHA_TEST);
+	glShadeModel(GL_SMOOTH);
+	glAlphaFunc(GL_GREATER, 0.0);
+	glEnable(GL_BLEND);
 
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, Mdl->IndexBuffer);
+	if (Alpha < 1.0 && !ForceDepth)
+	{
+		glDepthMask(GL_FALSE);
+	}
 	p_glDrawRangeElementsEXT(GL_TRIANGLES, 0, Mdl->STVerts.Num() - 1, Mdl->Tris.Num() * 3, GL_UNSIGNED_SHORT, 0);
+	if (Alpha < 1.0 && !ForceDepth)
+	{
+		glDepthMask(GL_TRUE);
+	}
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
 
 	p_glDisableVertexAttribArrayARB(0);
+	p_glDisableVertexAttribArrayARB(ShadowsModelAmbientVertNormalLoc);
 	p_glDisableVertexAttribArrayARB(ShadowsModelAmbientVert2Loc);
+	p_glDisableVertexAttribArrayARB(ShadowsModelAmbientVert2NormalLoc);
 	p_glDisableVertexAttribArrayARB(ShadowsModelAmbientTexCoordLoc);
 	p_glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
+
+	glDisable(GL_BLEND);
+	glAlphaFunc(GL_GREATER, 0.333);
+	glShadeModel(GL_FLAT);
+	glDisable(GL_ALPHA_TEST);
 	unguard;
 }
 
@@ -490,8 +578,8 @@
 
 void VOpenGLDrawer::DrawAliasModelTextures(const TVec &origin, const TAVec &angles,
 	const TVec& Offset, const TVec& Scale, VMeshModel* Mdl, int frame, int nextframe,
-	VTexture* Skin, VTextureTranslation* Trans, int CMap, float Inter,
-	bool Interpolate)
+	VTexture* Skin, VTextureTranslation* Trans, int CMap, float Alpha, float Inter,
+	bool Interpolate, bool ForceDepth, bool AllowTransparency)
 {
 	guard(VOpenGLDrawer::DrawAliasModelTextures);
 	UploadModel(Mdl);
@@ -502,29 +590,78 @@
 
 	VMatrix4 RotationMatrix;
 	AliasSetUpTransform(origin, angles, Offset, Scale, RotationMatrix);
+	VMatrix4 normalmatrix;
+	AliasSetUpNormalTransform(angles, Scale, normalmatrix);
+	float NormalMat[3][3];
+	NormalMat[0][0] = normalmatrix[0][0];
+	NormalMat[0][1] = normalmatrix[0][1];
+	NormalMat[0][2] = normalmatrix[0][2];
+	NormalMat[1][0] = normalmatrix[1][0];
+	NormalMat[1][1] = normalmatrix[1][1];
+	NormalMat[1][2] = normalmatrix[1][2];
+	NormalMat[2][0] = normalmatrix[2][0];
+	NormalMat[2][1] = normalmatrix[2][1];
+	NormalMat[2][2] = normalmatrix[2][2];
 
 	p_glUseProgramObjectARB(ShadowsModelTexturesProgram);
 	p_glUniform1iARB(ShadowsModelTexturesTextureLoc, 0);
 	p_glUniform1fARB(ShadowsModelTexturesInterLoc, Inter);
 	p_glUniformMatrix4fvARB(ShadowsModelTexturesModelToWorldMatLoc, 1, GL_FALSE, RotationMatrix[0]);
+	p_glUniformMatrix3fvARB(ShadowsModelTexturesNormalToWorldMatLoc, 1, GL_FALSE, NormalMat[0]);
 
 	p_glBindBufferARB(GL_ARRAY_BUFFER_ARB, Mdl->VertsBuffer);
 	p_glVertexAttribPointerARB(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)FrameDesc->VertsOffset);
 	p_glEnableVertexAttribArrayARB(0);
+	p_glVertexAttribPointerARB(ShadowsModelTexturesVertNormalLoc, 3, GL_FLOAT, GL_FALSE, 0,
+		(void*)FrameDesc->NormalsOffset);
+	p_glEnableVertexAttribArrayARB(ShadowsModelTexturesVertNormalLoc);
 	p_glVertexAttribPointerARB(ShadowsModelTexturesVert2Loc, 3, GL_FLOAT, GL_FALSE, 0,
 		(void*)NextFrameDesc->VertsOffset);
 	p_glEnableVertexAttribArrayARB(ShadowsModelTexturesVert2Loc);
+	p_glVertexAttribPointerARB(ShadowsModelTexturesVert2NormalLoc, 3, GL_FLOAT, GL_FALSE, 0,
+		(void*)NextFrameDesc->NormalsOffset);
+	p_glEnableVertexAttribArrayARB(ShadowsModelTexturesVert2NormalLoc);
 	p_glVertexAttribPointerARB(ShadowsModelTexturesTexCoordLoc, 2, GL_FLOAT, GL_FALSE, 0, 0);
 	p_glEnableVertexAttribArrayARB(ShadowsModelTexturesTexCoordLoc);
+	p_glUniform3fARB(ShadowsModelTexturesViewOrigin, vieworg.x, vieworg.y, vieworg.z);
+
+	if (Alpha < 1.0)
+	{
+		p_glUniform1fARB(ShadowsModelTexturesAlphaLoc, Alpha);
+	}
+	else
+	{
+		p_glUniform1fARB(ShadowsModelTexturesAlphaLoc, 1.0);
+	}
+
+	if (AllowTransparency)
+	{
+		p_glUniform1iARB(ShadowsModelTexturesAllowTransparency, GL_TRUE);
+	}
+	else
+	{
+		p_glUniform1iARB(ShadowsModelTexturesAllowTransparency, GL_FALSE);
+	}
+	glEnable(GL_ALPHA_TEST);
+	glShadeModel(GL_SMOOTH);
+	glAlphaFunc(GL_GREATER, 0.0);
 
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, Mdl->IndexBuffer);
+	glDepthMask(GL_FALSE);
 	p_glDrawRangeElementsEXT(GL_TRIANGLES, 0, Mdl->STVerts.Num() - 1, Mdl->Tris.Num() * 3, GL_UNSIGNED_SHORT, 0);
+	glDepthMask(GL_TRUE);
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
 
 	p_glDisableVertexAttribArrayARB(0);
+	p_glDisableVertexAttribArrayARB(ShadowsModelLightVertNormalLoc);
 	p_glDisableVertexAttribArrayARB(ShadowsModelTexturesVert2Loc);
+	p_glDisableVertexAttribArrayARB(ShadowsModelLightVert2NormalLoc);
 	p_glDisableVertexAttribArrayARB(ShadowsModelTexturesTexCoordLoc);
 	p_glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
+
+	glShadeModel(GL_FLAT);
+	glAlphaFunc(GL_GREATER, 0.333);
+	glDisable(GL_ALPHA_TEST);
 	unguard;
 }
 
@@ -556,7 +693,7 @@
 
 void VOpenGLDrawer::DrawAliasModelLight(const TVec &origin, const TAVec &angles,
 	const TVec& Offset, const TVec& Scale, VMeshModel* Mdl, int frame, int nextframe,
-	VTexture* Skin, float Inter, bool Interpolate)
+	VTexture* Skin, float Alpha, float Inter, bool Interpolate, bool AllowTransparency)
 {
 	guard(VOpenGLDrawer::DrawAliasModelLight);
 	UploadModel(Mdl);
@@ -599,6 +736,25 @@
 	p_glVertexAttribPointerARB(ShadowsModelLightTexCoordLoc, 2, GL_FLOAT, GL_FALSE, 0, 0);
 	p_glEnableVertexAttribArrayARB(ShadowsModelLightTexCoordLoc);
 
+	if (Alpha < 1.0)
+	{
+		p_glUniform1fARB(ShadowsModelAlphaLoc, Alpha);
+	}
+	else
+	{
+		p_glUniform1fARB(ShadowsModelAlphaLoc, 1.0);
+	}
+
+	if (AllowTransparency)
+	{
+		p_glUniform1iARB(ShadowsModelLightAllowTransparency, GL_TRUE);
+	}
+	else
+	{
+		p_glUniform1iARB(ShadowsModelLightAllowTransparency, GL_FALSE);
+	}
+	p_glUniform3fARB(ShadowsModelLightViewOrigin, vieworg.x, vieworg.y, vieworg.z);
+
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, Mdl->IndexBuffer);
 	p_glDrawRangeElementsEXT(GL_TRIANGLES, 0, Mdl->STVerts.Num() - 1, Mdl->Tris.Num() * 3, GL_UNSIGNED_SHORT, 0);
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
@@ -653,7 +809,9 @@
 	TPlane* P = PlanesFrame->Planes;
 	for (int i = 0; i < Mdl->Tris.Num(); i++, P++)
 	{
-		PlaneSides[i] = DotProduct(LocalLightPos, P->normal) - P->dist > 0.1;
+		// Planes facing to the light
+		PlaneSides[i] = DotProduct(LocalLightPos, P->normal) - P->dist > 0.0 && 
+						DotProduct(LocalLightPos, P->normal) - P->dist <= LightRadius;
 	}
 
 	p_glUniform1fARB(ShadowsModelShadowInterLoc, Inter);
@@ -666,7 +824,7 @@
 		(void*)NextFrameDesc->VertsOffset);
 	p_glEnableVertexAttribArrayARB(ShadowsModelShadowVert2Loc);
 
-	float Offset = M_INFINITY;
+	float Shadow_Offset = M_INFINITY;
 
 	glBegin(GL_TRIANGLES);
 	p_glVertexAttrib1fARB(ShadowsModelShadowOffsetLoc, 0);
@@ -680,7 +838,7 @@
 		}
 	}
 
-	p_glVertexAttrib1fARB(ShadowsModelShadowOffsetLoc, Offset);
+	p_glVertexAttrib1fARB(ShadowsModelShadowOffsetLoc, Shadow_Offset);
 	for (int i = 0; i < Mdl->Tris.Num(); i++)
 	{
 		if (PlaneSides[i])
@@ -702,28 +860,25 @@
 			int index1 = Mdl->Edges[i].Vert1;
 			int index2 = Mdl->Edges[i].Vert2;
 
-#define outv(idx, offs) \
-			p_glVertexAttrib1fARB(ShadowsModelShadowOffsetLoc, offs); \
-			glArrayElement(index ## idx);
-
 			glBegin(GL_TRIANGLE_STRIP);
 			if (PlaneSides[Mdl->Edges[i].Tri1])
 			{
 				outv(1, 0);
-				outv(1, Offset);
+				outv(1, Shadow_Offset);
 				outv(2, 0);
-				outv(2, Offset);
+				outv(2, Shadow_Offset);
 			}
 			else
 			{
 				outv(2, 0);
-				outv(2, Offset);
+				outv(2, Shadow_Offset);
 				outv(1, 0);
-				outv(1, Offset);
+				outv(1, Shadow_Offset);
 			}
 			glEnd();
 		}
 	}
+	p_glUniform3fARB(ShadowsModelShadowViewOrigin, vieworg.x, vieworg.y, vieworg.z);
 
 	p_glDisableVertexAttribArrayARB(0);
 	p_glDisableVertexAttribArrayARB(ShadowsModelShadowVert2Loc);
@@ -739,7 +894,8 @@
 
 void VOpenGLDrawer::DrawAliasModelFog(const TVec &origin, const TAVec &angles,
 	const TVec& Offset, const TVec& Scale, VMeshModel* Mdl, int frame, int nextframe,
-	VTexture* Skin, vuint32 Fade, float Inter, bool Interpolate)
+	VTexture* Skin, vuint32 Fade, float Alpha, float Inter, bool Interpolate,
+	bool AllowTransparency)
 {
 	guard(VOpenGLDrawer::DrawAliasModelFog);
 	UploadModel(Mdl);
@@ -759,7 +915,7 @@
 	p_glUniform4fARB(ShadowsModelFogFogColourLoc,
 		((Fade >> 16) & 255) / 255.0,
 		((Fade >> 8) & 255) / 255.0,
-		(Fade & 255) / 255.0, 1.0);
+		(Fade & 255) / 255.0, Alpha);
 	p_glUniform1fARB(ShadowsModelFogFogDensityLoc, Fade == FADE_LIGHT ? 0.3 : r_fog_density);
 	p_glUniform1fARB(ShadowsModelFogFogStartLoc, Fade == FADE_LIGHT ? 1.0 : r_fog_start);
 	p_glUniform1fARB(ShadowsModelFogFogEndLoc, Fade == FADE_LIGHT ? 1024.0 * r_fade_factor : r_fog_end);
@@ -772,14 +928,43 @@
 	p_glEnableVertexAttribArrayARB(ShadowsModelFogVert2Loc);
 	p_glVertexAttribPointerARB(ShadowsModelFogTexCoordLoc, 2, GL_FLOAT, GL_FALSE, 0, 0);
 	p_glEnableVertexAttribArrayARB(ShadowsModelFogTexCoordLoc);
+	p_glUniform3fARB(ShadowsModelFogViewOrigin, vieworg.x, vieworg.y, vieworg.z);
+	if (Alpha < 1.0)
+	{
+		p_glUniform1fARB(ShadowsModelFogAlphaLoc, Alpha);
+	}
+	else
+	{
+		p_glUniform1fARB(ShadowsModelFogAlphaLoc, 1.0);
+	}
+
+	if (AllowTransparency)
+	{
+		p_glUniform1iARB(ShadowsModelFogAllowTransparency, GL_TRUE);
+	}
+	else
+	{
+		p_glUniform1iARB(ShadowsModelFogAllowTransparency, GL_FALSE);
+	}
+	glEnable(GL_ALPHA_TEST);
+	glShadeModel(GL_SMOOTH);
+	glAlphaFunc(GL_GREATER, 0.0);
+	glEnable(GL_BLEND);
 
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, Mdl->IndexBuffer);
+	glDepthMask(GL_FALSE);
 	p_glDrawRangeElementsEXT(GL_TRIANGLES, 0, Mdl->STVerts.Num() - 1, Mdl->Tris.Num() * 3, GL_UNSIGNED_SHORT, 0);
+	glDepthMask(GL_TRUE);
 	p_glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER_ARB, 0);
 
 	p_glDisableVertexAttribArrayARB(0);
 	p_glDisableVertexAttribArrayARB(ShadowsModelFogVert2Loc);
 	p_glDisableVertexAttribArrayARB(ShadowsModelFogTexCoordLoc);
 	p_glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);
+
+	glDisable(GL_BLEND);
+	glAlphaFunc(GL_GREATER, 0.333);
+	glShadeModel(GL_FLAT);
+	glDisable(GL_ALPHA_TEST);
 	unguard;
 }
diff -Nur orig/source/gl_poly.cpp mod/source/gl_poly.cpp
--- orig/source/gl_poly.cpp	2010-12-17 16:07:02.000000000 +0100
+++ mod/source/gl_poly.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_poly.cpp 4349 2010-12-17 15:07:11Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -83,6 +83,12 @@
 	{
 		for (surf = RendLev->HorizonPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			DoHorizonPolygon(surf);
 		}
 	}
@@ -95,6 +101,12 @@
 		glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
 		for (surf = RendLev->SkyPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			glBegin(GL_POLYGON);
 			for (i = 0; i < surf->count; i++)
 			{
@@ -111,6 +123,12 @@
 	{
 		for (surf = RendLev->SimpleSurfsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			texinfo_t* tex = surf->texinfo;
 			SetTexture(tex->Tex, tex->ColourMap);
 
@@ -171,6 +189,11 @@
 			for (cache = RendLev->light_chain[lb]; cache; cache = cache->chain)
 			{
 				surf = cache->surf;
+				if (surf->plane->PointOnSide(vieworg))
+				{
+					//	Viewer is in back side or on plane
+					continue;
+				}
 				tex = surf->texinfo;
 
 				SetTexture(tex->Tex, tex->ColourMap);
@@ -212,8 +235,8 @@
 			}
 
 			glBindTexture(GL_TEXTURE_2D, lmap_id[lb]);
-			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 
 			if (RendLev->block_changed[lb])
 			{
@@ -225,6 +248,11 @@
 			for (cache = RendLev->light_chain[lb]; cache; cache = cache->chain)
 			{
 				surf = cache->surf;
+				if (surf->plane->PointOnSide(vieworg))
+				{
+					//	Viewer is in back side or on plane
+					continue;
+				}
 				tex = surf->texinfo;
 
 				SetFade(surf->Fade);
@@ -266,8 +294,8 @@
 			}
 
 			glBindTexture(GL_TEXTURE_2D, addmap_id[lb]);
-			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 
 			if (RendLev->add_changed[lb])
 			{
@@ -279,6 +307,11 @@
 			for (cache = RendLev->add_chain[lb]; cache; cache = cache->addchain)
 			{
 				surf = cache->surf;
+				if (surf->plane->PointOnSide(vieworg))
+				{
+					//	Viewer is in back side or on plane
+					continue;
+				}
 				tex = surf->texinfo;
 
 				glBegin(GL_POLYGON);
@@ -320,6 +353,12 @@
 	{
 		for (surf = RendLev->HorizonPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			DoHorizonPolygon(surf);
 		}
 	}
@@ -332,6 +371,12 @@
 		glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
 		for (surf = RendLev->SkyPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			glBegin(GL_POLYGON);
 			for (int i = 0; i < surf->count; i++)
 			{
@@ -351,8 +396,15 @@
 
 		for (surf = RendLev->SimpleSurfsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			texinfo_t* tex = surf->texinfo;
 			SetTexture(tex->Tex, tex->ColourMap);
+
 			p_glUniform3fvARB(SurfSimpleSAxisLoc, 1, &tex->saxis.x);
 			p_glUniform1fARB(SurfSimpleSOffsLoc, tex->soffs);
 			p_glUniform1fARB(SurfSimpleTexIWLoc, tex_iw);
@@ -431,6 +483,11 @@
 		for (cache = RendLev->light_chain[lb]; cache; cache = cache->chain)
 		{
 			surf = cache->surf;
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
 			tex = surf->texinfo;
 			SetTexture(tex->Tex, tex->ColourMap);
 
@@ -486,6 +543,12 @@
 	{
 		for (surface_t* surf = RendLev->HorizonPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			DoHorizonPolygon(surf);
 		}
 	}
@@ -496,6 +559,12 @@
 		glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
 		for (surface_t* surf = RendLev->SkyPortalsHead; surf; surf = surf->DrawNext)
 		{
+			if (surf->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			glBegin(GL_POLYGON);
 			for (int i = 0; i < surf->count; i++)
 			{
@@ -507,8 +576,23 @@
 	}
 
 	p_glUseProgramObjectARB(ShadowsAmbientProgram);
+	p_glUniform1iARB(ShadowsAmbientTextureLoc, 0);
 	for (surface_t* surf = RendLev->SimpleSurfsHead; surf; surf = surf->DrawNext)
 	{
+		if (surf->plane->PointOnSide(vieworg))
+		{
+			//	Viewer is in back side or on plane
+			continue;
+		}
+		texinfo_t* tex = surf->texinfo;
+		SetTexture(tex->Tex, tex->ColourMap);
+		p_glUniform3fvARB(ShadowsAmbientSAxisLoc, 1, &tex->saxis.x);
+		p_glUniform1fARB(ShadowsAmbientSOffsLoc, tex->soffs);
+		p_glUniform1fARB(ShadowsAmbientTexIWLoc, tex_iw);
+		p_glUniform3fvARB(ShadowsAmbientTAxisLoc, 1, &tex->taxis.x);
+		p_glUniform1fARB(ShadowsAmbientTOffsLoc, tex->toffs);
+		p_glUniform1fARB(ShadowsAmbientTexIHLoc, tex_ih);
+
 		float lev = float(surf->Light >> 24) / 255.0;
 		p_glUniform4fARB(ShadowsAmbientLightLoc,
 			((surf->Light >> 16) & 255) * lev / 255.0,
@@ -552,8 +636,8 @@
 	//	Set up for shadow volume rendering.
 	glClear(GL_STENCIL_BUFFER_BIT);
 	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
-	//glEnable(GL_POLYGON_OFFSET_FILL);
-	//glPolygonOffset(0.0f, 10.0f);
+	glEnable(GL_POLYGON_OFFSET_FILL);
+	glPolygonOffset(1.0f, 10.0f);
 	glDepthFunc(GL_LESS);
 
 	glDisable(GL_BLEND);
@@ -572,21 +656,25 @@
 //
 //==========================================================================
 
-void VOpenGLDrawer::RenderSurfaceShadowVolume(surface_t *surf, TVec& LightPos, float Radius)
+void VOpenGLDrawer::RenderSurfaceShadowVolume(surface_t *surf, TVec& LightPos, float Radius, bool LightCanCross)
 {
 	guard(VOpenGLDrawer::RenderSurfaceShadowVolume);
-	float dist = DotProduct(LightPos, surf->plane->normal) - surf->plane->dist;
-	if (dist <= 0)
+	int i;
+	TArray<TVec>    v;
+	if (surf->plane->PointOnSide(vieworg) && LightCanCross)
 	{
 		//	Viewer is in back side or on plane
 		return;
 	}
-
-	int i;
-	TArray<TVec>    v;
+	float dist = DotProduct(LightPos, surf->plane->normal) - surf->plane->dist;
+	if ((dist <= 0.0 && !LightCanCross) || dist < -Radius || dist > Radius)
+	{
+		//	Light is too far away
+		return;
+	}
 	v.SetNum(surf->count);
 
-	for (int i = 0; i < surf->count; i++)
+	for (i = 0; i < surf->count; i++)
 	{
 		v[i] = Normalise(surf->verts[i] - LightPos);
 		v[i] *= M_INFINITY;
@@ -628,9 +716,9 @@
 void VOpenGLDrawer::BeginLightPass(TVec& LightPos, float Radius, vuint32 Colour)
 {
 	guard(VOpenGLDrawer::BeginLightPass);
-	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
-	glDisable(GL_POLYGON_OFFSET_FILL);
 	glDepthFunc(GL_LEQUAL);
+	glDisable(GL_POLYGON_OFFSET_FILL);
+	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
 
 	glStencilFunc(GL_EQUAL, 0x0, 0xff);
 	glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
@@ -654,14 +742,36 @@
 //
 //==========================================================================
 
-void VOpenGLDrawer::DrawSurfaceLight(surface_t* Surf)
+void VOpenGLDrawer::DrawSurfaceLight(surface_t* Surf, TVec& LightPos, float Radius, bool LightCanCross)
 {
 	guard(VOpenGLDrawer::DrawSurfaceLight);
+	if (Surf->plane->PointOnSide(vieworg))
+	{
+		//	Viewer is in back side or on plane
+		return;
+	}
+	float dist = DotProduct(LightPos, Surf->plane->normal) - Surf->plane->dist;
+	if ((dist <= 0.0 && !LightCanCross) || dist < -Radius || dist > Radius)
+	{
+		//	Light is too far away
+		return;
+	}
+	p_glUniform1iARB(ShadowsAmbientTextureLoc, 0);
+	texinfo_t* tex = Surf->texinfo;
+	SetTexture(tex->Tex, tex->ColourMap);
+	p_glUniform3fvARB(ShadowsAmbientSAxisLoc, 1, &tex->saxis.x);
+	p_glUniform1fARB(ShadowsAmbientSOffsLoc, tex->soffs);
+	p_glUniform1fARB(ShadowsAmbientTexIWLoc, tex_iw);
+	p_glUniform3fvARB(ShadowsAmbientTAxisLoc, 1, &tex->taxis.x);
+	p_glUniform1fARB(ShadowsAmbientTOffsLoc, tex->toffs);
+	p_glUniform1fARB(ShadowsAmbientTexIHLoc, tex_ih);
+	p_glVertexAttrib3fvARB(ShadowsLightSurfNormalLoc, &Surf->plane->normal.x);
+	p_glVertexAttrib1fvARB(ShadowsLightSurfDistLoc, &Surf->plane->dist);
+	p_glUniform3fARB(ShadowsLightViewOrigin, vieworg.x, vieworg.y, vieworg.z);
+
 	glBegin(GL_POLYGON);
 	for (int i = 0; i < Surf->count; i++)
 	{
-		p_glVertexAttrib3fvARB(ShadowsLightSurfNormalLoc, &Surf->plane->normal.x);
-		p_glVertexAttrib1fvARB(ShadowsLightSurfDistLoc, &Surf->plane->dist);
 		glVertex(Surf->verts[i]);
 	}
 	glEnd();
@@ -688,6 +798,12 @@
 
 	for (surface_t* surf = RendLev->SimpleSurfsHead; surf; surf = surf->DrawNext)
 	{
+		if (surf->plane->PointOnSide(vieworg))
+		{
+			//	Viewer is in back side or on plane
+			continue;
+		}
+
 		texinfo_t* tex = surf->texinfo;
 		SetTexture(tex->Tex, tex->ColourMap);
 		glBegin(GL_POLYGON);
@@ -725,6 +841,12 @@
 			continue;
 		}
 
+		if (surf->plane->PointOnSide(vieworg))
+		{
+			//	Viewer is in back side or on plane
+			continue;
+		}
+
 		p_glUniform4fARB(ShadowsFogFogColourLoc,
 			((surf->Fade >> 16) & 255) / 255.0,
 			((surf->Fade >> 8) & 255) / 255.0,
@@ -1057,6 +1179,12 @@
 	bool Additive)
 {
 	guard(VOpenGLDrawer::DrawMaskedPolygon);
+	if (surf->plane->PointOnSide(vieworg))
+	{
+		//	Viewer is in back side or on plane
+		return;
+	}
+
 	texinfo_t* tex = surf->texinfo;
 	SetTexture(tex->Tex, tex->ColourMap);
 
@@ -1091,7 +1219,7 @@
 			p_glUniform4fARB(SurfMaskedLightLoc,
 				((surf->Light >> 16) & 255) * lev / 255.0,
 				((surf->Light >> 8) & 255) * lev / 255.0,
-				(surf->Light & 255) * lev / 255.0, 1.0);
+				(surf->Light & 255) * lev / 255.0, Alpha);
 		}
 		if (surf->Fade)
 		{
@@ -1099,7 +1227,7 @@
 			p_glUniform4fARB(SurfMaskedFogColourLoc,
 				((surf->Fade >> 16) & 255) / 255.0,
 				((surf->Fade >> 8) & 255) / 255.0,
-				(surf->Fade & 255) / 255.0, 1.0);
+				(surf->Fade & 255) / 255.0, Alpha);
 			p_glUniform1fARB(SurfMaskedFogDensityLoc, surf->Fade == FADE_LIGHT ? 0.3 : r_fog_density);
 			p_glUniform1fARB(SurfMaskedFogStartLoc, surf->Fade == FADE_LIGHT ? 1.0 : r_fog_start);
 			p_glUniform1fARB(SurfMaskedFogEndLoc, surf->Fade == FADE_LIGHT ? 1024.0 * r_fade_factor : r_fog_end);
@@ -1111,12 +1239,12 @@
 
 		if (blend_sprites || Additive || Alpha < 1.0)
 		{
-			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.0);
+			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.333);
 			glEnable(GL_BLEND);
 		}
 		else
 		{
-			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.66);
+			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.555);
 		}
 		if (Additive)
 		{
@@ -1147,7 +1275,7 @@
 		glEnable(GL_ALPHA_TEST);
 		if (blend_sprites || Additive || Alpha < 1.0)
 		{
-			glAlphaFunc(GL_GREATER, 0.0);
+			glAlphaFunc(GL_GREATER, 0.111);
 			glEnable(GL_BLEND);
 		}
 		if (Additive)
@@ -1194,7 +1322,7 @@
 
 		if (blend_sprites || Additive || Alpha < 1.0)
 		{
-			glAlphaFunc(GL_GREATER, 0.666);
+			glAlphaFunc(GL_GREATER, 0.333);
 			glDisable(GL_BLEND);
 		}
 		if (Additive)
@@ -1222,6 +1350,53 @@
 
 	SetSpriteLump(Tex, Translation, CMap);
 
+	switch (sprite_tex_linear)
+	{
+		case 1:
+		{
+			spr_maxfilter = GL_LINEAR;
+			spr_minfilter = GL_LINEAR;
+			spr_mipfilter = GL_NEAREST;
+			break;
+		}
+		case 2:
+		{
+			spr_maxfilter = GL_LINEAR;
+			spr_minfilter = GL_LINEAR;
+			spr_mipfilter = GL_LINEAR_MIPMAP_NEAREST;
+			break;
+		}
+		case 3:
+		{
+			spr_maxfilter = GL_LINEAR;
+			spr_minfilter = GL_LINEAR;
+			spr_mipfilter = GL_LINEAR_MIPMAP_LINEAR;
+			break;
+		}
+		case 4: // BILINEAR
+		{
+			spr_maxfilter = GL_NEAREST;
+			spr_minfilter = GL_LINEAR_MIPMAP_NEAREST;
+			spr_mipfilter = GL_LINEAR_MIPMAP_NEAREST;
+			break;
+		}
+		case 5: // TRILINEAR
+		{
+			spr_maxfilter = GL_NEAREST;
+			spr_minfilter = GL_LINEAR_MIPMAP_LINEAR;
+			spr_mipfilter = GL_LINEAR_MIPMAP_LINEAR;
+			break;
+		}
+		default:
+		{
+			spr_maxfilter = GL_NEAREST;
+			spr_minfilter = GL_NEAREST;
+			spr_mipfilter = GL_NEAREST;
+		}
+	}
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, spr_mipfilter);
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, spr_maxfilter);
+
 	if (HaveShaders)
 	{
 		p_glUseProgramObjectARB(SurfMaskedProgram);
@@ -1238,7 +1413,7 @@
 			p_glUniform4fARB(SurfMaskedFogColourLoc,
 				((Fade >> 16) & 255) / 255.0,
 				((Fade >> 8) & 255) / 255.0,
-				(Fade & 255) / 255.0, 1.0);
+				(Fade & 255) / 255.0, Alpha);
 			p_glUniform1fARB(SurfMaskedFogDensityLoc, Fade == FADE_LIGHT ? 0.3 : r_fog_density);
 			p_glUniform1fARB(SurfMaskedFogStartLoc, Fade == FADE_LIGHT ? 1.0 : r_fog_start);
 			p_glUniform1fARB(SurfMaskedFogEndLoc, Fade == FADE_LIGHT ? 1024.0 * r_fade_factor : r_fog_end);
@@ -1250,12 +1425,12 @@
 
 		if (blend_sprites || Additive || Alpha < 1.0)
 		{
-			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.0);
+			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.333);
 			glEnable(GL_BLEND);
 		}
 		else
 		{
-			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.66);
+			p_glUniform1fARB(SurfMaskedAlphaRefLoc, 0.555);
 		}
 		if (Additive)
 		{
@@ -1304,7 +1479,7 @@
 		glEnable(GL_ALPHA_TEST);
 		if (blend_sprites || Additive || Alpha < 1.0)
 		{
-			glAlphaFunc(GL_GREATER, 0.0);
+			glAlphaFunc(GL_GREATER, 0.111);
 			glEnable(GL_BLEND);
 		}
 		if (Additive)
@@ -1342,7 +1517,7 @@
 
 		if (blend_sprites || Additive || Alpha < 1.0)
 		{
-			glAlphaFunc(GL_GREATER, 0.666);
+			glAlphaFunc(GL_GREATER, 0.333);
 			glDisable(GL_BLEND);
 		}
 		if (Additive)
@@ -1372,7 +1547,7 @@
 	else
 	{
 		glEnable(GL_ALPHA_TEST);
-		glAlphaFunc(GL_GREATER, 0.0);
+		glAlphaFunc(GL_GREATER, 0.111);
 		if (pointparmsable)
 		{
 			GLfloat parms[3] = { 0.0, 1.0, 0.0 };
@@ -1384,9 +1559,9 @@
 		}
 		else
 		{
-			glBindTexture(GL_TEXTURE_2D, particle_texture);
 			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, maxfilter);
-			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minfilter);
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, mipfilter);
+			glBindTexture(GL_TEXTURE_2D, particle_texture);
 			glBegin(GL_QUADS);
 		}
 	}
@@ -1430,10 +1605,14 @@
 		}
 		else
 		{
-			glTexCoord2f(0, 0); glVertex(p->org - viewright * p->Size + viewup * p->Size);
-			glTexCoord2f(1, 0); glVertex(p->org + viewright * p->Size + viewup * p->Size);
-			glTexCoord2f(1, 1); glVertex(p->org + viewright * p->Size - viewup * p->Size);
-			glTexCoord2f(0, 1); glVertex(p->org - viewright * p->Size - viewup * p->Size);
+			glTexCoord2f(0, 0);
+			glVertex(p->org - viewright * p->Size + viewup * p->Size);
+			glTexCoord2f(1, 0);
+			glVertex(p->org + viewright * p->Size + viewup * p->Size);
+			glTexCoord2f(1, 1);
+			glVertex(p->org + viewright * p->Size - viewup * p->Size);
+			glTexCoord2f(0, 1);
+			glVertex(p->org - viewright * p->Size - viewup * p->Size);
 		}
 	}
 	unguard;
@@ -1452,7 +1631,7 @@
 	if (!HaveShaders)
 	{
 		glDisable(GL_ALPHA_TEST);
-		glAlphaFunc(GL_GREATER, 0.666);
+		glAlphaFunc(GL_GREATER, 0.333);
 		if (pointparmsable)
 		{
 			glDisable(GL_POINT_SMOOTH);
@@ -1557,9 +1736,9 @@
 	{
 		const surface_t* Surf = Portal->Surfs[i];
 		glBegin(GL_POLYGON);
-		for (int i = 0; i < Surf->count; i++)
+		for (int j = 0; j < Surf->count; j++)
 		{
-			glVertex(Surf->verts[i]);
+			glVertex(Surf->verts[j]);
 		}
 		glEnd();
 	}
diff -Nur orig/source/gl_sdl.cpp mod/source/gl_sdl.cpp
--- orig/source/gl_sdl.cpp	2010-12-17 15:27:47.000000000 +0100
+++ mod/source/gl_sdl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_sdl.cpp 4346 2010-12-17 14:27:56Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/gl_tex.cpp mod/source/gl_tex.cpp
--- orig/source/gl_tex.cpp	2010-12-15 23:20:47.000000000 +0100
+++ mod/source/gl_tex.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_tex.cpp 4341 2010-12-15 22:20:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -83,7 +83,13 @@
 			pbuf[j][i].a = vuint8(ptex[j][i] * 255);
 		}
 	}
+	VTexture::SmoothEdges((vuint8 *)pbuf, 8, 8, (vuint8 *)pbuf);
 	glBindTexture(GL_TEXTURE_2D, particle_texture);
+	//	Set up texture anisotropic filtering.
+	if (max_anisotropy > 1.0)
+	{
+		glTexParameterf(GL_TEXTURE_2D, GLenum(GL_TEXTURE_MAX_ANISOTROPY_EXT), (GLfloat)(max_anisotropy));
+	}
 	glTexImage2D(GL_TEXTURE_2D, 0, 4, 8, 8, 0, GL_RGBA, GL_UNSIGNED_BYTE, pbuf);
 
 	texturesGenerated = true;
@@ -179,6 +185,18 @@
 void VOpenGLDrawer::SetTexture(VTexture* Tex, int CMap)
 {
 	guard(VOpenGLDrawer::SetTexture);
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, maxfilter);
+	if (Tex->Type == TEXTYPE_WallPatch || Tex->Type == TEXTYPE_Wall ||
+		Tex->Type == TEXTYPE_Flat)
+	{
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);
+	}
+	else
+	{
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, mipfilter);
+	}
+	
+
 	SetSpriteLump(Tex, NULL, CMap);
 	unguard;
 }
@@ -225,8 +243,6 @@
 		}
 	}
 
-	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, maxfilter);
-	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, mipfilter);
 	tex_iw = 1.0 / Tex->GetWidth();
 	tex_ih = 1.0 / Tex->GetHeight();
 	unguard;
@@ -242,6 +258,16 @@
 	int CMap)
 {
 	guard(VOpenGLDrawer::SetPic);
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, maxfilter);
+	if (Tex->Type == TEXTYPE_Skin || Tex->Type == TEXTYPE_FontChar)
+	{
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, mipfilter);
+	}
+	else
+	{
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minfilter);
+	}
+
 	SetSpriteLump(Tex, Trans, CMap);
 	unguard;
 }
@@ -340,7 +366,9 @@
 	for (int i = 0; i < Width * Height; i++)
 	{
 		if (Data[i])
+		{
 			NewData[i] = Pal[Data[i]];
+		}
 	}
 	UploadTexture(Width, Height, NewData);
 	Z_Free(NewData);
@@ -358,7 +386,7 @@
 	int		w, h;
 	vuint8*	image;
 	int		level;
-	vuint8	stackbuf[256 * 128 * 4];
+	vuint8*	stackbuf = (vuint8 *)Z_Malloc(256 * 128 * 4);
 
 	w = ToPowerOf2(width);
 	if (w > maxTexSize)
@@ -382,9 +410,12 @@
 	if (w != width || h != height)
 	{
 		/* Smooth transparent edges */
-		VTexture::SmoothEdges((vuint8*)data, width, height, (vuint8*)data);
+		VTexture::SmoothEdges(image, w, h, image);
 		/* must rescale image to get "top" mipmap texture image */
-		VTexture::ResampleTexture(width, height, (vuint8*)data, w, h, image);
+		VTexture::ResampleTexture(width, height, (vuint8*)data, w, h, image, multisampling_sample);
+		/*avir::CImageResizerParamsUltra Params;
+		avir::CImageResizer<avir::fpclass_float4> ImageResizer(8, 16, Params);
+		ImageResizer.resizeImage((vuint8*)data, width, height, 0, image, w, h, 4, 0);*/
 	}
 	else
 	{
@@ -408,5 +439,6 @@
 	{
 		Z_Free(image);
 	}
+	Z_Free(stackbuf);
 	unguard;
 }
diff -Nur orig/source/gl_win32.cpp mod/source/gl_win32.cpp
--- orig/source/gl_win32.cpp	2010-12-17 15:27:47.000000000 +0100
+++ mod/source/gl_win32.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_win32.cpp 4346 2010-12-17 14:27:56Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -137,7 +137,9 @@
 
 	//	Create window
 	RenderWindow = CreateWindow("VAVOOM", "VAVOOM for Windows",
-		Windowed ? WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS : WS_POPUP,
+		Windowed ? (WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX) |
+		WS_CLIPCHILDREN | WS_CLIPSIBLINGS : WS_POPUP | 
+		WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
 		0, 0, 2, 2, hwnd, NULL, hInst, NULL);
 	if (!RenderWindow)
 	{
@@ -270,7 +272,7 @@
 		GCon->Log(NAME_Init, "Swap control extension found.");
 		typedef bool (APIENTRY *PFNWGLSWAPINTERVALFARPROC)(int);
 
-		PFNWGLSWAPINTERVALFARPROC wglSwapIntervalEXT = 0;
+		PFNWGLSWAPINTERVALFARPROC wglSwapIntervalEXT;
 
 		wglSwapIntervalEXT = (PFNWGLSWAPINTERVALFARPROC)GetExtFuncPtr("wglSwapIntervalEXT");
 
diff -Nur orig/source/gl_x.cpp mod/source/gl_x.cpp
--- orig/source/gl_x.cpp	2006-10-31 22:05:00.000000000 +0100
+++ mod/source/gl_x.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gl_x.cpp 1838 2006-10-31 21:00:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/gme/changes.txt mod/source/gme/changes.txt
--- orig/source/gme/changes.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/changes.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,225 @@
+Game_Music_Emu Change Log
+-------------------------
+
+Game_Music_Emu 0.5.5
+--------------------
+- CMake build support has been added.  You can build Game_Music_Emu as
+a shared library and install it so that you do not have to include your
+own copy if you know libgme will be present on your target system.
+Requires CMake 2.6 or higher.
+
+Game_Music_Emu 0.5.2
+--------------------
+- *TONS* of changes and improvements. You should re-read the new header
+files and documentation as the changes will allow you to simplify your
+code a lot (it might even be simpler to just rewrite it). Existing code
+should continue to work without changes in most cases (see Deprecated
+features in gme.txt).
+
+- New file formats: AY, HES, KSS, SAP, NSFE
+
+- All-new comprehensive C interface (also usable from C++). Simplifies
+many things, especially file loading, and brings everything together in
+one header file (gme.h).
+
+- Information tags and track names and times can be accessed for all
+game music formats
+
+- New features supported by all emulators: end of track fading,
+automatic silence detection, adjustable song tempo, seek to new time in
+track
+
+- Updated mini player example to support track names and times, echo,
+tempo, and channel muting, and added visual waveform display
+
+- Improved configuration to use blargg_config.h, which you can modify
+and keep when you update to a newer libary version. Includes flag for
+library to automatically handle gzipped files using zlib (so you don't
+need to use Gzip_File_Reader anymore).
+
+- GBS: Fixed wave channel to not reset waveform when APU is powered off
+(affected Garfield). Also improved invalid bank selection (affected Game
+& Watch and others).
+
+- VGM: Added support for alternate noise shifter register
+configurations, used by other systems like the BBC Micro.
+
+- SPC: Removed IPL ROM dump from emulator, as none of the SPC files I
+scanned needed it, and an SPC file can include a copy if necessary. Also
+re-enabled supposed clamping in gaussian interpolation between the third
+and fourth lookups, though I don't know whether it matters
+
+- Added Music_Emu::load_mem() to use music data already in memory
+(without copying it)
+
+- Added Music_Emu::warning(), which reports minor problems when loading
+and playing a music file
+
+- Added Music_Emu::set_gain() for uniform adjustment of gain. Can only
+be set during initialization, so not useful as a general volume control.
+
+- Added custom operator new to ensure that no exceptions are thrown in
+the library (I'd use std::nothrow if it were part of pre-ISO (ARM) C++)
+
+- Added BLIP_BUFFER_FAST flag to blargg_config.h to use a lower quality
+bandlimited synthesis in "classic" emulators, which might help
+performance on ancient processors (measure first!). Don't use this
+unless absolutely necessary, as quality suffers.
+
+- Improved performance a bit for x86 platforms
+
+- Text files now in DOS newline format so they will open in Notepad
+properly
+
+- Removed requirement that file header structures not have any padding
+added to the end
+
+- Fixed common bug in all CPU emulators where negative program counter
+could crash emulator (occurred during a negative branch from the
+beginning of memory). Also fixed related bug in Z80 emulator for
+IX/IY+displacement mode.
+
+- Eliminated all warnings when compiling on gcc 4.0. The following
+generates no diagnostics:
+
+	gcc -S gme/*.cpp -o /dev/null -ansi -fno-gnu-keywords
+	-fno-nonansi-builtins -pedantic -W -Wabi -Wall -Wcast-align
+	-Wcast-qual -Wchar-subscripts -Wdisabled-optimization -Werror
+	-Winline -Wlong-long -Wmultichar -Winvalid-offsetof
+	-Wnon-virtual-dtor -Woverloaded-virtual -Wparentheses
+	-Wpointer-arith -Wredundant-decls -Wreorder -Wsign-compare
+	-Wsign-promo -Wunknown-pragmas -Wwrite-strings
+
+
+Game_Music_Emu 0.3.0
+--------------------
+- Added more demos, including music player using the SDL multimedia
+library for sound, and improved documentation
+
+- All: Improved interface to emulators to allow simpler setup and
+loading. Instead of various init() functions, all now support
+set_sample_rate( long rate ) and load( const char* file_path ).
+
+- All: Removed error return from start_track() and play(), and added
+error_count() to get the total number of emulation errors since the
+track was last started. See demos for examples of new usage.
+
+- All: Fixed mute_voices() muting to be preserved after loading files
+and starting tracks, instead of being cleared as it was whenever a track
+was started
+
+- VGM: Rewrote Vgm_Emu to support Sega Genesis/Mega Drive FM sound at
+any sample rate with optional FM oversampling, support for alternate
+YM2612 sound cores, and support for optional YM2413
+
+- VGM: Added tempo control, useful for slowing 60Hz NTSC Sega Genesis
+music to 50Hz PAL
+
+- VGM: Removed Vgm_Emu::track_data(), since I realized that this
+information is already present in the VGM header (oops!)
+
+- GYM: Changed Gym_Emu::track_length() operation (see Gym_Emu.h)
+
+- NSF: Added support for Sunsoft FME-7 sound chip used by Gimmick
+soundtrack
+
+- NSF: Fixed Namco 106 problems with Final Lap and others
+
+- Moved library sources to gme/ directory to reduce clutter, and merged
+boost/ functionality into blargg_common.h
+
+- Added Gzip_File_Reader for transparently using gzipped files
+
+
+Game_Music_Emu 0.2.4
+--------------------
+- Created a discussion forum for problems and feedback:
+http://groups-beta.google.com/group/blargg-sound-libs
+
+- Changed error return value of Blip_Buffer::sample_rate() (also for
+Stereo_Buffer, Effects_Buffer, etc.) to blargg_err_t (defined in
+blargg_common.h), to make error reporting consistent with other
+functions. This means the "no error" return value is the opposite of
+what it was before, which will break current code which checks the error
+return value:
+
+	// current code (broken)
+	if ( !buf.sample_rate( samples_per_sec ) )
+		out_of_memory();
+	
+	// quick-and-dirty fix (just remove the ! operation)
+	if ( buf.sample_rate( samples_per_sec ) )
+		out_of_memory();
+	
+	// proper fix
+	blargg_err_t error = buf.sample_rate( samples_per_sec );
+	if ( error )
+		report_error( error );
+
+- Implemented workaround for MSVC++ 6 compiler limitations, allowing it
+to work on that compiler again
+
+- Added sample clamping to avoid wrap-around at high volumes, allowing
+higher volume with little distortion
+
+- Added to-do list and design notes
+
+- Added Music_Emu::skip( long sample_count ) to skip ahead in current
+track
+
+- Added Gym_Emu::track_length() and Vgm_Emu::track_length() for
+determining the length of non-looped GYM and VGM files
+
+- Partially implemented DMC non-linearity when its value is directly set
+using $4011, which reduces previously over-emphasized "popping" of
+percussion on some games (TMNT II in particular)
+
+- Fixed Fir_Resampler, used for SPC and GYM playback (was incorrectly
+using abs() instead of fabs()...argh)
+
+- Fixed SPC emulation bugs: eliminated clicks in Plok! soundtrack and
+now stops sample slightly earlier than the end, as the SNES does. Fixed
+a totally broken CPU addressing mode.
+
+- Fixed Konami VRC6 saw wave (was very broken before). Now VRC6 music
+sounds decent
+
+- Fixed a minor GBS emulation bug
+
+- Fixed GYM loop point bug when track was restarted before loop point
+had been reached
+
+- Made default GBS frequency equalization less muffled
+
+- Added pseudo-surround effect removal for SPC files
+
+- Added Music_Emu::voice_names() which returns names for each voice.
+
+- Added BLARGG_SOURCE_BEGIN which allows custom compiler options to be
+easily set for library sources
+
+- Changed assignment of expansion sound chips in Nsf_Emu to be spread
+more evenly when using Effects_Buffer
+
+- Changed 'size_t' values in Blip_Buffer interface to 'long'
+
+- Changed demo to generate a WAVE sound file rather than an AIFF file
+
+
+Game_Music_Emu 0.2.0
+--------------------
+- Redid framework and rewrote/cleaned up emulators
+
+- Changed licensing to GNU Lesser General Public License (LGPL)
+
+- Added Sega Genesis GYM and Super Nintendo SPC emulators
+
+- Added Namco-106 and Konami VRC6 sound chip support to NSF emulator
+
+- Eliminated use of static mutable data in emulators, allowing
+multi-instance safety
+
+
+Game_Music_Emu 0.1.0
+--------------------
+- First release
diff -Nur orig/source/gme/CMakeLists.txt mod/source/gme/CMakeLists.txt
--- orig/source/gme/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1 @@
+add_subdirectory(src)
diff -Nur orig/source/gme/design.txt mod/source/gme/design.txt
--- orig/source/gme/design.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/design.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,194 @@
+Game_Music_Emu 0.5.2 Design
+---------------------------
+This might be slightly out-of-date at times, but will be a big help in
+understanding the library implementation.
+
+
+Architecture
+------------
+The library is essentially a bunch of independent game music file
+emulators unified with a common interface.
+
+Gme_File and Music_Emu provide a common interface to the emulators. The
+virtual functions are protected rather than public to allow pre- and
+post-processing of arguments and data in one place. This allows the
+emulator classes to assume that everything is set up properly when
+starting a track and playing samples.
+
+All file input is done with the Data_Reader interface. Many derived
+classes are present, for the usual disk-based file and block of memory,
+to specialized adaptors for things like reading a subset of data or
+combining a block of memory with a Data_Reader to the remaining data.
+This makes the library much more flexible with regard to the source of
+game music file data. I still added a specialized load_mem() function to
+have the emulator keep a pointer to data already read in memory, for
+those formats whose files can be absolutely huge (GYM, some VGMs). This
+is important if for some reason the caller must load the data ahead of
+time, but doesn't want the emulator needlessly making a copy.
+
+Since silence checking and fading are relatively complex, they are kept
+separate from basic file loading and track information, which are
+handled in the base class Gme_File. My original intent was to use
+Gme_File as the common base class for full emulators and track
+information-only readers, but implementing the C interface was much
+simpler if both derived from Music_Emu. User C++ code can still benefit
+from static checking by using Gme_File where only track information will
+be accessed.
+
+Each emulator generally has three components: main emulator, CPU
+emulator, and sound chip emulator(s). Each component has minimal
+coupling, so use in a full emulator or stand alone is fairly easy. This
+modularity really helps reduce complexity. Blip_Buffer helps a lot with
+simplifying the APU interfaces and implementation.
+
+The "classic" emulators derive from Classic_Emu, which handles
+Blip_Buffer filling and multiple channels. It uses Multi_Buffer for
+output, allowing you to derive a custom buffer that could output each
+voice to a separate sound channel and do different processing on each.
+At some point I'm going to implement a better Effects_Buffer that allows
+individual control of every channel.
+
+In implementing the C interface, I wanted a way to specify an emulator
+type that didn't require linking in all the emulators. For each emulator
+type there is a global object with pointers to functions to create the
+emulator or a track information reader. The emulator type is thus a
+pointer to this, which conveniently allows for a NULL value. The user
+referencing this emulator type object is what ultimately links the
+emulator in (unless new Foo_Emu is used in C++, of course). This type
+also serves as a useful substitute for RTTI on older C++ compilers.
+
+Addendum: I have since added gme_type_list(), which causes all listed
+emulators to be linked in. To avoid this, I make the list itself
+editable in blargg_config.h. Having a built-in list allows
+gme_load_file() to take a path and give back an emulator with the file
+loaded, which is extremely useful for new users.
+
+
+Interface conventions
+----------------------
+If a function retains a pointer to or replaces the value of an object
+passed, it takes a pointer so that it will be clear in the caller's
+source code that care is required.
+
+Multi-word names have an underscore '_' separator between individual
+words.
+
+Functions are named with lowercase words. Functions which perform an
+action with side-effects are named with a verb phrase (i.e. load, move,
+run). Functions which return the value of a piece of state are named
+using a noun phrase (i.e. loaded, moved, running).
+
+Classes are named with capitalized words. Only the first letter of an
+acronym is capitalized. Class names are nouns, sometimes suggestive of
+what they do (i.e. File_Scanner).
+
+Structure, enumeration, and typedefs to these and built-in types are
+named using lowercase words with a _t suffix.
+
+Macros are named with all-uppercase words.
+
+Internal names which can't be hidden due to technical reasons have an
+underscore '_' suffix.
+
+
+Managing Complexity
+-------------------
+Complexity has been a factor in most library decisions. Many features
+have been passed by due to the complexity they would add. Once
+complexity goes past a certain level, it mentally grasping the library
+in its entirety, at which point more defects will occur and be hard to
+find.
+
+I chose 16-bit signed samples because it seems to be the most common
+format. Supporting multiple formats would add too much complexity to be
+worth it. Other formats can be obtained via conversion.
+
+I've kept interfaces fairly lean, leaving many possible features
+untapped but easy to add if necessary. For example the classic emulators
+could have volume and frequency equalization adjusted separately for
+each channel, since they each have an associated Blip_Synth.
+
+Source files of 400 lines or less seem to be the best size to limit
+complexity. In a few cases there is no reasonable way to split longer
+files, or there is benefit from having the source together in one file.
+
+
+Preventing Bugs
+---------------
+I've done many things to reduce the opportunity for defects. A general
+principle is to write code so that defects will be as visible as
+possible. I've used several techniques to achieve this.
+
+I put assertions at key points where defects seem likely or where
+corruption due to a defect is likely to be visible. I've also put
+assertions where violations of the interface are likely. In emulators
+where I am unsure of exact hardware operation in a particular case, I
+output a debug-only message noting that this has occurred; many times I
+haven't implemented a hardware feature because nothing uses it. I've
+made code brittle where there is no clear reason flexibility; code
+written to handle every possibility sacrifices quality and reliability
+to handle vaguely defined situations.
+
+
+Flexibility through indirection
+-------------------------------
+I've tried to allow the most flexibility of modules by using indirection
+to allow extension by the user. This keeps each module simpler and more
+focused on its unique task.
+
+The classic emulators use Multi_Buffer, which potentially allows a
+separate Blip_Buffer for each channel. This keeps emulators free of
+typical code to allow output in mono, stereo, panning, etc.
+
+All emulators use a reader object to access file data, allowing it to be
+stored in a regular file, compressed archive, memory, or generated
+on-the-fly. Again, the library can be kept free of the particulars of
+file access and changes required to support new formats.
+
+
+Emulators in general
+--------------------
+When I wrote the first NES sound emulator, I stored most of the state in
+an emulator-specific format, with significant redundancy. In the
+register write function I decoded everything into named variables. I
+became tired of the verbosity and wanted to more closely model the
+hardware, so I moved to a style of storing the last written value to
+each register, along with as little other state as possible, mostly the
+internal hardware registers. While this involves slightly more
+recalculation, in most cases the emulation code is of comparable size.
+It also makes state save/restore (for use in a full emulator) much
+simpler. Finally, it makes debugging easier since the hardware registers
+used in emulation are obvious.
+
+
+CPU Cores
+---------
+I've spent lots of time coming up with techniques to optimize the CPU
+cores. Some of the most important: execute multiple instructions during
+an emulation call, keep state in local variables to allow register
+assignment, optimize state representation for most common instructions,
+defer status flag calculation until actually needed, read program code
+directly without a call to the memory read function, always pre-fetch
+the operand byte before decoding instruction, and emulate instructions
+using common blocks of code.
+
+I've successfully used Nes_Cpu in a fairly complete NES emulator, and
+I'd like to make all the CPU emulators suitable for use in emulators. It
+seems a waste for them to be used only for the small amount of emulation
+necessary for game music files.
+
+I debugged the CPU cores by writing a test shell that ran them in
+parallel with other CPU cores and compared all memory accesses and
+processor states at each step. This provided good value at little cost.
+
+The CPU mapping page size is adjustable to allow the best tradeoff
+between memory/cache usage and handler granularity. The interface allows
+code to be somewhat independent of the page size.
+
+I optimize program memory accesses to direct reads rather than calls to
+the memory read function. My assumption is that it would be difficult to
+get useful code out of hardware I/O addresses, so no software will
+intentionally execute out of I/O space. Since the page size can be
+changed easily, most program memory mapping schemes can be accommodated.
+This greatly reduces memory access function calls.
+
diff -Nur orig/source/gme/gme.txt mod/source/gme/gme.txt
--- orig/source/gme/gme.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/gme.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,464 @@
+Game_Music_Emu 0.5.5
+--------------------
+Author : Shay Green <gblargg@gmail.com>
+Website: http://www.slack.net/~ant/libs/
+Forum  : http://groups.google.com/group/blargg-sound-libs
+License: GNU Lesser General Public License (LGPL)
+
+Contents
+--------
+* Overview
+* C and C++ interfaces
+* Function reference
+* Error handling
+* Emulator types
+* M3U playlist support
+* Information fields
+* Track length
+* Loading file data
+* Sound parameters
+* VGM/GYM YM2413 & YM2612 FM sound
+* Modular construction
+* Obscure features
+* Solving problems
+* Deprecated features
+* Thanks
+
+
+Overview
+--------
+This library can open game music files, play tracks, and read game and
+track information tags. To play a game music file, do the following:
+
+* Open the file with gme_open_file()
+* Start a track with gme_start_track();
+* Generate samples as needed with gme_play()
+* Play samples through speaker using your operating system
+* Delete emulator when done with gme_delete()
+
+Your code must arrange for the generated samples to be played through
+the computer's speaker using whatever method your operating system
+requires.
+
+There are many additional features available; you can:
+
+* Determine of the type of a music file without opening it with
+gme_identify_*()
+* Load just the file's information tags with gme_info_only
+* Load from a block of memory rather than a file with gme_load_data()
+* Arrange for a fade-out at a particular time with gme_set_fade
+* Find when a track has ended with gme_track_ended()
+* Seek to a new time in the track with gme_seek()
+* Load an extended m3u playlist with gme_load_m3u()
+* Get a list of the voices (channels) and mute them individually with
+gme_voice_names() and gme_mute_voice()
+* Change the playback tempo without affecting pitch with gme_set_tempo()
+* Adjust treble/bass equalization with gme_set_equalizer()
+* Associate your own data with an emulator and later get it back with
+gme_set_user_data()
+* Register a function of yours to be called back when the emulator is
+deleted with gme_set_user_cleanup()
+
+Refer to gme.h for a comprehensive summary of features.
+
+
+C and C++ interfaces
+--------------------
+While the library is written in C++, an extensive C interface is
+provided in gme.h. This C interface will be referred to throughout this
+documentation unless a feature is only available in the full C++
+interface. All C interface functions and other names have the gme_
+prefix, so you can recognize a C++-only feature by the lack of gme_ in
+the names used (contact me if you'd like a feature added to the C
+interface). If you're building a shared library, I highly recommend
+sticking to the C interface only, because it will be more stable between
+releases of the library than the C++ interface. Finally, the C and C++
+interfaces can be freely mixed without problems. Compare demo/basics.c
+with demo/cpp_basics.cpp to see how the C and C++ interfaces translate
+between each other.
+
+
+Function reference
+------------------
+Read the following header files for a complete reference to functions
+and features. The second group of header files can only be used in C++.
+
+blargg_config.h     Library configuration
+gme.h               C interface (also usable from C++)
+
+Gme_File.h          File loading and track information
+Music_Emu.h         Track playback and adjustments
+Data_Reader.h       Custom data readers
+Effects_Buffer.h    Sound buffer with adjustable stereo echo and panning
+M3u_Playlist.h      M3U playlist support
+Gbs_Emu.h           GBS equalizer settings
+Nsf_Emu.h           NSF equalizer settings
+Spc_Emu.h           SPC surround disable
+Vgm_Emu.h           VGM oversampling disable and custom buffer query
+
+
+Error handling
+--------------
+Functions which can fail have a return type of gme_err_t (blargg_err_t
+in the C++ interfaces), which is a pointer to an error string (const
+char*). If a function is successful it returns NULL. Errors that you can
+easily avoid are checked with debug assertions; gme_err_t return values
+are only used for genuine run-time errors that can't be easily predicted
+in advance (out of memory, I/O errors, incompatible file data). Your
+code should check all error values.
+
+To improve usability for C programmers, C++ programmers unfamiliar with
+exceptions, and compatibility with older C++ compilers, the library does
+*not* throw any C++ exceptions and uses malloc() instead of the standard
+operator new. This means that you *must* check for NULL when creating a
+library object with the new operator.
+
+When loading a music file in the wrong emulator or trying to load a
+non-music file, gme_wrong_file_type is returned. You can check for this
+error in C++ like this:
+
+	gme_err_t err = gme_open_file( path, &emu );
+	if ( err == gme_wrong_file_type )
+		...
+
+To check for minor problems, call gme_warning() to get a string
+describing the last warning. Your player should allow the user some way
+of knowing when this is the case, since these minor errors could affect
+playback. Without this information the user can't solve problems as
+well. When playing a track, gme_warning() returns minor playback-related
+problems (major playback problems end the track immediately and set the
+warning string).
+
+
+Emulator types
+--------------
+The library includes several game music emulators that each support a
+different file type. Each is identified by a gme_type_t constant defined
+in gme.h, for example gme_nsf_emu is for the NSF emulator. If you use
+gme_open_file() or gme_open_data(), the library does the work of
+determining the file type and creating an appropriate emulator. If you
+want more control over this process, read on.
+
+There are two basic ways to identify a game music file's type: look at
+its file extension, or read the header data. The library includes
+functions to help with both methods. The first is preferable because it
+is fast and the most common way to identify files. Sometimes the
+extension is lost or wrong, so the header must be read.
+
+Use gme_identify_extension() to find the correct game music type based
+on a filename. To identify a file based on its extension and header
+contents, use gme_identify_file(). If you read the header data yourself,
+use gme_identify_header().
+
+If you want to remove support for some music types to reduce your
+executable size, edit GME_TYPE_LIST in blargg_config.h. For example, to
+support just NSF and GBS, use this:
+
+	#define GME_TYPE_LIST gme_nsf_type, gme_gbs_type
+
+
+M3U playlist support
+--------------------
+The library supports playlists in an extended m3u format with
+gme_load_m3u() to give track names and times to multi-song formats: AY,
+GBS, HES, KSS, NSF, NSFE, and SAP. Some aspects of the file format
+itself is not well-defined so some m3u files won't work properly
+(particularly those provided with KSS files). Only m3u files referencing
+a single file are supported; your code must handle m3u files covering
+more than one game music file, though it can use the built-in m3u
+parsing provided by the library.
+
+
+Information fields
+------------------
+Support is provided for the various text fields and length information
+in a file with gme_track_info(). If you just need track information for
+a file (for example, building a playlist), use gme_new_info() in place
+of gme_new_emu(), load the file normally, then you can access the track
+count and info, but nothing else.
+
+             M3U  VGM  GYM  SPC  SAP  NSFE  NSF  AY  GBS  HES  KSS
+             -------------------------------------------------------
+Track Count | *    *    *    *    *    *    *    *    *
+            |
+System      |      *    *    *    *    *    *    *    *    *    *
+            |
+Game        |      *    *    *         *    *         *    *
+            |
+Song        | *    *    *    *    *    *         *
+            |
+Author      |      *         *    *    *    *    *    *    *
+            |
+Copyright   |      *    *    *    *    *    *         *    *
+            |
+Comment     |      *    *    *                   *
+            |
+Dumper      |      *    *    *         *
+            |
+Length      | *    *    *    *    *    *
+            |
+Intro Length| *    *    *
+            |
+Loop Length | *    *    *
+
+As listed above, the HES and KSS file formats don't include a track
+count, and tracks are often scattered over the 0-255 range, so an m3u
+playlist for these is a must.
+
+Unavailable text fields are set to an empty string and times to -1. Your
+code should be prepared for any combination of available and unavailable
+fields, as a particular music file might not use all of the supported
+fields listed above.
+
+Currently text fields are truncated to 255 characters. Obscure fields of
+some formats are not currently decoded; contact me if you want one
+added.
+
+
+Track length
+------------
+The library leaves it up to you as to when to stop playing a track. You
+can ask for available length information and then tell the library what
+time it should start fading the track with gme_set_fade(). By default it
+also continually checks for 6 or more seconds of silence to mark the end
+of a track. Here is a reasonable algorithm you can use to decide how
+long to play a track:
+
+* If the track length is > 0, use it
+* If the loop length > 0, play for intro + loop * 2
+* Otherwise, default to 2.5 minutes (150000 msec)
+
+If you want to play a track longer than normal, be sure the loop length
+isn't zero. See Music_Player.cpp around line 145 for example code.
+
+By default, the library skips silence at the beginning of a track. It
+also continually checks for the end of a non-looping track by watching
+for 6 seconds of unbroken silence. When doing this is scans *ahead* by
+several seconds so it can report the end of the track after only one
+second of silence has actually played. This feature can be disabled with
+gme_ignore_silence().
+
+
+Loading file data
+-----------------
+The library allows file data to be loaded in many different ways. All
+load functions return an error which you should check. The following
+examples assume these variables:
+
+	Music_Emu* emu;
+	gme_err_t error;
+
+If you're letting the library determine a file's type, you can use
+either gme_open_file() or gme_open_data():
+	
+	error = gme_open_file( pathname, &emu );
+	error = gme_open_data( pointer, size, &emu );
+
+If you're manually determining file type and using used gme_new_emu() to
+create an emulator, you can use the following methods of loading:
+
+* From a block of memory:
+
+	error = gme_load_data( emu, pointer, size );
+
+* Have library call your function to read data:
+
+	gme_err_t my_read( void* my_data, void* out, long count )
+	{
+		// code that reads 'count' bytes into 'out' buffer
+		// and return 0 if no error
+	}
+	
+	error = gme_load_custom( emu, my_read, file_size, my_data );
+
+* If you must load the file data into memory yourself, you can have the
+library use your data directly *without* making a copy. If you do this,
+you must not free the data until you're done playing the file.
+
+	error = emu->load_mem( pointer, size );
+
+* If you've already read the first bytes of a file (perhaps to determine
+the file type) and want to avoid seeking back to the beginning for
+performance reasons, use Remaining_Reader:
+
+	Std_File_Reader in;
+	error = in.open( file_path );
+	
+	char header [4];
+	error = in.read( &header, sizeof header );
+	...
+	
+	Remaining_Reader rem( &header, sizeof header, &in );
+	error = emu->load( rem );
+
+If you merely need access to a file's header after loading, use the
+emulator-specific header() functions, after casting the Music_Emu
+pointer to the specific emulator's type. This example examines the
+chip_flags field of the header if it's an NSF file:
+
+	if ( music_emu->type() == gme_nsf_type )
+	{
+		Nsf_Emu* nsf_emu = (Nsf_Emu*) music_emu;
+		if ( nsf_emu->header().chip_flags & 0x01 )
+			...
+	}
+
+Contact me if you want more information about loading files.
+
+
+Sound parameters
+----------------
+All emulators support an arbitrary output sampling rate. A rate of 44100
+Hz should work well on most systems. Since band-limited synthesis is
+used, a sampling rate above 48000 Hz is not necessary and will actually
+reduce sound quality and performance.
+
+All emulators also support adjustable gain, mainly for the purpose of
+getting consistent volume between different music formats and avoiding
+excessive modulation. The gain can only be set *before* setting the
+emulator's sampling rate, so it's not useful as a general volume
+control. The default gains of emulators are set so that they give
+generally similar volumes, though some soundtracks are significantly
+louder or quieter than normal.
+
+Some emulators support adjustable treble and bass frequency equalization
+(AY, GBS, HES, KSS, NSF, NSFE, SAP, VGM) using set_equalizer().
+Parameters are specified using gme_equalizer_t eq = { treble_dB,
+bass_freq }. Treble_dB sets the treble level (in dB), where 0.0 dB gives
+normal treble; -200.0 dB is quite muffled, and 5.0 dB emphasizes treble
+for an extra crisp sound. Bass_freq sets the frequency where bass
+response starts to diminish; 15 Hz is normal, 0 Hz gives maximum bass,
+and 15000 Hz removes all bass. For example, the following makes the
+sound extra-crisp but lacking bass:
+
+	gme_equalizer_t eq = { 5.0, 1000 };
+	gme_set_equalizer( music_emu, &eq );
+
+Each emulator's equalization defaults to approximate the particular
+console's sound quality; this default can be determined by calling
+equalizer() just after creating the emulator. The Music_Emu::tv_eq
+profile gives sound as if coming from a TV speaker, and some emulators
+include other profiles for different versions of the system. For
+example, to use Famicom sound equalization with the NSF emulator, do the
+following:
+
+	music_emu->set_equalizer( Nsf_Emu::famicom_eq );
+
+
+VGM/GYM YM2413 & YM2612 FM sound
+--------------------------------
+The library plays Sega Genesis/Mega Drive music using a YM2612 FM sound
+chip emulator based on the Gens project. Because this has some
+inaccuracies, other YM2612 emulators can be used in its place by
+re-implementing the interface in YM2612_Emu.h. Available on my website
+is a modified version of MAME's YM2612 emulator, which sounds better in
+some ways and whose author is still making improvements.
+
+VGM music files using the YM2413 FM sound chip are also supported, but a
+YM2413 emulator isn't included with the library due to technical
+reasons. I have put one of the available YM2413 emulators on my website
+that can be used directly.
+
+
+Modular construction
+--------------------
+The library is made of many fairly independent modules. If you're using
+only one music file emulator, you can eliminate many of the library
+sources from your program. Refer to the files list in readme.txt to get
+a general idea of what can be removed, and be sure to edit GME_TYPE_LIST
+(see "Emulator types" above). Post to the forum if you'd like me to put
+together a smaller version for a particular use, as this only takes me a
+few minutes to do.
+
+If you want to use one of the individual sound chip emulators (or CPU
+cores) in your own console emulator, first check the libraries page on
+my website since I have released several of them as stand alone
+libraries with included documentation and examples on their use. If you
+don't find it as a standalone library, contact me and I'll consider
+separating it.
+
+The "classic" sound chips use my Blip_Buffer library, which greatly
+simplifies their implementation and efficiently handles band-limited
+synthesis. It is also available as a stand alone library with
+documentation and many examples.
+
+
+Obscure features
+----------------
+The library's flexibility allows many possibilities. Contact me if you
+want help implementing ideas or removing limitations.
+
+* Uses no global/static variables, allowing multiple instances of any
+emulator. This is useful in a music player if you want to allow
+simultaneous recording or scanning of other tracks while one is already
+playing. This will also be useful if your platform disallows global
+data.
+
+* Emulators that support a custom sound buffer can have *every* voice
+routed to a different Blip_Buffer, allowing custom processing on each
+voice. For example you could record a Game Boy track as a 4-channel
+sound file.
+
+* Defining BLIP_BUFFER_FAST uses lower quality, less-multiply-intensive
+synthesis on "classic" emulators, which might help on some really old
+processors. This significantly lowers sound quality and prevents treble
+equalization. Try this if your platform's processor isn't fast enough
+for normal quality. Even on my ten-year-old 400 MHz Mac, this reduces
+processor usage at most by about 0.6% (from 4% to 3.4%), hardly worth
+the quality loss.
+
+
+Solving problems
+----------------
+If you're having problems, try the following:
+
+* If you're getting garbled sound, try this simple siren generator in
+place of your call to play(). This will quickly tell whether the problem
+is in the library or in your code.
+
+	static void play_siren( long count, short* out )
+	{
+		static double a, a2;
+		while ( count-- )
+			*out++ = 0x2000 * sin( a += .1 + .05*sin( a2+=.00005 ) );
+	}
+
+* Enable debugging support in your environment. This enables assertions
+and other run-time checks.
+
+* Turn the compiler's optimizer is off. Sometimes an optimizer generates
+bad code.
+
+* If multiple threads are being used, ensure that only one at a time is
+accessing a given set of objects from the library. This library is not
+in general thread-safe, though independent objects can be used in
+separate threads.
+
+* If all else fails, see if the demos work.
+
+
+Deprecated features
+-------------------
+The following functions and other features have been deprecated and will
+be removed in a future release of the library. Alternatives to the
+deprecated features are listed to the right.
+
+Music_Emu::error_count()        warning()
+load( header, reader )          see "Loading file data" above
+Spc_Emu::trailer()              track_info()
+Spc_Emu::trailer_size()
+Gym_Emu::track_length()         track_info()
+Vgm_Emu::gd3_data()             track_info()
+Nsfe_Emu::disable_playlist()    clear_playlist()
+
+
+Thanks
+------
+Big thanks to Chris Moeller (kode54) for help with library testing and
+feedback, for maintaining the Foobar2000 plugin foo_gep based on it, and
+for original work on openspc++ that was used when developing Spc_Emu.
+Brad Martin's excellent OpenSPC SNES DSP emulator worked well from the
+start. Also thanks to Richard Bannister, Mahendra Tallur, Shazz,
+nenolod, theHobbit, Johan Samuelsson, and nes6502 for testing, using,
+and giving feedback for the library in their respective game music
+players.
diff -Nur orig/source/gme/license.txt mod/source/gme/license.txt
--- orig/source/gme/license.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/license.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+ 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -Nur orig/source/gme/modifications.txt mod/source/gme/modifications.txt
--- orig/source/gme/modifications.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/modifications.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,3 @@
+This library source code has been modified from it's original version to make the 'msec_to_samples' method
+public, so that it can be accessed by Vavoom to determine the number of samples played at any time, the rest
+of the library functions as originally designed.
\ Nincs új sor a fájl végén
diff -Nur orig/source/gme/readme.txt mod/source/gme/readme.txt
--- orig/source/gme/readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/readme.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,218 @@
+Game_Music_Emu 0.5.5: Game Music Emulators
+------------------------------------------
+Game_Music_Emu is a collection of video game music file emulators that
+support the following formats and systems:
+
+AY        ZX Spectrum/Amstrad CPC
+GBS       Nintendo Game Boy
+GYM       Sega Genesis/Mega Drive
+HES       NEC TurboGrafx-16/PC Engine
+KSS       MSX Home Computer/other Z80 systems (doesn't support FM sound)
+NSF/NSFE  Nintendo NES/Famicom (with VRC 6, Namco 106, and FME-7 sound)
+SAP       Atari systems using POKEY sound chip
+SPC       Super Nintendo/Super Famicom
+VGM/VGZ   Sega Master System/Mark III, Sega Genesis/Mega Drive,BBC Micro
+
+Features:
+* Can be used in C and C++ code
+* High emphasis has been placed on making the library very easy to use
+* One set of common functions work with all emulators the same way
+* Several code examples, including music player using SDL
+* Portable code for use on any system with modern or older C++ compilers
+* Adjustable output sample rate using quality band-limited resampling
+* Uniform access to text information fields and track timing information
+* End-of-track fading and automatic look ahead silence detection
+* Treble/bass and stereo echo for AY/GBS/HES/KSS/NSF/NSFE/SAP/VGM
+* Tempo can be adjusted and individual voices can be muted while playing
+* Can read music data from file, memory, or custom reader function/class
+* Can access track information without having to load into full emulator
+* M3U track listing support for multi-track formats
+* Modular design allows elimination of unneeded emulators/features
+
+This library has been used in game music players for Windows, Linux on
+several architectures, Mac OS, MorphOS, Xbox, PlayStation Portable,
+GP2X, and Nintendo DS.
+
+Author : Shay Green <gblargg@gmail.com>
+Website: http://www.slack.net/~ant/
+Forum  : http://groups.google.com/group/blargg-sound-libs
+License: GNU Lesser General Public License (LGPL)
+
+
+Getting Started
+---------------
+Build a program consisting of demo/basics.c, demo/Wave_Writer.cpp, and
+all source files in gme/.
+
+If you have CMake 2.6 or higher you can use CMake to perform the build for
+you using standard CMake technique (i.e. cd to the source directory, run
+cmake, cd demo, run make)
+
+Be sure "test.nsf" is in the same directory.
+Running the program should generate the recording "out.wav".
+
+A slightly more extensive demo application is available in the player/
+directory.  It requires SDL to build.
+
+Read gme.txt for more information. Post to the discussion forum for
+assistance.
+
+
+Files
+-----
+gme.txt               General notes about the library
+changes.txt           Changes made since previous releases
+design.txt            Library design notes
+license.txt           GNU Lesser General Public License
+CMakeLists.txt        CMake build rules
+
+test.nsf              Test file for NSF emulator
+test.m3u              Test m3u playlist for features.c demo
+
+demo/
+  basics.c            Records NSF file to wave sound file
+  cpp_basics.cpp      C++ version of basics.c
+  features.c          Demonstrates many additional features
+  Wave_Writer.h       WAVE sound file writer used for demo output
+  Wave_Writer.cpp
+  CMakeLists.txt      CMake build rules
+
+player/               Player using the SDL multimedia library
+  player.cpp          Simple music player with waveform display
+  Music_Player.cpp    Stand alone player for background music
+  Music_Player.h
+  Audio_Scope.cpp     Audio waveform scope
+  Audio_Scope.h
+  CMakeLists.txt      CMake build rules
+
+gme/
+  blargg_config.h     Library configuration (modify this file as needed)
+
+  gme.h               C interface (also usable in C++, and simpler too)
+  gme.cpp
+
+  Gme_File.h          File loading and track information
+  Music_Emu.h         Track playback and adjustments
+  Data_Reader.h       Custom data readers
+
+  Effects_Buffer.h    Sound buffer with stereo echo and panning
+  Effects_Buffer.cpp
+
+  M3u_Playlist.h      M3U playlist support
+  M3u_Playlist.cpp
+
+  Ay_Emu.h            ZX Spectrum AY emulator
+  Ay_Emu.cpp
+  Ay_Apu.cpp
+  Ay_Apu.h
+  Ay_Cpu.cpp
+  Ay_Cpu.h
+
+  Gbs_Emu.h           Nintendo Game Boy GBS emulator
+  Gbs_Emu.cpp
+  Gb_Apu.cpp
+  Gb_Apu.h
+  Gb_Cpu.cpp
+  Gb_Cpu.h
+  gb_cpu_io.h
+  Gb_Oscs.cpp
+  Gb_Oscs.h
+
+  Hes_Emu.h           TurboGrafx-16/PC Engine HES emulator
+  Hes_Apu.cpp
+  Hes_Apu.h
+  Hes_Cpu.cpp
+  Hes_Cpu.h
+  hes_cpu_io.h
+  Hes_Emu.cpp
+
+  Kss_Emu.h           MSX Home Computer/other Z80 systems KSS emulator
+  Kss_Emu.cpp
+  Kss_Cpu.cpp
+  Kss_Cpu.h
+  Kss_Scc_Apu.cpp
+  Kss_Scc_Apu.h
+  Ay_Apu.h
+  Ay_Apu.cpp
+  Sms_Apu.h
+  Sms_Apu.cpp
+  Sms_Oscs.h
+
+  Nsf_Emu.h           Nintendo NES NSF/NSFE emulator
+  Nsf_Emu.cpp
+  Nes_Apu.cpp
+  Nes_Apu.h
+  Nes_Cpu.cpp
+  Nes_Cpu.h
+  nes_cpu_io.h
+  Nes_Oscs.cpp
+  Nes_Oscs.h
+  Nes_Fme7_Apu.cpp
+  Nes_Fme7_Apu.h
+  Nes_Namco_Apu.cpp
+  Nes_Namco_Apu.h
+  Nes_Vrc6_Apu.cpp
+  Nes_Vrc6_Apu.h
+  Nsfe_Emu.h          NSFE support
+  Nsfe_Emu.cpp
+
+  Spc_Emu.h           Super Nintendo SPC emulator
+  Spc_Emu.cpp
+  Snes_Spc.cpp
+  Snes_Spc.h
+  Spc_Cpu.cpp
+  Spc_Cpu.h
+  Spc_Dsp.cpp
+  Spc_Dsp.h
+  Fir_Resampler.cpp
+  Fir_Resampler.h
+
+  Sap_Emu.h           Atari SAP emulator
+  Sap_Emu.cpp
+  Sap_Apu.cpp
+  Sap_Apu.h
+  Sap_Cpu.cpp
+  Sap_Cpu.h
+  sap_cpu_io.h
+
+  Vgm_Emu.h           Sega VGM emulator
+  Vgm_Emu_Impl.cpp
+  Vgm_Emu_Impl.h
+  Vgm_Emu.cpp
+  Ym2413_Emu.cpp
+  Ym2413_Emu.h
+  Gym_Emu.h           Sega Genesis GYM emulator
+  Gym_Emu.cpp
+  Sms_Apu.cpp         Common Sega emulator files
+  Sms_Apu.h
+  Sms_Oscs.h
+  Ym2612_Emu.cpp
+  Ym2612_Emu.h
+  Dual_Resampler.cpp
+  Dual_Resampler.h
+  Fir_Resampler.cpp
+  Fir_Resampler.h
+
+  blargg_common.h     Common files needed by all emulators
+  blargg_endian.h
+  blargg_source.h
+  Blip_Buffer.cpp
+  Blip_Buffer.h
+  Gme_File.cpp
+  Music_Emu.cpp
+  Classic_Emu.h
+  Classic_Emu.cpp
+  Multi_Buffer.h
+  Multi_Buffer.cpp
+  Data_Reader.cpp
+  CMakeLists.txt      CMake build rules
+
+
+Legal
+-----
+Game_Music_Emu library copyright (C) 2003-2006 Shay Green.
+SNES SPC DSP emulator based on OpenSPC, copyright (C) 2002 Brad Martin.
+Sega Genesis YM2612 emulator copyright (C) 2002 Stephane Dallongeville.
+
+--
+Shay Green <gblargg@gmail.com>
diff -Nur orig/source/gme/src/Ay_Apu.cpp mod/source/gme/src/Ay_Apu.cpp
--- orig/source/gme/src/Ay_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,406 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Ay_Apu.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// Emulation inaccuracies:
+// * Noise isn't run when not in use
+// * Changes to envelope and noise periods are delayed until next reload
+// * Super-sonic tone should attenuate output to about 60%, not 50%
+
+// Tones above this frequency are treated as disabled tone at half volume.
+// Power of two is more efficient (avoids division).
+int const inaudible_freq = 16384;
+
+int const period_factor = 16;
+
+static byte const amp_table [16] =
+{
+#define ENTRY( n ) byte (n * Ay_Apu::amp_range + 0.5)
+	// With channels tied together and 1K resistor to ground (as datasheet recommends),
+	// output nearly matches logarithmic curve as claimed. Approx. 1.5 dB per step.
+	ENTRY(0.000000),ENTRY(0.007813),ENTRY(0.011049),ENTRY(0.015625),
+	ENTRY(0.022097),ENTRY(0.031250),ENTRY(0.044194),ENTRY(0.062500),
+	ENTRY(0.088388),ENTRY(0.125000),ENTRY(0.176777),ENTRY(0.250000),
+	ENTRY(0.353553),ENTRY(0.500000),ENTRY(0.707107),ENTRY(1.000000),
+	
+	/*
+	// Measured from an AY-3-8910A chip with date code 8611.
+	
+	// Direct voltages without any load (very linear)
+	ENTRY(0.000000),ENTRY(0.046237),ENTRY(0.064516),ENTRY(0.089785),
+	ENTRY(0.124731),ENTRY(0.173118),ENTRY(0.225806),ENTRY(0.329032),
+	ENTRY(0.360215),ENTRY(0.494624),ENTRY(0.594624),ENTRY(0.672043),
+	ENTRY(0.766129),ENTRY(0.841935),ENTRY(0.926882),ENTRY(1.000000),
+	// With only some load
+	ENTRY(0.000000),ENTRY(0.011940),ENTRY(0.017413),ENTRY(0.024876),
+	ENTRY(0.036318),ENTRY(0.054229),ENTRY(0.072637),ENTRY(0.122388),
+	ENTRY(0.174129),ENTRY(0.239303),ENTRY(0.323881),ENTRY(0.410945),
+	ENTRY(0.527363),ENTRY(0.651741),ENTRY(0.832338),ENTRY(1.000000),
+	*/
+#undef ENTRY
+};
+
+static byte const modes [8] =
+{
+#define MODE( a0,a1, b0,b1, c0,c1 ) \
+		(a0 | a1<<1 | b0<<2 | b1<<3 | c0<<4 | c1<<5)
+	MODE( 1,0, 1,0, 1,0 ),
+	MODE( 1,0, 0,0, 0,0 ),
+	MODE( 1,0, 0,1, 1,0 ),
+	MODE( 1,0, 1,1, 1,1 ),
+	MODE( 0,1, 0,1, 0,1 ),
+	MODE( 0,1, 1,1, 1,1 ),
+	MODE( 0,1, 1,0, 0,1 ),
+	MODE( 0,1, 0,0, 0,0 ),
+};
+
+void Ay_Apu::set_output( Blip_Buffer* b )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		set_output( i, b );
+}
+
+Ay_Apu::Ay_Apu()
+{
+	// build full table of the upper 8 envelope waveforms
+	for ( int m = 8; m--; )
+	{
+		byte* out = env_modes [m];
+		int flags = modes [m];
+		for ( int x = 3; --x >= 0; )
+		{
+			int amp = flags & 1;
+			int end = flags >> 1 & 1;
+			int step = end - amp;
+			amp *= 15;
+			for ( int y = 16; --y >= 0; )
+			{
+				*out++ = amp_table [amp];
+				amp += step;
+			}
+			flags >>= 2;
+		}
+	}
+	
+	set_output( NULL );
+	volume( 1.0 );
+	reset();
+}
+
+void Ay_Apu::reset()
+{
+	addr_       = 0;
+	last_time   = 0;
+	noise_delay = 0;
+	noise_lfsr  = 1;
+	
+	for ( osc_t* osc = &oscs [osc_count]; osc != oscs; )
+	{
+		osc--;
+		osc->period   = period_factor;
+		osc->delay    = 0;
+		osc->last_amp = 0;
+		osc->phase    = 0;
+	}
+	
+	for ( int i = sizeof regs; --i >= 0; )
+		regs [i] = 0;
+	regs [7] = 0xFF;
+	write_data_( 13, 0 );
+}
+
+int Ay_Apu::read()
+{
+	static byte const masks [reg_count] = { 
+		0xFF, 0x0F, 0xFF, 0x0F, 0xFF, 0x0F, 0x1F, 0x3F,
+		0x1F, 0x1F, 0x1F, 0xFF, 0xFF, 0x0F, 0x00, 0x00
+	};
+	return regs [addr_] & masks [addr_];
+}
+
+void Ay_Apu::write_data_( int addr, int data )
+{
+	assert( (unsigned) addr < reg_count );
+	
+	if ( (unsigned) addr >= 14 )
+		dprintf( "Wrote to I/O port %02X\n", (int) addr );
+	
+	// envelope mode
+	if ( addr == 13 )
+	{
+		if ( !(data & 8) ) // convert modes 0-7 to proper equivalents
+			data = (data & 4) ? 15 : 9;
+		env_wave = env_modes [data - 7];
+		env_pos = -48;
+		env_delay = 0; // will get set to envelope period in run_until()
+	}
+	regs [addr] = data;
+	
+	// handle period changes accurately
+	int i = addr >> 1;
+	if ( i < osc_count )
+	{
+		blip_time_t period = (regs [i * 2 + 1] & 0x0F) * (0x100 * period_factor) +
+				regs [i * 2] * period_factor;
+		if ( !period )
+			period = period_factor;
+		
+		// adjust time of next timer expiration based on change in period
+		osc_t& osc = oscs [i];
+		if ( (osc.delay += period - osc.period) < 0 )
+			osc.delay = 0;
+		osc.period = period;
+	}
+	
+	// TODO: same as above for envelope timer, and it also has a divide by two after it
+}
+
+int const noise_off = 0x08;
+int const tone_off  = 0x01;
+
+void Ay_Apu::run_until( blip_time_t final_end_time )
+{
+	require( final_end_time >= last_time );
+	
+	// noise period and initial values
+	blip_time_t const noise_period_factor = period_factor * 2; // verified
+	blip_time_t noise_period = (regs [6] & 0x1F) * noise_period_factor;
+	if ( !noise_period )
+		noise_period = noise_period_factor;
+	blip_time_t const old_noise_delay = noise_delay;
+	unsigned const old_noise_lfsr = noise_lfsr;
+	
+	// envelope period
+	blip_time_t const env_period_factor = period_factor * 2; // verified
+	blip_time_t env_period = (regs [12] * 0x100 + regs [11]) * env_period_factor;
+	if ( !env_period )
+		env_period = env_period_factor; // same as period 1 on my AY chip
+	if ( !env_delay )
+		env_delay = env_period;
+	
+	// run each osc separately
+	for ( int index = 0; index < osc_count; index++ )
+	{
+		osc_t* const osc = &oscs [index];
+		int osc_mode = regs [7] >> index;
+		
+		// output
+		Blip_Buffer* const osc_output = osc->output;
+		if ( !osc_output )
+			continue;
+		osc_output->set_modified();
+		
+		// period
+		int half_vol = 0;
+		blip_time_t inaudible_period = (unsigned) (osc_output->clock_rate() +
+				inaudible_freq) / (unsigned) (inaudible_freq * 2);
+		if ( osc->period <= inaudible_period && !(osc_mode & tone_off) )
+		{
+			half_vol = 1; // Actually around 60%, but 50% is close enough
+			osc_mode |= tone_off;
+		}
+		
+		// envelope
+		blip_time_t start_time = last_time;
+		blip_time_t end_time   = final_end_time;
+		int const vol_mode = regs [0x08 + index];
+		int volume = amp_table [vol_mode & 0x0F] >> half_vol;
+		int osc_env_pos = env_pos;
+		if ( vol_mode & 0x10 )
+		{
+			volume = env_wave [osc_env_pos] >> half_vol;
+			// use envelope only if it's a repeating wave or a ramp that hasn't finished
+			if ( !(regs [13] & 1) || osc_env_pos < -32 )
+			{
+				end_time = start_time + env_delay;
+				if ( end_time >= final_end_time )
+					end_time = final_end_time;
+				
+				//if ( !(regs [12] | regs [11]) )
+				//  dprintf( "Used envelope period 0\n" );
+			}
+			else if ( !volume )
+			{
+				osc_mode = noise_off | tone_off;
+			}
+		}
+		else if ( !volume )
+		{
+			osc_mode = noise_off | tone_off;
+		}
+		
+		// tone time
+		blip_time_t const period = osc->period;
+		blip_time_t time = start_time + osc->delay;
+		if ( osc_mode & tone_off ) // maintain tone's phase when off
+		{
+			int count = (final_end_time - time + period - 1) / period;
+			time += count * period;
+			osc->phase ^= count & 1;
+		}
+		
+		// noise time
+		blip_time_t ntime = final_end_time;
+		noise_lfsr = 1;
+		if ( !(osc_mode & noise_off) )
+		{
+			ntime = start_time + old_noise_delay;
+			noise_lfsr = old_noise_lfsr;
+			//if ( (regs [6] & 0x1F) == 0 )
+			//  dprintf( "Used noise period 0\n" );
+		}
+		
+		// The following efficiently handles several cases (least demanding first):
+		// * Tone, noise, and envelope disabled, where channel acts as 4-bit DAC
+		// * Just tone or just noise, envelope disabled
+		// * Envelope controlling tone and/or noise
+		// * Tone and noise disabled, envelope enabled with high frequency
+		// * Tone and noise together
+		// * Tone and noise together with envelope
+		
+		// This loop only runs one iteration if envelope is disabled. If envelope
+		// is being used as a waveform (tone and noise disabled), this loop will
+		// still be reasonably efficient since the bulk of it will be skipped.
+		while ( 1 )
+		{
+			// current amplitude
+			int amp = 0;
+			if ( (osc_mode | osc->phase) & 1 & (osc_mode >> 3 | noise_lfsr) )
+				amp = volume;
+			{
+				int delta = amp - osc->last_amp;
+				if ( delta )
+				{
+					osc->last_amp = amp;
+					synth_.offset( start_time, delta, osc_output );
+				}
+			}
+			
+			// Run wave and noise interleved with each catching up to the other.
+			// If one or both are disabled, their "current time" will be past end time,
+			// so there will be no significant performance hit.
+			if ( ntime < end_time || time < end_time )
+			{
+				// Since amplitude was updated above, delta will always be +/- volume,
+				// so we can avoid using last_amp every time to calculate the delta.
+				int delta = amp * 2 - volume;
+				int delta_non_zero = delta != 0;
+				int phase = osc->phase | (osc_mode & tone_off); assert( tone_off == 0x01 );
+				do
+				{
+					// run noise
+					blip_time_t end = end_time;
+					if ( end_time > time ) end = time;
+					if ( phase & delta_non_zero )
+					{
+						while ( ntime <= end ) // must advance *past* time to avoid hang
+						{
+							int changed = noise_lfsr + 1;
+							noise_lfsr = (-(noise_lfsr & 1) & 0x12000) ^ (noise_lfsr >> 1);
+							if ( changed & 2 )
+							{
+								delta = -delta;
+								synth_.offset( ntime, delta, osc_output );
+							}
+							ntime += noise_period;
+						}
+					}
+					else
+					{
+						// 20 or more noise periods on average for some music
+						int remain = end - ntime;
+						int count = remain / noise_period;
+						if ( remain >= 0 )
+							ntime += noise_period + count * noise_period;
+					}
+					
+					// run tone
+					end = end_time;
+					if ( end_time > ntime ) end = ntime;
+					if ( noise_lfsr & delta_non_zero )
+					{
+						while ( time < end )
+						{
+							delta = -delta;
+							synth_.offset( time, delta, osc_output );
+							time += period;
+							
+							// alternate (less-efficient) implementation
+							//phase ^= 1;
+						}
+						phase = unsigned (-delta) >> (CHAR_BIT * sizeof (unsigned) - 1);
+						check( phase == (delta > 0) );
+					}
+					else
+					{
+						// loop usually runs less than once
+						//SUB_CASE_COUNTER( (time < end) * (end - time + period - 1) / period );
+						
+						while ( time < end )
+						{
+							time += period;
+							phase ^= 1;
+						}
+					}
+				}
+				while ( time < end_time || ntime < end_time );
+				
+				osc->last_amp = (delta + volume) >> 1;
+				if ( !(osc_mode & tone_off) )
+					osc->phase = phase;
+			}
+			
+			if ( end_time >= final_end_time )
+				break; // breaks first time when envelope is disabled
+			
+			// next envelope step
+			if ( ++osc_env_pos >= 0 )
+				osc_env_pos -= 32;
+			volume = env_wave [osc_env_pos] >> half_vol;
+			
+			start_time = end_time;
+			end_time += env_period;
+			if ( end_time > final_end_time )
+				end_time = final_end_time;
+		}
+		osc->delay = time - final_end_time;
+		
+		if ( !(osc_mode & noise_off) )
+		{
+			noise_delay = ntime - final_end_time;
+			this->noise_lfsr = noise_lfsr;
+		}
+	}
+	
+	// TODO: optimized saw wave envelope?
+	
+	// maintain envelope phase
+	blip_time_t remain = final_end_time - last_time - env_delay;
+	if ( remain >= 0 )
+	{
+		int count = (remain + env_period) / env_period;
+		env_pos += count;
+		if ( env_pos >= 0 )
+			env_pos = (env_pos & 31) - 32;
+		remain -= count * env_period;
+		assert( -remain <= env_period );
+	}
+	env_delay = -remain;
+	assert( env_delay > 0 );
+	assert( env_pos < 0 );
+	
+	last_time = final_end_time;
+}
diff -Nur orig/source/gme/src/Ay_Apu.h mod/source/gme/src/Ay_Apu.h
--- orig/source/gme/src/Ay_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,104 @@
+// AY-3-8910 sound chip emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef AY_APU_H
+#define AY_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+class Ay_Apu {
+public:
+// Basics
+
+	// Sets buffer to generate sound into, or 0 to mute.
+	void set_output( Blip_Buffer* );
+	
+	// Writes to address register
+	void write_addr( int data )                 { addr_ = data & 0x0F; }
+	
+	// Emulates to time t, then writes to current data register
+	void write_data( blip_time_t t, int data )  { run_until( t ); write_data_( addr_, data ); }
+	
+	// Emulates to time t, then subtracts t from the current time.
+	// OK if previous write call had time slightly after t.
+	void end_frame( blip_time_t t );
+	
+// More features
+	
+	// Reads from current data register
+	int read();
+	
+	// Resets sound chip
+	void reset();
+	
+	// Number of registers
+	enum { reg_count = 16 };
+	
+	// Same as set_output(), but for a particular channel
+	enum { osc_count = 3 };
+	void set_output( int chan, Blip_Buffer* );
+	
+	// Sets overall volume, where 1.0 is normal
+	void volume( double v )                     { synth_.volume( 0.7/osc_count/amp_range * v ); }
+	
+	// Sets treble equalization
+	void treble_eq( blip_eq_t const& eq )       { synth_.treble_eq( eq ); }
+	
+private:
+	// noncopyable
+	Ay_Apu( const Ay_Apu& );
+	Ay_Apu& operator = ( const Ay_Apu& );
+
+// Implementation
+public:
+	Ay_Apu();
+	BLARGG_DISABLE_NOTHROW
+	typedef BOOST::uint8_t byte;
+
+private:
+	struct osc_t
+	{
+		blip_time_t  period;
+		blip_time_t  delay;
+		short        last_amp;
+		short        phase;
+		Blip_Buffer* output;
+	} oscs [osc_count];
+	
+	blip_time_t last_time;
+	byte        addr_;
+	byte        regs [reg_count];
+	
+	blip_time_t noise_delay;
+	int    noise_lfsr;
+	
+	blip_time_t env_delay;
+	byte const* env_wave;
+	int         env_pos;
+	byte        env_modes [8] [48]; // values already passed through volume table
+	
+	void write_data_( int addr, int data );
+	void run_until( blip_time_t );
+	
+public:
+	enum { amp_range = 255 };
+	Blip_Synth_Norm synth_; // used by Ay_Core for beeper sound
+};
+
+inline void Ay_Apu::set_output( int i, Blip_Buffer* out )
+{
+	assert( (unsigned) i < osc_count );
+	oscs [i].output = out;
+}
+
+inline void Ay_Apu::end_frame( blip_time_t time )
+{
+	if ( time > last_time )
+		run_until( time );
+	
+	last_time -= time;
+	assert( last_time >= 0 );
+}
+
+#endif
diff -Nur orig/source/gme/src/Ay_Core.cpp mod/source/gme/src/Ay_Core.cpp
--- orig/source/gme/src/Ay_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,190 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Ay_Core.h"
+
+/* Copyright (C) 2006-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+inline void Ay_Core::disable_beeper()
+{
+	beeper_mask = 0;
+	last_beeper = 0;
+}
+
+Ay_Core::Ay_Core()
+{
+	beeper_output = NULL;
+	disable_beeper();
+}
+
+Ay_Core::~Ay_Core() { }
+
+void Ay_Core::set_beeper_output( Blip_Buffer* b )
+{
+	beeper_output = b;
+	if ( b && !cpc_mode )
+		beeper_mask = 0x10;
+	else
+		disable_beeper();
+}
+
+void Ay_Core::start_track( registers_t const& r, addr_t play )
+{
+	play_addr = play;
+	
+	memset( mem_.padding1, 0xFF, sizeof mem_.padding1 );
+	
+	int const mirrored = 0x80; // this much is mirrored after end of memory
+	memset( mem_.ram + mem_size + mirrored, 0xFF, sizeof mem_.ram - mem_size - mirrored );
+	memcpy( mem_.ram + mem_size, mem_.ram, mirrored ); // some code wraps around (ugh)
+	
+	cpu.reset( mem_.padding1, mem_.padding1 );
+	cpu.map_mem( 0, mem_size, mem_.ram, mem_.ram );
+	cpu.r = r;
+	
+	beeper_delta   = (int) (apu_.amp_range * 0.8);
+	last_beeper    = 0;
+	next_play      = play_period;
+	spectrum_mode  = false;
+	cpc_mode       = false;
+	cpc_latch      = 0;
+	set_beeper_output( beeper_output );
+	apu_.reset();
+	
+	// a few tunes rely on channels having tone enabled at the beginning
+	apu_.write_addr( 7 );
+	apu_.write_data( 0, 0x38 );
+	
+}
+
+// Emulation
+
+void Ay_Core::cpu_out_( time_t time, addr_t addr, int data )
+{
+	// Spectrum
+	if ( !cpc_mode )
+	{
+		switch ( addr & 0xFEFF )
+		{
+		case 0xFEFD:
+			spectrum_mode = true;
+			apu_.write_addr( data );
+			return;
+		
+		case 0xBEFD:
+			spectrum_mode = true;
+			apu_.write_data( time, data );
+			return;
+		}
+	}
+	
+	// CPC
+	if ( !spectrum_mode )
+	{
+		switch ( addr >> 8 )
+		{
+		case 0xF6:
+			switch ( data & 0xC0 )
+			{
+			case 0xC0:
+				apu_.write_addr( cpc_latch );
+				goto enable_cpc;
+			
+			case 0x80:
+				apu_.write_data( time, cpc_latch );
+				goto enable_cpc;
+			}
+			break;
+		
+		case 0xF4:
+			cpc_latch = data;
+			goto enable_cpc;
+		}
+	}
+	
+	dprintf( "Unmapped OUT: $%04X <- $%02X\n", addr, data );
+	return;
+	
+enable_cpc:
+	if ( !cpc_mode )
+	{
+		cpc_mode = true;
+		disable_beeper();
+		set_cpc_callback.f( set_cpc_callback.data );
+	}
+}
+
+int Ay_Core::cpu_in( addr_t addr )
+{
+	// keyboard read and other things
+	if ( (addr & 0xFF) == 0xFE )
+		return 0xFF; // other values break some beeper tunes
+	
+	dprintf( "Unmapped IN : $%04X\n", addr );
+	return 0xFF;
+}
+
+void Ay_Core::end_frame( time_t* end )
+{
+	cpu.set_time( 0 );
+	
+	// Since detection of CPC mode will halve clock rate during the frame
+	// and thus generate up to twice as much sound, we must generate half
+	// as much until mode is known.
+	if ( !(spectrum_mode | cpc_mode) )
+		*end /= 2;
+	
+	while ( cpu.time() < *end )
+	{
+		run_cpu( min( *end, next_play ) );
+		
+		if ( cpu.time() >= next_play )
+		{
+			// next frame
+			next_play += play_period;
+			
+			if ( cpu.r.iff1 )
+			{
+				// interrupt enabled
+				
+				if ( mem_.ram [cpu.r.pc] == 0x76 )
+					cpu.r.pc++; // advance past HALT instruction
+				
+				cpu.r.iff1 = 0;
+				cpu.r.iff2 = 0;
+				
+				mem_.ram [--cpu.r.sp] = byte (cpu.r.pc >> 8);
+				mem_.ram [--cpu.r.sp] = byte (cpu.r.pc);
+				
+				// fixed interrupt
+				cpu.r.pc = 0x38;
+				cpu.adjust_time( 12 );
+				
+				if ( cpu.r.im == 2 )
+				{
+					// vectored interrupt
+					addr_t addr = cpu.r.i * 0x100 + 0xFF;
+					cpu.r.pc = mem_.ram [(addr + 1) & 0xFFFF] * 0x100 + mem_.ram [addr];
+					cpu.adjust_time( 6 );
+				}
+			}
+		}
+	}
+	
+	// End time frame
+	*end = cpu.time();
+	next_play -= *end;
+	check( next_play >= 0 );
+	cpu.adjust_time( -*end );
+	apu_.end_frame( *end );
+}
diff -Nur orig/source/gme/src/Ay_Core.h mod/source/gme/src/Ay_Core.h
--- orig/source/gme/src/Ay_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,81 @@
+// Sinclair Spectrum AY music emulator core
+
+// Game_Music_Emu 0.6-pre
+#ifndef AY_CORE_H
+#define AY_CORE_H
+
+#include "Z80_Cpu.h"
+#include "Ay_Apu.h"
+
+class Ay_Core {
+public:
+	
+	// Clock count
+	typedef int time_t;
+	
+	// Sound chip access, to assign it to Blip_Buffer etc.
+	Ay_Apu& apu()                                   { return apu_; }
+	
+	// Sets beeper sound buffer, or NULL to mute it. Volume and treble EQ of
+	// beeper are set by APU.
+	void set_beeper_output( Blip_Buffer* );
+	
+	// Sets time between calls to play routine. Can be changed while playing.
+	void set_play_period( time_t p )                { play_period = p; }
+	
+	// 64K memory to load code and data into before starting track. Caller
+	// must parse the AY file.
+	BOOST::uint8_t* mem()                           { return mem_.ram; }
+	enum { mem_size = 0x10000 };
+	enum { ram_addr = 0x4000 }; // where official RAM starts
+	
+	// Starts track using specified register values, and sets play routine that
+	// is called periodically
+	typedef Z80_Cpu::registers_t registers_t;
+	typedef int addr_t;
+	void start_track( registers_t const&, addr_t play );
+	
+	// Ends time frame of at most *end clocks and sets *end to number of clocks
+	// emulated. Until Spectrum/CPC mode is determined, *end is HALVED.
+	void end_frame( time_t* end );
+	
+	// Called when CPC hardware is first accessed. AY file format doesn't specify
+	// which sound hardware is used, so it must be determined during playback
+	// based on which sound port is first used.
+	blargg_callback<void (*)( void* )> set_cpc_callback;
+
+// Implementation
+public:
+	Ay_Core();
+	~Ay_Core();
+
+private:
+	Blip_Buffer* beeper_output;
+	int          beeper_delta;
+	int          last_beeper;
+	int          beeper_mask;
+	
+	addr_t play_addr;
+	time_t play_period;
+	time_t next_play;
+	
+	int  cpc_latch;
+	bool spectrum_mode;
+	bool cpc_mode;
+	
+	// large items
+	Z80_Cpu cpu;
+	struct {
+		BOOST::uint8_t padding1 [0x100];
+		BOOST::uint8_t ram      [mem_size + 0x100];
+	} mem_;
+	Ay_Apu apu_;
+	
+	int  cpu_in( addr_t );
+	void cpu_out(  time_t, addr_t, int data );
+	void cpu_out_( time_t, addr_t, int data );
+	bool run_cpu( time_t end );
+	void disable_beeper();
+};
+
+#endif
diff -Nur orig/source/gme/src/Ay_Cpu.cpp mod/source/gme/src/Ay_Cpu.cpp
--- orig/source/gme/src/Ay_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,59 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Ay_Core.h"
+
+#include "blargg_endian.h"
+//#include "z80_cpu_log.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void Ay_Core::cpu_out( time_t time, addr_t addr, int data )
+{
+	if ( (addr & 0xFF) == 0xFE )
+	{
+		check( !cpc_mode );
+		spectrum_mode = !cpc_mode;
+		
+		// beeper_mask and last_beeper are 0 if (cpc_mode || !beeper_output)
+		if ( (data &= beeper_mask) != last_beeper )
+		{
+			last_beeper = data;
+			int delta = -beeper_delta;
+			beeper_delta = delta;
+			Blip_Buffer* bb = beeper_output;
+			bb->set_modified();
+			apu_.synth_.offset( time, delta, bb );
+		}
+	}
+	else
+	{
+		cpu_out_( time, addr, data );
+	}
+}
+
+#define OUT_PORT( addr, data )  cpu_out( TIME(), addr, data )
+#define IN_PORT(  addr       )  cpu_in( addr )
+#define FLAT_MEM                mem
+#define CPU                     cpu
+
+#define CPU_BEGIN \
+bool Ay_Core::run_cpu( time_t end_time ) \
+{\
+	cpu.set_end_time( end_time );\
+	byte* const mem = mem_.ram; // cache
+	
+	#include "Z80_Cpu_run.h"
+	
+	return warning;
+}
diff -Nur orig/source/gme/src/Ay_Cpu.h mod/source/gme/src/Ay_Cpu.h
--- orig/source/gme/src/Ay_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,92 @@
+// Z80 CPU emulator
+
+// Game_Music_Emu 0.5.5
+#ifndef AY_CPU_H
+#define AY_CPU_H
+
+#include "blargg_endian.h"
+
+typedef blargg_long cpu_time_t;
+
+// must be defined by caller
+void ay_cpu_out( class Ay_Cpu*, cpu_time_t, unsigned addr, int data );
+int ay_cpu_in( class Ay_Cpu*, unsigned addr );
+
+class Ay_Cpu {
+public:
+	// Clear all registers and keep pointer to 64K memory passed in
+	void reset( void* mem_64k );
+	
+	// Run until specified time is reached. Returns true if suspicious/unsupported
+	// instruction was encountered at any point during run.
+	bool run( cpu_time_t end_time );
+	
+	// Time of beginning of next instruction
+	cpu_time_t time() const             { return state->time + state->base; }
+	
+	// Alter current time. Not supported during run() call.
+	void set_time( cpu_time_t t )       { state->time = t - state->base; }
+	void adjust_time( int delta )       { state->time += delta; }
+	
+	typedef BOOST::uint8_t uint8_t;
+	typedef BOOST::uint16_t uint16_t;
+	
+	#if BLARGG_BIG_ENDIAN
+		struct regs_t { uint8_t b, c, d, e, h, l, flags, a; };
+	#else
+		struct regs_t { uint8_t c, b, e, d, l, h, a, flags; };
+	#endif
+	BOOST_STATIC_ASSERT( sizeof (regs_t) == 8 );
+	
+	struct pairs_t { uint16_t bc, de, hl, fa; };
+	
+	// Registers are not updated until run() returns
+	struct registers_t {
+		uint16_t pc;
+		uint16_t sp;
+		uint16_t ix;
+		uint16_t iy;
+		union {
+			regs_t b; //  b.b, b.c, b.d, b.e, b.h, b.l, b.flags, b.a
+			pairs_t w; // w.bc, w.de, w.hl. w.fa
+		};
+		union {
+			regs_t b;
+			pairs_t w;
+		} alt;
+		uint8_t iff1;
+		uint8_t iff2;
+		uint8_t r;
+		uint8_t i;
+		uint8_t im;
+	};
+	//registers_t r; (below for efficiency)
+	
+	// can read this far past end of memory
+	enum { cpu_padding = 0x100 };
+	
+public:
+	Ay_Cpu();
+private:
+	uint8_t szpc [0x200];
+	uint8_t* mem;
+	cpu_time_t end_time_;
+	struct state_t {
+		cpu_time_t base;
+		cpu_time_t time;
+	};
+	state_t* state; // points to state_ or a local copy within run()
+	state_t state_;
+	void set_end_time( cpu_time_t t );
+public:
+	registers_t r;
+};
+
+inline void Ay_Cpu::set_end_time( cpu_time_t t )
+{
+	cpu_time_t delta = state->base - t;
+	state->base = t;
+	state->time += delta;
+}
+
+#endif
diff -Nur orig/source/gme/src/Ay_Emu.cpp mod/source/gme/src/Ay_Emu.cpp
--- orig/source/gme/src/Ay_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,306 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Ay_Emu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2006-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// TODO: probably don't need detailed errors as to why file is corrupt
+
+int const spectrum_clock = 3546900; // 128K Spectrum
+int const spectrum_period = 70908;
+
+//int const spectrum_clock = 3500000; // 48K Spectrum
+//int const spectrum_period = 69888;
+
+int const cpc_clock = 2000000;
+
+Ay_Emu::Ay_Emu()
+{
+	core.set_cpc_callback( enable_cpc_, this );
+	set_type( gme_ay_type );
+	set_silence_lookahead( 6 );
+}
+
+Ay_Emu::~Ay_Emu() { }
+
+// Track info
+
+// Given pointer to 2-byte offset of data, returns pointer to data, or NULL if
+// offset is 0 or there is less than min_size bytes of data available.
+static byte const* get_data( Ay_Emu::file_t const& file, byte const ptr [], int min_size )
+{
+	int offset = (BOOST::int16_t) get_be16( ptr );
+	int pos  = ptr - (byte const*) file.header;
+	int size = file.end - (byte const*) file.header;
+	assert( (unsigned) pos <= (unsigned) size - 2 );
+	int limit = size - min_size;
+	if ( limit < 0 || !offset || (unsigned) (pos + offset) > (unsigned) limit )
+		return NULL;
+	return ptr + offset;
+}
+
+static blargg_err_t parse_header( byte const in [], int size, Ay_Emu::file_t* out )
+{
+	typedef Ay_Emu::header_t header_t;
+	if ( size < header_t::size )
+		return blargg_err_file_type;
+	
+	out->header = (header_t const*) in;
+	out->end    = in + size;
+	header_t const& h = *(header_t const*) in;
+	if ( memcmp( h.tag, "ZXAYEMUL", 8 ) )
+		return blargg_err_file_type;
+	
+	out->tracks = get_data( *out, h.track_info, (h.max_track + 1) * 4 );
+	if ( !out->tracks )
+		return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "missing track data" );
+	
+	return blargg_ok;
+}
+
+static void copy_ay_fields( Ay_Emu::file_t const& file, track_info_t* out, int track )
+{
+	Gme_File::copy_field_( out->song, (char const*) get_data( file, file.tracks + track * 4, 1 ) );
+	byte const* track_info = get_data( file, file.tracks + track * 4 + 2, 6 );
+	if ( track_info )
+		out->length = get_be16( track_info + 4 ) * (1000 / 50); // frames to msec
+	
+	Gme_File::copy_field_( out->author,  (char const*) get_data( file, file.header->author, 1 ) );
+	Gme_File::copy_field_( out->comment, (char const*) get_data( file, file.header->comment, 1 ) );
+}
+
+blargg_err_t Ay_Emu::track_info_( track_info_t* out, int track ) const
+{
+	copy_ay_fields( file, out, track );
+	return blargg_ok;
+}
+
+struct Ay_File : Gme_Info_
+{
+	Ay_Emu::file_t file;
+	
+	Ay_File() { set_type( gme_ay_type ); }
+	
+	blargg_err_t load_mem_( byte const begin [], int size )
+	{
+		RETURN_ERR( parse_header( begin, size, &file ) );
+		set_track_count( file.header->max_track + 1 );
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int track ) const
+	{
+		copy_ay_fields( file, out, track );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_ay_emu ()
+{
+	return BLARGG_NEW Ay_Emu;
+}
+
+static Music_Emu* new_ay_file()
+{
+	return BLARGG_NEW Ay_File;
+}
+
+gme_type_t_ const gme_ay_type [1] = {{
+	"ZX Spectrum",
+	0,
+	&new_ay_emu,
+	&new_ay_file,
+	"AY",
+	1
+}};
+
+// Setup
+
+blargg_err_t Ay_Emu::load_mem_( byte const in [], int size )
+{
+	assert( offsetof (header_t,track_info [2]) == header_t::size );
+	
+	RETURN_ERR( parse_header( in, size, &file ) );
+	set_track_count( file.header->max_track + 1 );
+	
+	if ( file.header->vers > 2 )
+		set_warning( "Unknown file version" );
+	
+	int const osc_count = Ay_Apu::osc_count + 1; // +1 for beeper
+	
+	set_voice_count( osc_count );
+	core.apu().volume( gain() );
+	
+	static const char* const names [osc_count] = {
+		"Wave 1", "Wave 2", "Wave 3", "Beeper"
+	};
+	set_voice_names( names );
+	
+	static int const types [osc_count] = {
+		wave_type+0, wave_type+1, wave_type+2, mixed_type+1
+	};
+	set_voice_types( types );
+	
+	return setup_buffer( spectrum_clock );
+}
+	
+void Ay_Emu::update_eq( blip_eq_t const& eq )
+{
+	core.apu().treble_eq( eq );
+}
+
+void Ay_Emu::set_voice( int i, Blip_Buffer* center, Blip_Buffer*, Blip_Buffer* )
+{
+	if ( i >= Ay_Apu::osc_count )
+		core.set_beeper_output( center );
+	else
+		core.apu().set_output( i, center );
+}
+
+void Ay_Emu::set_tempo_( double t )
+{
+	int p = spectrum_period;
+	if ( clock_rate() != spectrum_clock )
+		p = clock_rate() / 50;
+	
+	core.set_play_period( blip_time_t (p / t) );
+}
+
+blargg_err_t Ay_Emu::start_track_( int track )
+{
+	RETURN_ERR( Classic_Emu::start_track_( track ) );
+	
+	byte* const mem = core.mem();
+	
+	memset( mem + 0x0000, 0xC9, 0x100 ); // fill RST vectors with RET
+	memset( mem + 0x0100, 0xFF, 0x4000 - 0x100 );
+	memset( mem + core.ram_addr, 0x00, core.mem_size - core.ram_addr );
+
+	// locate data blocks
+	byte const* const data = get_data( file, file.tracks + track * 4 + 2, 14 );
+	if ( !data )
+		return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "file data missing" );
+	
+	byte const* const more_data = get_data( file, data + 10, 6 );
+	if ( !more_data )
+		return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "file data missing" );
+	
+	byte const* blocks = get_data( file, data + 12, 8 );
+	if ( !blocks )
+		return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "file data missing" );
+	
+	// initial addresses
+	unsigned addr = get_be16( blocks );
+	if ( !addr )
+		return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "file data missing" );
+	
+	unsigned init = get_be16( more_data + 2 );
+	if ( !init )
+		init = addr;
+	
+	// copy blocks into memory
+	do
+	{
+		blocks += 2;
+		unsigned len = get_be16( blocks ); blocks += 2;
+		if ( addr + len > core.mem_size )
+		{
+			set_warning( "Bad data block size" );
+			len = core.mem_size - addr;
+		}
+		check( len );
+		byte const* in = get_data( file, blocks, 0 ); blocks += 2;
+		if ( len > (unsigned) (file.end - in) )
+		{
+			set_warning( "File data missing" );
+			len = file.end - in;
+		}
+		//dprintf( "addr: $%04X, len: $%04X\n", addr, len );
+		if ( addr < core.ram_addr && addr >= 0x400 ) // several tracks use low data
+			dprintf( "Block addr in ROM\n" );
+		memcpy( mem + addr, in, len );
+		
+		if ( file.end - blocks < 8 )
+		{
+			set_warning( "File data missing" );
+			break;
+		}
+	}
+	while ( (addr = get_be16( blocks )) != 0 );
+	
+	// copy and configure driver
+	static byte const passive [] = {
+		0xF3,       // DI
+		0xCD, 0, 0, // CALL init
+		0xED, 0x5E, // LOOP: IM 2
+		0xFB,       // EI
+		0x76,       // HALT
+		0x18, 0xFA  // JR LOOP
+	};
+	static byte const active [] = {
+		0xF3,       // DI
+		0xCD, 0, 0, // CALL init
+		0xED, 0x56, // LOOP: IM 1
+		0xFB,       // EI
+		0x76,       // HALT
+		0xCD, 0, 0, // CALL play
+		0x18, 0xF7  // JR LOOP
+	};
+	memcpy( mem, passive, sizeof passive );
+	int const play_addr = get_be16( more_data + 4 );
+	if ( play_addr )
+	{
+		memcpy( mem, active, sizeof active );
+		mem [ 9] = play_addr;
+		mem [10] = play_addr >> 8;
+	}
+	mem [2] = init;
+	mem [3] = init >> 8;
+	
+	mem [0x38] = 0xFB; // Put EI at interrupt vector (followed by RET)
+	
+	// start at spectrum speed
+	change_clock_rate( spectrum_clock );
+	set_tempo( tempo() );
+	
+	Ay_Core::registers_t r = { };
+	r.sp = get_be16( more_data );
+	r.b.a     = r.b.b = r.b.d = r.b.h = data [8];
+	r.b.flags = r.b.c = r.b.e = r.b.l = data [9];
+	r.alt.w = r.w;
+	r.ix = r.iy = r.w.hl;
+	
+	core.start_track( r, play_addr );
+	
+	return blargg_ok;
+}
+
+blargg_err_t Ay_Emu::run_clocks( blip_time_t& duration, int )
+{
+	core.end_frame( &duration );
+	return blargg_ok;
+}
+
+inline void Ay_Emu::enable_cpc()
+{
+	change_clock_rate( cpc_clock );
+	set_tempo( tempo() );
+}
+
+void Ay_Emu::enable_cpc_( void* data )
+{
+	STATIC_CAST(Ay_Emu*,data)->enable_cpc();
+}
diff -Nur orig/source/gme/src/Ay_Emu.h mod/source/gme/src/Ay_Emu.h
--- orig/source/gme/src/Ay_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ay_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,58 @@
+// Sinclair Spectrum AY music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef AY_EMU_H
+#define AY_EMU_H
+
+#include "Classic_Emu.h"
+#include "Ay_Core.h"
+
+class Ay_Emu : public Classic_Emu {
+public:
+	// AY file header
+	struct header_t
+	{
+		enum { size = 0x14 };
+		
+		byte tag        [8];
+		byte vers;
+		byte player;
+		byte unused     [2];
+		byte author     [2];
+		byte comment    [2];
+		byte max_track;
+		byte first_track;
+		byte track_info [2];
+	};
+	
+	static gme_type_t static_type() { return gme_ay_type; }
+
+// Implementation
+public:
+	Ay_Emu();
+	~Ay_Emu();
+
+	struct file_t {
+		header_t const* header;
+		byte const* tracks;
+		byte const* end;    // end of file data
+	};
+	
+protected:
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t load_mem_( byte const [], int );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+
+private:
+	file_t file;
+	Ay_Core core;
+	
+	void enable_cpc();
+	static void enable_cpc_( void* data );
+};
+
+#endif
diff -Nur orig/source/gme/src/blargg_common.cpp mod/source/gme/src/blargg_common.cpp
--- orig/source/gme/src/blargg_common.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/blargg_common.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,59 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "blargg_common.h"
+
+/* Copyright (C) 2008-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+BLARGG_NAMESPACE_BEGIN
+
+// defined here to avoid need for blargg_errors.cpp in simple programs
+blargg_err_def_t blargg_err_memory = BLARGG_ERR_MEMORY;
+
+void blargg_vector_::init()
+{
+	begin_ = NULL;
+	size_  = 0;
+}
+
+void blargg_vector_::clear()
+{
+	void* p = begin_;
+	begin_  = NULL;
+	size_   = 0;
+	free( p );
+	p = NULL;
+}
+
+blargg_err_t blargg_vector_::resize_( size_t n, size_t elem_size )
+{
+	if ( n != size_ )
+	{
+		if ( n == 0 )
+		{
+			// Simpler to handle explicitly. Realloc will handle a size of 0,
+			// but then we have to avoid raising an error for a NULL return.
+			clear();
+		}
+		else
+		{
+			void* p = realloc( begin_, n * elem_size );
+			CHECK_ALLOC( p );
+			begin_ = p;
+			size_  = n;
+		}
+	}
+	return blargg_ok;
+}
+
+BLARGG_NAMESPACE_END
diff -Nur orig/source/gme/src/blargg_common.h mod/source/gme/src/blargg_common.h
--- orig/source/gme/src/blargg_common.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/blargg_common.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,225 @@
+// Sets up common environment for Shay Green's libraries.
+// To change configuration options, modify blargg_config.h, not this file.
+
+// Game_Music_Emu 0.6-pre
+#ifndef BLARGG_COMMON_H
+#define BLARGG_COMMON_H
+
+#include <stdlib.h>
+#include <assert.h>
+#include <limits.h>
+
+typedef const char* blargg_err_t; // 0 on success, otherwise error string
+
+// Success; no error
+blargg_err_t const blargg_ok = NULL;
+
+// BLARGG_RESTRICT: equivalent to C99's restrict, where supported
+#if __GNUC__ >= 3 || _MSC_VER >= 1100
+	#define BLARGG_RESTRICT __restrict
+#else
+	#define BLARGG_RESTRICT
+#endif
+
+#if __cplusplus >= 199711
+	#define BLARGG_MUTABLE mutable
+#else
+	#define BLARGG_MUTABLE
+#endif
+
+/* BLARGG_4CHAR('a','b','c','d') = 'abcd' (four character integer constant).
+I don't just use 'abcd' because that's implementation-dependent. */
+#define BLARGG_4CHAR( a, b, c, d ) \
+	((a&0xFF)*0x1000000 + (b&0xFF)*0x10000 + (c&0xFF)*0x100 + (d&0xFF))
+
+/* BLARGG_STATIC_ASSERT( expr ): Generates compile error if expr is 0.
+Can be used at file, function, or class scope. */
+#ifdef _MSC_VER
+	// MSVC6 (_MSC_VER < 1300) __LINE__ fails when /Zl is specified
+	#define BLARGG_STATIC_ASSERT( expr )    \
+		void blargg_failed_( int (*arg) [2 / (int) !!(expr) - 1] )
+#else
+	// Others fail when declaring same function multiple times in class,
+	// so differentiate them by line
+	#define BLARGG_STATIC_ASSERT( expr )    \
+		void blargg_failed_( int (*arg) [2 / !!(expr) - 1] [__LINE__] )
+#endif
+
+/* Pure virtual functions cause a vtable entry to a "called pure virtual"
+error handler, requiring linkage to the C++ runtime library. This macro is
+used in place of the "= 0", and simply expands to its argument. During
+development, it expands to "= 0", allowing detection of missing overrides. */
+#define BLARGG_PURE( def ) def
+
+/* My code depends on ASCII anywhere a character or string constant is
+compared with data read from a file, and anywhere file data is read and
+treated as a string. */
+#if '\n'!=0x0A || ' '!=0x20 || '0'!=0x30 || 'A'!=0x41 || 'a'!=0x61
+	#error "ASCII character set required"
+#endif
+
+/* My code depends on int being at least 32 bits. Almost everything these days
+uses at least 32-bit ints, so it's hard to even find a system with 16-bit ints
+to test with. The issue can't be gotten around by using a suitable blargg_int
+everywhere either, because int is often converted to implicitly when doing
+arithmetic on smaller types. */
+#if UINT_MAX < 0xFFFFFFFF
+	#error "int must be at least 32 bits"
+#endif
+
+// In case compiler doesn't support these properly. Used rarely.
+#define STATIC_CAST(T,expr) static_cast<T> (expr)
+#define CONST_CAST( T,expr) const_cast<T> (expr)
+
+// User configuration can override the above macros if necessary
+#include "blargg_config.h"
+
+#ifdef BLARGG_NAMESPACE
+	#define BLARGG_NAMESPACE_BEGIN namespace BLARGG_NAMESPACE {
+	#define BLARGG_NAMESPACE_END }
+	
+	BLARGG_NAMESPACE_BEGIN
+	BLARGG_NAMESPACE_END
+	using namespace BLARGG_NAMESPACE;
+#else
+	#define BLARGG_NAMESPACE_BEGIN
+	#define BLARGG_NAMESPACE_END
+#endif
+
+BLARGG_NAMESPACE_BEGIN
+
+/* BLARGG_DEPRECATED [_TEXT] for any declarations/text to be removed in a
+future version. In GCC, we can let the compiler warn. In other compilers,
+we strip it out unless BLARGG_LEGACY is true. */
+#if BLARGG_LEGACY
+	// Allow old client code to work without warnings
+	#define BLARGG_DEPRECATED_TEXT( text ) text
+	#define BLARGG_DEPRECATED(      text ) text
+#elif __GNUC__ >= 4
+	// In GCC, we can mark declarations and let the compiler warn
+	#define BLARGG_DEPRECATED_TEXT( text ) text
+	#define BLARGG_DEPRECATED(      text ) __attribute__ ((deprecated)) text
+#else
+	// By default, deprecated items are removed, to avoid use in new code
+	#define BLARGG_DEPRECATED_TEXT( text )
+	#define BLARGG_DEPRECATED(      text )
+#endif
+
+#define HAVE_STDINT_H
+/* BOOST::int8_t, BOOST::int32_t, etc.
+I used BOOST since I originally was going to allow use of the boost library
+for prividing the definitions. If I'm defining them, they must be scoped or
+else they could conflict with the standard ones at global scope. Even if
+HAVE_STDINT_H isn't defined, I can't assume the typedefs won't exist at
+global scope already. */
+#if defined (HAVE_STDINT_H) || \
+		UCHAR_MAX != 0xFF || USHRT_MAX != 0xFFFF || UINT_MAX != 0xFFFFFFFF
+	#include <stdint.h>
+	#define BOOST
+#else
+	struct BOOST
+	{
+		typedef signed char        int8_t;
+		typedef unsigned char     uint8_t;
+		typedef short             int16_t;
+		typedef unsigned short   uint16_t;
+		typedef int               int32_t;
+		typedef unsigned int     uint32_t;
+	    typedef __int64           int64_t;
+		typedef unsigned __int64 uint64_t;
+	};
+#endif
+
+/* My code is not written with exceptions in mind, so either uses new (nothrow)
+OR overrides operator new in my classes. The former is best since clients
+creating objects will get standard exceptions on failure, but that causes it
+to require the standard C++ library. So, when the client is using the C
+interface, I override operator new to use malloc. */
+
+// BLARGG_DISABLE_NOTHROW is put inside classes
+#ifndef BLARGG_DISABLE_NOTHROW
+	// throw spec mandatory in ISO C++ if NULL can be returned
+	#if __cplusplus >= 199711 || __GNUC__ >= 3 || _MSC_VER >= 1300
+		#define BLARGG_THROWS_NOTHING throw ()
+	#else
+		#define BLARGG_THROWS_NOTHING
+	#endif
+
+	#define BLARGG_DISABLE_NOTHROW \
+		void* operator new ( size_t s ) BLARGG_THROWS_NOTHING { return malloc( s ); }\
+		void operator delete( void* p ) BLARGG_THROWS_NOTHING { free( p ); p = NULL; }
+
+	#define BLARGG_NEW new
+#else
+	// BLARGG_NEW is used in place of new in library code
+	#include <new>
+	#define BLARGG_NEW new (std::nothrow)
+#endif
+
+	class blargg_vector_ {
+	protected:
+		void* begin_;
+		size_t size_;
+		void init();
+		blargg_err_t resize_( size_t n, size_t elem_size );
+	public:
+		size_t size() const { return size_; }
+		void clear();
+	};
+
+// Very lightweight vector for POD types (no constructor/destructor)
+template<class T>
+class blargg_vector : public blargg_vector_ {
+	union T_must_be_pod { T t; }; // fails if T is not POD
+public:
+	blargg_vector()         { init(); }
+	~blargg_vector()        { clear(); }
+	
+	blargg_err_t resize( size_t n ) { return resize_( n, sizeof (T) ); }
+	
+	      T* begin()       { return static_cast<T*> (begin_); }
+	const T* begin() const { return static_cast<T*> (begin_); }
+	
+	      T* end()         { return static_cast<T*> (begin_) + size_; }
+	const T* end()   const { return static_cast<T*> (begin_) + size_; }
+	
+	T& operator [] ( size_t n )
+	{
+		assert( n < size_ );
+		return static_cast<T*> (begin_) [n];
+	}
+	
+	const T& operator [] ( size_t n ) const
+	{
+		assert( n < size_ );
+		return static_cast<T*> (begin_) [n];
+	}
+};
+
+// Callback function with user data.
+// blargg_callback<T> set_callback; // for user, this acts like...
+// void set_callback( T func, void* user_data = NULL ); // ...this
+// To call function, do set_callback.f( .. set_callback.data ... );
+template<class T>
+struct blargg_callback
+{
+	T f;
+	void* data;
+	blargg_callback() { f = NULL; }
+	void operator () ( T callback, void* user_data = NULL ) { f = callback; data = user_data; }
+};
+
+#ifndef _WIN32
+	// Not supported on any other platforms
+	#undef BLARGG_UTF8_PATHS
+#endif
+
+BLARGG_DEPRECATED( typedef signed   int blargg_long; )
+BLARGG_DEPRECATED( typedef unsigned int blargg_ulong; )
+#if BLARGG_LEGACY
+	#define BOOST_STATIC_ASSERT BLARGG_STATIC_ASSERT
+#endif
+
+BLARGG_NAMESPACE_END
+
+#endif
diff -Nur orig/source/gme/src/blargg_config.h mod/source/gme/src/blargg_config.h
--- orig/source/gme/src/blargg_config.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/blargg_config.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,55 @@
+// Library configuration. Modify this file as necessary.
+
+// Game_Music_Emu 0.6-pre
+#ifndef BLARGG_CONFIG_H
+#define BLARGG_CONFIG_H
+
+// Uncomment a #define line below to have effect described.
+
+// Allow static linking with this library and one of my other libraries
+// in the same program.
+//#define BLARGG_NAMESPACE blargg_gme
+
+// Use zlib for transparent decompression of gzipped files.
+//#define HAVE_ZLIB_H
+
+// Support only listed music types. Remove a line to disable that type.
+/* #define GME_TYPE_LIST \
+	gme_ay_type,\
+	gme_gbs_type,\
+	gme_gym_type,\
+	gme_hes_type,\
+	gme_kss_type,\
+	gme_nsf_type,\
+	gme_nsfe_type,\
+	gme_sap_type,\
+	gme_sgc_type,\
+	gme_spc_type,\
+	gme_vgm_type,\
+	gme_vgz_type
+*/
+
+// Enable platform-specific optimizations.
+//#define BLARGG_NONPORTABLE 1
+
+// Use faster sample rate convertor for SPC music.
+//#define GME_SPC_FAST_RESAMPLER 1
+
+// Use faster sample rate convertor for VGM and GYM music.
+//#define GME_VGM_FAST_RESAMPLER 1
+
+// Use faster, significantly lower quality sound synthesis for classic emulators.
+//#define BLIP_BUFFER_FAST 1
+
+// Reduce memory usage of gme.h by disabling gme_set_effects_config().
+//#define GME_DISABLE_EFFECTS 1
+
+// Force library to use assume big-endian processor.
+//#define BLARGG_BIG_ENDIAN 1
+
+// Use standard config.h if present
+#ifdef HAVE_CONFIG_H
+	#include "config.h"
+#endif
+
+#endif
diff -Nur orig/source/gme/src/blargg_endian.h mod/source/gme/src/blargg_endian.h
--- orig/source/gme/src/blargg_endian.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/blargg_endian.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,189 @@
+// CPU Byte Order Utilities
+
+// Game_Music_Emu 0.6-pre
+#ifndef BLARGG_ENDIAN_H
+#define BLARGG_ENDIAN_H
+
+#include "blargg_common.h"
+
+// BLARGG_CPU_CISC: Defined if CPU has very few general-purpose registers (< 16)
+#if defined (__i386__) || defined (__x86_64__) || defined (_M_IX86) || defined (_M_X64)
+	#define BLARGG_CPU_X86 1
+	#define BLARGG_CPU_CISC 1
+#endif
+
+#if defined (__powerpc__) || defined (__ppc__) || defined (__ppc64__) || \
+		defined (__POWERPC__) || defined (__powerc)
+	#define BLARGG_CPU_POWERPC 1
+	#define BLARGG_CPU_RISC 1
+#endif
+
+// BLARGG_BIG_ENDIAN, BLARGG_LITTLE_ENDIAN: Determined automatically, otherwise only
+// one may be #defined to 1. Only needed if something actually depends on byte order.
+#if !defined (BLARGG_BIG_ENDIAN) && !defined (BLARGG_LITTLE_ENDIAN)
+#ifdef __GLIBC__
+	// GCC handles this for us
+	#include <endian.h>
+	#if __BYTE_ORDER == __LITTLE_ENDIAN
+		#define BLARGG_LITTLE_ENDIAN 1
+	#elif __BYTE_ORDER == __BIG_ENDIAN
+		#define BLARGG_BIG_ENDIAN 1
+	#endif
+#else
+
+#if defined (LSB_FIRST) || defined (__LITTLE_ENDIAN__) || BLARGG_CPU_X86 || \
+		(defined (LITTLE_ENDIAN) && LITTLE_ENDIAN+0 != 1234)
+	#define BLARGG_LITTLE_ENDIAN 1
+#endif
+
+#if defined (MSB_FIRST)     || defined (__BIG_ENDIAN__) || defined (WORDS_BIGENDIAN) || \
+	defined (__sparc__)     ||  BLARGG_CPU_POWERPC || \
+	(defined (BIG_ENDIAN) && BIG_ENDIAN+0 != 4321)
+	#define BLARGG_BIG_ENDIAN 1
+#elif !defined (__mips__)
+	// No endian specified; assume little-endian, since it's most common
+	#define BLARGG_LITTLE_ENDIAN 1
+#endif
+#endif
+#endif
+
+#if BLARGG_LITTLE_ENDIAN && BLARGG_BIG_ENDIAN
+	#undef BLARGG_LITTLE_ENDIAN
+	#undef BLARGG_BIG_ENDIAN
+#endif
+
+BLARGG_NAMESPACE_BEGIN
+
+inline void blargg_verify_byte_order()
+{
+	#ifndef NDEBUG
+		#if BLARGG_BIG_ENDIAN
+			volatile int i = 1;
+			assert( *(volatile char*) &i == 0 );
+		#elif BLARGG_LITTLE_ENDIAN
+			volatile int i = 1;
+			assert( *(volatile char*) &i != 0 );
+		#endif
+	#endif
+}
+
+inline unsigned get_le16( void const* p )
+{
+	return  (unsigned) ((unsigned char const*) p) [1] << 8 |
+			(unsigned) ((unsigned char const*) p) [0];
+}
+
+inline unsigned get_be16( void const* p )
+{
+	return  (unsigned) ((unsigned char const*) p) [0] << 8 |
+			(unsigned) ((unsigned char const*) p) [1];
+}
+
+inline unsigned get_le32( void const* p )
+{
+	return  (unsigned) ((unsigned char const*) p) [3] << 24 |
+			(unsigned) ((unsigned char const*) p) [2] << 16 |
+			(unsigned) ((unsigned char const*) p) [1] <<  8 |
+			(unsigned) ((unsigned char const*) p) [0];
+}
+
+inline unsigned get_be32( void const* p )
+{
+	return  (unsigned) ((unsigned char const*) p) [0] << 24 |
+			(unsigned) ((unsigned char const*) p) [1] << 16 |
+			(unsigned) ((unsigned char const*) p) [2] <<  8 |
+			(unsigned) ((unsigned char const*) p) [3];
+}
+
+inline void set_le16( void* p, unsigned n )
+{
+	((unsigned char*) p) [1] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [0] = (unsigned char) n;
+}
+
+inline void set_be16( void* p, unsigned n )
+{
+	((unsigned char*) p) [0] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [1] = (unsigned char) n;
+}
+
+inline void set_le32( void* p, unsigned n )
+{
+	((unsigned char*) p) [0] = (unsigned char) n;
+	((unsigned char*) p) [1] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [2] = (unsigned char) (n >> 16);
+	((unsigned char*) p) [3] = (unsigned char) (n >> 24);
+}
+
+inline void set_be32( void* p, unsigned n )
+{
+	((unsigned char*) p) [3] = (unsigned char) n;
+	((unsigned char*) p) [2] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [1] = (unsigned char) (n >> 16);
+	((unsigned char*) p) [0] = (unsigned char) (n >> 24);
+}
+
+#if BLARGG_NONPORTABLE
+	// Optimized implementation if byte order is known
+	#if BLARGG_LITTLE_ENDIAN
+		#define GET_LE16( addr )        (*(BOOST::uint16_t const*) (addr))
+		#define GET_LE32( addr )        (*(BOOST::uint32_t const*) (addr))
+		#define SET_LE16( addr, data )  (void) (*(BOOST::uint16_t*) (addr) = (data))
+		#define SET_LE32( addr, data )  (void) (*(BOOST::uint32_t*) (addr) = (data))
+	#elif BLARGG_BIG_ENDIAN
+		#define GET_BE16( addr )        (*(BOOST::uint16_t const*) (addr))
+		#define GET_BE32( addr )        (*(BOOST::uint32_t const*) (addr))
+		#define SET_BE16( addr, data )  (void) (*(BOOST::uint16_t*) (addr) = (data))
+		#define SET_BE32( addr, data )  (void) (*(BOOST::uint32_t*) (addr) = (data))
+
+		#if BLARGG_CPU_POWERPC
+			// PowerPC has special byte-reversed instructions
+			#if defined (__MWERKS__)
+				#define GET_LE16( addr )        (__lhbrx( addr, 0 ))
+				#define GET_LE32( addr )        (__lwbrx( addr, 0 ))
+				#define SET_LE16( addr, in )    (__sthbrx( in, addr, 0 ))
+				#define SET_LE32( addr, in )    (__stwbrx( in, addr, 0 ))
+			#elif defined (__GNUC__)
+				#define GET_LE16( addr )        ({unsigned short ppc_lhbrx_; __asm__ volatile( "lhbrx %0,0,%1" : "=r" (ppc_lhbrx_) : "r" (addr) : "memory" ); ppc_lhbrx_;})
+				#define GET_LE32( addr )        ({unsigned short ppc_lwbrx_; __asm__ volatile( "lwbrx %0,0,%1" : "=r" (ppc_lwbrx_) : "r" (addr) : "memory" ); ppc_lwbrx_;})
+				#define SET_LE16( addr, in )    ({__asm__ volatile( "sthbrx %0,0,%1" : : "r" (in), "r" (addr) : "memory" );})
+				#define SET_LE32( addr, in )    ({__asm__ volatile( "stwbrx %0,0,%1" : : "r" (in), "r" (addr) : "memory" );})
+			#endif
+		#endif
+	#endif
+#endif
+
+#ifndef GET_LE16
+	#define GET_LE16( addr )        get_le16( addr )
+	#define SET_LE16( addr, data )  set_le16( addr, data )
+#endif
+
+#ifndef GET_LE32
+	#define GET_LE32( addr )        get_le32( addr )
+	#define SET_LE32( addr, data )  set_le32( addr, data )
+#endif
+
+#ifndef GET_BE16
+	#define GET_BE16( addr )        get_be16( addr )
+	#define SET_BE16( addr, data )  set_be16( addr, data )
+#endif
+
+#ifndef GET_BE32
+	#define GET_BE32( addr )        get_be32( addr )
+	#define SET_BE32( addr, data )  set_be32( addr, data )
+#endif
+
+// auto-selecting versions
+
+inline void set_le( BOOST::uint16_t* p, unsigned n ) { SET_LE16( p, n ); }
+inline void set_le( BOOST::uint32_t* p, unsigned n ) { SET_LE32( p, n ); }
+inline void set_be( BOOST::uint16_t* p, unsigned n ) { SET_BE16( p, n ); }
+inline void set_be( BOOST::uint32_t* p, unsigned n ) { SET_BE32( p, n ); }
+inline unsigned get_le( BOOST::uint16_t const* p ) { return GET_LE16( p ); }
+inline unsigned get_le( BOOST::uint32_t const* p ) { return GET_LE32( p ); }
+inline unsigned get_be( BOOST::uint16_t const* p ) { return GET_BE16( p ); }
+inline unsigned get_be( BOOST::uint32_t const* p ) { return GET_BE32( p ); }
+
+BLARGG_NAMESPACE_END
+
+#endif
diff -Nur orig/source/gme/src/blargg_errors.cpp mod/source/gme/src/blargg_errors.cpp
--- orig/source/gme/src/blargg_errors.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/blargg_errors.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,117 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "blargg_errors.h"
+
+/* Copyright (C) 2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+BLARGG_NAMESPACE_BEGIN
+
+blargg_err_def_t blargg_err_generic      = BLARGG_ERR_GENERIC;
+// blargg_err_memory is defined in blargg_common.cpp
+blargg_err_def_t blargg_err_caller       = BLARGG_ERR_CALLER;
+blargg_err_def_t blargg_err_internal     = BLARGG_ERR_INTERNAL;
+blargg_err_def_t blargg_err_limitation   = BLARGG_ERR_LIMITATION;
+
+blargg_err_def_t blargg_err_file_missing = BLARGG_ERR_FILE_MISSING;
+blargg_err_def_t blargg_err_file_read    = BLARGG_ERR_FILE_READ;
+blargg_err_def_t blargg_err_file_write   = BLARGG_ERR_FILE_WRITE;
+blargg_err_def_t blargg_err_file_io      = BLARGG_ERR_FILE_IO;
+blargg_err_def_t blargg_err_file_full    = BLARGG_ERR_FILE_FULL;
+blargg_err_def_t blargg_err_file_eof     = BLARGG_ERR_FILE_EOF;
+
+blargg_err_def_t blargg_err_file_type    = BLARGG_ERR_FILE_TYPE;
+blargg_err_def_t blargg_err_file_feature = BLARGG_ERR_FILE_FEATURE;
+blargg_err_def_t blargg_err_file_corrupt = BLARGG_ERR_FILE_CORRUPT;
+
+const char* blargg_err_str( blargg_err_t err )
+{
+	if ( !err )
+		return "";
+	
+	if ( *err == BLARGG_ERR_TYPE("")[0] )
+		return err + 1;
+	
+	return err;
+}
+
+bool blargg_is_err_type( blargg_err_t err, const char type [] )
+{
+	if ( err )
+	{
+		// True if first strlen(type) characters of err match type
+		char const* p = err;
+		while ( *type && *type == *p )
+		{
+			type++;
+			p++;
+		}
+		
+		if ( !*type )
+			return true;
+	}
+	
+	return false;
+}
+
+const char* blargg_err_details( blargg_err_t err )
+{
+	const char* p = err;
+	if ( !p )
+	{
+		p = "";
+	}
+	else if ( *p == BLARGG_ERR_TYPE("")[0] )
+	{
+		while ( *p && *p != ';' )
+			p++;
+		
+		// Skip ; and space after it
+		if ( *p )
+		{
+			p++;
+		
+			check( *p == ' ' );
+			if ( *p )
+				p++;
+		}
+	}
+	return p;
+}
+
+int blargg_err_to_code( blargg_err_t err, blargg_err_to_code_t const codes [] )
+{
+	if ( !err )
+		return 0;
+	
+	while ( codes->str && !blargg_is_err_type( err, codes->str ) )
+		codes++;
+	
+	return codes->code;
+}
+
+blargg_err_t blargg_code_to_err( int code, blargg_err_to_code_t const codes [] )
+{
+	if ( !code )
+		return blargg_ok;
+	
+	while ( codes->str && codes->code != code )
+		codes++;
+	
+	if ( !codes->str )
+		return blargg_err_generic;
+	
+	return codes->str;
+}
+
+BLARGG_NAMESPACE_END
diff -Nur orig/source/gme/src/blargg_errors.h mod/source/gme/src/blargg_errors.h
--- orig/source/gme/src/blargg_errors.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/blargg_errors.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,84 @@
+// Error strings and conversion functions
+
+// Game_Music_Emu 0.6-pre
+#ifndef BLARGG_ERRORS_H
+#define BLARGG_ERRORS_H
+
+#ifndef BLARGG_COMMON_H
+	#include "blargg_common.h"
+#endif
+
+BLARGG_NAMESPACE_BEGIN
+
+typedef const char blargg_err_def_t [];
+
+// Basic errors
+extern blargg_err_def_t blargg_err_generic;
+extern blargg_err_def_t blargg_err_memory;
+extern blargg_err_def_t blargg_err_caller;
+extern blargg_err_def_t blargg_err_internal;
+extern blargg_err_def_t blargg_err_limitation;
+
+// File low-level
+extern blargg_err_def_t blargg_err_file_missing; // not found
+extern blargg_err_def_t blargg_err_file_read;
+extern blargg_err_def_t blargg_err_file_write;
+extern blargg_err_def_t blargg_err_file_io;
+extern blargg_err_def_t blargg_err_file_full;
+extern blargg_err_def_t blargg_err_file_eof;
+
+// File high-level
+extern blargg_err_def_t blargg_err_file_type;   // wrong file type
+extern blargg_err_def_t blargg_err_file_feature;
+extern blargg_err_def_t blargg_err_file_corrupt;
+
+// C string describing error, or "" if err == NULL
+const char* blargg_err_str( blargg_err_t err );
+
+// True iff error is of given type, or false if err == NULL
+bool blargg_is_err_type( blargg_err_t, const char type [] );
+
+// Details of error without describing main cause, or "" if err == NULL
+const char* blargg_err_details( blargg_err_t err );
+
+// Converts error string to integer code using mapping table. Calls blargg_is_err_type()
+// for each str and returns code on first match. Returns 0 if err == NULL.
+struct blargg_err_to_code_t {
+	const char* str;
+	int code;
+};
+int blargg_err_to_code( blargg_err_t err, blargg_err_to_code_t const [] );
+
+// Converts error code back to string. If code == 0, returns NULL. If not in table,
+// returns blargg_err_generic.
+blargg_err_t blargg_code_to_err( int code, blargg_err_to_code_t const [] );
+
+// Generates error string literal with details of cause
+#define BLARGG_ERR( type, str ) (type "; " str)
+
+// Extra space to make it clear when blargg_err_str() isn't called to get
+// printable version of error. At some point, I might prefix error strings
+// with a code, to speed conversion to a code.
+#define BLARGG_ERR_TYPE( str )  " " str
+
+// Error types to pass to BLARGG_ERR macro
+#define BLARGG_ERR_GENERIC      BLARGG_ERR_TYPE( "operation failed" )
+#define BLARGG_ERR_MEMORY       BLARGG_ERR_TYPE( "out of memory" )
+#define BLARGG_ERR_CALLER       BLARGG_ERR_TYPE( "internal usage bug" )
+#define BLARGG_ERR_INTERNAL     BLARGG_ERR_TYPE( "internal bug" )
+#define BLARGG_ERR_LIMITATION   BLARGG_ERR_TYPE( "exceeded limitation" )
+
+#define BLARGG_ERR_FILE_MISSING BLARGG_ERR_TYPE( "file not found" )
+#define BLARGG_ERR_FILE_READ    BLARGG_ERR_TYPE( "couldn't open file" )
+#define BLARGG_ERR_FILE_WRITE   BLARGG_ERR_TYPE( "couldn't modify file" )
+#define BLARGG_ERR_FILE_IO      BLARGG_ERR_TYPE( "read/write error" )
+#define BLARGG_ERR_FILE_FULL    BLARGG_ERR_TYPE( "disk full" )
+#define BLARGG_ERR_FILE_EOF     BLARGG_ERR_TYPE( "truncated file" )
+
+#define BLARGG_ERR_FILE_TYPE    BLARGG_ERR_TYPE( "wrong file type" )
+#define BLARGG_ERR_FILE_FEATURE BLARGG_ERR_TYPE( "unsupported file feature" )
+#define BLARGG_ERR_FILE_CORRUPT BLARGG_ERR_TYPE( "corrupt file" )
+
+BLARGG_NAMESPACE_END
+
+#endif
diff -Nur orig/source/gme/src/blargg_source.h mod/source/gme/src/blargg_source.h
--- orig/source/gme/src/blargg_source.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/blargg_source.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,146 @@
+/* Included at the beginning of library source files, AFTER all other #include
+lines. Sets up helpful macros and services used in my source code. Since this
+is only "active" in my source code, I don't have to worry about polluting the
+global namespace with unprefixed names. */
+
+// Game_Music_Emu 0.6-pre
+#ifndef BLARGG_SOURCE_H
+#define BLARGG_SOURCE_H
+
+#ifndef BLARGG_COMMON_H // optimization only
+	#include "blargg_common.h"
+#endif
+#include "blargg_errors.h"
+
+#include <string.h> /* memcpy(), memset(), memmove() */
+#include <stddef.h> /* offsetof() */
+
+/* The following four macros are for debugging only. Some or all might be
+defined to do nothing, depending on the circumstances. Described is what
+happens when a particular macro is defined to do something. When defined to
+do nothing, the macros do NOT evaluate their argument(s). */
+
+/* If expr is false, prints file and line number, then aborts program. Meant
+for checking internal state and consistency. A failed assertion indicates a bug
+in MY code.
+
+void assert( bool expr ); */
+#include <assert.h>
+
+/* If expr is false, prints file and line number, then aborts program. Meant
+for checking caller-supplied parameters and operations that are outside the
+control of the module. A failed requirement probably indicates a bug in YOUR
+code.
+
+void require( bool expr ); */
+#undef  require
+#define require( expr ) assert( expr )
+
+/* Like printf() except output goes to debugging console/file.
+
+void dprintf( const char format [], ... ); */
+#ifdef NDEBUG
+static inline void blargg_dprintf_( const char [], ... ) { }
+#undef  dprintf
+#define dprintf (1) ? (void) 0 : blargg_dprintf_
+#else
+#ifdef _WIN32
+#include <windows.h>
+#endif
+#include <stdarg.h>
+#include <stdio.h>
+static inline void blargg_dprintf_( const char * fmt, ... )
+{
+	char error[512];
+	va_list vl;
+	va_start(vl, fmt);
+	vsnprintf( error, 511, fmt, vl );
+	va_end(vl);
+#ifdef _WIN32
+	OutputDebugStringA( error );
+#endif
+}
+#undef  dprintf
+#define dprintf blargg_dprintf_
+#endif
+
+/* If expr is false, prints file and line number to debug console/log, then
+continues execution normally. Meant for flagging potential problems or things
+that should be looked into, but that aren't serious problems.
+
+void check( bool expr ); */
+#undef  check
+#define check( expr ) ((void) 0)
+
+/* If expr yields non-NULL error string, returns it from current function,
+otherwise continues normally. */
+#undef  RETURN_ERR
+#define RETURN_ERR( expr ) \
+	do {\
+		blargg_err_t blargg_return_err_ = (expr);\
+		if ( blargg_return_err_ )\
+			return blargg_return_err_;\
+	} while ( 0 )
+
+/* If ptr is NULL, returns out-of-memory error, otherwise continues normally. */
+#undef  CHECK_ALLOC
+#define CHECK_ALLOC( ptr ) \
+	do {\
+		if ( !(ptr) )\
+			return blargg_err_memory;\
+	} while ( 0 )
+
+/* The usual min/max functions for built-in types.
+
+template<typename T> T min( T x, T y ) { return x < y ? x : y; }
+template<typename T> T max( T x, T y ) { return x > y ? x : y; } */
+#define BLARGG_DEF_MIN_MAX( type ) \
+	static inline type blargg_min( type x, type y ) { if ( y < x ) x = y; return x; }\
+	static inline type blargg_max( type x, type y ) { if ( x < y ) x = y; return x; }
+
+BLARGG_DEF_MIN_MAX( int )
+BLARGG_DEF_MIN_MAX( unsigned )
+BLARGG_DEF_MIN_MAX( long )
+BLARGG_DEF_MIN_MAX( unsigned long )
+BLARGG_DEF_MIN_MAX( float )
+BLARGG_DEF_MIN_MAX( double )
+
+#undef  min
+#define min blargg_min
+
+#undef  max
+#define max blargg_max
+
+// typedef unsigned char byte;
+typedef unsigned char blargg_byte;
+#undef  byte
+#define byte blargg_byte
+
+#ifndef BLARGG_EXPORT
+	#if defined (_WIN32) && BLARGG_BUILD_DLL
+		#define BLARGG_EXPORT __declspec(dllexport)
+	#elif defined (__GNUC__)
+		// can always set visibility, even when not building DLL
+		#define BLARGG_EXPORT __attribute__ ((visibility ("default")))
+	#else
+		#define BLARGG_EXPORT
+	#endif
+#endif
+
+#if BLARGG_LEGACY
+	#define BLARGG_CHECK_ALLOC CHECK_ALLOC
+	#define BLARGG_RETURN_ERR  RETURN_ERR
+#endif
+
+// Called after failed operation when overall operation may still complete OK.
+// Only used by unit testing framework.
+#undef ACK_FAILURE
+#define ACK_FAILURE() ((void)0)
+
+/* BLARGG_SOURCE_BEGIN: If defined, #included, allowing redefition of dprintf etc.
+and check */
+#ifdef BLARGG_SOURCE_BEGIN
+	#include BLARGG_SOURCE_BEGIN
+#endif
+
+#endif
diff -Nur orig/source/gme/src/Blip_Buffer.cpp mod/source/gme/src/Blip_Buffer.cpp
--- orig/source/gme/src/Blip_Buffer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Blip_Buffer.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,510 @@
+// Blip_Buffer 0.4.0. http://www.slack.net/~ant/
+
+#include "Blip_Buffer.h"
+
+#include <math.h>
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+//// Blip_Buffer
+
+Blip_Buffer::Blip_Buffer()
+{
+	factor_      = UINT_MAX/2 + 1;
+	buffer_      = NULL;
+	buffer_center_ = NULL;
+	buffer_size_ = 0;
+	sample_rate_ = 0;
+	bass_shift_  = 0;
+	clock_rate_  = 0;
+	bass_freq_   = 16;
+	length_      = 0;
+	
+	// assumptions code makes about implementation-defined features
+	#ifndef NDEBUG
+		// right shift of negative value preserves sign
+		int i = -0x7FFFFFFE;
+		assert( (i >> 1) == -0x3FFFFFFF );
+		
+		// casting truncates and sign-extends
+		i = 0x18000;
+		assert( (BOOST::int16_t) i == -0x8000 );
+	#endif
+	
+	clear();
+}
+
+Blip_Buffer::~Blip_Buffer()
+{
+	free( buffer_ );
+	buffer_ = NULL;
+}
+
+void Blip_Buffer::clear()
+{
+	bool const entire_buffer = true;
+	
+	offset_       = 0;
+	reader_accum_ = 0;
+	modified_     = false;
+	
+	if ( buffer_ )
+	{
+		int count = (entire_buffer ? buffer_size_ : samples_avail());
+		memset( buffer_, 0, (count + blip_buffer_extra_) * sizeof (delta_t) );
+	}
+}
+
+blargg_err_t Blip_Buffer::set_sample_rate( int new_rate, int msec )
+{
+	// Limit to maximum size that resampled time can represent
+	int max_size = (((blip_resampled_time_t) -1) >> BLIP_BUFFER_ACCURACY) -
+			blip_buffer_extra_ - 64; // TODO: -64 isn't needed
+	int new_size = (new_rate * (msec + 1) + 999) / 1000;
+	if ( new_size > max_size )
+		new_size = max_size;
+	
+	// Resize buffer
+	if ( buffer_size_ != new_size )
+	{
+		//dprintf( "%d \n", (new_size + blip_buffer_extra_) * sizeof *buffer_  );
+		void* p = realloc( buffer_, (new_size + blip_buffer_extra_) * sizeof *buffer_ );
+		CHECK_ALLOC( p );
+		buffer_      = (delta_t*) p;
+		buffer_center_ = buffer_ + BLIP_MAX_QUALITY/2;
+		buffer_size_ = new_size;
+	}
+	
+	// Update sample_rate and things that depend on it
+	sample_rate_ = new_rate;
+	length_      = new_size * 1000 / new_rate - 1;
+	if ( clock_rate_ )
+		clock_rate( clock_rate_ );
+	bass_freq( bass_freq_ );
+	
+	clear();
+	
+	return blargg_ok;
+}
+
+blip_resampled_time_t Blip_Buffer::clock_rate_factor( int rate ) const
+{
+	double ratio = (double) sample_rate_ / rate;
+	int factor = (int) floor( ratio * (1 << BLIP_BUFFER_ACCURACY) + 0.5 );
+	assert( factor > 0 || !sample_rate_ ); // fails if clock/output ratio is too large
+	return (blip_resampled_time_t) factor;
+}
+
+void Blip_Buffer::bass_freq( int freq )
+{
+	bass_freq_ = freq;
+	int shift = 31;
+	if ( freq > 0 && sample_rate_ )
+	{
+		shift = 13;
+		int f = (freq << 16) / sample_rate_;
+		while ( (f >>= 1) != 0 && --shift ) { }
+	}
+	bass_shift_ = shift;
+}
+
+void Blip_Buffer::end_frame( blip_time_t t )
+{
+	offset_ += t * factor_;
+	assert( samples_avail() <= (int) buffer_size_ ); // fails if time is past end of buffer
+}
+
+int Blip_Buffer::count_samples( blip_time_t t ) const
+{
+	blip_resampled_time_t last_sample  = resampled_time( t ) >> BLIP_BUFFER_ACCURACY;
+	blip_resampled_time_t first_sample = offset_             >> BLIP_BUFFER_ACCURACY;
+	return (int) (last_sample - first_sample);
+}
+
+blip_time_t Blip_Buffer::count_clocks( int count ) const
+{
+	if ( count > buffer_size_ )
+		count = buffer_size_;
+	blip_resampled_time_t time = (blip_resampled_time_t) count << BLIP_BUFFER_ACCURACY;
+	return (blip_time_t) ((time - offset_ + factor_ - 1) / factor_);
+}
+
+void Blip_Buffer::remove_samples( int count )
+{
+	if ( count )
+	{
+		remove_silence( count );
+		
+		// copy remaining samples to beginning and clear old samples
+		int remain = samples_avail() + blip_buffer_extra_;
+		memmove( buffer_, buffer_ + count, remain * sizeof *buffer_ );
+		memset( buffer_ + remain, 0, count * sizeof *buffer_ );
+	}
+}
+
+int Blip_Buffer::read_samples( blip_sample_t out_ [], int max_samples, bool stereo )
+{
+	int count = samples_avail();
+	if ( count > max_samples )
+		count = max_samples;
+	
+	if ( count )
+	{
+		int const bass = highpass_shift();
+		delta_t const* reader = read_pos() + count;
+		int reader_sum = integrator();
+		
+		blip_sample_t* BLARGG_RESTRICT out = out_ + count;
+		if ( stereo )
+			out += count;
+		int offset = -count;
+		
+		if ( !stereo )
+		{
+			do
+			{
+				int s = reader_sum >> delta_bits;
+				
+				reader_sum -= reader_sum >> bass;
+				reader_sum += reader [offset];
+				
+				BLIP_CLAMP( s, s );
+				out [offset] = (blip_sample_t) s;
+			}
+			while ( ++offset );
+		}
+		else
+		{
+			do
+			{
+				int s = reader_sum >> delta_bits;
+				
+				reader_sum -= reader_sum >> bass;
+				reader_sum += reader [offset];
+				
+				BLIP_CLAMP( s, s );
+				out [offset * 2] = (blip_sample_t) s;
+			}
+			while ( ++offset );
+		}
+		
+		set_integrator( reader_sum );
+		
+		remove_samples( count );
+	}
+	return count;
+}
+
+void Blip_Buffer::mix_samples( blip_sample_t const in [], int count )
+{
+	delta_t* out = buffer_center_ + (offset_ >> BLIP_BUFFER_ACCURACY);
+	
+	int const sample_shift = blip_sample_bits - 16;
+	int prev = 0;
+	while ( --count >= 0 )
+	{
+		int s = *in++ << sample_shift;
+		*out += s - prev;
+		prev = s;
+		++out;
+	}
+	*out -= prev;
+}
+
+void Blip_Buffer::save_state( blip_buffer_state_t* out )
+{
+	assert( samples_avail() == 0 );
+	out->offset_       = offset_;
+	out->reader_accum_ = reader_accum_;
+	memcpy( out->buf, &buffer_ [offset_ >> BLIP_BUFFER_ACCURACY], sizeof out->buf );
+}
+
+void Blip_Buffer::load_state( blip_buffer_state_t const& in )
+{
+	clear();
+	
+	offset_       = in.offset_;
+	reader_accum_ = in.reader_accum_;
+	memcpy( buffer_, in.buf, sizeof in.buf );
+}
+
+
+//// Blip_Synth_
+
+Blip_Synth_Fast_::Blip_Synth_Fast_()
+{
+	buf          = NULL;
+	last_amp     = 0;
+	delta_factor = 0;
+}
+
+void Blip_Synth_Fast_::volume_unit( double new_unit )
+{
+	delta_factor = int (new_unit * (1 << blip_sample_bits) + 0.5);
+}
+
+#if BLIP_BUFFER_FAST
+
+void blip_eq_t::generate( float* out, int count ) const { }
+
+#else
+
+Blip_Synth_::Blip_Synth_( short p [], int w ) :
+	phases( p ),
+	width( w )
+{
+	volume_unit_ = 0.0;
+	kernel_unit  = 0;
+	buf          = NULL;
+	last_amp     = 0;
+	delta_factor = 0;
+}
+
+#undef PI
+#define PI 3.1415926535897932384626433832795029
+
+// Generates right half of sinc kernel (including center point) with cutoff at
+// sample rate / 2 / oversample. Frequency response at cutoff frequency is
+// treble dB (-6=0.5,-12=0.25). Mid controls frequency that rolloff begins at,
+// cut * sample rate / 2.
+static void gen_sinc( float out [], int out_size, double oversample,
+		double treble, double mid )
+{
+	if ( mid    > 0.9999 ) mid    = 0.9999;
+	if ( treble < -300.0 ) treble = -300.0;
+	if ( treble >    5.0 ) treble =    5.0;
+	
+	double const maxh = 4096.0;
+	double rolloff = pow( 10.0, 1.0 / (maxh * 20.0) * treble / (1.0 - mid) );
+	double const pow_a_n = pow( rolloff, maxh - maxh * mid );
+	double const to_angle = PI / maxh / oversample;
+	for ( int i = 1; i < out_size; i++ )
+	{
+		double angle = i * to_angle;
+		double c = rolloff *   cos( angle * maxh       - angle ) -
+		                       cos( angle * maxh               );
+		double cos_nc_angle  = cos( angle * maxh * mid         );
+		double cos_nc1_angle = cos( angle * maxh * mid - angle );
+		double cos_angle     = cos( angle                         );
+		
+		c = c * pow_a_n - rolloff * cos_nc1_angle + cos_nc_angle;
+		double d = 1.0 + rolloff * (rolloff - cos_angle - cos_angle);
+		double b = 2.0 - cos_angle - cos_angle;
+		double a = 1.0 - cos_angle - cos_nc_angle + cos_nc1_angle;
+		
+		out [i] = (float) ((a * d + c * b) / (b * d)); // a / b + c / d
+	}
+	
+	// Approximate center by looking at two points to right. Much simpler
+	// and more reliable than trying to calculate it properly.
+	out [0] = (float) (out [1] + 0.5 * (out [1] - out [2]));
+}
+
+// Gain is 1-2800 for beta of 0-10, instead of 1.0 as it should be, but
+// this is corrected by normalization in treble_eq().
+static void kaiser_window( float io [], int count, float beta )
+{
+	int const accuracy = 10;
+	
+	float const beta2 = beta * beta;
+	float const step = (float) 0.5 / count;
+	float pos = (float) 0.5;
+	for ( float* const end = io + count; io < end; ++io )
+	{
+		float x = (pos - pos*pos) * beta2;
+		float u = x;
+		float k = 1;
+		float n = 2;
+		
+		// Keep refining until adjustment becomes small
+		do
+		{
+			u *= x / (n * n);
+			n += 1;
+			k += u;
+		}
+		while ( k <= u * (1 << accuracy) );
+		
+		pos += step;
+		*io *= k;
+	}
+}
+
+void blip_eq_t::generate( float out [], int count ) const
+{
+	// lower cutoff freq for narrow kernels with their wider transition band
+	// (8 points->1.49, 16 points->1.15)
+	double cutoff_adj = blip_res * 2.25 / count + 0.85;
+	if ( cutoff_adj < 1.02 )
+		cutoff_adj = 1.02;
+	double half_rate = sample_rate * 0.5;
+	if ( cutoff_freq )
+		cutoff_adj = half_rate / cutoff_freq;
+	double cutoff = rolloff_freq * cutoff_adj / half_rate;
+	
+	gen_sinc( out, count, oversample * cutoff_adj, treble, cutoff );
+	
+	kaiser_window( out, count, (float)kaiser );
+}
+
+void Blip_Synth_::treble_eq( blip_eq_t const& eq )
+{
+	// Generate right half of kernel
+	int const half_size = blip_eq_t::calc_count( width );
+	float fimpulse [blip_res / 2 * (BLIP_MAX_QUALITY - 1) + 1];
+	eq.generate( fimpulse, half_size );
+	
+	int i;
+	
+	// Find rescale factor. Summing from small to large (right to left)
+	// reduces error.
+	double total = 0.0;
+	for ( i = half_size; --i > 0; )
+		total += fimpulse [i];
+	total = total * 2.0 + fimpulse [0];
+	
+	//double const base_unit = 44800.0 - 128 * 18; // allows treble up to +0 dB
+	//double const base_unit = 37888.0; // allows treble to +5 dB
+	double const base_unit = 32768.0; // necessary for blip_unscaled to work
+	double rescale = base_unit / total;
+	kernel_unit = (int) base_unit;
+	
+	// Integrate, first difference, rescale, convert to int
+	double sum  = 0;
+	double next = 0;
+	int const size = impulses_size();
+	for ( i = 0; i < size; i++ )
+	{
+		int j = (half_size - 1) - i;
+		
+		if ( i >= blip_res )
+			sum += fimpulse [j + blip_res];
+		
+		// goes slightly past center, so it needs a little mirroring
+		next += fimpulse [j < 0 ? -j : j];
+		
+		// calculate unintereleved index
+		int x = (~i & (blip_res - 1)) * (width >> 1) + (i >> BLIP_PHASE_BITS);
+		assert( (unsigned) x < (unsigned) size );
+		
+		// flooring separately virtually eliminates error
+		phases [x] = (short) (int)
+				(floor( sum * rescale + 0.5 ) - floor( next * rescale + 0.5 ));
+		//phases [x] = (short) (int)
+		//      floor( sum * rescale - next * rescale + 0.5 );
+	}
+	
+	adjust_impulse();
+	
+	// volume might require rescaling
+	double vol = volume_unit_;
+	if ( vol )
+	{
+		volume_unit_ = 0.0;
+		volume_unit( vol );
+	}
+}
+
+void Blip_Synth_::adjust_impulse()
+{
+	int const size = impulses_size();
+	int const half_width = width / 2;
+	
+	// Sum each phase as would be done when synthesizing, and correct
+	// any that don't add up to exactly kernel_half.
+	for ( int phase = blip_res / 2; --phase >= 0; )
+	{
+		int const fwd = phase * half_width;
+		int const rev = size - half_width - fwd;
+		
+		int error = kernel_unit;
+		for ( int i = half_width; --i >= 0; )
+		{
+			error += phases [fwd + i];
+			error += phases [rev + i];
+		}
+		phases [fwd + half_width - 1] -= (short) error;
+		
+		// Error shouldn't occur now with improved calculation
+		//if ( error ) printf( "error: %ld\n", error );
+	}
+	
+	#if 0
+		for ( int i = 0; i < blip_res; i++, printf( "\n" ) )
+			for ( int j = 0; j < width / 2; j++ )
+				printf( "%5d,", (int) -phases [j + width/2 * i] );
+	#endif
+}
+
+void Blip_Synth_::rescale_kernel( int shift )
+{
+	// Keep values positive to avoid round-towards-zero of sign-preserving
+	// right shift for negative values.
+	int const keep_positive = 0x8000 + (1 << (shift - 1));
+	
+	int const half_width = width / 2;
+	for ( int phase = blip_res; --phase >= 0; )
+	{
+		int const fwd = phase * half_width;
+		
+		// Integrate, rescale, then differentiate again.
+		// If differences are rescaled directly, more error results.
+		int sum = keep_positive;
+		for ( int i = 0; i < half_width; i++ )
+		{
+			int prev = sum;
+			sum += phases [fwd + i];
+			phases [fwd + i] = (sum >> shift) - (prev >> shift);
+		}
+	}
+	
+	adjust_impulse();
+}
+
+void Blip_Synth_::volume_unit( double new_unit )
+{
+	if ( volume_unit_ != new_unit )
+	{
+		// use default eq if it hasn't been set yet
+		if ( !kernel_unit )
+			treble_eq( -8.0 );
+		
+		// Factor that kernel must be multiplied by
+		volume_unit_ = new_unit;
+		double factor = new_unit * (1 << blip_sample_bits) / kernel_unit;
+		
+		if ( factor > 0.0 )
+		{
+			// If factor is low, reduce amplitude of kernel itself
+			int shift = 0;
+			while ( factor < 2.0 )
+			{
+				shift++;
+				factor *= 2.0;
+			}
+			
+			if ( shift )
+			{
+				kernel_unit >>= shift;
+				assert( kernel_unit > 0 ); // fails if volume unit is too low
+				
+				rescale_kernel( shift );
+			}
+		}
+		
+		delta_factor = -(int) floor( factor + 0.5 );
+		//printf( "delta_factor: %d, kernel_unit: %d\n", delta_factor, kernel_unit );
+	}
+}
+#endif
diff -Nur orig/source/gme/src/Blip_Buffer.h mod/source/gme/src/Blip_Buffer.h
--- orig/source/gme/src/Blip_Buffer.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Blip_Buffer.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,198 @@
+// Band-limited sound synthesis buffer
+
+// Blip_Buffer 0.4.0
+#ifndef BLIP_BUFFER_H
+#define BLIP_BUFFER_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer_impl.h"
+
+typedef int blip_time_t;                    // Source clocks in current time frame
+typedef BOOST::int16_t blip_sample_t;       // 16-bit signed output sample
+int const blip_default_length = 1000 / 4;   // Default Blip_Buffer length (1/4 second)
+
+
+//// Sample buffer for band-limited synthesis
+
+class Blip_Buffer : public Blip_Buffer_ {
+public:
+
+	// Sets output sample rate and resizes and clears sample buffer
+	blargg_err_t set_sample_rate( int samples_per_sec, int msec_length = blip_default_length );
+	
+	// Sets number of source time units per second
+	void clock_rate( int clocks_per_sec );
+	
+	// Clears buffer and removes all samples
+	void clear();
+	
+	// Use Blip_Synth to add waveform to buffer
+	
+	// Resamples to time t, then subtracts t from current time. Appends result of resampling
+	// to buffer for reading.
+	void end_frame( blip_time_t t );
+	
+	// Number of samples available for reading with read_samples()
+	int samples_avail() const;
+	
+	// Reads at most n samples to out [0 to n-1] and returns number actually read. If stereo
+	// is true, writes to out [0], out [2], out [4] etc. instead.
+	int read_samples( blip_sample_t out [], int n, bool stereo = false );
+	
+// More features
+
+	// Sets flag that tells some Multi_Buffer types that sound was added to buffer,
+	// so they know that it needs to be mixed in. Only needs to be called once
+	// per time frame that sound was added. Not needed if not using Multi_Buffer.
+	void set_modified()                 { modified_ = true; }
+	
+	// Sets high-pass filter frequency, from 0 to 20000 Hz, where higher values reduce bass more
+	void bass_freq( int frequency );
+
+	int length() const;         // Length of buffer in milliseconds
+	int sample_rate() const;    // Current output sample rate
+	int clock_rate() const;     // Number of source time units per second
+	int output_latency() const; // Number of samples delay from offset() to read_samples()
+	
+// Low-level features
+	
+	// Removes the first n samples
+	void remove_samples( int n );
+	
+	// Returns number of clocks needed until n samples will be available.
+	// If buffer cannot even hold n samples, returns number of clocks
+	// until buffer becomes full.
+	blip_time_t count_clocks( int n ) const;
+	
+	// Number of samples that should be mixed before calling end_frame( t )
+	int count_samples( blip_time_t t ) const;
+	
+	// Mixes n samples into buffer
+	void mix_samples( const blip_sample_t in [], int n );
+
+// Resampled time (sorry, poor documentation right now)
+	
+	// Resampled time is fixed-point, in terms of output samples.
+	
+	// Converts clock count to resampled time
+	blip_resampled_time_t resampled_duration( int t ) const         { return t * factor_; }
+	
+	// Converts clock time since beginning of current time frame to resampled time
+	blip_resampled_time_t resampled_time( blip_time_t t ) const     { return t * factor_ + offset_; }
+	
+	// Returns factor that converts clock rate to resampled time
+	blip_resampled_time_t clock_rate_factor( int clock_rate ) const;
+	
+// State save/load
+
+	// Saves state, including high-pass filter and tails of last deltas.
+	// All samples must have been read from buffer before calling this
+	// (that is, samples_avail() must return 0).
+	void save_state( blip_buffer_state_t* out );
+	
+	// Loads state. State must have been saved from Blip_Buffer with same
+	// settings during same run of program; states can NOT be stored on disk.
+	// Clears buffer before loading state.
+	void load_state( const blip_buffer_state_t& in );
+
+private:
+	// noncopyable
+	Blip_Buffer( const Blip_Buffer& );
+	Blip_Buffer& operator = ( const Blip_Buffer& );
+
+// Implementation
+public:
+	BLARGG_DISABLE_NOTHROW
+	Blip_Buffer();
+	~Blip_Buffer();
+	void remove_silence( int n );
+};
+
+
+//// Adds amplitude changes to Blip_Buffer
+
+template<int quality,int range> class Blip_Synth;
+
+typedef Blip_Synth<8, 1> Blip_Synth_Fast; // faster, but less equalizer control
+typedef Blip_Synth<12,1> Blip_Synth_Norm; // good for most things
+typedef Blip_Synth<16,1> Blip_Synth_Good; // sharper filter cutoff
+
+template<int quality,int range>
+class Blip_Synth {
+public:
+
+	// Sets volume of amplitude delta unit
+	void volume( double v )                     { impl.volume_unit( 1.0 / range * v ); }
+	
+	// Configures low-pass filter
+	void treble_eq( const blip_eq_t& eq )       { impl.treble_eq( eq ); }
+	
+	// Gets/sets default Blip_Buffer
+	Blip_Buffer* output() const                 { return impl.buf; }
+	void output( Blip_Buffer* b )               { impl.buf = b; impl.last_amp = 0; }
+	
+	// Extends waveform to time t at current amplitude, then changes its amplitude to a
+	// Using this requires a separate Blip_Synth for each waveform.
+	void update( blip_time_t t, int a );
+
+// Low-level interface
+	
+	// If no Blip_Buffer* is specified, uses one set by output() above
+	
+	// Adds amplitude transition at time t. Delta can be positive or negative.
+	// The actual change in amplitude is delta * volume.
+	void offset( blip_time_t t, int delta, Blip_Buffer* ) const;
+	void offset( blip_time_t t, int delta               ) const { offset( t, delta, impl.buf ); }
+	
+	// Same as offset(), except code is inlined for higher performance
+	void offset_inline( blip_time_t t, int delta, Blip_Buffer* buf ) const { offset_resampled( buf->to_fixed( t ), delta, buf ); }
+	void offset_inline( blip_time_t t, int delta                   ) const { offset_resampled( impl.buf->to_fixed( t ), delta, impl.buf ); }
+	
+	// Works directly in terms of fractional output samples. Use resampled time functions in Blip_Buffer
+	// to convert clock counts to resampled time.
+	void offset_resampled( blip_resampled_time_t, int delta, Blip_Buffer* ) const;
+	
+// Implementation
+public:
+	BLARGG_DISABLE_NOTHROW
+
+private:
+#if BLIP_BUFFER_FAST
+	Blip_Synth_Fast_ impl;
+	typedef char coeff_t;
+#else
+	Blip_Synth_ impl;
+	typedef short coeff_t;
+	// Left halves of first difference of step response for each possible phase
+	coeff_t phases [quality / 2 * blip_res];
+public:
+	Blip_Synth() : impl( phases, quality ) { }
+#endif
+};
+
+
+//// Low-pass equalization parameters
+
+class blip_eq_t {
+	double treble, kaiser;
+	int rolloff_freq, sample_rate, cutoff_freq;
+public:
+	// Logarithmic rolloff to treble dB at half sampling rate. Negative values reduce
+	// treble, small positive values (0 to 5.0) increase treble.
+	blip_eq_t( double treble_db = 0 );
+	
+	// See blip_buffer.txt
+	blip_eq_t( double treble, int rolloff_freq, int sample_rate, int cutoff_freq = 0,
+			double kaiser = 5.2 );
+	
+	// Generate center point and right half of impulse response
+	virtual void generate( float out [], int count ) const;
+	virtual ~blip_eq_t() { }
+	
+	enum { oversample = blip_res };
+	static int calc_count( int quality ) { return (quality - 1) * (oversample / 2) + 1; }
+};
+
+#include "Blip_Buffer_impl2.h"
+
+#endif
diff -Nur orig/source/gme/src/Blip_Buffer_impl2.h mod/source/gme/src/Blip_Buffer_impl2.h
--- orig/source/gme/src/Blip_Buffer_impl2.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Blip_Buffer_impl2.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,282 @@
+// Internal stuff here to keep public header uncluttered
+
+// Blip_Buffer 0.4.0
+#ifndef BLIP_BUFFER_IMPL2_H
+#define BLIP_BUFFER_IMPL2_H
+
+//// Compatibility
+
+BLARGG_DEPRECATED( int const blip_low_quality  =  8; )
+BLARGG_DEPRECATED( int const blip_med_quality  =  8; )
+BLARGG_DEPRECATED( int const blip_good_quality = 12; )
+BLARGG_DEPRECATED( int const blip_high_quality = 16; )
+
+BLARGG_DEPRECATED( int const blip_sample_max = 32767; )
+
+// Number of bits in raw sample that covers normal output range. Less than 32 bits to give
+// extra amplitude range. That is,
+// +1 << (blip_sample_bits-1) = +1.0
+// -1 << (blip_sample_bits-1) = -1.0
+int const blip_sample_bits = 30;
+
+//// BLIP_READER_
+
+//// Optimized reading from Blip_Buffer, for use in custom sample buffer or mixer
+
+// Begins reading from buffer. Name should be unique to the current {} block.
+#define BLIP_READER_BEGIN( name, blip_buffer ) \
+	const Blip_Buffer::delta_t* BLARGG_RESTRICT name##_reader_buf = (blip_buffer).read_pos();\
+	int name##_reader_accum = (blip_buffer).integrator()
+
+// Gets value to pass to BLIP_READER_NEXT()
+#define BLIP_READER_BASS( blip_buffer ) (blip_buffer).highpass_shift()
+
+// Constant value to use instead of BLIP_READER_BASS(), for slightly more optimal
+// code at the cost of having no bass_freq() functionality
+int const blip_reader_default_bass = 9;
+
+// Current sample as 16-bit signed value
+#define BLIP_READER_READ( name )        (name##_reader_accum >> (blip_sample_bits - 16))
+
+// Current raw sample in full internal resolution
+#define BLIP_READER_READ_RAW( name )    (name##_reader_accum)
+
+// Advances to next sample
+#define BLIP_READER_NEXT( name, bass ) \
+	(void) (name##_reader_accum += *name##_reader_buf++ - (name##_reader_accum >> (bass)))
+
+// Ends reading samples from buffer. The number of samples read must now be removed
+// using Blip_Buffer::remove_samples().
+#define BLIP_READER_END( name, blip_buffer ) \
+	(void) ((blip_buffer).set_integrator( name##_reader_accum ))
+
+#define BLIP_READER_ADJ_( name, offset ) (name##_reader_buf += offset)
+
+int const blip_reader_idx_factor = sizeof (Blip_Buffer::delta_t);
+
+#define BLIP_READER_NEXT_IDX_( name, bass, idx ) {\
+	name##_reader_accum -= name##_reader_accum >> (bass);\
+	name##_reader_accum += name##_reader_buf [(idx)];\
+}
+
+#define BLIP_READER_NEXT_RAW_IDX_( name, bass, idx ) {\
+	name##_reader_accum -= name##_reader_accum >> (bass);\
+	name##_reader_accum +=\
+			*(Blip_Buffer::delta_t const*) ((char const*) name##_reader_buf + (idx));\
+}
+
+//// BLIP_CLAMP
+
+#if defined (_M_IX86) || defined (_M_IA64) || defined (__i486__) || \
+		defined (__x86_64__) || defined (__ia64__) || defined (__i386__)
+	#define BLIP_X86 1
+	#define BLIP_CLAMP_( in ) in < -0x8000 || 0x7FFF < in
+#else
+	#define BLIP_CLAMP_( in ) (blip_sample_t) in != in
+#endif
+
+// Clamp sample to blip_sample_t range
+#define BLIP_CLAMP( sample, out )\
+	{ if ( BLIP_CLAMP_( (sample) ) ) (out) = ((sample) >> 31) ^ 0x7FFF; }
+
+
+//// Blip_Synth
+
+// (in >> sh & mask) * mul
+#define BLIP_SH_AND_MUL( in, sh, mask, mul ) \
+((int) (in) / ((1U << (sh)) / (mul)) & (unsigned) ((mask) * (mul)))
+
+// (T*) ptr + (off >> sh)
+#define BLIP_PTR_OFF_SH( T, ptr, off, sh ) \
+	((T*) (BLIP_SH_AND_MUL( off, sh, -1, sizeof (T) ) + (char*) (ptr)))
+
+template<int quality,int range>
+inline void Blip_Synth<quality,range>::offset_resampled( blip_resampled_time_t time,
+		int delta, Blip_Buffer* blip_buf ) const
+{
+#if BLIP_BUFFER_FAST
+	int const half_width = 1;
+#else
+	int const half_width = quality / 2;
+#endif
+	
+	Blip_Buffer::delta_t* BLARGG_RESTRICT buf = blip_buf->delta_at( time );
+	
+	delta *= impl.delta_factor;
+
+	int const phase_shift = BLIP_BUFFER_ACCURACY - BLIP_PHASE_BITS;
+	int const phase = (half_width & (half_width - 1)) ?
+		(int) BLIP_SH_AND_MUL( time, phase_shift, blip_res - 1, sizeof (coeff_t) ) * half_width :
+		(int) BLIP_SH_AND_MUL( time, phase_shift, blip_res - 1, sizeof (coeff_t) * half_width );
+	
+#if BLIP_BUFFER_FAST
+	int left = buf [0] + delta;
+	
+	// Kind of crappy, but doing shift after multiply results in overflow.
+	// Alternate way of delaying multiply by delta_factor results in worse
+	// sub-sample resolution.
+	int right = (delta >> BLIP_PHASE_BITS) * phase;
+	#if BLIP_BUFFER_NOINTERP
+		// TODO: remove? (just a hack to see how it sounds)
+		right = 0;
+	#endif
+	left  -= right;
+	right += buf [1];
+	
+	buf [0] = left;
+	buf [1] = right;
+#else
+	
+	int const fwd = -quality / 2;
+	int const rev = fwd + quality - 2;
+	
+	coeff_t const* BLARGG_RESTRICT imp = (coeff_t const*) ((char const*) phases + phase);
+	int const phase2 = phase + phase - (blip_res - 1) * half_width * sizeof (coeff_t);
+	
+	#define BLIP_MID_IMP imp = (coeff_t const*) ((char const*) imp - phase2);
+	
+	#if BLIP_MAX_QUALITY > 16
+		// General version for any quality
+		if ( quality != 8 && quality != 12 && quality != 16 )
+		{
+			buf += fwd;
+			
+			// left half
+			for ( int n = half_width / 2; --n >= 0; )
+			{
+				buf [0] += imp [0] * delta;
+				buf [1] += imp [1] * delta;
+				imp += 2;
+				buf += 2;
+			}
+			
+			// mirrored right half
+			BLIP_MID_IMP
+			for ( int n = half_width / 2; --n >= 0; )
+			{
+				buf [0] +=   imp  [-1] * delta;
+				buf [1] += *(imp -= 2) * delta;
+				buf += 2;
+			}
+			
+			return;
+		}
+	#endif
+	
+	// Unrolled versions for qualities 8, 12, and 16
+	
+	#if BLIP_X86
+		// This gives better code for x86
+		#define BLIP_ADD( out, in ) \
+			buf [out] += imp [in] * delta
+		
+		#define BLIP_FWD( i ) {\
+			BLIP_ADD( fwd     + i, i     );\
+			BLIP_ADD( fwd + 1 + i, i + 1 );\
+		}
+		
+		#define BLIP_REV( r ) {\
+			BLIP_ADD( rev     - r, r + 1 );\
+			BLIP_ADD( rev + 1 - r, r     );\
+		}
+		
+		BLIP_FWD( 0 )
+		BLIP_FWD( 2 )
+		if ( quality > 8  ) BLIP_FWD( 4 )
+		if ( quality > 12 ) BLIP_FWD( 6 )
+			BLIP_MID_IMP
+		if ( quality > 12 ) BLIP_REV( 6 )
+		if ( quality > 8  ) BLIP_REV( 4 )
+		BLIP_REV( 2 )
+		BLIP_REV( 0 )
+	
+	#else
+		// Help RISC processors and simplistic compilers by reading ahead of writes
+		#define BLIP_FWD( i ) {\
+			int t0 =          i0 * delta + buf [fwd     + i];\
+			int t1 = imp [i + 1] * delta + buf [fwd + 1 + i];\
+			i0 =           imp [i + 2];\
+			buf [fwd     + i] = t0;\
+			buf [fwd + 1 + i] = t1;\
+		}
+		
+		#define BLIP_REV( r ) {\
+			int t0 =      i0 * delta + buf [rev     - r];\
+			int t1 = imp [r] * delta + buf [rev + 1 - r];\
+			i0 =           imp [r - 1];\
+			buf [rev     - r] = t0;\
+			buf [rev + 1 - r] = t1;\
+		}
+		
+		int i0 = *imp;
+		BLIP_FWD( 0 )
+		if ( quality > 8  ) BLIP_FWD( 2 )
+		if ( quality > 12 ) BLIP_FWD( 4 )
+		{
+			int const mid = half_width - 1;
+			int t0 =        i0 * delta + buf [fwd + mid - 1];
+			int t1 = imp [mid] * delta + buf [fwd + mid    ];
+			BLIP_MID_IMP
+			i0           = imp [mid];
+			buf [fwd + mid - 1] = t0;
+			buf [fwd + mid    ] = t1;
+		}
+		if ( quality > 12 ) BLIP_REV( 6 )
+		if ( quality > 8  ) BLIP_REV( 4 )
+		BLIP_REV( 2 )
+		
+		int t0 =   i0 * delta + buf [rev    ];
+		int t1 = *imp * delta + buf [rev + 1];
+		buf [rev    ] = t0;
+		buf [rev + 1] = t1;
+	#endif
+	
+#endif
+}
+
+template<int quality,int range>
+#if BLIP_BUFFER_FAST
+	inline
+#endif
+void Blip_Synth<quality,range>::offset( blip_time_t t, int delta, Blip_Buffer* buf ) const
+{
+	offset_resampled( buf->to_fixed( t ), delta, buf );
+}
+
+template<int quality,int range>
+#if BLIP_BUFFER_FAST
+	inline
+#endif
+void Blip_Synth<quality,range>::update( blip_time_t t, int amp )
+{
+	int delta = amp - impl.last_amp;
+	impl.last_amp = amp;
+	offset_resampled( impl.buf->to_fixed( t ), delta, impl.buf );
+}
+
+
+//// blip_eq_t
+
+inline blip_eq_t::blip_eq_t( double t ) :
+		treble( t ), kaiser( 5.2 ), rolloff_freq( 0 ), sample_rate( 44100 ), cutoff_freq( 0 ) { }
+inline blip_eq_t::blip_eq_t( double t, int rf, int sr, int cf, double k ) :
+		treble( t ), kaiser( k ), rolloff_freq( rf ), sample_rate( sr ), cutoff_freq( cf ) { }
+
+
+//// Blip_Buffer
+
+inline int  Blip_Buffer::length() const         { return length_; }
+inline int  Blip_Buffer::samples_avail() const  { return (int) (offset_ >> BLIP_BUFFER_ACCURACY); }
+inline int  Blip_Buffer::sample_rate() const    { return sample_rate_; }
+inline int  Blip_Buffer::output_latency() const { return BLIP_MAX_QUALITY / 2; }
+inline int  Blip_Buffer::clock_rate() const     { return clock_rate_; }
+inline void Blip_Buffer::clock_rate( int cps )  { factor_ = clock_rate_factor( clock_rate_ = cps ); }
+
+inline void Blip_Buffer::remove_silence( int count )
+{
+	// fails if you try to remove more samples than available
+	assert( count <= samples_avail() );
+	offset_ -= (blip_resampled_time_t) count << BLIP_BUFFER_ACCURACY;
+}
+
+#endif
diff -Nur orig/source/gme/src/Blip_Buffer_impl.h mod/source/gme/src/Blip_Buffer_impl.h
--- orig/source/gme/src/Blip_Buffer_impl.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Blip_Buffer_impl.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,135 @@
+// Internal stuff here to keep public header uncluttered
+
+// Blip_Buffer 0.4.0
+#ifndef BLIP_BUFFER_IMPL_H
+#define BLIP_BUFFER_IMPL_H
+
+typedef unsigned blip_resampled_time_t;
+
+#ifndef BLIP_MAX_QUALITY
+	#define BLIP_MAX_QUALITY 32
+#endif
+
+#ifndef BLIP_BUFFER_ACCURACY
+	#define BLIP_BUFFER_ACCURACY 16
+#endif
+
+#ifndef BLIP_PHASE_BITS
+	#define BLIP_PHASE_BITS 6
+#endif
+
+class blip_eq_t;
+class Blip_Buffer;
+
+#if BLIP_BUFFER_FAST
+	// linear interpolation needs 8 bits
+	#undef BLIP_PHASE_BITS
+	#define BLIP_PHASE_BITS 8
+	
+	#undef BLIP_MAX_QUALITY
+	#define BLIP_MAX_QUALITY 2
+#endif
+
+int const blip_res           = 1 << BLIP_PHASE_BITS;
+int const blip_buffer_extra_ = BLIP_MAX_QUALITY + 2;
+
+class Blip_Buffer_ {
+public:
+// Writer
+	
+	typedef int clocks_t;
+	
+	// Properties of fixed-point sample position
+	typedef unsigned fixed_t; // unsigned for more range, optimized shifts
+	enum { fixed_bits = BLIP_BUFFER_ACCURACY };             // bits in fraction
+	enum { fixed_unit = 1 << fixed_bits };  // 1.0 samples
+
+	// Converts clock count to fixed-point sample position
+	fixed_t to_fixed( clocks_t t ) const    { return t * factor_ + offset_; }
+	
+	// Deltas in buffer are fixed-point with this many fraction bits.
+	// Less than 16 for extra range.
+	enum { delta_bits = 14 };
+	
+	// Pointer to first committed delta sample
+	typedef int delta_t;
+	
+	// Pointer to delta corresponding to fixed-point sample position
+	delta_t* delta_at( fixed_t );
+	
+// Reader
+	
+	delta_t* read_pos()                         { return buffer_; }
+	
+	void clear_modified()                   { modified_ = false; }
+	int highpass_shift() const              { return bass_shift_; }
+	int integrator() const                  { return reader_accum_; }
+	void set_integrator( int n )            { reader_accum_ = n; }
+	
+public: //friend class Tracked_Blip_Buffer; private:
+	bool modified() const                   { return modified_; }
+	void remove_silence( int count );
+	
+private:
+	unsigned factor_;
+	fixed_t  offset_;
+	delta_t* buffer_center_;
+	int      buffer_size_;
+	int      reader_accum_;
+	int      bass_shift_;
+	delta_t* buffer_;
+	int      sample_rate_;
+	int      clock_rate_;
+	int      bass_freq_;
+	int      length_;
+	bool     modified_;
+	
+	friend class Blip_Buffer;
+};
+
+class Blip_Synth_Fast_ {
+public:
+	int delta_factor;
+	int last_amp;
+	Blip_Buffer* buf;
+	
+	void volume_unit( double );
+	void treble_eq( blip_eq_t const& ) { }
+	Blip_Synth_Fast_();
+};
+
+class Blip_Synth_ {
+public:
+	int delta_factor;
+	int last_amp;
+	Blip_Buffer* buf;
+	
+	void volume_unit( double );
+	void treble_eq( blip_eq_t const& );
+	Blip_Synth_( short phases [], int width );
+private:
+	double volume_unit_;
+	short* const phases;
+	int const width;
+	int kernel_unit;
+	
+	void adjust_impulse();
+	void rescale_kernel( int shift );
+	int impulses_size() const { return blip_res / 2 * width; }
+};
+
+class blip_buffer_state_t
+{
+	blip_resampled_time_t offset_;
+	int reader_accum_;
+	int buf [blip_buffer_extra_];
+	friend class Blip_Buffer;
+};
+
+inline Blip_Buffer_::delta_t* Blip_Buffer_::delta_at( fixed_t f )
+{
+	assert( (f >> fixed_bits) < (unsigned) buffer_size_ );
+	return buffer_center_ + (f >> fixed_bits);
+}
+
+#endif
diff -Nur orig/source/gme/src/Classic_Emu.cpp mod/source/gme/src/Classic_Emu.cpp
--- orig/source/gme/src/Classic_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Classic_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,124 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Classic_Emu.h"
+
+#include "Multi_Buffer.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Classic_Emu::Classic_Emu()
+{
+	buf           = NULL;
+	stereo_buffer = NULL;
+	voice_types   = NULL;
+	
+	// avoid inconsistency in our duplicated constants
+	assert( (int) wave_type  == (int) Multi_Buffer::wave_type );
+	assert( (int) noise_type == (int) Multi_Buffer::noise_type );
+	assert( (int) mixed_type == (int) Multi_Buffer::mixed_type );
+}
+
+Classic_Emu::~Classic_Emu()
+{
+	delete stereo_buffer;
+	delete effects_buffer_;
+	effects_buffer_ = NULL;
+}
+
+void Classic_Emu::set_equalizer_( equalizer_t const& eq )
+{
+	Music_Emu::set_equalizer_( eq );
+	update_eq( eq.treble );
+	if ( buf )
+		buf->bass_freq( (int) equalizer().bass );
+}
+	
+blargg_err_t Classic_Emu::set_sample_rate_( int rate )
+{
+	if ( !buf )
+	{
+		if ( !stereo_buffer )
+			CHECK_ALLOC( stereo_buffer = BLARGG_NEW Stereo_Buffer );
+		buf = stereo_buffer;
+	}
+	return buf->set_sample_rate( rate, 1000 / 20 );
+}
+
+void Classic_Emu::mute_voices_( int mask )
+{
+	Music_Emu::mute_voices_( mask );
+	for ( int i = voice_count(); i--; )
+	{
+		if ( mask & (1 << i) )
+		{
+			set_voice( i, NULL, NULL, NULL );
+		}
+		else
+		{
+			Multi_Buffer::channel_t ch = buf->channel( i );
+			assert( (ch.center && ch.left && ch.right) ||
+					(!ch.center && !ch.left && !ch.right) ); // all or nothing
+			set_voice( i, ch.center, ch.left, ch.right );
+		}
+	}
+}
+
+void Classic_Emu::change_clock_rate( int rate )
+{
+	clock_rate_ = rate;
+	buf->clock_rate( rate );
+}
+
+blargg_err_t Classic_Emu::setup_buffer( int rate )
+{
+	change_clock_rate( rate );
+	RETURN_ERR( buf->set_channel_count( voice_count(), voice_types ) );
+	set_equalizer( equalizer() );
+	buf_changed_count = buf->channels_changed_count();
+	return blargg_ok;
+}
+
+blargg_err_t Classic_Emu::start_track_( int track )
+{
+	RETURN_ERR( Music_Emu::start_track_( track ) );
+	buf->clear();
+	return blargg_ok;
+}
+
+blargg_err_t Classic_Emu::play_( int count, sample_t out [] )
+{
+	// read from buffer, then refill buffer and repeat if necessary
+	int remain = count;
+	while ( remain )
+	{
+		buf->disable_immediate_removal();
+		remain -= buf->read_samples( &out [count - remain], remain );
+		if ( remain )
+		{
+			if ( buf_changed_count != buf->channels_changed_count() )
+			{
+				buf_changed_count = buf->channels_changed_count();
+				remute_voices();
+			}
+			
+			// TODO: use more accurate length calculation
+			int msec = buf->length();
+			blip_time_t clocks_emulated = msec * clock_rate_ / 1000 - 100;
+			RETURN_ERR( run_clocks( clocks_emulated, msec ) );
+			assert( clocks_emulated );
+			buf->end_frame( clocks_emulated );
+		}
+	}
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Classic_Emu.h mod/source/gme/src/Classic_Emu.h
--- orig/source/gme/src/Classic_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Classic_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,79 @@
+// Common aspects of emulators which use Blip_Buffer for sound output
+
+// Game_Music_Emu 0.6-pre
+#ifndef CLASSIC_EMU_H
+#define CLASSIC_EMU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+#include "Music_Emu.h"
+
+class Classic_Emu : public Music_Emu {
+protected:
+// Derived interface
+
+	// Advertises type of sound on each voice, so Effects_Buffer can better choose
+	// what effect to apply (pan, echo, surround). Constant can have value added so
+	// that voices of the same type can be spread around the stereo sound space.
+	enum { wave_type = 0x100, noise_type = 0x200, mixed_type = wave_type | noise_type };
+	void set_voice_types( int const types [] )          { voice_types = types; }
+	
+	// Sets up Blip_Buffers after loading file
+	blargg_err_t setup_buffer( int clock_rate );
+	
+	// Clock rate of Blip_buffers
+	int  clock_rate() const                             { return clock_rate_; }
+	
+	// Changes clock rate of Blip_Buffers (experimental)
+	void change_clock_rate( int );
+	
+// Overrides should do the indicated task
+	
+	// Set Blip_Buffer(s) voice outputs to, or mute voice if pointer is NULL
+	virtual void set_voice( int index, Blip_Buffer* center,
+			Blip_Buffer* left, Blip_Buffer* right )                     BLARGG_PURE( ; )
+	
+	// Update equalization
+	virtual void update_eq( blip_eq_t const& )                          BLARGG_PURE( ; )
+	
+	// Start track
+	virtual blargg_err_t start_track_( int track )                      BLARGG_PURE( ; )
+	
+	// Run for at most msec or time_io clocks, then set time_io to number of clocks
+	// actually run for. After returning, Blip_Buffers have time frame of time_io clocks
+	// ended.
+	virtual blargg_err_t run_clocks( blip_time_t& time_io, int msec )   BLARGG_PURE( ; )
+
+// Internal
+public:
+	Classic_Emu();
+	~Classic_Emu();
+	virtual void set_buffer( Multi_Buffer* );
+
+protected:
+	virtual blargg_err_t set_sample_rate_( int sample_rate );
+	virtual void mute_voices_( int );
+	virtual void set_equalizer_( equalizer_t const& );
+	virtual blargg_err_t play_( int, sample_t [] );
+
+private:
+	Multi_Buffer* buf;
+	Multi_Buffer* stereo_buffer; // NULL if using custom buffer
+	int clock_rate_;
+	unsigned buf_changed_count;
+	int const* voice_types;
+};
+
+inline void Classic_Emu::set_buffer( Multi_Buffer* new_buf )
+{
+	assert( !buf && new_buf );
+	buf = new_buf;
+}
+
+inline void Classic_Emu::set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* ) { }
+
+inline void Classic_Emu::update_eq( blip_eq_t const& )                              { }
+
+inline blargg_err_t Classic_Emu::run_clocks( blip_time_t&, int )                    { return blargg_ok; }
+
+#endif
diff -Nur orig/source/gme/src/CMakeLists.txt mod/source/gme/src/CMakeLists.txt
--- orig/source/gme/src/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/CMakeLists.txt	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,125 @@
+add_library( gme STATIC
+
+    s_deltat.c
+    s_logtbl.c
+    s_opl.c
+    s_opltbl.c
+    blargg_common.cpp
+    blargg_errors.cpp
+    Resampler.cpp
+    Rom_Data.cpp
+    Downsampler.cpp
+    Blip_Buffer.cpp
+
+    Classic_Emu.cpp
+
+    Data_Reader.cpp
+
+    Dual_Resampler.cpp
+
+    Effects_Buffer.cpp
+
+    Fir_Resampler.cpp
+
+    gme.cpp
+    Gme_Loader.cpp
+
+    Gme_File.cpp
+
+    M3u_Playlist.cpp
+
+    Multi_Buffer.cpp
+
+    Music_Emu.cpp
+
+    fmopl.cpp
+    emu2413.cpp
+    Ay_Apu.cpp
+
+    Ay_Cpu.cpp
+
+    Ay_Emu.cpp
+    Ay_Core.cpp
+
+    Gb_Apu.cpp
+
+    Gb_Cpu.cpp
+
+    Gb_Oscs.cpp
+
+    Gbs_Emu.cpp
+
+    Gbs_Core.cpp
+    Gbs_Cpu.cpp
+    Gym_Emu.cpp
+
+    Hes_Apu.cpp
+
+    Hes_Cpu.cpp
+    Hes_Core.cpp
+    Hes_Emu.cpp
+
+    Hes_Apu_Adpcm.cpp
+    Kss_Cpu.cpp
+
+    Kss_Core.cpp
+    Kss_Emu.cpp
+
+    Kss_Scc_Apu.cpp
+
+    Nes_Apu.cpp
+
+    Nes_Cpu.cpp
+
+    Nes_Fds_Apu.cpp
+    Nes_Vrc7_Apu.cpp
+    Nes_Fme7_Apu.cpp
+
+    Nes_Namco_Apu.cpp
+
+    Nes_Oscs.cpp
+
+    Nes_Vrc6_Apu.cpp
+
+    Nsf_Impl.cpp
+    Nsf_Core.cpp
+    Nsf_Cpu.cpp
+    Nsf_Emu.cpp
+
+    Nsfe_Emu.cpp
+
+    Sap_Apu.cpp
+    Sap_Core.cpp
+
+    Sap_Cpu.cpp
+
+    Sap_Emu.cpp
+
+    Sms_Apu.cpp
+
+    Snes_Spc.cpp
+
+    Sgc_Core.cpp
+    Sgc_Cpu.cpp
+    Sgc_Emu.cpp
+    Sgc_Impl.cpp
+    Sms_Fm_Apu.cpp
+    SPC_Filter.cpp
+    Track_Filter.cpp
+    Upsampler.cpp
+    Vgm_Core.cpp
+    ym2413.c
+    ymdeltat.cpp
+    Z80_Cpu.cpp
+    Spc_Cpu.cpp
+
+    Spc_Dsp.cpp
+
+    Spc_Emu.cpp
+
+    Vgm_Emu.cpp
+
+    Ym2413_Emu.cpp
+
+    Ym2612_Emu.cpp
+    Opl_Apu.cpp )
diff -Nur orig/source/gme/src/Data_Reader.cpp mod/source/gme/src/Data_Reader.cpp
--- orig/source/gme/src/Data_Reader.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Data_Reader.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,315 @@
+// File_Extractor 0.4.0. http://www.slack.net/~ant/
+
+#include "Data_Reader.h"
+
+#include "blargg_endian.h"
+#include <assert.h>
+#include <string.h>
+#include <stdio.h>
+
+/* Copyright (C) 2005-2006 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+const char Data_Reader::eof_error [] = "Unexpected end of file";
+
+blargg_err_t Data_Reader::read( void* p, long s )
+{
+	long result = read_avail( p, s );
+	if ( result != s )
+	{
+		if ( result >= 0 && result < s )
+			return eof_error;
+		
+		return "Read error";
+	}
+	
+	return 0;
+}
+
+blargg_err_t Data_Reader::skip( long count )
+{
+	char buf [512];
+	while ( count )
+	{
+		long n = sizeof buf;
+		if ( n > count )
+			n = count;
+		count -= n;
+		RETURN_ERR( read( buf, n ) );
+	}
+	return 0;
+}
+
+long File_Reader::remain() const { return size() - tell(); }
+
+blargg_err_t File_Reader::skip( long n )
+{
+	assert( n >= 0 );
+	if ( !n )
+		return 0;
+	return seek( tell() + n );
+}
+
+// Subset_Reader
+
+Subset_Reader::Subset_Reader( Data_Reader* dr, long size )
+{
+	in = dr;
+	remain_ = dr->remain();
+	if ( remain_ > size )
+		remain_ = size;
+}
+
+long Subset_Reader::remain() const { return remain_; }
+
+long Subset_Reader::read_avail( void* p, long s )
+{
+	if ( s > remain_ )
+		s = remain_;
+	remain_ -= s;
+	return in->read_avail( p, s );
+}
+
+// Remaining_Reader
+
+Remaining_Reader::Remaining_Reader( void const* h, long size, Data_Reader* r )
+{
+	header = (char const*) h;
+	header_end = header + size;
+	in = r;
+}
+
+long Remaining_Reader::remain() const { return header_end - header + in->remain(); }
+
+long Remaining_Reader::read_first( void* out, long count )
+{
+	long first = header_end - header;
+	if ( first )
+	{
+		if ( first > count )
+			first = count;
+		void const* old = header;
+		header += first;
+		memcpy( out, old, first );
+	}
+	return first;
+}
+
+long Remaining_Reader::read_avail( void* out, long count )
+{
+	long first = read_first( out, count );
+	long second = count - first;
+	if ( second )
+	{
+		second = in->read_avail( (char*) out + first, second );
+		if ( second <= 0 )
+			return second;
+	}
+	return first + second;
+}
+
+blargg_err_t Remaining_Reader::read( void* out, long count )
+{
+	long first = read_first( out, count );
+	long second = count - first;
+	if ( !second )
+		return 0;
+	return in->read( (char*) out + first, second );
+}
+
+// Mem_File_Reader
+
+Mem_File_Reader::Mem_File_Reader( const void* p, long s ) :
+	begin( (const char*) p ),
+	size_( s )
+{
+	pos = 0;
+}
+	
+long Mem_File_Reader::size() const { return size_; }
+
+long Mem_File_Reader::read_avail( void* p, long s )
+{
+	long r = remain();
+	if ( s > r )
+		s = r;
+	memcpy( p, begin + pos, s );
+	pos += s;
+	return s;
+}
+
+long Mem_File_Reader::tell() const { return pos; }
+
+blargg_err_t Mem_File_Reader::seek( long n )
+{
+	if ( n > size_ )
+		return eof_error;
+	pos = n;
+	return 0;
+}
+
+// Callback_Reader
+
+Callback_Reader::Callback_Reader( callback_t c, long size, void* d ) :
+	callback( c ),
+	data( d )
+{
+	remain_ = size;
+}
+
+long Callback_Reader::remain() const { return remain_; }
+
+long Callback_Reader::read_avail( void* out, long count )
+{
+	if ( count > remain_ )
+		count = remain_;
+	if ( Callback_Reader::read( out, count ) )
+		count = -1;
+	return count;
+}
+
+blargg_err_t Callback_Reader::read( void* out, long count )
+{
+	if ( count > remain_ )
+		return eof_error;
+	return callback( data, out, count );
+}
+
+// Std_File_Reader
+
+Std_File_Reader::Std_File_Reader() : file_( 0 ) { }
+
+Std_File_Reader::~Std_File_Reader() { close(); }
+
+blargg_err_t Std_File_Reader::open( const char* path )
+{
+	file_ = fopen( path, "rb" );
+	if ( !file_ )
+		return "Couldn't open file";
+	return 0;
+}
+
+long Std_File_Reader::size() const
+{
+	long pos = tell();
+	fseek( (FILE*) file_, 0, SEEK_END );
+	long result = tell();
+	fseek( (FILE*) file_, pos, SEEK_SET );
+	return result;
+}
+
+long Std_File_Reader::read_avail( void* p, long s )
+{
+	return fread( p, 1, s, (FILE*) file_ );
+}
+
+blargg_err_t Std_File_Reader::read( void* p, long s )
+{
+	if ( s == (long) fread( p, 1, s, (FILE*) file_ ) )
+		return 0;
+	if ( feof( (FILE*) file_ ) )
+		return eof_error;
+	return "Couldn't read from file";
+}
+
+long Std_File_Reader::tell() const { return ftell( (FILE*) file_ ); }
+
+blargg_err_t Std_File_Reader::seek( long n )
+{
+	if ( !fseek( (FILE*) file_, n, SEEK_SET ) )
+		return 0;
+	if ( n > size() )
+		return eof_error;
+	return "Error seeking in file";
+}
+
+void Std_File_Reader::close()
+{
+	if ( file_ )
+	{
+		fclose( (FILE*) file_ );
+		file_ = 0;
+	}
+}
+
+// Gzip_File_Reader
+
+#ifdef HAVE_ZLIB_H
+
+#include "zlib.h"
+
+static const char* get_gzip_eof( const char* path, long* eof )
+{
+	FILE* file = fopen( path, "rb" );
+	if ( !file )
+		return "Couldn't open file";
+	
+	unsigned char buf [4];
+	if ( fread( buf, 2, 1, file ) > 0 && buf [0] == 0x1F && buf [1] == 0x8B )
+	{
+		fseek( file, -4, SEEK_END );
+		fread( buf, 4, 1, file );
+		*eof = get_le32( buf );
+	}
+	else
+	{
+		fseek( file, 0, SEEK_END );
+		*eof = ftell( file );
+	}
+	const char* err = (ferror( file ) || feof( file )) ? "Couldn't get file size" : 0;
+	fclose( file );
+	return err;
+}
+
+Gzip_File_Reader::Gzip_File_Reader() : file_( 0 ) { }
+
+Gzip_File_Reader::~Gzip_File_Reader() { close(); }
+
+blargg_err_t Gzip_File_Reader::open( const char* path )
+{
+	close();
+	
+	RETURN_ERR( get_gzip_eof( path, &size_ ) );
+	
+	file_ = gzopen( path, "rb" );
+	if ( !file_ )
+		return "Couldn't open file";
+	
+	return 0;
+}
+
+long Gzip_File_Reader::size() const { return size_; }
+
+long Gzip_File_Reader::read_avail( void* p, long s ) { return gzread( file_, p, s ); }
+
+long Gzip_File_Reader::tell() const { return gztell( file_ ); }
+
+blargg_err_t Gzip_File_Reader::seek( long n )
+{
+	if ( gzseek( file_, n, SEEK_SET ) >= 0 )
+		return 0;
+	if ( n > size_ )
+		return eof_error;
+	return "Error seeking in file";
+}
+
+void Gzip_File_Reader::close()
+{
+	if ( file_ )
+	{
+		gzclose( file_ );
+		file_ = 0;
+	}
+}
+
+#endif
diff -Nur orig/source/gme/src/Data_Reader.h mod/source/gme/src/Data_Reader.h
--- orig/source/gme/src/Data_Reader.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Data_Reader.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,151 @@
+// Data reader interface for uniform access
+
+// File_Extractor 0.4.0
+#ifndef DATA_READER_H
+#define DATA_READER_H
+
+#include "blargg_common.h"
+
+// Supports reading and finding out how many bytes are remaining
+class Data_Reader {
+public:
+	virtual ~Data_Reader() { }
+	
+	static const char eof_error []; // returned by read() when request goes beyond end
+	
+	// Read at most count bytes and return number actually read, or <= 0 if error
+	virtual long read_avail( void*, long n ) = 0;
+	
+	// Read exactly count bytes and return error if they couldn't be read
+	virtual blargg_err_t read( void*, long count );
+	
+	// Number of bytes remaining until end of file
+	virtual long remain() const = 0;
+	
+	// Read and discard count bytes
+	virtual blargg_err_t skip( long count );
+	
+public:
+	Data_Reader() { }
+	typedef blargg_err_t error_t; // deprecated
+private:
+	// noncopyable
+	Data_Reader( const Data_Reader& );
+	Data_Reader& operator = ( const Data_Reader& );
+};
+
+// Supports seeking in addition to Data_Reader operations
+class File_Reader : public Data_Reader {
+public:
+	// Size of file
+	virtual long size() const = 0;
+	
+	// Current position in file
+	virtual long tell() const = 0;
+	
+	// Go to new position
+	virtual blargg_err_t seek( long ) = 0;
+	
+	long remain() const;
+	blargg_err_t skip( long n );
+};
+
+// Disk file reader
+class Std_File_Reader : public File_Reader {
+public:
+	blargg_err_t open( const char* path );
+	void close();
+	
+public:
+	Std_File_Reader();
+	~Std_File_Reader();
+	long size() const;
+	blargg_err_t read( void*, long );
+	long read_avail( void*, long );
+	long tell() const;
+	blargg_err_t seek( long );
+private:
+	void* file_;
+};
+
+// Treats range of memory as a file
+class Mem_File_Reader : public File_Reader {
+public:
+	Mem_File_Reader( const void*, long size );
+	
+public:
+	long size() const;
+	long read_avail( void*, long );
+	long tell() const;
+	blargg_err_t seek( long );
+private:
+	const char* const begin;
+	const long size_;
+	long pos;
+};
+
+// Makes it look like there are only count bytes remaining
+class Subset_Reader : public Data_Reader {
+public:
+	Subset_Reader( Data_Reader*, long count );
+
+public:
+	long remain() const;
+	long read_avail( void*, long );
+private:
+	Data_Reader* in;
+	long remain_;
+};
+
+// Joins already-read header and remaining data into original file (to avoid seeking)
+class Remaining_Reader : public Data_Reader {
+public:
+	Remaining_Reader( void const* header, long size, Data_Reader* );
+
+public:
+	long remain() const;
+	long read_avail( void*, long );
+	blargg_err_t read( void*, long );
+private:
+	char const* header;
+	char const* header_end;
+	Data_Reader* in;
+	long read_first( void* out, long count );
+};
+
+// Invokes callback function to read data. Size of data must be specified in advance.
+class Callback_Reader : public Data_Reader {
+public:
+	typedef const char* (*callback_t)( void* data, void* out, int count );
+	Callback_Reader( callback_t, long size, void* data = 0 );
+public:
+	long read_avail( void*, long );
+	blargg_err_t read( void*, long );
+	long remain() const;
+private:
+	callback_t const callback;
+	void* const data;
+	long remain_;
+};
+
+#ifdef HAVE_ZLIB_H
+// Gzip compressed file reader
+class Gzip_File_Reader : public File_Reader {
+public:
+	blargg_err_t open( const char* path );
+	void close();
+	
+public:
+	Gzip_File_Reader();
+	~Gzip_File_Reader();
+	long size() const;
+	long read_avail( void*, long );
+	long tell() const;
+	blargg_err_t seek( long );
+private:
+	void* file_;
+	long size_;
+};
+#endif
+
+#endif
diff -Nur orig/source/gme/src/divfix.h mod/source/gme/src/divfix.h
--- orig/source/gme/src/divfix.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/divfix.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,18 @@
+
+static Uint32 DivFix(Uint32 p1, Uint32 p2, Uint32 fix)
+{
+	Uint32 ret;
+	ret = p1 / p2;
+	p1  = p1 % p2;/* p1 = p1 - p2 * ret; */
+	while (fix--)
+	{
+		p1 += p1;
+		ret += ret;
+		if (p1 >= p2)
+		{
+			p1 -= p2;
+			ret++;
+		}
+	}
+	return ret;
+}
diff -Nur orig/source/gme/src/Downsampler.cpp mod/source/gme/src/Downsampler.cpp
--- orig/source/gme/src/Downsampler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Downsampler.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,74 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Downsampler.h"
+
+/* Copyright (C) 2004-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const shift = 14;
+int const unit = 1 << shift;
+
+void Downsampler::clear_()
+{
+	pos = 0;
+	Resampler::clear_();
+}
+
+Downsampler::Downsampler()
+{
+	clear();
+}
+
+blargg_err_t Downsampler::set_rate_( double new_factor )
+{
+	step = (int) (new_factor * unit + 0.5);
+	return Resampler::set_rate_( 1.0 / unit * step );
+}
+
+Resampler::sample_t const* Downsampler::resample_( sample_t** out_,
+		sample_t const* out_end, sample_t const in [], int in_size )
+{
+	in_size -= write_offset;
+	if ( in_size > 0 )
+	{
+		sample_t* BLARGG_RESTRICT out = *out_;
+		sample_t const* const in_end = in + in_size;
+		
+		int const step = this->step;
+		int       pos  = this->pos;
+		
+		// TODO: IIR filter, then linear resample
+		// TODO: detect skipped sample, allowing merging of IIR and resample?
+		
+		do
+		{
+			#define INTERP( i, out )\
+				out = (in [0 + i] * (unit - pos) + ((in [2 + i] + in [4 + i] + in [6 + i]) << shift) +\
+				in [8 + i] * pos) >> (shift + 2);
+			
+			int out_0;
+			INTERP( 0,                  out_0 )
+			INTERP( 1, out [0] = out_0; out [1] )
+			out += stereo;
+			
+			pos += step;
+			in += ((unsigned) pos >> shift) * stereo;
+			pos &= unit - 1;
+		}
+		while ( in < in_end && out < out_end );
+		
+		this->pos = pos;
+		*out_ = out;
+	}
+	return in;
+}
diff -Nur orig/source/gme/src/Downsampler.h mod/source/gme/src/Downsampler.h
--- orig/source/gme/src/Downsampler.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Downsampler.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,25 @@
+// Linear downsampler with pre-low-pass
+
+// Game_Music_Emu 0.6-pre
+#ifndef DOWNSAMPLER_H
+#define DOWNSAMPLER_H
+
+#include "Resampler.h"
+
+class Downsampler : public Resampler {
+public:
+	Downsampler();
+
+protected:
+	virtual blargg_err_t set_rate_( double );
+	virtual void clear_();
+	virtual sample_t const* resample_( sample_t**, sample_t const*, sample_t const [], int );
+
+private:
+	enum { stereo = 2 };
+	enum { write_offset = 8 * stereo };
+	int pos;
+	int step;
+};
+
+#endif
diff -Nur orig/source/gme/src/Dual_Resampler.cpp mod/source/gme/src/Dual_Resampler.cpp
--- orig/source/gme/src/Dual_Resampler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Dual_Resampler.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,200 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Dual_Resampler.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// TODO: fix this. hack since resampler holds back some output.
+int const resampler_extra = 34;
+
+int const stereo = 2;
+
+Dual_Resampler::Dual_Resampler() { }
+
+Dual_Resampler::~Dual_Resampler() { }
+
+blargg_err_t Dual_Resampler::reset( int pairs )
+{
+	// expand allocations a bit
+	RETURN_ERR( sample_buf.resize( (pairs + (pairs >> 2)) * 2 ) );
+	resize( pairs );
+	resampler_size = oversamples_per_frame + (oversamples_per_frame >> 2);
+	RETURN_ERR( resampler.resize_buffer( resampler_size ) );
+	resampler.clear();
+	return blargg_ok;
+}
+
+void Dual_Resampler::resize( int pairs )
+{
+	int new_sample_buf_size = pairs * 2;
+	//new_sample_buf_size = new_sample_buf_size / 4 * 4; // TODO: needed only for 3:2 downsampler
+	if ( sample_buf_size != new_sample_buf_size )
+	{
+		if ( (unsigned) new_sample_buf_size > sample_buf.size() )
+		{
+			check( false );
+			return;
+		}
+		sample_buf_size = new_sample_buf_size;
+		oversamples_per_frame = int (pairs * resampler.rate()) * 2 + 2;
+		clear();
+	}
+}
+
+void Dual_Resampler::clear()
+{
+	buf_pos = sample_buf_size;
+	resampler.clear();
+}
+
+
+void Dual_Resampler::play_frame_( Stereo_Buffer& stereo_buf, dsample_t out [] )
+{
+	int pair_count = sample_buf_size >> 1;
+	blip_time_t blip_time = stereo_buf.center()->count_clocks( pair_count );
+	int sample_count = oversamples_per_frame - resampler.written() + resampler_extra;
+	
+	int new_count = set_callback.f( set_callback.data, blip_time, sample_count, resampler.buffer() );
+	assert( new_count < resampler_size );
+	
+	stereo_buf.end_frame( blip_time );
+	assert( stereo_buf.samples_avail() == pair_count * 2 );
+	
+	resampler.write( new_count );
+	
+	int count = resampler.read( sample_buf.begin(), sample_buf_size );
+	assert( count == sample_buf_size );
+	
+	mix_samples( stereo_buf, out );
+	stereo_buf.left()->remove_samples( pair_count );
+	stereo_buf.right()->remove_samples( pair_count );
+	stereo_buf.center()->remove_samples( pair_count );
+}
+
+void Dual_Resampler::dual_play( int count, dsample_t out [], Stereo_Buffer& stereo_buf )
+{
+	// empty extra buffer
+	int remain = sample_buf_size - buf_pos;
+	if ( remain )
+	{
+		if ( remain > count )
+			remain = count;
+		count -= remain;
+		memcpy( out, &sample_buf [buf_pos], remain * sizeof *out );
+		out += remain;
+		buf_pos += remain;
+	}
+	
+	// entire frames
+	while ( count >= sample_buf_size )
+	{
+		play_frame_( stereo_buf, out );
+		out += sample_buf_size;
+		count -= sample_buf_size;
+	}
+	
+	// extra
+	if ( count )
+	{
+		play_frame_( stereo_buf, sample_buf.begin() );
+		buf_pos = count;
+		memcpy( out, sample_buf.begin(), count * sizeof *out );
+		out += count;
+	}
+}
+
+void Dual_Resampler::mix_samples( Stereo_Buffer& stereo_buf, dsample_t out_ [] )
+{
+	// lol hax
+	if ( ((Tracked_Blip_Buffer*)stereo_buf.left())->non_silent() | ((Tracked_Blip_Buffer*)stereo_buf.right())->non_silent() )
+		mix_stereo( stereo_buf, out_ );
+	else
+		mix_mono( stereo_buf, out_ );
+}
+
+void Dual_Resampler::mix_mono( Stereo_Buffer& stereo_buf, dsample_t out_ [] )
+{
+	int const bass = BLIP_READER_BASS( *stereo_buf.center() );
+	BLIP_READER_BEGIN( sn, *stereo_buf.center() );
+	
+	int count = sample_buf_size >> 1;
+	BLIP_READER_ADJ_( sn, count );
+	
+	typedef dsample_t stereo_dsample_t [2];
+	stereo_dsample_t* BLARGG_RESTRICT out = (stereo_dsample_t*) out_ + count;
+	stereo_dsample_t const* BLARGG_RESTRICT in =
+			(stereo_dsample_t const*) sample_buf.begin() + count;
+	int offset = -count;
+	int const gain = gain_;
+	do
+	{
+		int s = BLIP_READER_READ_RAW( sn ) >> (blip_sample_bits - 16);
+		BLIP_READER_NEXT_IDX_( sn, bass, offset );
+		
+		int l = (in [offset] [0] * gain >> gain_bits) + s;
+		int r = (in [offset] [1] * gain >> gain_bits) + s;
+		
+		BLIP_CLAMP( l, l );
+		out [offset] [0] = (blip_sample_t) l;
+		
+		BLIP_CLAMP( r, r );
+		out [offset] [1] = (blip_sample_t) r;
+	}
+	while ( ++offset );
+	
+	BLIP_READER_END( sn, *stereo_buf.center() );
+}
+
+void Dual_Resampler::mix_stereo( Stereo_Buffer& stereo_buf, dsample_t out_ [] )
+{
+	int const bass = BLIP_READER_BASS( *stereo_buf.center() );
+	BLIP_READER_BEGIN( snc, *stereo_buf.center() );
+	BLIP_READER_BEGIN( snl, *stereo_buf.left() );
+	BLIP_READER_BEGIN( snr, *stereo_buf.right() );
+	
+	int count = sample_buf_size >> 1;
+	BLIP_READER_ADJ_( snc, count );
+	BLIP_READER_ADJ_( snl, count );
+	BLIP_READER_ADJ_( snr, count );
+	
+	typedef dsample_t stereo_dsample_t [2];
+	stereo_dsample_t* BLARGG_RESTRICT out = (stereo_dsample_t*) out_ + count;
+	stereo_dsample_t const* BLARGG_RESTRICT in =
+			(stereo_dsample_t const*) sample_buf.begin() + count;
+	int offset = -count;
+	int const gain = gain_;
+	do
+	{
+		int sc = BLIP_READER_READ_RAW( snc ) >> (blip_sample_bits - 16);
+		int sl = BLIP_READER_READ_RAW( snl ) >> (blip_sample_bits - 16);
+		int sr = BLIP_READER_READ_RAW( snr ) >> (blip_sample_bits - 16);
+		BLIP_READER_NEXT_IDX_( snc, bass, offset );
+		BLIP_READER_NEXT_IDX_( snl, bass, offset );
+		BLIP_READER_NEXT_IDX_( snr, bass, offset );
+		
+		int l = (in [offset] [0] * gain >> gain_bits) + sl + sc;
+		int r = (in [offset] [1] * gain >> gain_bits) + sr + sc;
+		
+		BLIP_CLAMP( l, l );
+		out [offset] [0] = (blip_sample_t) l;
+		
+		BLIP_CLAMP( r, r );
+		out [offset] [1] = (blip_sample_t) r;
+	}
+	while ( ++offset );
+	
+	BLIP_READER_END( snc, *stereo_buf.center() );
+	BLIP_READER_END( snl, *stereo_buf.left() );
+	BLIP_READER_END( snr, *stereo_buf.right() );
+}
diff -Nur orig/source/gme/src/Dual_Resampler.h mod/source/gme/src/Dual_Resampler.h
--- orig/source/gme/src/Dual_Resampler.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Dual_Resampler.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,58 @@
+// Combination of Fir_Resampler and Stereo_Buffer mixing. Used by Sega FM emulators.
+
+// Game_Music_Emu 0.6-pre
+#ifndef DUAL_RESAMPLER_H
+#define DUAL_RESAMPLER_H
+
+#include "Multi_Buffer.h"
+
+#if GME_VGM_FAST_RESAMPLER
+	#include "Downsampler.h"
+	typedef Downsampler Dual_Resampler_Downsampler;
+#else
+	#include "Fir_Resampler.h"
+	typedef Fir_Resampler_Norm Dual_Resampler_Downsampler;
+#endif
+
+class Dual_Resampler {
+public:
+	typedef short dsample_t;
+	
+	blargg_err_t setup( double oversample, double rolloff, double gain );
+	double rate() const { return resampler.rate(); }
+	blargg_err_t reset( int max_pairs );
+	void resize( int pairs_per_frame );
+	void clear();
+	
+	void dual_play( int count, dsample_t out [], Stereo_Buffer& );
+	
+	blargg_callback<int (*)( void*, blip_time_t, int, dsample_t* )> set_callback;
+
+// Implementation
+public:
+	Dual_Resampler();
+	~Dual_Resampler();
+
+private:
+	enum { gain_bits = 14 };
+	blargg_vector<dsample_t> sample_buf;
+	int sample_buf_size;
+	int oversamples_per_frame;
+	int buf_pos;
+	int resampler_size;
+	int gain_;
+	
+	Dual_Resampler_Downsampler resampler;
+	void mix_samples( Stereo_Buffer&, dsample_t []);
+	void mix_mono( Stereo_Buffer&, dsample_t []);
+	void mix_stereo( Stereo_Buffer&, dsample_t []);
+	void play_frame_( Stereo_Buffer&, dsample_t []);
+};
+
+inline blargg_err_t Dual_Resampler::setup( double oversample, double rolloff, double gain )
+{
+	gain_ = (int) ((1 << gain_bits) * gain);
+	return resampler.set_rate( oversample );
+}
+
+#endif
diff -Nur orig/source/gme/src/Effects_Buffer.cpp mod/source/gme/src/Effects_Buffer.cpp
--- orig/source/gme/src/Effects_Buffer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Effects_Buffer.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,640 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Effects_Buffer.h"
+
+/* Copyright (C) 2006-2007 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#ifdef BLARGG_ENABLE_OPTIMIZER
+	#include BLARGG_ENABLE_OPTIMIZER
+#endif
+
+int const fixed_shift = 12;
+#define TO_FIXED( f )   fixed_t ((f) * ((fixed_t) 1 << fixed_shift))
+#define FROM_FIXED( f ) (f >> fixed_shift)
+
+int const max_read = 2560; // determines minimum delay
+
+Effects_Buffer::Effects_Buffer( int max_bufs, int echo_size_ ) : Multi_Buffer( stereo )
+{
+	echo_size   = max( max_read * (int) stereo, echo_size_ & ~1 );
+	clock_rate_ = 0;
+	bass_freq_  = 90;
+	bufs        = NULL;
+	bufs_size   = 0;
+	bufs_max    = max( max_bufs, (int) extra_chans );
+	no_echo     = true;
+	no_effects  = true;
+	
+	// defaults
+	config_.enabled   = false;
+	config_.delay [0] = 120;
+	config_.delay [1] = 122;
+	config_.feedback  = 0.2f;
+	config_.treble    = 0.4f;
+	
+	static float const sep = 0.8f;
+	config_.side_chans [0].pan = -sep;
+	config_.side_chans [1].pan = +sep;
+	config_.side_chans [0].vol = 1.0f;
+	config_.side_chans [1].vol = 1.0f;
+
+	memset( &s, 0, sizeof s );
+	clear();
+}
+
+Effects_Buffer::~Effects_Buffer()
+{
+	delete_bufs();
+}
+
+// avoid using new []
+blargg_err_t Effects_Buffer::new_bufs( int size )
+{
+	bufs = (buf_t*) malloc( size * sizeof *bufs );
+	CHECK_ALLOC( bufs );
+	for ( int i = 0; i < size; i++ )
+		new (bufs + i) buf_t;
+	bufs_size = size;
+	return blargg_ok;
+}
+
+void Effects_Buffer::delete_bufs()
+{
+	if ( bufs )
+	{
+		for ( int i = bufs_size; --i >= 0; )
+			bufs [i].~buf_t();
+		free( bufs );
+		bufs = NULL;
+	}
+	bufs_size = 0;
+}
+
+blargg_err_t Effects_Buffer::set_sample_rate( int rate, int msec )
+{
+	// extra to allow farther past-the-end pointers
+	mixer.samples_read = 0;
+	RETURN_ERR( echo.resize( echo_size + stereo ) );
+	return Multi_Buffer::set_sample_rate( rate, msec );
+}
+
+void Effects_Buffer::clock_rate( int rate )
+{
+	clock_rate_ = rate;
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].clock_rate( clock_rate_ );
+}
+
+void Effects_Buffer::bass_freq( int freq )
+{
+	bass_freq_ = freq;
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].bass_freq( bass_freq_ );
+}
+
+blargg_err_t Effects_Buffer::set_channel_count( int count, int const types [] )
+{
+	RETURN_ERR( Multi_Buffer::set_channel_count( count, types ) );
+	
+	delete_bufs();
+	
+	mixer.samples_read = 0;
+	
+	RETURN_ERR( chans.resize( count + extra_chans ) );
+	
+	RETURN_ERR( new_bufs( min( bufs_max, count + extra_chans ) ) );
+	
+	for ( int i = bufs_size; --i >= 0; )
+		RETURN_ERR( bufs [i].set_sample_rate( sample_rate(), length() ) );
+	
+	for ( int i = chans.size(); --i >= 0; )
+	{
+		chan_t& ch = chans [i];
+		ch.cfg.vol      = 1.0f;
+		ch.cfg.pan      = 0.0f;
+		ch.cfg.surround = false;
+		ch.cfg.echo     = false;
+	}
+	// side channels with echo
+	chans [2].cfg.echo = true;
+	chans [3].cfg.echo = true;
+	
+	clock_rate( clock_rate_ );
+	bass_freq( bass_freq_ );
+	apply_config();
+	clear();
+	
+	return blargg_ok;
+}
+
+void Effects_Buffer::clear_echo()
+{
+	if ( echo.size() )
+		memset( echo.begin(), 0, echo.size() * sizeof echo [0] );
+}
+
+void Effects_Buffer::clear()
+{
+	echo_pos       = 0;
+	s.low_pass [0] = 0;
+	s.low_pass [1] = 0;
+	mixer.samples_read = 0;
+	
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].clear();
+	clear_echo();
+}
+
+Effects_Buffer::channel_t Effects_Buffer::channel( int i )
+{
+	i += extra_chans;
+	require( extra_chans <= i && i < (int) chans.size() );
+	return chans [i].channel;
+}
+
+
+// Configuration
+
+// 3 wave positions with/without surround, 2 multi (one with same config as wave)
+int const simple_bufs = 3 * 2 + 2 - 1;
+
+Simple_Effects_Buffer::Simple_Effects_Buffer() :
+	Effects_Buffer( extra_chans + simple_bufs, 18 * 1024 )
+{
+	config_.echo     = 0.20f;
+	config_.stereo   = 0.20f;
+	config_.surround = true;
+	config_.enabled  = false;
+}
+
+void Simple_Effects_Buffer::apply_config()
+{
+	Effects_Buffer::config_t& c = Effects_Buffer::config();
+	
+	c.enabled = config_.enabled;
+	if ( c.enabled )
+	{
+		c.delay [0] = 120;
+		c.delay [1] = 122;
+		c.feedback  = config_.echo * 0.7f;
+		c.treble    = 0.6f - 0.3f * config_.echo;
+		
+		float sep = config_.stereo + 0.80f;
+		if ( sep > 1.0f )
+			sep = 1.0f;
+		
+		c.side_chans [0].pan = -sep;
+		c.side_chans [1].pan = +sep;
+		
+		for ( int i = channel_count(); --i >= 0; )
+		{
+			chan_config_t& ch = Effects_Buffer::chan_config( i );
+			
+			ch.pan      = 0.0f;
+			ch.surround = config_.surround;
+			ch.echo     = false;
+			
+			int const type = (channel_types() ? channel_types() [i] : 0);
+			if ( !(type & noise_type) )
+			{
+				int index = (type & type_index_mask) % 6 - 3;
+				if ( index < 0 )
+				{
+					index += 3;
+					ch.surround = false;
+					ch.echo     = true;
+				}
+				if ( index >= 1 )
+				{
+					ch.pan = config_.stereo;
+					if ( index == 1 )
+						ch.pan = -ch.pan;
+				}
+			}
+			else if ( type & 1 )
+			{
+				ch.surround = false;
+			}
+		}
+	}
+	
+	Effects_Buffer::apply_config();
+}
+
+int Effects_Buffer::min_delay() const
+{
+	require( sample_rate() );
+	return max_read * 1000 / sample_rate();
+}
+
+int Effects_Buffer::max_delay() const
+{
+	require( sample_rate() );
+	return (echo_size / stereo - max_read) * 1000 / sample_rate();
+}
+
+void Effects_Buffer::apply_config()
+{
+	int i;
+	
+	if ( !bufs_size )
+		return;
+	
+	s.treble = TO_FIXED( config_.treble );
+	
+	bool echo_dirty = false;
+	
+	fixed_t old_feedback = s.feedback;
+	s.feedback = TO_FIXED( config_.feedback );
+	if ( !old_feedback && s.feedback )
+		echo_dirty = true;
+	
+	// delays
+	for ( i = stereo; --i >= 0; )
+	{
+		int delay = config_.delay [i] * sample_rate() / 1000 * stereo;
+		delay = max( delay, (int) (max_read * stereo) );
+		delay = min( delay, (int) (echo_size - max_read * stereo) );
+		if ( s.delay [i] != delay )
+		{
+			s.delay [i] = delay;
+			echo_dirty = true;
+		}
+	}
+	
+	// side channels
+	for ( i = 2; --i >= 0; )
+	{
+		chans [i+2].cfg.vol = chans [i].cfg.vol = config_.side_chans [i].vol * 0.5f;
+		chans [i+2].cfg.pan = chans [i].cfg.pan = config_.side_chans [i].pan;
+	}
+	
+	// convert volumes
+	for ( i = chans.size(); --i >= 0; )
+	{
+		chan_t& ch = chans [i];
+		ch.vol [0] = TO_FIXED( ch.cfg.vol - ch.cfg.vol * ch.cfg.pan );
+		ch.vol [1] = TO_FIXED( ch.cfg.vol + ch.cfg.vol * ch.cfg.pan );
+		if ( ch.cfg.surround )
+			ch.vol [0] = -ch.vol [0];
+	}
+	
+	assign_buffers();
+	
+	// set side channels
+	for ( i = chans.size(); --i >= 0; )
+	{
+		chan_t& ch = chans [i];
+		ch.channel.left  = chans [ch.cfg.echo*2  ].channel.center;
+		ch.channel.right = chans [ch.cfg.echo*2+1].channel.center;
+	}
+	
+	bool old_echo = !no_echo && !no_effects;
+	
+	// determine whether effects and echo are needed at all
+	no_effects = true;
+	no_echo    = true;
+	for ( i = chans.size(); --i >= extra_chans; )
+	{
+		chan_t& ch = chans [i];
+		if ( ch.cfg.echo && s.feedback )
+			no_echo = false;
+		
+		if ( ch.vol [0] != TO_FIXED( 1 ) || ch.vol [1] != TO_FIXED( 1 ) )
+			no_effects = false;
+	}
+	if ( !no_echo )
+		no_effects = false;
+	
+	if (    chans [0].vol [0] != TO_FIXED( 1 ) ||
+			chans [0].vol [1] != TO_FIXED( 0 ) ||
+			chans [1].vol [0] != TO_FIXED( 0 ) ||
+			chans [1].vol [1] != TO_FIXED( 1 ) )
+		no_effects = false;
+	
+	if ( !config_.enabled )
+		no_effects = true;
+	
+	if ( no_effects )
+	{
+		for ( i = chans.size(); --i >= 0; )
+		{
+			chan_t& ch = chans [i];
+			ch.channel.center = &bufs [2];
+			ch.channel.left   = &bufs [0];
+			ch.channel.right  = &bufs [1];
+		}
+	}
+	
+	mixer.bufs [0] = &bufs [0];
+	mixer.bufs [1] = &bufs [1];
+	mixer.bufs [2] = &bufs [2];
+	
+	if ( echo_dirty || (!old_echo && (!no_echo && !no_effects)) )
+		clear_echo();
+	
+	channels_changed();
+}
+
+void Effects_Buffer::assign_buffers()
+{
+	// assign channels to buffers
+	int buf_count = 0;
+	for ( int i = 0; i < (int) chans.size(); i++ )
+	{
+		// put second two side channels at end to give priority to main channels
+		// in case closest matching is necessary
+		int x = i;
+		if ( i > 1 )
+			x += 2;
+		if ( x >= (int) chans.size() )
+			x -= (chans.size() - 2);
+		chan_t& ch = chans [x];
+		
+		int b = 0;
+		for ( ; b < buf_count; b++ )
+		{
+			if (    ch.vol [0] == bufs [b].vol [0] &&
+					ch.vol [1] == bufs [b].vol [1] &&
+					(ch.cfg.echo == bufs [b].echo || !s.feedback) )
+				break;
+		}
+		
+		if ( b >= buf_count )
+		{
+			if ( buf_count < bufs_max )
+			{
+				bufs [b].vol [0] = ch.vol [0];
+				bufs [b].vol [1] = ch.vol [1];
+				bufs [b].echo    = ch.cfg.echo;
+				buf_count++;
+			}
+			else
+			{
+				// TODO: this is a mess, needs refinement
+				dprintf( "Effects_Buffer ran out of buffers; using closest match\n" );
+				b = 0;
+				fixed_t best_dist = TO_FIXED( 8 );
+				for ( int h = buf_count; --h >= 0; )
+				{
+					#define CALC_LEVELS( vols, sum, diff, surround ) \
+					fixed_t sum, diff;\
+					bool surround = false;\
+					{\
+						fixed_t vol_0 = vols [0];\
+						if ( vol_0 < 0 ) vol_0 = -vol_0, surround = true;\
+						fixed_t vol_1 = vols [1];\
+						if ( vol_1 < 0 ) vol_1 = -vol_1, surround = true;\
+						sum  = vol_0 + vol_1;\
+						diff = vol_0 - vol_1;\
+					}
+					CALC_LEVELS( ch.vol,       ch_sum,  ch_diff,  ch_surround );
+					CALC_LEVELS( bufs [h].vol, buf_sum, buf_diff, buf_surround );
+					
+					fixed_t dist = abs( ch_sum - buf_sum ) + abs( ch_diff - buf_diff );
+					
+					if ( ch_surround != buf_surround )
+						dist += TO_FIXED( 1 ) / 2;
+					
+					if ( s.feedback && ch.cfg.echo != bufs [h].echo )
+						dist += TO_FIXED( 1 ) / 2;
+					
+					if ( best_dist > dist )
+					{
+						best_dist = dist;
+						b = h;
+					}
+				}
+			}
+		}
+		
+		//dprintf( "ch %d->buf %d\n", x, b );
+		ch.channel.center = &bufs [b];
+	}
+}
+
+
+// Mixing
+
+void Effects_Buffer::end_frame( blip_time_t time )
+{
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].end_frame( time );
+}
+
+int Effects_Buffer::read_samples( blip_sample_t out [], int out_size )
+{
+	out_size = min( out_size, samples_avail() );
+	
+	int pair_count = int (out_size >> 1);
+	require( pair_count * stereo == out_size ); // must read an even number of samples
+	if ( pair_count )
+	{
+		if ( no_effects )
+		{
+			mixer.read_pairs( out, pair_count );
+		}
+		else
+		{
+			int pairs_remain = pair_count;
+			do
+			{
+				// mix at most max_read pairs at a time
+				int count = max_read;
+				if ( count > pairs_remain )
+					count = pairs_remain;
+				
+				if ( no_echo )
+				{
+					// optimization: clear echo here to keep mix_effects() a leaf function
+					echo_pos = 0;
+					memset( echo.begin(), 0, count * stereo * sizeof echo [0] );
+				}
+				mix_effects( out, count );
+				
+				int new_echo_pos = echo_pos + count * stereo;
+				if ( new_echo_pos >= echo_size )
+					new_echo_pos -= echo_size;
+				echo_pos = new_echo_pos;
+				assert( echo_pos < echo_size );
+				
+				out += count * stereo;
+				mixer.samples_read += count;
+				pairs_remain -= count;
+			}
+			while ( pairs_remain );
+		}
+		
+		if ( samples_avail() <= 0 || immediate_removal() )
+		{
+			for ( int i = bufs_size; --i >= 0; )
+			{
+				buf_t& b = bufs [i];
+				// TODO: might miss non-silence settling since it checks END of last read
+				if ( b.non_silent() )
+					b.remove_samples( mixer.samples_read );
+				else
+					b.remove_silence( mixer.samples_read );
+			}
+			mixer.samples_read = 0;
+		}
+	}
+	return out_size;
+}
+
+void Effects_Buffer::mix_effects( blip_sample_t out_ [], int pair_count )
+{
+	typedef fixed_t stereo_fixed_t [stereo];
+	
+	// add channels with echo, do echo, add channels without echo, then convert to 16-bit and output
+	int echo_phase = 1;
+	do
+	{
+		// mix any modified buffers
+		{
+			buf_t* buf = bufs;
+			int bufs_remain = bufs_size;
+			do
+			{
+				if ( buf->non_silent() && buf->echo == (echo_phase > 0) )
+				{
+					stereo_fixed_t* BLARGG_RESTRICT out = (stereo_fixed_t*) &echo [echo_pos];
+					int const bass = BLIP_READER_BASS( *buf );
+					BLIP_READER_BEGIN( in, *buf );
+					BLIP_READER_ADJ_( in, mixer.samples_read );
+					fixed_t const vol_0 = buf->vol [0];
+					fixed_t const vol_1 = buf->vol [1];
+					
+					int count = (unsigned) (echo_size - echo_pos) / stereo;
+					int remain = pair_count;
+					if ( count > remain )
+						count = remain;
+					do
+					{
+						remain -= count;
+						BLIP_READER_ADJ_( in, count );
+						
+						out += count;
+						int offset = -count;
+						do
+						{
+							fixed_t s = BLIP_READER_READ( in );
+							BLIP_READER_NEXT_IDX_( in, bass, offset );
+							
+							out [offset] [0] += s * vol_0;
+							out [offset] [1] += s * vol_1;
+						}
+						while ( ++offset );
+						
+						out = (stereo_fixed_t*) echo.begin();
+						count = remain;
+					}
+					while ( remain );
+					
+					BLIP_READER_END( in, *buf );
+				}
+				buf++;
+			}
+			while ( --bufs_remain );
+		}
+		
+		// add echo
+		if ( echo_phase && !no_echo )
+		{
+			fixed_t const feedback = s.feedback;
+			fixed_t const treble   = s.treble;
+			
+			int i = 1;
+			do
+			{
+				fixed_t low_pass = s.low_pass [i];
+				
+				fixed_t* echo_end = &echo [echo_size + i];
+				fixed_t const* BLARGG_RESTRICT in_pos = &echo [echo_pos + i];
+				int out_offset = echo_pos + i + s.delay [i];
+				if ( out_offset >= echo_size )
+					out_offset -= echo_size;
+				assert( out_offset < echo_size );
+				fixed_t* BLARGG_RESTRICT out_pos = &echo [out_offset];
+				
+				// break into up to three chunks to avoid having to handle wrap-around
+				// in middle of core loop
+				int remain = pair_count;
+				do
+				{
+					fixed_t const* pos = in_pos;
+					if ( pos < out_pos )
+						pos = out_pos;
+					int count = (unsigned) ((char*) echo_end - (char const*) pos) /
+							(unsigned) (stereo * sizeof (fixed_t));
+					if ( count > remain )
+						count = remain;
+					remain -= count;
+					
+					in_pos  += count * stereo;
+					out_pos += count * stereo;
+					int offset = -count;
+					do
+					{
+						low_pass += FROM_FIXED( (in_pos [offset * stereo] - low_pass) ) * treble;
+						out_pos [offset * stereo] = FROM_FIXED( low_pass ) * feedback;
+					}
+					while ( ++offset );
+					
+					if (  in_pos >= echo_end )  in_pos -= echo_size;
+					if ( out_pos >= echo_end ) out_pos -= echo_size;
+				}
+				while ( remain );
+				
+				s.low_pass [i] = low_pass;
+			}
+			while ( --i >= 0 );
+		}
+	}
+	while ( --echo_phase >= 0 );
+	
+	// clamp to 16 bits
+	{
+		stereo_fixed_t const* BLARGG_RESTRICT in = (stereo_fixed_t*) &echo [echo_pos];
+		typedef blip_sample_t stereo_blip_sample_t [stereo];
+		stereo_blip_sample_t* BLARGG_RESTRICT out = (stereo_blip_sample_t*) out_;
+		int count = (unsigned) (echo_size - echo_pos) / (unsigned) stereo;
+		int remain = pair_count;
+		if ( count > remain )
+			count = remain;
+		do
+		{
+			remain -= count;
+			in  += count;
+			out += count;
+			int offset = -count;
+			do
+			{
+				fixed_t in_0 = FROM_FIXED( in [offset] [0] );
+				fixed_t in_1 = FROM_FIXED( in [offset] [1] );
+				
+				BLIP_CLAMP( in_0, in_0 );
+				out [offset] [0] = (blip_sample_t) in_0;
+				
+				BLIP_CLAMP( in_1, in_1 );
+				out [offset] [1] = (blip_sample_t) in_1;
+			}
+			while ( ++offset );
+			
+			in = (stereo_fixed_t*) echo.begin();
+			count = remain;
+		}
+		while ( remain );
+	}
+}
diff -Nur orig/source/gme/src/Effects_Buffer.h mod/source/gme/src/Effects_Buffer.h
--- orig/source/gme/src/Effects_Buffer.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Effects_Buffer.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,149 @@
+// Multi-channel effects buffer with echo and individual panning for each channel
+
+// Game_Music_Emu 0.6-pre
+#ifndef EFFECTS_BUFFER_H
+#define EFFECTS_BUFFER_H
+
+#include "Multi_Buffer.h"
+
+// See Simple_Effects_Buffer (below) for a simpler interface
+
+class Effects_Buffer : public Multi_Buffer {
+public:
+	// To reduce memory usage, fewer buffers can be used (with a best-fit
+	// approach if there are too few), and maximum echo delay can be reduced
+	Effects_Buffer( int max_bufs = 32, int echo_size = 24 * 1024 );
+	
+	struct pan_vol_t
+	{
+		float vol; // 0.0 = silent, 0.5 = half volume, 1.0 = normal
+		float pan; // -1.0 = left, 0.0 = center, +1.0 = right
+	};
+	
+	// Global configuration
+	struct config_t
+	{
+		bool enabled; // false = disable all effects
+		
+		// Current sound is echoed at adjustable left/right delay,
+		// with reduced treble and volume (feedback). 
+		float treble;   // 1.0 = full treble, 0.1 = very little, 0.0 = silent
+		int delay [2];  // left, right delays (msec)
+		float feedback; // 0.0 = no echo, 0.5 = each echo half previous, 1.0 = cacophony
+		pan_vol_t side_chans [2]; // left and right side channel volume and pan
+	};
+	config_t& config() { return config_; }
+	
+	// Limits of delay (msec)
+	int min_delay() const;
+	int max_delay() const;
+	
+	// Per-channel configuration. Two or more channels with matching parameters are
+	// optimized to internally use the same buffer.
+	struct chan_config_t : pan_vol_t
+	{
+		// (inherited from pan_vol_t)
+		//float vol;        // these only affect center channel
+		//float pan;
+		bool surround;  // if true, negates left volume to put sound in back
+		bool echo;      // false = channel doesn't have any echo
+	};
+	chan_config_t& chan_config( int i ) { return chans [i + extra_chans].cfg; }
+	
+	// Applies any changes made to config() and chan_config()
+	virtual void apply_config();
+	
+// Implementation
+public:
+	~Effects_Buffer();
+	blargg_err_t set_sample_rate( int samples_per_sec, int msec = blip_default_length );
+	blargg_err_t set_channel_count( int, int const* = NULL );
+	void clock_rate( int );
+	void bass_freq( int );
+	void clear();
+	channel_t channel( int );
+	void end_frame( blip_time_t );
+	int read_samples( blip_sample_t [], int );
+	int samples_avail() const { return (bufs [0].samples_avail() - mixer.samples_read) * 2; }
+	enum { stereo = 2 };
+	typedef int fixed_t;
+
+protected:
+	enum { extra_chans = stereo * stereo };
+
+private:
+	config_t config_;
+	int clock_rate_;
+	int bass_freq_;
+	
+	int echo_size;
+	
+	struct chan_t
+	{
+		fixed_t vol [stereo];
+		chan_config_t cfg;
+		channel_t channel;
+	};
+	blargg_vector<chan_t> chans;
+	
+	struct buf_t : Tracked_Blip_Buffer
+	{
+		// nasty: Blip_Buffer has something called fixed_t
+		Effects_Buffer::fixed_t vol [stereo];
+		bool echo;
+		
+		void* operator new ( size_t, void* p ) { return p; }
+		void operator delete ( void* ) { }
+		
+		~buf_t() { }
+	};
+	buf_t* bufs;
+	int bufs_size;
+	int bufs_max; // bufs_size <= bufs_max, to limit memory usage
+	Stereo_Mixer mixer;
+	
+	struct {
+		int delay [stereo];
+		fixed_t treble;
+		fixed_t feedback;
+		fixed_t low_pass [stereo];
+	} s;
+	
+	blargg_vector<fixed_t> echo;
+	int echo_pos;
+	
+	bool no_effects;
+	bool no_echo;
+	
+	void assign_buffers();
+	void clear_echo();
+	void mix_effects( blip_sample_t out [], int pair_count );
+	blargg_err_t new_bufs( int size );
+	void delete_bufs();
+};
+
+// Simpler interface and lower memory usage
+class Simple_Effects_Buffer : public Effects_Buffer {
+public:
+	struct config_t
+	{
+		bool enabled;   // false = disable all effects
+		
+		float echo;     // 0.0 = none, 1.0 = lots
+		float stereo;   // 0.0 = channels in center, 1.0 = channels on left/right
+		bool surround;  // true = put some channels in back
+	};
+	config_t& config() { return config_; }
+	
+	// Applies any changes made to config()
+	void apply_config();
+	
+// Implementation
+public:
+	Simple_Effects_Buffer();
+private:
+	config_t config_;
+	void chan_config(); // hide
+};
+
+#endif
diff -Nur orig/source/gme/src/emu2413.cpp mod/source/gme/src/emu2413.cpp
--- orig/source/gme/src/emu2413.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/emu2413.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,742 @@
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications. To alter this software and redistribute it freely,
+// if the origin of this software is not misrepresented.
+
+// written by Mitsutaka Okazaki 2001
+// Modified by xodnizel to remove code not needed for the VRC7, among other things.
+// Optimized performance and code size - Shay Green
+
+// References: 
+// fmopl.c        -- 1999,2000 written by Tatsuyuki Satoh (MAME development).
+// fmopl.c(fixed) -- (C) 2002 Jarek Burczynski.
+// s_opl.c        -- 2001 written by Mamiya (NEZplug development).
+// fmgen.cpp      -- 1999,2000 written by cisc.
+// fmpac.ill      -- 2000 created by NARUTO.
+// MSX-Datapack
+// YMU757 data sheet
+// YM2143 data sheet
+
+#include <assert.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include "emu2413.h"
+
+#undef PI
+#define PI 3.14159265358979323846
+
+static const unsigned char default_inst[15][8] =
+{
+// VRC7 instruments, January 17, 2004 update -Xodnizel
+    {0x03, 0x21, 0x04, 0x06, 0x8D, 0xF2, 0x42, 0x17}, 
+    {0x13, 0x41, 0x05, 0x0E, 0x99, 0x96, 0x63, 0x12}, 
+    {0x31, 0x11, 0x10, 0x0A, 0xF0, 0x9C, 0x32, 0x02}, 
+    {0x21, 0x61, 0x1D, 0x07, 0x9F, 0x64, 0x20, 0x27}, 
+    {0x22, 0x21, 0x1E, 0x06, 0xF0, 0x76, 0x08, 0x28}, 
+    {0x02, 0x01, 0x06, 0x00, 0xF0, 0xF2, 0x03, 0x95}, 
+    {0x21, 0x61, 0x1C, 0x07, 0x82, 0x81, 0x16, 0x07}, 
+    {0x23, 0x21, 0x1A, 0x17, 0xEF, 0x82, 0x25, 0x15}, 
+    {0x25, 0x11, 0x1F, 0x00, 0x86, 0x41, 0x20, 0x11}, 
+    {0x85, 0x01, 0x1F, 0x0F, 0xE4, 0xA2, 0x11, 0x12}, 
+    {0x07, 0xC1, 0x2B, 0x45, 0xB4, 0xF1, 0x24, 0xF4},
+    {0x61, 0x23, 0x11, 0x06, 0x96, 0x96, 0x13, 0x16}, 
+    {0x01, 0x02, 0xD3, 0x05, 0x82, 0xA2, 0x31, 0x51}, 
+    {0x61, 0x22, 0x0D, 0x02, 0xC3, 0x7F, 0x24, 0x05},
+    {0x21, 0x62, 0x0E, 0x00, 0xA1, 0xA0, 0x44, 0x17},
+
+};
+
+#define EG2DB(d) ((d)*(e_int32)(EG_STEP/DB_STEP))
+#define TL2EG(d) ((d)*(e_int32)(TL_STEP/EG_STEP))
+#define SL2EG(d) ((d)*(e_int32)(SL_STEP/EG_STEP))
+
+// Bits for liner value
+#define DB2LIN_AMP_BITS 11
+#define SLOT_AMP_BITS (DB2LIN_AMP_BITS)
+
+// Bits for envelope phase incremental counter
+#define EG_DP_BITS 22
+#define EG_DP_WIDTH (1<<EG_DP_BITS)
+
+// PM table is calcurated by PM_AMP * pow(2,PM_DEPTH*sin(x)/1200)
+#define PM_AMP_BITS 8
+#define PM_AMP (1<<PM_AMP_BITS)
+
+// PM speed(Hz) and depth(cent)
+#define PM_SPEED 6.4
+#define PM_DEPTH 13.75
+
+// AM speed(Hz) and depth(dB)
+#define AM_SPEED 3.7
+//#define AM_DEPTH 4.8
+#define AM_DEPTH 2.4
+
+// Cut the lower b bit(s) off.
+#define HIGHBITS(c,b) ((c)>>(b))
+
+// Expand x which is s bits to d bits.
+#define EXPAND_BITS(x,s,d) ((x)<<((d)-(s)))
+
+#define CAR_OFFSET 1
+#define MOD_CAR( o, x, sel ) (&((o)->slot + (sel)) [(x) << 1])
+#define MOD(o,x) MOD_CAR( o, x, 0 )
+#define CAR(o,x) MOD_CAR( o, x, 1 )
+
+// Definition of envelope mode
+enum { SUSHOLD, SETTLE, ATTACK, DECAY, SUSTINE, RELEASE, FINISH };
+
+inline static void update_eg_dphase_inl ( OPLL* opll, OPLL_SLOT* slot, e_int32 slot_eg_mode )
+{
+	e_uint32 result = 0;
+	int index = slot->patch.RR;
+	switch ( slot_eg_mode )
+	{
+	case ATTACK:
+		result = opll->dphaseARTable[slot->patch.AR][slot->rks];
+		break;
+
+	case DECAY:
+		index = slot->patch.DR;
+		goto common;
+
+	case RELEASE:
+		if (slot->sustine)
+			index = 5;
+		else if (!slot->patch.EG)
+			index = 7;
+	case SUSTINE:
+	common:
+		result = opll->dphaseDRTable [index] [slot->rks];
+	case SUSHOLD:
+	case FINISH:
+	default:
+		break;
+	}
+	
+	slot->eg_dphase = result;
+}
+
+// out = in, then verify that value wasn't truncated
+#define ASSIGN( out, in )\
+	((out = in), assert( out == in ))
+
+static void maketables ( OPLL* opll )
+{
+	e_int32 i;
+	
+	// Table for Pitch Modulator
+	for (i = 0; i < PM_PG_WIDTH; i++)
+		ASSIGN( opll->pmtable[i],
+				(e_int32) ((double) PM_AMP * pow (2, (double) PM_DEPTH * sin (2.0 * PI * i / PM_PG_WIDTH) / 1200)) );
+	
+	// Table for Amp Modulator
+	for ( i = 0; i < AM_PG_WIDTH; i++)
+		ASSIGN( opll->amtable[i],
+				(e_int32) ((double) AM_DEPTH / 2 / DB_STEP * (1.0 + sin (2.0 * PI * i / PM_PG_WIDTH))) );
+	
+	// Table for dB(0 -- (1<<DB_BITS)-1) to Liner(0 -- DB2LIN_AMP_WIDTH)
+	for (i = 0; i < DB_MUTE; i++)
+		ASSIGN( opll->DB2LIN_TABLE[i],
+				(e_int16) ((double) ((1 << DB2LIN_AMP_BITS) - 1) * pow (10, -(double) i * DB_STEP / 20)) );
+	
+	// TODO: remove (calloc already ensures zero fill)
+	//for (i = DB_MUTE; i < 2 * DB_MUTE; i++)
+	//	opll->DB2LIN_TABLE[i] = 0;
+	
+	for (i = 0; i < 2 * DB_MUTE; i++)
+		ASSIGN( opll->DB2LIN_TABLE[i + DB_MUTE + DB_MUTE],
+				(e_int16) (-opll->DB2LIN_TABLE[i]) );
+	
+	// Table for AR to LogCurve.
+	{
+		ASSIGN( opll->AR_ADJUST_TABLE[0], (1 << EG_BITS) );
+		for (i = 1; i < 128; i++)
+			ASSIGN( opll->AR_ADJUST_TABLE[i],
+					(e_uint16) ((double) (1 << EG_BITS) - 1 - (1 << EG_BITS) * log ((double)i) / log (128.)) );
+	}
+	
+	{
+		#define dB2(x) ((x)*2)
+		static const double kltable[16] = {
+			dB2 (0.000), dB2 (9.000), dB2 (12.000), dB2 (13.875), dB2 (15.000), dB2 (16.125), dB2 (16.875), dB2 (17.625),
+			dB2 (18.000), dB2 (18.750), dB2 (19.125), dB2 (19.500), dB2 (19.875), dB2 (20.250), dB2 (20.625), dB2 (21.000)
+		};
+
+		for (int fnum = 0; fnum < 16; fnum++)
+		{
+			for (int block = 0; block < 8; block++)
+			{
+				for (int TL = 0; TL < 64; TL++)
+				{
+					e_uint32 eg = TL2EG( TL );
+					ASSIGN( opll->tllTable[fnum][block][TL][0], eg );
+					for (int KL = 1; KL < 4; KL++)
+					{
+						e_int32 tmp = (e_int32) (kltable[fnum] - dB2 (3.000) * (7 - block));
+						e_uint32 n = eg;
+						if ( tmp > 0 )
+							n += (e_uint32) ((tmp >> (3 - KL)) / EG_STEP);
+						ASSIGN( opll->tllTable[fnum][block][TL][KL], n );
+					}
+				}
+			}
+		}
+	}
+
+	{
+		for (int fnum8 = 0; fnum8 < 2; fnum8++)
+		{
+			for (int block = 0; block < 8; block++)
+			{
+				ASSIGN( opll->rksTable[fnum8][block][0], block >> 1 );
+				for (int KR = 1; KR < 2; KR++)
+					ASSIGN( opll->rksTable[fnum8][block][KR], (block << 1) + fnum8 );
+			}
+		}
+	}
+
+	// Sin Table
+	for (i = 0; i < PG_WIDTH / 4; i++)
+	{
+		double d = sin (2.0 * PI / PG_WIDTH * i);
+		
+		// Liner(+0.0 - +1.0) to dB((1<<DB_BITS) - 1 -- 0)
+		e_int32 x = DB_MUTE - 1;
+		if ( d )
+		{
+			e_int32 y = -(e_int32) (20.0 / DB_STEP * log10 (d));
+			if ( x > y )
+				x = y;
+		}
+
+		ASSIGN( opll->sintable [0] [i], (e_uint32) x );
+	}
+
+	for (i = 0; i < PG_WIDTH / 4; i++)
+		ASSIGN( opll->sintable [0] [PG_WIDTH / 2 - 1 - i], opll->sintable [0] [i] );
+
+	for (i = 0; i < PG_WIDTH / 2; i++)
+		ASSIGN( opll->sintable [0] [PG_WIDTH / 2 + i], (e_uint32) (DB_MUTE + DB_MUTE + opll->sintable [0] [i]) );
+
+	for (i = 0; i < PG_WIDTH / 2; i++)
+		ASSIGN( opll->sintable [1] [i], opll->sintable [0] [i] );
+	
+	for (i = PG_WIDTH / 2; i < PG_WIDTH; i++)
+		ASSIGN( opll->sintable [1] [i], opll->sintable [0] [0] );
+
+	//makeDefaultPatch ();
+	
+	// internal refresh
+	
+	// Phase increment counter table
+	{
+		static int const mltable[16] = {
+			1, 1 * 2, 2 * 2, 3 * 2, 4 * 2, 5 * 2, 6 * 2, 7 * 2, 8 * 2,
+			9 * 2, 10 * 2, 10 * 2, 12 * 2, 12 * 2, 15 * 2, 15 * 2
+		};
+		for (int fnum = 0; fnum < 512; fnum++)
+			for (int block = 0; block < 8; block++)
+				for (int ML = 0; ML < 16; ML++)
+					ASSIGN( opll->dphaseTable[fnum][block][ML],
+							(((fnum * mltable[ML]) << block) >> (20 - DP_BITS)) );
+	}
+
+	// Rate Table for Attack
+	{
+		for (int Rks = 0; Rks < 16; Rks++)
+		{
+			// TODO: remove (calloc already ensures zero fill)
+			//opll->dphaseARTable[ 0][Rks] = 0;
+			//opll->dphaseARTable[15][Rks] = 0;
+			int RL = (Rks & 3) * 3 + 12;
+			for (int AR = 1; AR < 15; AR++)
+			{
+				int RM = AR + (Rks >> 2);
+				if (RM > 15)
+					RM = 15;
+				ASSIGN( opll->dphaseARTable[AR][Rks], RL << (RM + 1) );
+			}
+		}
+	}
+
+	// Rate Table for Decay and Release
+	{
+		for (int Rks = 0; Rks < 16; Rks++)
+		{
+			// TODO: remove (calloc already ensures zero fill)
+			//opll->dphaseDRTable[0][Rks] = 0;
+			int RL = (Rks & 3) + 4;
+			for (int DR = 1; DR < 16; DR++)
+			{
+				int RM = DR + (Rks >> 2);
+				if (RM > 15)
+					RM = 15;
+				ASSIGN( opll->dphaseDRTable[DR][Rks], RL << (RM - 1) );
+			}
+		}
+	}
+}
+
+OPLL* VRC7_new( long clock_rate )
+{
+	OPLL* opll = (OPLL*) calloc( sizeof *opll, 1 );
+	if ( opll )
+	{
+		maketables( opll );
+		ASSIGN( opll->pm_dphase, (e_uint32) (PM_SPEED * PM_DP_WIDTH / (clock_rate / 72)) );
+		ASSIGN( opll->am_dphase, (e_uint32) (AM_SPEED * AM_DP_WIDTH / (clock_rate / 72)) );
+		
+		VRC7_reset (opll);
+	}
+	return opll;
+}
+
+void VRC7_delete( OPLL* opll )
+{
+	free (opll);
+}
+
+// Reset whole of OPLL except patch datas.
+void VRC7_reset( OPLL* opll )
+{
+	opll->pm_phase = opll->pm_dphase;
+	opll->am_phase = opll->am_dphase;
+	
+	int i;
+	for ( i = 0; i < 12; i++)
+	{
+		OPLL_SLOT* slot = &opll->slot[i];
+		memset( slot, 0, offsetof (OPLL_SLOT,patch) );
+		slot->sintbl    = opll->sintable [0];
+		slot->eg_mode   = SETTLE;
+		slot->eg_phase  = EG_DP_WIDTH;
+	}
+
+	for (i = 0; i < 0x40; i++)
+		VRC7_writeReg (opll, i, 0);
+}
+
+// Force Refresh (When external program changes some parameters).
+/*
+void VRC7_forceRefresh( OPLL* opll )
+{
+	for (e_int32 i = 0; i < 12; i++)
+		UPDATE_ALL( opll, &opll->slot[i], i & 1 );
+}
+*/
+
+// Convert Amp(0 to EG_HEIGHT) to Phase(0 to 2PI).
+#if ( SLOT_AMP_BITS - PG_BITS ) > 0
+#define wave2_2pi(e)  ( (e) >> ( SLOT_AMP_BITS - PG_BITS ))
+#else
+#define wave2_2pi(e)  ( (e) << ( PG_BITS - SLOT_AMP_BITS ))
+#endif
+
+// Convert Amp(0 to EG_HEIGHT) to Phase(0 to 4PI).
+#if ( SLOT_AMP_BITS - PG_BITS - 1 ) == 0
+#define wave2_4pi(e)  (e)
+#elif ( SLOT_AMP_BITS - PG_BITS - 1 ) > 0
+#define wave2_4pi(e)  ( (e) >> ( SLOT_AMP_BITS - PG_BITS - 1 ))
+#else
+#define wave2_4pi(e)  ( (e) << ( 1 + PG_BITS - SLOT_AMP_BITS ))
+#endif
+
+// Convert Amp(0 to EG_HEIGHT) to Phase(0 to 8PI).
+#if ( SLOT_AMP_BITS - PG_BITS - 2 ) == 0
+#define wave2_8pi(e)  (e)
+#elif ( SLOT_AMP_BITS - PG_BITS - 2 ) > 0
+#define wave2_8pi(e)  ( (e) >> ( SLOT_AMP_BITS - PG_BITS - 2 ))
+#else
+#define wave2_8pi(e)  ( (e) << ( 2 + PG_BITS - SLOT_AMP_BITS ))
+#endif
+
+void VRC7_run( OPLL* opll )
+{
+	// PM
+	int const opll_lfo_pm = opll->pmtable [HIGHBITS( opll->pm_phase, PM_DP_BITS - PM_PG_BITS )];
+	opll->pm_phase = (opll->pm_phase + opll->pm_dphase) & (PM_DP_WIDTH - 1);
+	
+	{
+		int n = 12;
+		OPLL_SLOT* slot = opll->slot;
+		do
+		{
+			// phase
+			int step = slot->dphase;
+			if ( slot->patch.PM ) // 36%
+				step = (step * opll_lfo_pm) >> PM_AMP_BITS;
+			
+			e_uint32 slot_phase = (slot->phase + step) & (DP_WIDTH - 1);
+			slot->phase = slot_phase;
+			slot->pgout = HIGHBITS( slot_phase, DP_BASE_BITS );
+			
+			slot++;
+		}
+		while ( --n );
+	}
+	
+	// AM
+	int const opll_lfo_am = opll->amtable [HIGHBITS( opll->am_phase, AM_DP_BITS - AM_PG_BITS )];
+	opll->am_phase = (opll->am_phase + opll->am_dphase) & (AM_DP_WIDTH - 1);
+	
+	int n = 12;
+	OPLL_SLOT* slot = opll->slot;
+	do
+	{
+		// envelope
+		e_uint32 egout = HIGHBITS( slot->eg_phase, EG_DP_BITS - EG_BITS );
+		
+		switch ( slot->eg_mode )
+		{
+		case SUSHOLD: // 54%
+			if ( slot->patch.EG ) // 99%
+				break;
+			slot->eg_mode = SUSTINE;
+			update_eg_dphase_inl( opll, slot, SUSTINE );
+			break;
+
+		case DECAY:{// 23%
+			#define S2E(x) (SL2EG((e_int32)(x/SL_STEP))<<(EG_DP_BITS-EG_BITS))
+			static const e_uint32 SL[16] = {
+				S2E (0.0), S2E (3.0), S2E (6.0), S2E (9.0), S2E (12.0), S2E (15.0), S2E (18.0), S2E (21.0),
+				S2E (24.0), S2E (27.0), S2E (30.0), S2E (33.0), S2E (36.0), S2E (39.0), S2E (42.0), S2E (48.0)
+			};
+			slot->eg_phase += slot->eg_dphase;
+			if ( slot->eg_phase >= SL [slot->patch.SL] )
+			{
+				slot->eg_phase = SL [slot->patch.SL];
+				if ( slot->patch.EG )
+				{
+					slot->eg_mode = SUSHOLD;
+					update_eg_dphase_inl( opll, slot, SUSHOLD );
+				}
+				else
+				{
+					slot->eg_mode = SUSTINE;
+					update_eg_dphase_inl( opll, slot, SUSTINE );
+				}
+			}
+			break;
+		}
+
+		case ATTACK: // 3%
+			egout = opll->AR_ADJUST_TABLE[egout];
+			slot->eg_phase += slot->eg_dphase;
+			if((EG_DP_WIDTH & slot->eg_phase)||(slot->patch.AR==15))
+			{
+				egout = 0;
+				slot->eg_phase = 0;
+				slot->eg_mode = DECAY;
+				update_eg_dphase_inl( opll, slot, DECAY );
+			}
+			break;
+
+		case SUSTINE:
+		case RELEASE: // 18%
+			slot->eg_phase += slot->eg_dphase;
+			if ( egout < (1 << EG_BITS) )
+				break;
+			slot->eg_mode = FINISH;
+		case FINISH: // 2%
+		default:
+			egout = (1 << EG_BITS) - 1;
+			break;
+		}
+		
+		egout = EG2DB( egout + slot->tll );
+		if ( slot->patch.AM )
+			egout += opll_lfo_am;
+
+		if ( egout > DB_MUTE - 1 )
+			egout = DB_MUTE;
+		
+		slot->egout = egout;
+		
+		slot++;
+	}
+	while ( --n );
+}
+
+e_uint32 VRC7_calcCh( OPLL* opll, e_uint32 ch )
+{
+	OPLL_SLOT* slot = MOD( opll, ch );
+	
+	// modulator
+	e_int32 feedback;
+	{
+		e_int32 fm = wave2_4pi( slot->feedback ) >> slot->patch.FB_shift;
+		int index = (slot->pgout + fm) & (PG_WIDTH - 1);
+		feedback = opll->DB2LIN_TABLE [slot->sintbl [index] + slot->egout];
+		assert( slot->egout < DB_MUTE || feedback == 0 ); // was DB_MUTE - 1 in original
+		
+		e_int32 slot_output_1 = slot->output [0];
+		
+		if ( slot [CAR_OFFSET].eg_mode == FINISH ) // 3%
+			return 0;
+		
+		slot->output [0] = feedback;
+		slot->output [1] = slot_output_1;
+		
+		feedback = (feedback + slot_output_1) >> 1;
+		slot->feedback = feedback;
+	}
+	slot += CAR_OFFSET;
+	
+	// carrier
+	e_int32 output = opll->DB2LIN_TABLE [
+			slot->sintbl [(slot->pgout + wave2_8pi( feedback )) & (PG_WIDTH-1)] + slot->egout];
+	assert( slot->egout < DB_MUTE || output == 0 ); // was DB_MUTE - 1 in original
+	
+	e_int32 slot_output_1 = slot->output [0];
+	slot->output [0] = output;
+	slot->output [1] = slot_output_1;
+	
+	return (output + slot_output_1) >> 1;
+}
+
+static void setInstrument( OPLL* opll, unsigned i, unsigned inst )
+{
+	opll->patch_number[i]=inst;
+	
+	const e_uint8* src = opll->CustInst;
+	if(inst)
+		src=default_inst[inst-1];
+
+	OPLL_PATCH* modp=&MOD(opll,i)->patch;
+	OPLL_PATCH* carp=&CAR(opll,i)->patch;
+	
+	int src_0 = src [0];
+	modp->AM=(src_0>>7)&1;
+	modp->PM=(src_0>>6)&1;
+	modp->EG=(src_0>>5&1);
+	modp->KR=(src_0>>4)&1;
+	modp->ML=(src_0&0xF);
+
+	int src_1 = src [1];
+	carp->AM=(src_1>>7)&1;
+	carp->PM=(src_1>>6)&1;
+	carp->EG=(src_1>>5&1);
+	carp->KR=(src_1>>4)&1;
+	carp->ML=(src_1&0xF);  
+
+	int src_2 = src [2];
+	modp->KL=(src_2>>6)&3;
+	modp->TL=(src_2&0x3F);
+
+	int src_3 = src [3];
+	carp->KL = (src_3 >> 6) & 3; 
+	carp->WF = (src_3 >> 4) & 1;
+
+	modp->WF = (src_3 >> 3) & 1;
+	
+	int FB = (src_3) & 7;
+	modp->FB_shift = (FB ? 7 - FB : 31);
+	
+	int src_4 = src [4];
+	modp->AR = (src_4>>4)&0xF;
+	modp->DR = (src_4&0xF);
+
+	int src_5 = src [5];
+	carp->AR = (src_5>>4)&0xF;
+	carp->DR = (src_5&0xF);
+
+	int src_6 = src [6];
+	modp->SL = (src_6>>4)&0xF;
+	modp->RR = (src_6&0xF);
+
+	int src_7 = src [7];
+	carp->SL = (src_7>>4)&0xF;
+	carp->RR = (src_7&0xF);
+}
+
+static void update_eg_dphase( OPLL* opll, OPLL_SLOT* slot )
+{
+	update_eg_dphase_inl( opll, slot, slot->eg_mode );
+}
+
+#define UPDATE_PG(S)  (S)->dphase = opll->dphaseTable[(S)->fnum][(S)->block][(S)->patch.ML]
+#define UPDATE_RKS(S) (S)->rks = opll->rksTable[((S)->fnum)>>8][(S)->block][(S)->patch.KR]
+#define UPDATE_WF(S)  (S)->sintbl = opll->sintable [(S)->patch.WF]
+#define UPDATE_EG(S)  update_eg_dphase( opll, S )
+
+inline static void UPDATE_TLL( OPLL* opll, OPLL_SLOT* S, int type )
+{
+	int index = (type ? (S)->volume : (S)->patch.TL);
+	(S)->tll = opll->tllTable [(S)->fnum >> 5] [(S)->block] [index] [(S)->patch.KL];
+}
+
+static void UPDATE_ALL( OPLL* opll, OPLL_SLOT* S, int type )
+{
+	UPDATE_PG(S);
+	UPDATE_TLL(opll, S, type);
+	UPDATE_RKS(S);
+	UPDATE_WF(S);
+	UPDATE_EG(S); // must be done last
+}
+
+static void UPDATE_ALL_BOTH( OPLL* opll, OPLL_SLOT* slot )
+{
+	UPDATE_ALL( opll, slot, 0 );
+	UPDATE_ALL( opll, slot + CAR_OFFSET, 1 );
+}
+
+inline static void slotOn( OPLL_SLOT* slot )
+{
+	slot->eg_mode  = ATTACK;
+	slot->eg_phase = 0;
+	slot->phase    = 0;
+}
+
+inline static void setFnumber( OPLL_SLOT* slot, e_int32 fnum )
+{
+	slot [         0].fnum = fnum;
+	slot [CAR_OFFSET].fnum = fnum;
+}
+
+inline static void setBlock( OPLL_SLOT* slot, e_int32 block )
+{
+	slot [         0].block = block;
+	slot [CAR_OFFSET].block = block;
+}
+
+void VRC7_writeReg( OPLL* opll, int addr, e_uint32 data )
+{
+	e_int32 i;
+	
+	data &= 0xFF;
+	addr &= 0x3F;
+
+	switch ( addr )
+	{
+	case 0x00:
+	case 0x01:
+		opll->CustInst[addr]=data;
+		for (i = 0; i < 6; i++)
+		{
+			if (opll->patch_number[i] == 0)
+			{
+				setInstrument(opll, i, 0);
+				OPLL_SLOT* slot = MOD_CAR( opll, i, addr & 1 );
+				UPDATE_PG ( slot );
+				UPDATE_RKS( slot );
+				UPDATE_EG ( slot );
+			}
+		}
+		break;
+
+	case 0x02:
+		opll->CustInst[2]=data;
+		for (i = 0; i < 6; i++)
+		{
+			if (opll->patch_number[i] == 0)
+			{
+				setInstrument(opll, i, 0);
+				UPDATE_TLL(opll, MOD(opll,i), 0 );
+			}
+		}
+		break;
+
+	case 0x03:
+		opll->CustInst[3]=data;
+		for (i = 0; i < 6; i++)
+		{
+			if (opll->patch_number[i] == 0)
+			{
+				setInstrument(opll, i, 0);
+				UPDATE_WF(MOD(opll,i));
+				UPDATE_WF(CAR(opll,i));
+			}
+		}
+		break;
+
+	case 0x04:
+	case 0x05:
+	case 0x06:
+	case 0x07:
+		opll->CustInst[addr]=data;
+		for ( i = 0; i < 6; i++ )
+		{
+			if ( opll->patch_number [i] == 0 )
+			{
+				setInstrument( opll, i, 0 );
+				UPDATE_EG( MOD_CAR( opll, i, addr & 1 ) );
+			}
+		}
+		break;
+	
+	case 0x10:
+	case 0x11:
+	case 0x12:
+	case 0x13:
+	case 0x14:
+	case 0x15: {
+		int ch = addr - 0x10;
+		opll->LowFreq [ch] = data;
+		OPLL_SLOT* slot = MOD( opll, ch );
+		
+		setFnumber( slot, data + ((opll->HiFreq[ch] & 1) << 8));
+		UPDATE_ALL_BOTH( opll, slot );
+		break;
+	}
+	
+	case 0x20:
+	case 0x21:
+	case 0x22:
+	case 0x23:
+	case 0x24:
+	case 0x25: {
+		int ch = addr - 0x20;
+		opll->HiFreq [ch] = data;
+		OPLL_SLOT* slot = MOD( opll, ch );
+		
+		setFnumber( slot, ((data & 1) << 8) + opll->LowFreq[ch]);
+		setBlock( slot, (data >> 1) & 7);
+		slot [CAR_OFFSET].sustine = (data >> 5) & 1;
+		if (data & 0x10)
+		{
+			if ( !slot->slot_on_flag )
+				slotOn( slot );
+			
+			if ( !slot [CAR_OFFSET].slot_on_flag )
+				slotOn( slot + CAR_OFFSET );
+		}
+		else if ( slot [CAR_OFFSET].slot_on_flag )
+		{
+			if (slot [CAR_OFFSET].eg_mode == ATTACK)
+				slot [CAR_OFFSET].eg_phase = EXPAND_BITS (opll->AR_ADJUST_TABLE[HIGHBITS (slot [CAR_OFFSET].eg_phase, EG_DP_BITS - EG_BITS)], EG_BITS, EG_DP_BITS);
+			slot [CAR_OFFSET].eg_mode = RELEASE;
+		}
+		UPDATE_ALL_BOTH( opll, slot );
+		
+		//inline static void update_key_status (OPLL * opll)
+		for (ch = 0; ch < 6; ch++)
+		{
+			int flag = (opll->HiFreq [ch]) & 0x10;
+			slot = MOD( opll, ch );
+			slot [         0].slot_on_flag = flag;
+			slot [CAR_OFFSET].slot_on_flag = flag;
+		}
+		break;
+	}
+
+	case 0x30:
+	case 0x31:
+	case 0x32:
+	case 0x33:
+	case 0x34:
+	case 0x35: {
+		int ch = addr - 0x30;
+		opll->InstVol [ch] = data;
+		
+		setInstrument( opll, ch, data >> 4 & 0x0F );
+		OPLL_SLOT* slot = MOD( opll, ch );
+		slot [CAR_OFFSET].volume = (data & 0x0F) << 2;
+		UPDATE_ALL_BOTH( opll, slot );
+		break;
+	}
+	
+	default:
+		break;
+	}
+}
diff -Nur orig/source/gme/src/emu2413.h mod/source/gme/src/emu2413.h
--- orig/source/gme/src/emu2413.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/emu2413.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,143 @@
+#ifndef EMU2413_H
+#define EMU2413_H
+
+typedef unsigned char  e_uint8;
+typedef signed short   e_int16;
+typedef unsigned short e_uint16;
+typedef signed int     e_int32;
+typedef unsigned int   e_uint32;
+
+// Size of Sintable ( 8 -- 18 can be used. 9 recommended.)
+#define PG_BITS 9              
+#define PG_WIDTH (1<<PG_BITS)
+
+// Phase increment counter
+#define DP_BITS 18
+#define DP_WIDTH (1<<DP_BITS)
+#define DP_BASE_BITS (DP_BITS - PG_BITS)
+														
+// Dynamic range (Accuracy of sin table)
+#define DB_BITS 8
+#define DB_STEP (48.0/(1<<DB_BITS))
+#define DB_MUTE (1<<DB_BITS)
+
+// Dynamic range of envelope
+#define EG_STEP 0.375
+#define EG_BITS 7
+#define EG_MUTE (1<<EG_BITS)
+
+// Dynamic range of total level
+#define TL_STEP 0.75
+#define TL_BITS 6   
+#define TL_MUTE (1<<TL_BITS)
+
+// Dynamic range of sustine level
+#define SL_STEP 3.0
+#define SL_BITS 4  
+#define SL_MUTE (1<<SL_BITS)
+
+// Bits for Pitch and Amp modulator
+#define PM_PG_BITS 8
+#define PM_PG_WIDTH (1<<PM_PG_BITS)
+#define PM_DP_BITS 16
+#define PM_DP_WIDTH (1<<PM_DP_BITS)
+#define AM_PG_BITS 8
+#define AM_PG_WIDTH (1<<AM_PG_BITS)
+#define AM_DP_BITS 16
+#define AM_DP_WIDTH (1<<AM_DP_BITS)
+
+struct OPLL_PATCH
+{
+	e_uint32 TL,FB_shift,EG,ML,AR,DR,SL,RR,KR,KL,AM,PM,WF;
+};
+
+struct OPLL_SLOT
+{
+	// OUTPUT
+	e_int32 feedback;
+	e_int32 output[2];   // Output value of slot
+
+	// for Phase Generator (PG)
+	e_uint16 const* sintbl;    // Wavetable
+	e_uint32 phase;      // Phase
+	e_uint32 dphase;     // Phase increment amount
+	e_uint32 pgout;      // output
+
+	// for Envelope Generator (EG)
+	e_int32 fnum;          // F-Number
+	e_int32 block;         // Block
+	e_int32 volume;        // Current volume
+	e_int32 sustine;       // Sustine 1 = ON, 0 = OFF
+	e_uint32 tll;	      // Total Level + Key scale level
+	e_uint32 rks;        // Key scale offset (Rks)
+	e_int32 eg_mode;       // Current state
+	e_uint32 eg_phase;   // Phase
+	e_uint32 eg_dphase;  // Phase increment amount
+	e_uint32 egout;      // output
+
+	OPLL_PATCH patch;
+	e_uint8 slot_on_flag;
+	e_uint8 filler [7];
+};
+
+#define OPLL_MASK_CH(x) (1<<(x))
+
+struct OPLL
+{
+	OPLL_SLOT slot [6 * 2];
+
+	// Register
+	e_uint8 LowFreq [6];
+	e_uint8 HiFreq  [6];
+	e_uint8 InstVol [6];
+
+	// Channel Data
+	e_uint8 patch_number [6];
+	
+	e_uint8 CustInst [8];
+	
+	// LFO
+	e_uint32 pm_phase;
+	e_uint32 am_phase;
+	
+	e_uint32 pm_dphase;
+	e_uint32 am_dphase;
+	
+	e_int16 pmtable [PM_PG_WIDTH];
+	e_uint8 amtable [AM_PG_WIDTH];
+		
+	e_uint16 sintable [2] [PG_WIDTH]; // [0] = full, [1] = half
+
+	// dB to Liner table
+	e_int16 DB2LIN_TABLE [4 * DB_MUTE];  
+
+	// Liner to Log curve conversion table (for Attack rate).
+	e_uint16 AR_ADJUST_TABLE [1 << EG_BITS];
+
+	// Phase incr table for Attack
+	e_uint32 dphaseARTable [16] [16];
+
+	// Phase incr table for Decay and Release
+	e_uint32 dphaseDRTable [16] [16];
+
+	// KSL + TL Table
+	e_uint8 tllTable [16] [8] [1 << TL_BITS] [4];
+	e_uint8 rksTable [2] [8] [2];
+
+	// Phase incr table for PG  
+	e_uint32 dphaseTable [512] [8] [16];
+};
+
+OPLL* VRC7_new( long clock_rate );
+void VRC7_delete( OPLL* );
+void VRC7_reset( OPLL* );
+
+void VRC7_writeReg( OPLL*, int addr, e_uint32 data );
+
+// Run for one clock
+void VRC7_run( OPLL* );
+
+// Generate sample for a channel
+e_uint32 VRC7_calcCh( OPLL*, e_uint32 channel );
+
+#endif
diff -Nur orig/source/gme/src/Fir_Resampler.cpp mod/source/gme/src/Fir_Resampler.cpp
--- orig/source/gme/src/Fir_Resampler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Fir_Resampler.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,123 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Fir_Resampler.h"
+
+#include <math.h>
+
+/* Copyright (C) 2004-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#undef PI
+#define PI 3.1415926535897932384626433832795029
+
+static void gen_sinc( double rolloff, int width, double offset, double spacing, double scale,
+		int count, short* out )
+{
+	double const maxh = 256;
+	double const step = PI / maxh * spacing;
+	double const to_w = maxh * 2 / width;
+	double const pow_a_n = pow( rolloff, maxh );
+	scale /= maxh * 2;
+	
+	double angle = (count / 2 - 1 + offset) * -step;
+	while ( count-- )
+	{
+		*out++ = 0;
+		double w = angle * to_w;
+		if ( fabs( w ) < PI )
+		{
+			double rolloff_cos_a = rolloff * cos( angle );
+			double num = 1 - rolloff_cos_a -
+					pow_a_n * cos( maxh * angle ) +
+					pow_a_n * rolloff * cos( (maxh - 1) * angle );
+			double den = 1 - rolloff_cos_a - rolloff_cos_a + rolloff * rolloff;
+			double sinc = scale * num / den - scale;
+			
+			out [-1] = (short) (cos( w ) * sinc + sinc);
+		}
+		angle += step;
+	}
+}
+
+Fir_Resampler_::Fir_Resampler_( int width, sample_t impulses_ [] ) :
+	width_( width ),
+	impulses( impulses_ )
+{
+	imp = NULL;
+}
+
+void Fir_Resampler_::clear_()
+{
+	imp = impulses;
+	Resampler::clear_();
+}
+
+blargg_err_t Fir_Resampler_::set_rate_( double new_factor )
+{
+	double const rolloff = 0.999;
+	double const gain = 1.0;
+	
+	// determine number of sub-phases that yield lowest error
+	double ratio_ = 0.0;
+	int res = -1;
+	{
+		double least_error = 2;
+		double pos = 0;
+		for ( int r = 1; r <= max_res; r++ )
+		{
+			pos += new_factor;
+			double nearest = floor( pos + 0.5 );
+			double error = fabs( pos - nearest );
+			if ( error < least_error )
+			{
+				res = r;
+				ratio_ = nearest / res;
+				least_error = error;
+			}
+		}
+	}
+	RETURN_ERR( Resampler::set_rate_( ratio_ ) );
+	
+	// how much of input is used for each output sample
+	int const step = stereo * (int) floor( ratio_ );
+	double fraction = fmod( ratio_, 1.0 );
+	
+	double const filter = (ratio_ < 1.0) ? 1.0 : 1.0 / ratio_;
+	double pos = 0.0;
+	//int input_per_cycle = 0;
+	sample_t* out = impulses;
+	for ( int n = res; --n >= 0; )
+	{
+		gen_sinc( rolloff, int (width_ * filter + 1) & ~1, pos, filter,
+				double (0x7FFF * gain * filter), (int) width_, out );
+		out += width_;
+		
+		int cur_step = step;
+		pos += fraction;
+		if ( pos >= 0.9999999 )
+		{
+			pos -= 1.0;
+			cur_step += stereo;
+		}
+		
+		*out++ = (cur_step - width_ * 2 + 4) * sizeof (sample_t);
+		*out++ = 4 * sizeof (sample_t);
+		//input_per_cycle += cur_step;
+	}
+	// last offset moves back to beginning of impulses
+	out [-1] -= (char*) out - (char*) impulses;
+	
+	imp = impulses;
+	
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Fir_Resampler.h mod/source/gme/src/Fir_Resampler.h
--- orig/source/gme/src/Fir_Resampler.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Fir_Resampler.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,101 @@
+// Finite impulse response (FIR) resampler with adjustable FIR size
+
+// Game_Music_Emu 0.6-pre
+#ifndef FIR_RESAMPLER_H
+#define FIR_RESAMPLER_H
+
+#include "Resampler.h"
+
+template<int width>
+class Fir_Resampler;
+
+// Use one of these typedefs
+typedef Fir_Resampler< 8> Fir_Resampler_Fast;
+typedef Fir_Resampler<16> Fir_Resampler_Norm;
+typedef Fir_Resampler<24> Fir_Resampler_Good;
+
+// Implementation
+class Fir_Resampler_ : public Resampler {
+protected:
+	virtual blargg_err_t set_rate_( double );
+	virtual void clear_();
+
+protected:
+	enum { stereo = 2 };
+	enum { max_res = 32 }; // TODO: eliminate and keep impulses on freestore?
+	sample_t const* imp;
+	int const width_;
+	sample_t* impulses;
+	
+	Fir_Resampler_( int width, sample_t [] );
+};
+
+// Width is number of points in FIR. More points give better quality and
+// rolloff effectiveness, and take longer to calculate.
+template<int width>
+class Fir_Resampler : public Fir_Resampler_ {
+	enum { min_width = (width < 4 ? 4 : width) };
+	enum { adj_width = min_width / 4 * 4 + 2 };
+	enum { write_offset = adj_width * stereo };
+	short impulses [max_res * (adj_width + 2)];
+public:
+	Fir_Resampler() : Fir_Resampler_( adj_width, impulses ) { }
+
+protected:
+	virtual sample_t const* resample_( sample_t**, sample_t const*, sample_t const [], int );
+};
+
+template<int width>
+Resampler::sample_t const* Fir_Resampler<width>::resample_( sample_t** out_,
+		sample_t const* out_end, sample_t const in [], int in_size )
+{
+	in_size -= write_offset;
+	if ( in_size > 0 )
+	{
+		sample_t* BLARGG_RESTRICT out = *out_;
+		sample_t const* const in_end = in + in_size;
+		sample_t const* imp = this->imp;
+		
+		do
+		{
+			// accumulate in extended precision
+			int pt = imp [0];
+			int l = pt * in [0];
+			int r = pt * in [1];
+			if ( out >= out_end )
+				break;
+			for ( int n = (adj_width - 2) / 2; n; --n )
+			{
+				pt = imp [1];
+				l += pt * in [2];
+				r += pt * in [3];
+				
+				// pre-increment more efficient on some RISC processors
+				imp += 2;
+				pt = imp [0];
+				r += pt * in [5];
+				in += 4;
+				l += pt * in [0];
+			}
+			pt = imp [1];
+			l += pt * in [2];
+			r += pt * in [3];
+			
+			// these two "samples" after the end of the impulse give the
+			// proper offsets to the next input sample and next impulse
+			in  = (sample_t const*) ((char const*) in  + imp [2]); // some negative value
+			imp = (sample_t const*) ((char const*) imp + imp [3]); // small positive or large negative
+			
+			out [0] = sample_t (l >> 15);
+			out [1] = sample_t (r >> 15);
+			out += 2;
+		}
+		while ( in < in_end );
+		
+		this->imp = imp;
+		*out_ = out;
+	}
+	return in;
+}
+
+#endif
diff -Nur orig/source/gme/src/fmopl.cpp mod/source/gme/src/fmopl.cpp
--- orig/source/gme/src/fmopl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/fmopl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,2618 @@
+/*
+**
+** File: fmopl.c - software implementation of FM sound generator
+**                                            types OPL and OPL2
+**
+** Copyright Jarek Burczynski (bujar at mame dot net)
+** Copyright Tatsuyuki Satoh , MultiArcadeMachineEmulator development
+**
+** Version 0.72
+**
+
+Revision History:
+
+04-08-2003 Jarek Burczynski:
+ - removed BFRDY hack. BFRDY is busy flag, and it should be 0 only when the chip
+   handles memory read/write or during the adpcm synthesis when the chip
+   requests another byte of ADPCM data.
+
+24-07-2003 Jarek Burczynski:
+ - added a small hack for Y8950 status BFRDY flag (bit 3 should be set after
+   some (unknown) delay). Right now it's always set.
+
+14-06-2003 Jarek Burczynski:
+ - implemented all of the status register flags in Y8950 emulation
+ - renamed y8950_set_delta_t_memory() parameters from _rom_ to _mem_ since
+   they can be either RAM or ROM
+
+08-10-2002 Jarek Burczynski (thanks to Dox for the YM3526 chip)
+ - corrected ym3526_read() to always set bit 2 and bit 1
+   to HIGH state - identical to ym3812_read (verified on real YM3526)
+
+04-28-2002 Jarek Burczynski:
+ - binary exact Envelope Generator (verified on real YM3812);
+   compared to YM2151: the EG clock is equal to internal_clock,
+   rates are 2 times slower and volume resolution is one bit less
+ - modified interface functions (they no longer return pointer -
+   that's internal to the emulator now):
+    - new wrapper functions for OPLCreate: ym3526_init(), ym3812_init() and y8950_init()
+ - corrected 'off by one' error in feedback calculations (when feedback is off)
+ - enabled waveform usage (credit goes to Vlad Romascanu and zazzal22)
+ - speeded up noise generator calculations (Nicola Salmoria)
+
+03-24-2002 Jarek Burczynski (thanks to Dox for the YM3812 chip)
+ Complete rewrite (all verified on real YM3812):
+ - corrected sin_tab and tl_tab data
+ - corrected operator output calculations
+ - corrected waveform_select_enable register;
+   simply: ignore all writes to waveform_select register when
+   waveform_select_enable == 0 and do not change the waveform previously selected.
+ - corrected KSR handling
+ - corrected Envelope Generator: attack shape, Sustain mode and
+   Percussive/Non-percussive modes handling
+ - Envelope Generator rates are two times slower now
+ - LFO amplitude (tremolo) and phase modulation (vibrato)
+ - rhythm sounds phase generation
+ - white noise generator (big thanks to Olivier Galibert for mentioning Berlekamp-Massey algorithm)
+ - corrected key on/off handling (the 'key' signal is ORed from three sources: FM, rhythm and CSM)
+ - funky details (like ignoring output of operator 1 in BD rhythm sound when connect == 1)
+
+12-28-2001 Acho A. Tang
+ - reflected Delta-T EOS status on Y8950 status port.
+ - fixed subscription range of attack/decay tables
+
+
+    To do:
+        add delay before key off in CSM mode (see CSMKeyControll)
+        verify volume of the FM part on the Y8950
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include "fmopl.h"
+#include "ymdeltat.h"
+
+#define INLINE __inline
+#ifndef NULL
+	#define NULL ((void *)0)
+#endif
+#define logerror (void)
+
+#ifndef M_PI
+	#define M_PI 3.14159265358979323846
+#endif
+
+/* output final shift */
+#if (OPL_SAMPLE_BITS==16)
+	#define FINAL_SH	(0)
+	#define MAXOUT		(+32767)
+	#define MINOUT		(-32768)
+#else
+	#define FINAL_SH	(8)
+	#define MAXOUT		(+127)
+	#define MINOUT		(-128)
+#endif
+
+
+#define FREQ_SH			16  /* 16.16 fixed point (frequency calculations) */
+#define EG_SH			16  /* 16.16 fixed point (EG timing)              */
+#define LFO_SH			24  /*  8.24 fixed point (LFO calculations)       */
+#define TIMER_SH		16  /* 16.16 fixed point (timers calculations)    */
+
+#define FREQ_MASK		((1<<FREQ_SH)-1)
+
+/* envelope output entries */
+#define ENV_BITS		10
+#define ENV_LEN			(1<<ENV_BITS)
+#define ENV_STEP		(128.0/ENV_LEN)
+
+#define MAX_ATT_INDEX	((1<<(ENV_BITS-1))-1) /*511*/
+#define MIN_ATT_INDEX	(0)
+
+/* sinwave entries */
+#define SIN_BITS		10
+#define SIN_LEN			(1<<SIN_BITS)
+#define SIN_MASK		(SIN_LEN-1)
+
+#define TL_RES_LEN		(256)	/* 8 bits addressing (real chip) */
+
+
+
+/* register number to channel number , slot offset */
+#define SLOT1 0
+#define SLOT2 1
+
+/* Envelope Generator phases */
+
+#define EG_ATT			4
+#define EG_DEC			3
+#define EG_SUS			2
+#define EG_REL			1
+#define EG_OFF			0
+
+
+/* save output as raw 16-bit sample */
+
+/*#define SAVE_SAMPLE*/
+
+#ifdef SAVE_SAMPLE
+INLINE signed int acc_calc(signed int value)
+{
+	if (value>=0)
+	{
+		if (value < 0x0200)
+			return (value & ~0);
+		if (value < 0x0400)
+			return (value & ~1);
+		if (value < 0x0800)
+			return (value & ~3);
+		if (value < 0x1000)
+			return (value & ~7);
+		if (value < 0x2000)
+			return (value & ~15);
+		if (value < 0x4000)
+			return (value & ~31);
+		return (value & ~63);
+	}
+	/*else value < 0*/
+	if (value > -0x0200)
+		return (~abs(value) & ~0);
+	if (value > -0x0400)
+		return (~abs(value) & ~1);
+	if (value > -0x0800)
+		return (~abs(value) & ~3);
+	if (value > -0x1000)
+		return (~abs(value) & ~7);
+	if (value > -0x2000)
+		return (~abs(value) & ~15);
+	if (value > -0x4000)
+		return (~abs(value) & ~31);
+	return (~abs(value) & ~63);
+}
+
+
+static FILE *sample[1];
+	#if 1	/*save to MONO file */
+		#define SAVE_ALL_CHANNELS \
+		{	signed int pom = acc_calc(lt); \
+			fputc((unsigned short)pom&0xff,sample[0]); \
+			fputc(((unsigned short)pom>>8)&0xff,sample[0]); \
+		}
+	#else	/*save to STEREO file */
+		#define SAVE_ALL_CHANNELS \
+		{	signed int pom = lt; \
+			fputc((unsigned short)pom&0xff,sample[0]); \
+			fputc(((unsigned short)pom>>8)&0xff,sample[0]); \
+			pom = rt; \
+			fputc((unsigned short)pom&0xff,sample[0]); \
+			fputc(((unsigned short)pom>>8)&0xff,sample[0]); \
+		}
+	#endif
+#endif
+
+#define LOG_CYM_FILE 0
+//static FILE * cymfile = NULL;
+
+
+
+#define OPL_TYPE_WAVESEL   0x01  /* waveform select     */
+#define OPL_TYPE_ADPCM     0x02  /* DELTA-T ADPCM unit  */
+#define OPL_TYPE_KEYBOARD  0x04  /* keyboard interface  */
+#define OPL_TYPE_IO        0x08  /* I/O port            */
+
+/* ---------- Generic interface section ---------- */
+#define OPL_TYPE_YM3526 (0)
+#define OPL_TYPE_YM3812 (OPL_TYPE_WAVESEL)
+#define OPL_TYPE_Y8950  (OPL_TYPE_ADPCM|OPL_TYPE_KEYBOARD|OPL_TYPE_IO)
+
+
+
+typedef struct{
+	UINT32	ar;			/* attack rate: AR<<2           */
+	UINT32	dr;			/* decay rate:  DR<<2           */
+	UINT32	rr;			/* release rate:RR<<2           */
+	UINT8	KSR;		/* key scale rate               */
+	UINT8	ksl;		/* keyscale level               */
+	UINT8	ksr;		/* key scale rate: kcode>>KSR   */
+	UINT8	mul;		/* multiple: mul_tab[ML]        */
+
+	/* Phase Generator */
+	UINT32	Cnt;		/* frequency counter            */
+	UINT32	Incr;		/* frequency counter step       */
+	UINT8   FB;			/* feedback shift value         */
+	INT32   *connect1;	/* slot1 output pointer         */
+	INT32   op1_out[2];	/* slot1 output for feedback    */
+	UINT8   CON;		/* connection (algorithm) type  */
+
+	/* Envelope Generator */
+	UINT8	eg_type;	/* percussive/non-percussive mode */
+	UINT8	state;		/* phase type                   */
+	UINT32	TL;			/* total level: TL << 2         */
+	INT32	TLL;		/* adjusted now TL              */
+	INT32	volume;		/* envelope counter             */
+	UINT32	sl;			/* sustain level: sl_tab[SL]    */
+	UINT8	eg_sh_ar;	/* (attack state)               */
+	UINT8	eg_sel_ar;	/* (attack state)               */
+	UINT8	eg_sh_dr;	/* (decay state)                */
+	UINT8	eg_sel_dr;	/* (decay state)                */
+	UINT8	eg_sh_rr;	/* (release state)              */
+	UINT8	eg_sel_rr;	/* (release state)              */
+	UINT32	key;		/* 0 = KEY OFF, >0 = KEY ON     */
+
+	/* LFO */
+	UINT32	AMmask;		/* LFO Amplitude Modulation enable mask */
+	UINT8	vib;		/* LFO Phase Modulation enable flag (active high)*/
+
+	/* waveform select */
+	UINT16	wavetable;
+} OPL_SLOT;
+
+typedef struct{
+	OPL_SLOT SLOT[2];
+	/* phase generator state */
+	UINT32  block_fnum;	/* block+fnum                   */
+	UINT32  fc;			/* Freq. Increment base         */
+	UINT32  ksl_base;	/* KeyScaleLevel Base step      */
+	UINT8   kcode;		/* key code (for key scaling)   */
+} OPL_CH;
+
+/* OPL state */
+typedef struct fm_opl_f {
+	/* FM channel slots */
+	OPL_CH	P_CH[9];				/* OPL/OPL2 chips have 9 channels*/
+
+	UINT32	eg_cnt;					/* global envelope generator counter    */
+	UINT32	eg_timer;				/* global envelope generator counter works at frequency = chipclock/72 */
+	UINT32	eg_timer_add;			/* step of eg_timer                     */
+	UINT32	eg_timer_overflow;		/* envelope generator timer overlfows every 1 sample (on real chip) */
+
+	UINT8	rhythm;					/* Rhythm mode                  */
+
+	UINT32	fn_tab[1024];			/* fnumber->increment counter   */
+
+	/* LFO */
+	UINT8	lfo_am_depth;
+	UINT8	lfo_pm_depth_range;
+	UINT32	lfo_am_cnt;
+	UINT32	lfo_am_inc;
+	UINT32	lfo_pm_cnt;
+	UINT32	lfo_pm_inc;
+
+	UINT32	noise_rng;				/* 23 bit noise shift register  */
+	UINT32	noise_p;				/* current noise 'phase'        */
+	UINT32	noise_f;				/* current noise period         */
+
+	UINT8	wavesel;				/* waveform select enable flag  */
+
+	UINT32	T[2];					/* timer counters               */
+	UINT8	st[2];					/* timer enable                 */
+
+#if BUILD_Y8950
+	/* Delta-T ADPCM unit (Y8950) */
+
+	YM_DELTAT *deltat;
+
+	/* Keyboard and I/O ports interface */
+	UINT8	portDirection;
+	UINT8	portLatch;
+	OPL_PORTHANDLER_R porthandler_r;
+	OPL_PORTHANDLER_W porthandler_w;
+	void *	port_param;
+	OPL_PORTHANDLER_R keyboardhandler_r;
+	OPL_PORTHANDLER_W keyboardhandler_w;
+	void *	keyboard_param;
+#endif
+
+	/* external event callback handlers */
+	//OPL_TIMERHANDLER  timer_handler;	/* TIMER handler                */
+	void *TimerParam;					/* TIMER parameter              */
+	OPL_IRQHANDLER    IRQHandler;	/* IRQ handler                  */
+	void *IRQParam;					/* IRQ parameter                */
+	OPL_UPDATEHANDLER UpdateHandler;/* stream update handler        */
+	void *UpdateParam;				/* stream update parameter      */
+
+	UINT8 type;						/* chip type                    */
+	UINT8 address;					/* address register             */
+	UINT8 status;					/* status flag                  */
+	UINT8 statusmask;				/* status mask                  */
+	UINT8 mode;						/* Reg.08 : CSM,notesel,etc.    */
+
+	UINT32 clock;					/* master clock  (Hz)           */
+	UINT32 rate;					/* sampling rate (Hz)           */
+	double freqbase;				/* frequency base               */
+	//attotime TimerBase;			/* Timer base time (==sampling time)*/
+
+	OPL_SLOT *SLOT7_1, *SLOT7_2, *SLOT8_1, *SLOT8_2;
+
+	signed int phase_modulation;	/* phase modulation input (SLOT 2) */
+	signed int output[1];
+
+#if BUILD_Y8950
+	INT32 output_deltat[4];		/* for Y8950 DELTA-T, chip is mono, that 4 here is just for safety */
+#endif
+
+	UINT32	LFO_AM;
+	INT32	LFO_PM;
+} FM_OPL;
+
+
+
+/* mapping of register number (offset) to slot number used by the emulator */
+static const int slot_array[32]=
+{
+	 0, 2, 4, 1, 3, 5,-1,-1,
+	 6, 8,10, 7, 9,11,-1,-1,
+	12,14,16,13,15,17,-1,-1,
+	-1,-1,-1,-1,-1,-1,-1,-1
+};
+
+/* key scale level */
+/* table is 3dB/octave , DV converts this into 6dB/octave */
+/* 0.1875 is bit 0 weight of the envelope counter (volume) expressed in the 'decibel' scale */
+#define DV (0.1875/2.0)
+static double /*const UINT32*/ ksl_tab[8*16]=
+{
+	/* OCT 0 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	/* OCT 1 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.750/DV, 1.125/DV, 1.500/DV,
+	 1.875/DV, 2.250/DV, 2.625/DV, 3.000/DV,
+	/* OCT 2 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 1.125/DV, 1.875/DV, 2.625/DV,
+	 3.000/DV, 3.750/DV, 4.125/DV, 4.500/DV,
+	 4.875/DV, 5.250/DV, 5.625/DV, 6.000/DV,
+	/* OCT 3 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 1.875/DV,
+	 3.000/DV, 4.125/DV, 4.875/DV, 5.625/DV,
+	 6.000/DV, 6.750/DV, 7.125/DV, 7.500/DV,
+	 7.875/DV, 8.250/DV, 8.625/DV, 9.000/DV,
+	/* OCT 4 */
+	 0.000/DV, 0.000/DV, 3.000/DV, 4.875/DV,
+	 6.000/DV, 7.125/DV, 7.875/DV, 8.625/DV,
+	 9.000/DV, 9.750/DV,10.125/DV,10.500/DV,
+	10.875/DV,11.250/DV,11.625/DV,12.000/DV,
+	/* OCT 5 */
+	 0.000/DV, 3.000/DV, 6.000/DV, 7.875/DV,
+	 9.000/DV,10.125/DV,10.875/DV,11.625/DV,
+	12.000/DV,12.750/DV,13.125/DV,13.500/DV,
+	13.875/DV,14.250/DV,14.625/DV,15.000/DV,
+	/* OCT 6 */
+	 0.000/DV, 6.000/DV, 9.000/DV,10.875/DV,
+	12.000/DV,13.125/DV,13.875/DV,14.625/DV,
+	15.000/DV,15.750/DV,16.125/DV,16.500/DV,
+	16.875/DV,17.250/DV,17.625/DV,18.000/DV,
+	/* OCT 7 */
+	 0.000/DV, 9.000/DV,12.000/DV,13.875/DV,
+	15.000/DV,16.125/DV,16.875/DV,17.625/DV,
+	18.000/DV,18.750/DV,19.125/DV,19.500/DV,
+	19.875/DV,20.250/DV,20.625/DV,21.000/DV
+};
+#undef DV
+
+/* sustain level table (3dB per step) */
+/* 0 - 15: 0, 3, 6, 9,12,15,18,21,24,27,30,33,36,39,42,93 (dB)*/
+#define SC(db) (UINT32) ( db * (2.0/ENV_STEP) )
+static const UINT32 sl_tab[16]={
+ SC( 0),SC( 1),SC( 2),SC(3 ),SC(4 ),SC(5 ),SC(6 ),SC( 7),
+ SC( 8),SC( 9),SC(10),SC(11),SC(12),SC(13),SC(14),SC(31)
+};
+#undef SC
+
+
+#define RATE_STEPS (8)
+static const unsigned char eg_inc[15*RATE_STEPS]={
+
+/*cycle:0 1  2 3  4 5  6 7*/
+
+/* 0 */ 0,1, 0,1, 0,1, 0,1, /* rates 00..12 0 (increment by 0 or 1) */
+/* 1 */ 0,1, 0,1, 1,1, 0,1, /* rates 00..12 1 */
+/* 2 */ 0,1, 1,1, 0,1, 1,1, /* rates 00..12 2 */
+/* 3 */ 0,1, 1,1, 1,1, 1,1, /* rates 00..12 3 */
+
+/* 4 */ 1,1, 1,1, 1,1, 1,1, /* rate 13 0 (increment by 1) */
+/* 5 */ 1,1, 1,2, 1,1, 1,2, /* rate 13 1 */
+/* 6 */ 1,2, 1,2, 1,2, 1,2, /* rate 13 2 */
+/* 7 */ 1,2, 2,2, 1,2, 2,2, /* rate 13 3 */
+
+/* 8 */ 2,2, 2,2, 2,2, 2,2, /* rate 14 0 (increment by 2) */
+/* 9 */ 2,2, 2,4, 2,2, 2,4, /* rate 14 1 */
+/*10 */ 2,4, 2,4, 2,4, 2,4, /* rate 14 2 */
+/*11 */ 2,4, 4,4, 2,4, 4,4, /* rate 14 3 */
+
+/*12 */ 4,4, 4,4, 4,4, 4,4, /* rates 15 0, 15 1, 15 2, 15 3 (increment by 4) */
+/*13 */ 8,8, 8,8, 8,8, 8,8, /* rates 15 2, 15 3 for attack */
+/*14 */ 0,0, 0,0, 0,0, 0,0, /* infinity rates for attack and decay(s) */
+};
+
+
+#define O(a) (a*RATE_STEPS)
+
+/*note that there is no O(13) in this table - it's directly in the code */
+static const unsigned char eg_rate_select[16+64+16]={	/* Envelope Generator rates (16 + 64 rates + 16 RKS) */
+/* 16 infinite time rates */
+O(14),O(14),O(14),O(14),O(14),O(14),O(14),O(14),
+O(14),O(14),O(14),O(14),O(14),O(14),O(14),O(14),
+
+/* rates 00-12 */
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+
+/* rate 13 */
+O( 4),O( 5),O( 6),O( 7),
+
+/* rate 14 */
+O( 8),O( 9),O(10),O(11),
+
+/* rate 15 */
+O(12),O(12),O(12),O(12),
+
+/* 16 dummy rates (same as 15 3) */
+O(12),O(12),O(12),O(12),O(12),O(12),O(12),O(12),
+O(12),O(12),O(12),O(12),O(12),O(12),O(12),O(12),
+
+};
+#undef O
+
+/*rate  0,    1,    2,    3,   4,   5,   6,  7,  8,  9,  10, 11, 12, 13, 14, 15 */
+/*shift 12,   11,   10,   9,   8,   7,   6,  5,  4,  3,  2,  1,  0,  0,  0,  0  */
+/*mask  4095, 2047, 1023, 511, 255, 127, 63, 31, 15, 7,  3,  1,  0,  0,  0,  0  */
+
+#define O(a) (a*1)
+static const unsigned char eg_rate_shift[16+64+16]={	/* Envelope Generator counter shifts (16 + 64 rates + 16 RKS) */
+/* 16 infinite time rates */
+O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
+O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
+
+/* rates 00-12 */
+O(12),O(12),O(12),O(12),
+O(11),O(11),O(11),O(11),
+O(10),O(10),O(10),O(10),
+O( 9),O( 9),O( 9),O( 9),
+O( 8),O( 8),O( 8),O( 8),
+O( 7),O( 7),O( 7),O( 7),
+O( 6),O( 6),O( 6),O( 6),
+O( 5),O( 5),O( 5),O( 5),
+O( 4),O( 4),O( 4),O( 4),
+O( 3),O( 3),O( 3),O( 3),
+O( 2),O( 2),O( 2),O( 2),
+O( 1),O( 1),O( 1),O( 1),
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 13 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 14 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 15 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* 16 dummy rates (same as 15 3) */
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),
+
+};
+#undef O
+
+
+/* multiple table */
+#define ML 2
+static double/*const UINT8*/ mul_tab[16]= {
+/* 1/2, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,10,12,12,15,15 */
+   0.50*ML, 1.00*ML, 2.00*ML, 3.00*ML, 4.00*ML, 5.00*ML, 6.00*ML, 7.00*ML,
+   8.00*ML, 9.00*ML,10.00*ML,10.00*ML,12.00*ML,12.00*ML,15.00*ML,15.00*ML
+};
+#undef ML
+
+/*  TL_TAB_LEN is calculated as:
+*   12 - sinus amplitude bits     (Y axis)
+*   2  - sinus sign bit           (Y axis)
+*   TL_RES_LEN - sinus resolution (X axis)
+*/
+#define TL_TAB_LEN (12*2*TL_RES_LEN)
+static signed int tl_tab[TL_TAB_LEN];
+
+#define ENV_QUIET		(TL_TAB_LEN>>4)
+
+/* sin waveform table in 'decibel' scale */
+/* four waveforms on OPL2 type chips */
+static unsigned int sin_tab[SIN_LEN * 4];
+
+
+/* LFO Amplitude Modulation table (verified on real YM3812)
+   27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples
+
+   Length: 210 elements.
+
+    Each of the elements has to be repeated
+    exactly 64 times (on 64 consecutive samples).
+    The whole table takes: 64 * 210 = 13440 samples.
+
+    When AM = 1 data is used directly
+    When AM = 0 data is divided by 4 before being used (loosing precision is important)
+*/
+
+#define LFO_AM_TAB_ELEMENTS 210
+
+static const UINT8 lfo_am_table[LFO_AM_TAB_ELEMENTS] = {
+0,0,0,0,0,0,0,
+1,1,1,1,
+2,2,2,2,
+3,3,3,3,
+4,4,4,4,
+5,5,5,5,
+6,6,6,6,
+7,7,7,7,
+8,8,8,8,
+9,9,9,9,
+10,10,10,10,
+11,11,11,11,
+12,12,12,12,
+13,13,13,13,
+14,14,14,14,
+15,15,15,15,
+16,16,16,16,
+17,17,17,17,
+18,18,18,18,
+19,19,19,19,
+20,20,20,20,
+21,21,21,21,
+22,22,22,22,
+23,23,23,23,
+24,24,24,24,
+25,25,25,25,
+26,26,26,
+25,25,25,25,
+24,24,24,24,
+23,23,23,23,
+22,22,22,22,
+21,21,21,21,
+20,20,20,20,
+19,19,19,19,
+18,18,18,18,
+17,17,17,17,
+16,16,16,16,
+15,15,15,15,
+14,14,14,14,
+13,13,13,13,
+12,12,12,12,
+11,11,11,11,
+10,10,10,10,
+9,9,9,9,
+8,8,8,8,
+7,7,7,7,
+6,6,6,6,
+5,5,5,5,
+4,4,4,4,
+3,3,3,3,
+2,2,2,2,
+1,1,1,1
+};
+
+/* LFO Phase Modulation table (verified on real YM3812) */
+static const INT8 lfo_pm_table[8*8*2] = {
+
+/* FNUM2/FNUM = 00 0xxxxxxx (0x0000) */
+0, 0, 0, 0, 0, 0, 0, 0,	/*LFO PM depth = 0*/
+0, 0, 0, 0, 0, 0, 0, 0,	/*LFO PM depth = 1*/
+
+/* FNUM2/FNUM = 00 1xxxxxxx (0x0080) */
+0, 0, 0, 0, 0, 0, 0, 0,	/*LFO PM depth = 0*/
+1, 0, 0, 0,-1, 0, 0, 0,	/*LFO PM depth = 1*/
+
+/* FNUM2/FNUM = 01 0xxxxxxx (0x0100) */
+1, 0, 0, 0,-1, 0, 0, 0,	/*LFO PM depth = 0*/
+2, 1, 0,-1,-2,-1, 0, 1,	/*LFO PM depth = 1*/
+
+/* FNUM2/FNUM = 01 1xxxxxxx (0x0180) */
+1, 0, 0, 0,-1, 0, 0, 0,	/*LFO PM depth = 0*/
+3, 1, 0,-1,-3,-1, 0, 1,	/*LFO PM depth = 1*/
+
+/* FNUM2/FNUM = 10 0xxxxxxx (0x0200) */
+2, 1, 0,-1,-2,-1, 0, 1,	/*LFO PM depth = 0*/
+4, 2, 0,-2,-4,-2, 0, 2,	/*LFO PM depth = 1*/
+
+/* FNUM2/FNUM = 10 1xxxxxxx (0x0280) */
+2, 1, 0,-1,-2,-1, 0, 1,	/*LFO PM depth = 0*/
+5, 2, 0,-2,-5,-2, 0, 2,	/*LFO PM depth = 1*/
+
+/* FNUM2/FNUM = 11 0xxxxxxx (0x0300) */
+3, 1, 0,-1,-3,-1, 0, 1,	/*LFO PM depth = 0*/
+6, 3, 0,-3,-6,-3, 0, 3,	/*LFO PM depth = 1*/
+
+/* FNUM2/FNUM = 11 1xxxxxxx (0x0380) */
+3, 1, 0,-1,-3,-1, 0, 1,	/*LFO PM depth = 0*/
+7, 3, 0,-3,-7,-3, 0, 3	/*LFO PM depth = 1*/
+};
+
+
+/* lock level of common table */
+//static int num_lock = 0;
+
+
+//static void *cur_chip = NULL;	/* current chip pointer */
+
+INLINE int limit( int val, int max, int min ) {
+	if ( val > max )
+		val = max;
+	else if ( val < min )
+		val = min;
+
+	return val;
+}
+
+
+/* status set and IRQ handling */
+INLINE void OPL_STATUS_SET(FM_OPL *OPL,int flag)
+{
+	/* set status flag */
+	OPL->status |= flag;
+	if(!(OPL->status & 0x80))
+	{
+		if(OPL->status & OPL->statusmask)
+		{	/* IRQ on */
+			OPL->status |= 0x80;
+			/* callback user interrupt handler (IRQ is OFF to ON) */
+			if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,1);
+		}
+	}
+}
+
+/* status reset and IRQ handling */
+INLINE void OPL_STATUS_RESET(FM_OPL *OPL,int flag)
+{
+	/* reset status flag */
+	OPL->status &=~flag;
+	if((OPL->status & 0x80))
+	{
+		if (!(OPL->status & OPL->statusmask) )
+		{
+			OPL->status &= 0x7f;
+			/* callback user interrupt handler (IRQ is ON to OFF) */
+			if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,0);
+		}
+	}
+}
+
+/* IRQ mask set */
+INLINE void OPL_STATUSMASK_SET(FM_OPL *OPL,int flag)
+{
+	OPL->statusmask = flag;
+	/* IRQ handling check */
+	OPL_STATUS_SET(OPL,0);
+	OPL_STATUS_RESET(OPL,0);
+}
+
+
+/* advance LFO to next sample */
+INLINE void advance_lfo(FM_OPL *OPL)
+{
+	UINT8 tmp;
+
+	/* LFO */
+	OPL->lfo_am_cnt += OPL->lfo_am_inc;
+	if (OPL->lfo_am_cnt >= ((UINT32)LFO_AM_TAB_ELEMENTS<<LFO_SH) )	/* lfo_am_table is 210 elements long */
+		OPL->lfo_am_cnt -= ((UINT32)LFO_AM_TAB_ELEMENTS<<LFO_SH);
+
+	tmp = lfo_am_table[ OPL->lfo_am_cnt >> LFO_SH ];
+
+	if (OPL->lfo_am_depth)
+		OPL->LFO_AM = tmp;
+	else
+		OPL->LFO_AM = tmp>>2;
+
+	OPL->lfo_pm_cnt += OPL->lfo_pm_inc;
+	OPL->LFO_PM = ((OPL->lfo_pm_cnt>>LFO_SH) & 7) | OPL->lfo_pm_depth_range;
+}
+
+/* advance to next sample */
+INLINE void advance(FM_OPL *OPL)
+{
+	OPL_CH *CH;
+	OPL_SLOT *op;
+	int i;
+
+	OPL->eg_timer += OPL->eg_timer_add;
+
+	while (OPL->eg_timer >= OPL->eg_timer_overflow)
+	{
+		OPL->eg_timer -= OPL->eg_timer_overflow;
+
+		OPL->eg_cnt++;
+
+		for (i=0; i<9*2; i++)
+		{
+			CH  = &OPL->P_CH[i/2];
+			op  = &CH->SLOT[i&1];
+
+			/* Envelope Generator */
+			switch(op->state)
+			{
+			case EG_ATT:		/* attack phase */
+				if ( !(OPL->eg_cnt & ((1<<op->eg_sh_ar)-1) ) )
+				{
+					op->volume += (~op->volume *
+	                        		           (eg_inc[op->eg_sel_ar + ((OPL->eg_cnt>>op->eg_sh_ar)&7)])
+        			                          ) >>3;
+
+					if (op->volume <= MIN_ATT_INDEX)
+					{
+						op->volume = MIN_ATT_INDEX;
+						op->state = EG_DEC;
+					}
+
+				}
+			break;
+
+			case EG_DEC:	/* decay phase */
+				if ( !(OPL->eg_cnt & ((1<<op->eg_sh_dr)-1) ) )
+				{
+					op->volume += eg_inc[op->eg_sel_dr + ((OPL->eg_cnt>>op->eg_sh_dr)&7)];
+
+					if ( op->volume >= op->sl )
+						op->state = EG_SUS;
+
+				}
+			break;
+
+			case EG_SUS:	/* sustain phase */
+
+				/* this is important behaviour:
+                one can change percusive/non-percussive modes on the fly and
+                the chip will remain in sustain phase - verified on real YM3812 */
+
+				if(op->eg_type)		/* non-percussive mode */
+				{
+									/* do nothing */
+				}
+				else				/* percussive mode */
+				{
+					/* during sustain phase chip adds Release Rate (in percussive mode) */
+					if ( !(OPL->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )
+					{
+						op->volume += eg_inc[op->eg_sel_rr + ((OPL->eg_cnt>>op->eg_sh_rr)&7)];
+
+						if ( op->volume >= MAX_ATT_INDEX )
+							op->volume = MAX_ATT_INDEX;
+					}
+					/* else do nothing in sustain phase */
+				}
+			break;
+
+			case EG_REL:	/* release phase */
+				if ( !(OPL->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )
+				{
+					op->volume += eg_inc[op->eg_sel_rr + ((OPL->eg_cnt>>op->eg_sh_rr)&7)];
+
+					if ( op->volume >= MAX_ATT_INDEX )
+					{
+						op->volume = MAX_ATT_INDEX;
+						op->state = EG_OFF;
+					}
+
+				}
+			break;
+
+			default:
+			break;
+			}
+		}
+	}
+
+	for (i=0; i<9*2; i++)
+	{
+		CH  = &OPL->P_CH[i/2];
+		op  = &CH->SLOT[i&1];
+
+		/* Phase Generator */
+		if(op->vib)
+		{
+			UINT8 block;
+			unsigned int block_fnum = CH->block_fnum;
+
+			unsigned int fnum_lfo   = (block_fnum&0x0380) >> 7;
+
+			signed int lfo_fn_table_index_offset = lfo_pm_table[OPL->LFO_PM + 16*fnum_lfo ];
+
+			if (lfo_fn_table_index_offset)	/* LFO phase modulation active */
+			{
+				block_fnum += lfo_fn_table_index_offset;
+				block = (block_fnum&0x1c00) >> 10;
+				op->Cnt += (OPL->fn_tab[block_fnum&0x03ff] >> (7-block)) * op->mul;
+			}
+			else	/* LFO phase modulation  = zero */
+			{
+				op->Cnt += op->Incr;
+			}
+		}
+		else	/* LFO phase modulation disabled for this operator */
+		{
+			op->Cnt += op->Incr;
+		}
+	}
+
+	/*  The Noise Generator of the YM3812 is 23-bit shift register.
+    *   Period is equal to 2^23-2 samples.
+    *   Register works at sampling frequency of the chip, so output
+    *   can change on every sample.
+    *
+    *   Output of the register and input to the bit 22 is:
+    *   bit0 XOR bit14 XOR bit15 XOR bit22
+    *
+    *   Simply use bit 22 as the noise output.
+    */
+
+	OPL->noise_p += OPL->noise_f;
+	i = OPL->noise_p >> FREQ_SH;		/* number of events (shifts of the shift register) */
+	OPL->noise_p &= FREQ_MASK;
+	while (i)
+	{
+		/*
+        UINT32 j;
+        j = ( (OPL->noise_rng) ^ (OPL->noise_rng>>14) ^ (OPL->noise_rng>>15) ^ (OPL->noise_rng>>22) ) & 1;
+        OPL->noise_rng = (j<<22) | (OPL->noise_rng>>1);
+        */
+
+		/*
+            Instead of doing all the logic operations above, we
+            use a trick here (and use bit 0 as the noise output).
+            The difference is only that the noise bit changes one
+            step ahead. This doesn't matter since we don't know
+            what is real state of the noise_rng after the reset.
+        */
+
+		if (OPL->noise_rng & 1) OPL->noise_rng ^= 0x800302;
+		OPL->noise_rng >>= 1;
+
+		i--;
+	}
+}
+
+
+INLINE signed int op_calc(UINT32 phase, unsigned int env, signed int pm, unsigned int wave_tab)
+{
+	UINT32 p;
+
+	p = (env<<4) + sin_tab[wave_tab + ((((signed int)((phase & ~FREQ_MASK) + (pm<<16))) >> FREQ_SH ) & SIN_MASK) ];
+
+	if (p >= TL_TAB_LEN)
+		return 0;
+	return tl_tab[p];
+}
+
+INLINE signed int op_calc1(UINT32 phase, unsigned int env, signed int pm, unsigned int wave_tab)
+{
+	UINT32 p;
+
+	p = (env<<4) + sin_tab[wave_tab + ((((signed int)((phase & ~FREQ_MASK) + pm      )) >> FREQ_SH ) & SIN_MASK) ];
+
+	if (p >= TL_TAB_LEN)
+		return 0;
+	return tl_tab[p];
+}
+
+
+#define volume_calc(OP) ((OP)->TLL + ((UINT32)(OP)->volume) + (OPL->LFO_AM & (OP)->AMmask))
+
+/* calculate output */
+INLINE void OPL_CALC_CH( FM_OPL *OPL, OPL_CH *CH )
+{
+	OPL_SLOT *SLOT;
+	unsigned int env;
+	signed int out;
+
+	OPL->phase_modulation = 0;
+
+	/* SLOT 1 */
+	SLOT = &CH->SLOT[SLOT1];
+	env  = volume_calc(SLOT);
+	out  = SLOT->op1_out[0] + SLOT->op1_out[1];
+	SLOT->op1_out[0] = SLOT->op1_out[1];
+	*SLOT->connect1 += SLOT->op1_out[0];
+	SLOT->op1_out[1] = 0;
+	if( env < ENV_QUIET )
+	{
+		if (!SLOT->FB)
+			out = 0;
+		SLOT->op1_out[1] = op_calc1(SLOT->Cnt, env, (out<<SLOT->FB), SLOT->wavetable );
+	}
+
+	/* SLOT 2 */
+	SLOT++;
+	env = volume_calc(SLOT);
+	if( env < ENV_QUIET )
+		OPL->output[0] += op_calc(SLOT->Cnt, env, OPL->phase_modulation, SLOT->wavetable);
+}
+
+/*
+    operators used in the rhythm sounds generation process:
+
+    Envelope Generator:
+
+channel  operator  register number   Bass  High  Snare Tom  Top
+/ slot   number    TL ARDR SLRR Wave Drum  Hat   Drum  Tom  Cymbal
+ 6 / 0   12        50  70   90   f0  +
+ 6 / 1   15        53  73   93   f3  +
+ 7 / 0   13        51  71   91   f1        +
+ 7 / 1   16        54  74   94   f4              +
+ 8 / 0   14        52  72   92   f2                    +
+ 8 / 1   17        55  75   95   f5                          +
+
+    Phase Generator:
+
+channel  operator  register number   Bass  High  Snare Tom  Top
+/ slot   number    MULTIPLE          Drum  Hat   Drum  Tom  Cymbal
+ 6 / 0   12        30                +
+ 6 / 1   15        33                +
+ 7 / 0   13        31                      +     +           +
+ 7 / 1   16        34                -----  n o t  u s e d -----
+ 8 / 0   14        32                                  +
+ 8 / 1   17        35                      +                 +
+
+channel  operator  register number   Bass  High  Snare Tom  Top
+number   number    BLK/FNUM2 FNUM    Drum  Hat   Drum  Tom  Cymbal
+   6     12,15     B6        A6      +
+
+   7     13,16     B7        A7            +     +           +
+
+   8     14,17     B8        A8            +           +     +
+
+*/
+
+/* calculate rhythm */
+
+INLINE void OPL_CALC_RH( FM_OPL *OPL, OPL_CH *CH, unsigned int noise )
+{
+	OPL_SLOT *SLOT;
+	signed int out;
+	unsigned int env;
+
+
+	/* Bass Drum (verified on real YM3812):
+      - depends on the channel 6 'connect' register:
+          when connect = 0 it works the same as in normal (non-rhythm) mode (op1->op2->out)
+          when connect = 1 _only_ operator 2 is present on output (op2->out), operator 1 is ignored
+      - output sample always is multiplied by 2
+    */
+
+	OPL->phase_modulation = 0;
+	/* SLOT 1 */
+	SLOT = &CH[6].SLOT[SLOT1];
+	env = volume_calc(SLOT);
+
+	out = SLOT->op1_out[0] + SLOT->op1_out[1];
+	SLOT->op1_out[0] = SLOT->op1_out[1];
+
+	if (!SLOT->CON)
+		OPL->phase_modulation = SLOT->op1_out[0];
+	/* else ignore output of operator 1 */
+
+	SLOT->op1_out[1] = 0;
+	if( env < ENV_QUIET )
+	{
+		if (!SLOT->FB)
+			out = 0;
+		SLOT->op1_out[1] = op_calc1(SLOT->Cnt, env, (out<<SLOT->FB), SLOT->wavetable );
+	}
+
+	/* SLOT 2 */
+	SLOT++;
+	env = volume_calc(SLOT);
+	if( env < ENV_QUIET )
+		OPL->output[0] += op_calc(SLOT->Cnt, env, OPL->phase_modulation, SLOT->wavetable) * 2;
+
+
+	/* Phase generation is based on: */
+	/* HH  (13) channel 7->slot 1 combined with channel 8->slot 2 (same combination as TOP CYMBAL but different output phases) */
+	/* SD  (16) channel 7->slot 1 */
+	/* TOM (14) channel 8->slot 1 */
+	/* TOP (17) channel 7->slot 1 combined with channel 8->slot 2 (same combination as HIGH HAT but different output phases) */
+
+	/* Envelope generation based on: */
+	/* HH  channel 7->slot1 */
+	/* SD  channel 7->slot2 */
+	/* TOM channel 8->slot1 */
+	/* TOP channel 8->slot2 */
+
+
+	/* The following formulas can be well optimized.
+       I leave them in direct form for now (in case I've missed something).
+    */
+
+	/* High Hat (verified on real YM3812) */
+	env = volume_calc(OPL->SLOT7_1);
+	if( env < ENV_QUIET )
+	{
+
+		/* high hat phase generation:
+            phase = d0 or 234 (based on frequency only)
+            phase = 34 or 2d0 (based on noise)
+        */
+
+		/* base frequency derived from operator 1 in channel 7 */
+		unsigned char bit7 = ((OPL->SLOT7_1->Cnt>>FREQ_SH)>>7)&1;
+		unsigned char bit3 = ((OPL->SLOT7_1->Cnt>>FREQ_SH)>>3)&1;
+		unsigned char bit2 = ((OPL->SLOT7_1->Cnt>>FREQ_SH)>>2)&1;
+
+		unsigned char res1 = (bit2 ^ bit7) | bit3;
+
+		/* when res1 = 0 phase = 0x000 | 0xd0; */
+		/* when res1 = 1 phase = 0x200 | (0xd0>>2); */
+		UINT32 phase = res1 ? (0x200|(0xd0>>2)) : 0xd0;
+
+		/* enable gate based on frequency of operator 2 in channel 8 */
+		unsigned char bit5e= ((OPL->SLOT8_2->Cnt>>FREQ_SH)>>5)&1;
+		unsigned char bit3e= ((OPL->SLOT8_2->Cnt>>FREQ_SH)>>3)&1;
+
+		unsigned char res2 = (bit3e ^ bit5e);
+
+		/* when res2 = 0 pass the phase from calculation above (res1); */
+		/* when res2 = 1 phase = 0x200 | (0xd0>>2); */
+		if (res2)
+			phase = (0x200|(0xd0>>2));
+
+
+		/* when phase & 0x200 is set and noise=1 then phase = 0x200|0xd0 */
+		/* when phase & 0x200 is set and noise=0 then phase = 0x200|(0xd0>>2), ie no change */
+		if (phase&0x200)
+		{
+			if (noise)
+				phase = 0x200|0xd0;
+		}
+		else
+		/* when phase & 0x200 is clear and noise=1 then phase = 0xd0>>2 */
+		/* when phase & 0x200 is clear and noise=0 then phase = 0xd0, ie no change */
+		{
+			if (noise)
+				phase = 0xd0>>2;
+		}
+
+		OPL->output[0] += op_calc(phase<<FREQ_SH, env, 0, OPL->SLOT7_1->wavetable) * 2;
+	}
+
+	/* Snare Drum (verified on real YM3812) */
+	env = volume_calc(OPL->SLOT7_2);
+	if( env < ENV_QUIET )
+	{
+		/* base frequency derived from operator 1 in channel 7 */
+		unsigned char bit8 = ((OPL->SLOT7_1->Cnt>>FREQ_SH)>>8)&1;
+
+		/* when bit8 = 0 phase = 0x100; */
+		/* when bit8 = 1 phase = 0x200; */
+		UINT32 phase = bit8 ? 0x200 : 0x100;
+
+		/* Noise bit XOR'es phase by 0x100 */
+		/* when noisebit = 0 pass the phase from calculation above */
+		/* when noisebit = 1 phase ^= 0x100; */
+		/* in other words: phase ^= (noisebit<<8); */
+		if (noise)
+			phase ^= 0x100;
+
+		OPL->output[0] += op_calc(phase<<FREQ_SH, env, 0, OPL->SLOT7_2->wavetable) * 2;
+	}
+
+	/* Tom Tom (verified on real YM3812) */
+	env = volume_calc(OPL->SLOT8_1);
+	if( env < ENV_QUIET )
+		OPL->output[0] += op_calc(OPL->SLOT8_1->Cnt, env, 0, OPL->SLOT8_1->wavetable) * 2;
+
+	/* Top Cymbal (verified on real YM3812) */
+	env = volume_calc(OPL->SLOT8_2);
+	if( env < ENV_QUIET )
+	{
+		/* base frequency derived from operator 1 in channel 7 */
+		unsigned char bit7 = ((OPL->SLOT7_1->Cnt>>FREQ_SH)>>7)&1;
+		unsigned char bit3 = ((OPL->SLOT7_1->Cnt>>FREQ_SH)>>3)&1;
+		unsigned char bit2 = ((OPL->SLOT7_1->Cnt>>FREQ_SH)>>2)&1;
+
+		unsigned char res1 = (bit2 ^ bit7) | bit3;
+
+		/* when res1 = 0 phase = 0x000 | 0x100; */
+		/* when res1 = 1 phase = 0x200 | 0x100; */
+		UINT32 phase = res1 ? 0x300 : 0x100;
+
+		/* enable gate based on frequency of operator 2 in channel 8 */
+		unsigned char bit5e= ((OPL->SLOT8_2->Cnt>>FREQ_SH)>>5)&1;
+		unsigned char bit3e= ((OPL->SLOT8_2->Cnt>>FREQ_SH)>>3)&1;
+
+		unsigned char res2 = (bit3e ^ bit5e);
+		/* when res2 = 0 pass the phase from calculation above (res1); */
+		/* when res2 = 1 phase = 0x200 | 0x100; */
+		if (res2)
+			phase = 0x300;
+
+		OPL->output[0] += op_calc(phase<<FREQ_SH, env, 0, OPL->SLOT8_2->wavetable) * 2;
+	}
+
+}
+
+
+/* generic table initialize */
+static int init_tables(void)
+{
+	signed int i,x;
+	signed int n;
+	double o,m;
+
+
+	for (x=0; x<TL_RES_LEN; x++)
+	{
+		m = (1<<16) / pow(2, (x+1) * (ENV_STEP/4.0) / 8.0);
+		m = floor(m);
+
+		/* we never reach (1<<16) here due to the (x+1) */
+		/* result fits within 16 bits at maximum */
+
+		n = (int)m;		/* 16 bits here */
+		n >>= 4;		/* 12 bits here */
+		if (n&1)		/* round to nearest */
+			n = (n>>1)+1;
+		else
+			n = n>>1;
+						/* 11 bits here (rounded) */
+		n <<= 1;		/* 12 bits here (as in real chip) */
+		tl_tab[ x*2 + 0 ] = n;
+		tl_tab[ x*2 + 1 ] = -tl_tab[ x*2 + 0 ];
+
+		for (i=1; i<12; i++)
+		{
+			tl_tab[ x*2+0 + i*2*TL_RES_LEN ] =  tl_tab[ x*2+0 ]>>i;
+			tl_tab[ x*2+1 + i*2*TL_RES_LEN ] = -tl_tab[ x*2+0 + i*2*TL_RES_LEN ];
+		}
+	#if 0
+			logerror("tl %04i", x*2);
+			for (i=0; i<12; i++)
+				logerror(", [%02i] %5i", i*2, tl_tab[ x*2 /*+1*/ + i*2*TL_RES_LEN ] );
+			logerror("\n");
+	#endif
+	}
+	/*logerror("FMOPL.C: TL_TAB_LEN = %i elements (%i bytes)\n",TL_TAB_LEN, (int)sizeof(tl_tab));*/
+
+
+	for (i=0; i<SIN_LEN; i++)
+	{
+		/* non-standard sinus */
+		m = sin( ((i*2)+1) * M_PI / SIN_LEN ); /* checked against the real chip */
+
+		/* we never reach zero here due to ((i*2)+1) */
+
+		if (m>0.0)
+			o = 8*log(1.0/m)/log(2.0);	/* convert to 'decibels' */
+		else
+			o = 8*log(-1.0/m)/log(2.0);	/* convert to 'decibels' */
+
+		o = o / (ENV_STEP/4);
+
+		n = (int)(2.0*o);
+		if (n&1)						/* round to nearest */
+			n = (n>>1)+1;
+		else
+			n = n>>1;
+
+		sin_tab[ i ] = n*2 + (m>=0.0? 0: 1 );
+
+		/*logerror("FMOPL.C: sin [%4i (hex=%03x)]= %4i (tl_tab value=%5i)\n", i, i, sin_tab[i], tl_tab[sin_tab[i]] );*/
+	}
+
+	for (i=0; i<SIN_LEN; i++)
+	{
+		/* waveform 1:  __      __     */
+		/*             /  \____/  \____*/
+		/* output only first half of the sinus waveform (positive one) */
+
+		if (i & (1<<(SIN_BITS-1)) )
+			sin_tab[1*SIN_LEN+i] = TL_TAB_LEN;
+		else
+			sin_tab[1*SIN_LEN+i] = sin_tab[i];
+
+		/* waveform 2:  __  __  __  __ */
+		/*             /  \/  \/  \/  \*/
+		/* abs(sin) */
+
+		sin_tab[2*SIN_LEN+i] = sin_tab[i & (SIN_MASK>>1) ];
+
+		/* waveform 3:  _   _   _   _  */
+		/*             / |_/ |_/ |_/ |_*/
+		/* abs(output only first quarter of the sinus waveform) */
+
+		if (i & (1<<(SIN_BITS-2)) )
+			sin_tab[3*SIN_LEN+i] = TL_TAB_LEN;
+		else
+			sin_tab[3*SIN_LEN+i] = sin_tab[i & (SIN_MASK>>2)];
+
+		/*logerror("FMOPL.C: sin1[%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[1*SIN_LEN+i], tl_tab[sin_tab[1*SIN_LEN+i]] );
+        logerror("FMOPL.C: sin2[%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[2*SIN_LEN+i], tl_tab[sin_tab[2*SIN_LEN+i]] );
+        logerror("FMOPL.C: sin3[%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[3*SIN_LEN+i], tl_tab[sin_tab[3*SIN_LEN+i]] );*/
+	}
+	/*logerror("FMOPL.C: ENV_QUIET= %08x (dec*8=%i)\n", ENV_QUIET, ENV_QUIET*8 );*/
+
+
+#ifdef SAVE_SAMPLE
+	sample[0]=fopen("sampsum.pcm","wb");
+#endif
+
+	return 1;
+}
+
+static void OPLCloseTable( void )
+{
+#ifdef SAVE_SAMPLE
+	fclose(sample[0]);
+#endif
+}
+
+
+
+static void OPL_initalize(FM_OPL *OPL)
+{
+	int i;
+
+	/* frequency base */
+	OPL->freqbase  = (OPL->rate) ? ((double)OPL->clock / 72.0) / OPL->rate  : 0;
+#if 0
+	OPL->rate = (double)OPL->clock / 72.0;
+	OPL->freqbase  = 1.0;
+#endif
+
+	/*logerror("freqbase=%f\n", OPL->freqbase);*/
+
+	/* Timer base time */
+	//OPL->TimerBase = attotime_mul(ATTOTIME_IN_HZ(OPL->clock), 72);
+
+	/* make fnumber -> increment counter table */
+	for( i=0 ; i < 1024 ; i++ )
+	{
+		/* opn phase increment counter = 20bit */
+		OPL->fn_tab[i] = (UINT32)( (double)i * 64 * OPL->freqbase * (1<<(FREQ_SH-10)) ); /* -10 because chip works with 10.10 fixed point, while we use 16.16 */
+#if 0
+		logerror("FMOPL.C: fn_tab[%4i] = %08x (dec=%8i)\n",
+				 i, OPL->fn_tab[i]>>6, OPL->fn_tab[i]>>6 );
+#endif
+	}
+
+#if 0
+	for( i=0 ; i < 16 ; i++ )
+	{
+		logerror("FMOPL.C: sl_tab[%i] = %08x\n",
+			i, sl_tab[i] );
+	}
+	for( i=0 ; i < 8 ; i++ )
+	{
+		int j;
+		logerror("FMOPL.C: ksl_tab[oct=%2i] =",i);
+		for (j=0; j<16; j++)
+		{
+			logerror("%08x ", ksl_tab[i*16+j] );
+		}
+		logerror("\n");
+	}
+#endif
+
+
+	/* Amplitude modulation: 27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples */
+	/* One entry from LFO_AM_TABLE lasts for 64 samples */
+	OPL->lfo_am_inc = UINT32((1.0 / 64.0 ) * (1<<LFO_SH) * OPL->freqbase);
+
+	/* Vibrato: 8 output levels (triangle waveform); 1 level takes 1024 samples */
+	OPL->lfo_pm_inc = UINT32((1.0 / 1024.0) * (1<<LFO_SH) * OPL->freqbase);
+
+	/*logerror ("OPL->lfo_am_inc = %8x ; OPL->lfo_pm_inc = %8x\n", OPL->lfo_am_inc, OPL->lfo_pm_inc);*/
+
+	/* Noise generator: a step takes 1 sample */
+	OPL->noise_f = UINT32((1.0 / 1.0) * (1<<FREQ_SH) * OPL->freqbase);
+
+	OPL->eg_timer_add  = (1<<EG_SH)  * UINT32(OPL->freqbase);
+	OPL->eg_timer_overflow = ( 1 ) * (1<<EG_SH);
+	/*logerror("OPLinit eg_timer_add=%8x eg_timer_overflow=%8x\n", OPL->eg_timer_add, OPL->eg_timer_overflow);*/
+
+}
+
+INLINE void FM_KEYON(OPL_SLOT *SLOT, UINT32 key_set)
+{
+	if( !SLOT->key )
+	{
+		/* restart Phase Generator */
+		SLOT->Cnt = 0;
+		/* phase -> Attack */
+		SLOT->state = EG_ATT;
+	}
+	SLOT->key |= key_set;
+}
+
+INLINE void FM_KEYOFF(OPL_SLOT *SLOT, UINT32 key_clr)
+{
+	if( SLOT->key )
+	{
+		SLOT->key &= key_clr;
+
+		if( !SLOT->key )
+		{
+			/* phase -> Release */
+			if (SLOT->state>EG_REL)
+				SLOT->state = EG_REL;
+		}
+	}
+}
+
+/* update phase increment counter of operator (also update the EG rates if necessary) */
+INLINE void CALC_FCSLOT(OPL_CH *CH,OPL_SLOT *SLOT)
+{
+	int ksr;
+
+	/* (frequency) phase increment counter */
+	SLOT->Incr = CH->fc * SLOT->mul;
+	ksr = CH->kcode >> SLOT->KSR;
+
+	if( SLOT->ksr != ksr )
+	{
+		SLOT->ksr = ksr;
+
+		/* calculate envelope generator rates */
+		if ((SLOT->ar + SLOT->ksr) < 16+62)
+		{
+			SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];
+			SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];
+		}
+		else
+		{
+			SLOT->eg_sh_ar  = 0;
+			SLOT->eg_sel_ar = 13*RATE_STEPS;
+		}
+		SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];
+		SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];
+		SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];
+		SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];
+	}
+}
+
+/* set multi,am,vib,EG-TYP,KSR,mul */
+INLINE void set_mul(FM_OPL *OPL,int slot,int v)
+{
+	OPL_CH   *CH   = &OPL->P_CH[slot/2];
+	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
+
+	SLOT->mul     = UINT8(mul_tab[v&0x0f]);
+	SLOT->KSR     = (v&0x10) ? 0 : 2;
+	SLOT->eg_type = (v&0x20);
+	SLOT->vib     = (v&0x40);
+	SLOT->AMmask  = (v&0x80) ? ~0 : 0;
+	CALC_FCSLOT(CH,SLOT);
+}
+
+/* set ksl & tl */
+INLINE void set_ksl_tl(FM_OPL *OPL,int slot,int v)
+{
+	OPL_CH   *CH   = &OPL->P_CH[slot/2];
+	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
+	int ksl = v>>6; /* 0 / 1.5 / 3.0 / 6.0 dB/OCT */
+
+	SLOT->ksl = ksl ? 3-ksl : 31;
+	SLOT->TL  = (v&0x3f)<<(ENV_BITS-1-7); /* 7 bits TL (bit 6 = always 0) */
+
+	SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
+}
+
+/* set attack rate & decay rate  */
+INLINE void set_ar_dr(FM_OPL *OPL,int slot,int v)
+{
+	OPL_CH   *CH   = &OPL->P_CH[slot/2];
+	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
+
+	SLOT->ar = (v>>4)  ? 16 + ((v>>4)  <<2) : 0;
+
+	if ((SLOT->ar + SLOT->ksr) < 16+62)
+	{
+		SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];
+		SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];
+	}
+	else
+	{
+		SLOT->eg_sh_ar  = 0;
+		SLOT->eg_sel_ar = 13*RATE_STEPS;
+	}
+
+	SLOT->dr    = (v&0x0f)? 16 + ((v&0x0f)<<2) : 0;
+	SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];
+	SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];
+}
+
+/* set sustain level & release rate */
+INLINE void set_sl_rr(FM_OPL *OPL,int slot,int v)
+{
+	OPL_CH   *CH   = &OPL->P_CH[slot/2];
+	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
+
+	SLOT->sl  = sl_tab[ v>>4 ];
+
+	SLOT->rr  = (v&0x0f)? 16 + ((v&0x0f)<<2) : 0;
+	SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];
+	SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];
+}
+
+
+/* write a value v to register r on OPL chip */
+static void OPLWriteReg(FM_OPL *OPL, int r, int v)
+{
+	OPL_CH *CH;
+	int slot;
+	int block_fnum;
+
+
+	/* adjust bus to 8 bits */
+	r &= 0xff;
+	v &= 0xff;
+
+	/*if (LOG_CYM_FILE && (cymfile) && (r!=0) )
+	{
+		fputc( (unsigned char)r, cymfile );
+		fputc( (unsigned char)v, cymfile );
+	}*/
+
+
+	switch(r&0xe0)
+	{
+	case 0x00:	/* 00-1f:control */
+		switch(r&0x1f)
+		{
+		case 0x01:	/* waveform select enable */
+			if(OPL->type&OPL_TYPE_WAVESEL)
+			{
+				OPL->wavesel = v&0x20;
+				/* do not change the waveform previously selected */
+			}
+			break;
+		case 0x02:	/* Timer 1 */
+			OPL->T[0] = (256-v)*4;
+			break;
+		case 0x03:	/* Timer 2 */
+			OPL->T[1] = (256-v)*16;
+			break;
+		case 0x04:	/* IRQ clear / mask and Timer enable */
+			if(v&0x80)
+			{	/* IRQ flag clear */
+				OPL_STATUS_RESET(OPL,0x7f-0x08); /* don't reset BFRDY flag or we will have to call deltat module to set the flag */
+			}
+			else
+			{	/* set IRQ mask ,timer enable*/
+				UINT8 st1 = v&1;
+				UINT8 st2 = (v>>1)&1;
+
+				/* IRQRST,T1MSK,t2MSK,EOSMSK,BRMSK,x,ST2,ST1 */
+				OPL_STATUS_RESET(OPL, v & (0x78-0x08) );
+				OPL_STATUSMASK_SET(OPL, (~v) & 0x78 );
+
+				/* timer 2 */
+				/*if(OPL->st[1] != st2)
+				{
+					attotime period = st2 ? attotime_mul(OPL->TimerBase, OPL->T[1]) : attotime_zero;
+					OPL->st[1] = st2;
+					if (OPL->timer_handler) (OPL->timer_handler)(OPL->TimerParam,1,period);
+				}*/
+				/* timer 1 */
+				/*if(OPL->st[0] != st1)
+				{
+					attotime period = st1 ? attotime_mul(OPL->TimerBase, OPL->T[0]) : attotime_zero;
+					OPL->st[0] = st1;
+					if (OPL->timer_handler) (OPL->timer_handler)(OPL->TimerParam,0,period);
+				}*/
+			}
+			break;
+#if BUILD_Y8950
+		case 0x06:		/* Key Board OUT */
+			if(OPL->type&OPL_TYPE_KEYBOARD)
+			{
+				if(OPL->keyboardhandler_w)
+					OPL->keyboardhandler_w(OPL->keyboard_param,v);
+				else
+					logerror("Y8950: write unmapped KEYBOARD port\n");
+			}
+			break;
+		case 0x07:	/* DELTA-T control 1 : START,REC,MEMDATA,REPT,SPOFF,x,x,RST */
+			if(OPL->type&OPL_TYPE_ADPCM)
+				YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);
+			break;
+#endif
+		case 0x08:	/* MODE,DELTA-T control 2 : CSM,NOTESEL,x,x,smpl,da/ad,64k,rom */
+			OPL->mode = v;
+#if BUILD_Y8950
+			if(OPL->type&OPL_TYPE_ADPCM)
+				YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v&0x0f); /* mask 4 LSBs in register 08 for DELTA-T unit */
+#endif
+			break;
+
+#if BUILD_Y8950
+		case 0x09:		/* START ADD */
+		case 0x0a:
+		case 0x0b:		/* STOP ADD  */
+		case 0x0c:
+		case 0x0d:		/* PRESCALE   */
+		case 0x0e:
+		case 0x0f:		/* ADPCM data write */
+		case 0x10: 		/* DELTA-N    */
+		case 0x11: 		/* DELTA-N    */
+		case 0x12: 		/* ADPCM volume */
+			if(OPL->type&OPL_TYPE_ADPCM)
+				YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);
+			break;
+
+		case 0x15:		/* DAC data high 8 bits (F7,F6...F2) */
+		case 0x16:		/* DAC data low 2 bits (F1, F0 in bits 7,6) */
+		case 0x17:		/* DAC data shift (S2,S1,S0 in bits 2,1,0) */
+			logerror("FMOPL.C: DAC data register written, but not implemented reg=%02x val=%02x\n",r,v);
+			break;
+
+		case 0x18:		/* I/O CTRL (Direction) */
+			if(OPL->type&OPL_TYPE_IO)
+				OPL->portDirection = v&0x0f;
+			break;
+		case 0x19:		/* I/O DATA */
+			if(OPL->type&OPL_TYPE_IO)
+			{
+				OPL->portLatch = v;
+				if(OPL->porthandler_w)
+					OPL->porthandler_w(OPL->port_param,v&OPL->portDirection);
+			}
+			break;
+#endif
+		default:
+			logerror("FMOPL.C: write to unknown register: %02x\n",r);
+			break;
+		}
+		break;
+	case 0x20:	/* am ON, vib ON, ksr, eg_type, mul */
+		slot = slot_array[r&0x1f];
+		if(slot < 0) return;
+		set_mul(OPL,slot,v);
+		break;
+	case 0x40:
+		slot = slot_array[r&0x1f];
+		if(slot < 0) return;
+		set_ksl_tl(OPL,slot,v);
+		break;
+	case 0x60:
+		slot = slot_array[r&0x1f];
+		if(slot < 0) return;
+		set_ar_dr(OPL,slot,v);
+		break;
+	case 0x80:
+		slot = slot_array[r&0x1f];
+		if(slot < 0) return;
+		set_sl_rr(OPL,slot,v);
+		break;
+	case 0xa0:
+		if (r == 0xbd)			/* am depth, vibrato depth, r,bd,sd,tom,tc,hh */
+		{
+			OPL->lfo_am_depth = v & 0x80;
+			OPL->lfo_pm_depth_range = (v&0x40) ? 8 : 0;
+
+			OPL->rhythm  = v&0x3f;
+
+			if(OPL->rhythm&0x20)
+			{
+				/* BD key on/off */
+				if(v&0x10)
+				{
+					FM_KEYON (&OPL->P_CH[6].SLOT[SLOT1], 2);
+					FM_KEYON (&OPL->P_CH[6].SLOT[SLOT2], 2);
+				}
+				else
+				{
+					FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT1],~2);
+					FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT2],~2);
+				}
+				/* HH key on/off */
+				if(v&0x01) FM_KEYON (&OPL->P_CH[7].SLOT[SLOT1], 2);
+				else       FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT1],~2);
+				/* SD key on/off */
+				if(v&0x08) FM_KEYON (&OPL->P_CH[7].SLOT[SLOT2], 2);
+				else       FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT2],~2);
+				/* TOM key on/off */
+				if(v&0x04) FM_KEYON (&OPL->P_CH[8].SLOT[SLOT1], 2);
+				else       FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT1],~2);
+				/* TOP-CY key on/off */
+				if(v&0x02) FM_KEYON (&OPL->P_CH[8].SLOT[SLOT2], 2);
+				else       FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT2],~2);
+			}
+			else
+			{
+				/* BD key off */
+				FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT1],~2);
+				FM_KEYOFF(&OPL->P_CH[6].SLOT[SLOT2],~2);
+				/* HH key off */
+				FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT1],~2);
+				/* SD key off */
+				FM_KEYOFF(&OPL->P_CH[7].SLOT[SLOT2],~2);
+				/* TOM key off */
+				FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT1],~2);
+				/* TOP-CY off */
+				FM_KEYOFF(&OPL->P_CH[8].SLOT[SLOT2],~2);
+			}
+			return;
+		}
+		/* keyon,block,fnum */
+		if( (r&0x0f) > 8) return;
+		CH = &OPL->P_CH[r&0x0f];
+		if(!(r&0x10))
+		{	/* a0-a8 */
+			block_fnum  = (CH->block_fnum&0x1f00) | v;
+		}
+		else
+		{	/* b0-b8 */
+			block_fnum = ((v&0x1f)<<8) | (CH->block_fnum&0xff);
+
+			if(v&0x20)
+			{
+				FM_KEYON (&CH->SLOT[SLOT1], 1);
+				FM_KEYON (&CH->SLOT[SLOT2], 1);
+			}
+			else
+			{
+				FM_KEYOFF(&CH->SLOT[SLOT1],~1);
+				FM_KEYOFF(&CH->SLOT[SLOT2],~1);
+			}
+		}
+		/* update */
+		if(CH->block_fnum != block_fnum)
+		{
+			UINT8 block  = block_fnum >> 10;
+
+			CH->block_fnum = block_fnum;
+
+			CH->ksl_base = UINT32(ksl_tab[block_fnum>>6]);
+			CH->fc       = OPL->fn_tab[block_fnum&0x03ff] >> (7-block);
+
+			/* BLK 2,1,0 bits -> bits 3,2,1 of kcode */
+			CH->kcode    = (CH->block_fnum&0x1c00)>>9;
+
+			 /* the info below is actually opposite to what is stated in the Manuals (verifed on real YM3812) */
+			/* if notesel == 0 -> lsb of kcode is bit 10 (MSB) of fnum  */
+			/* if notesel == 1 -> lsb of kcode is bit 9 (MSB-1) of fnum */
+			if (OPL->mode&0x40)
+				CH->kcode |= (CH->block_fnum&0x100)>>8;	/* notesel == 1 */
+			else
+				CH->kcode |= (CH->block_fnum&0x200)>>9;	/* notesel == 0 */
+
+			/* refresh Total Level in both SLOTs of this channel */
+			CH->SLOT[SLOT1].TLL = CH->SLOT[SLOT1].TL + (CH->ksl_base>>CH->SLOT[SLOT1].ksl);
+			CH->SLOT[SLOT2].TLL = CH->SLOT[SLOT2].TL + (CH->ksl_base>>CH->SLOT[SLOT2].ksl);
+
+			/* refresh frequency counter in both SLOTs of this channel */
+			CALC_FCSLOT(CH,&CH->SLOT[SLOT1]);
+			CALC_FCSLOT(CH,&CH->SLOT[SLOT2]);
+		}
+		break;
+	case 0xc0:
+		/* FB,C */
+		if( (r&0x0f) > 8) return;
+		CH = &OPL->P_CH[r&0x0f];
+		CH->SLOT[SLOT1].FB  = (v>>1)&7 ? ((v>>1)&7) + 7 : 0;
+		CH->SLOT[SLOT1].CON = v&1;
+		CH->SLOT[SLOT1].connect1 = CH->SLOT[SLOT1].CON ? &OPL->output[0] : &OPL->phase_modulation;
+		break;
+	case 0xe0: /* waveform select */
+		/* simply ignore write to the waveform select register if selecting not enabled in test register */
+		if(OPL->wavesel)
+		{
+			slot = slot_array[r&0x1f];
+			if(slot < 0) return;
+			CH = &OPL->P_CH[slot/2];
+
+			CH->SLOT[slot&1].wavetable = (v&0x03)*SIN_LEN;
+		}
+		break;
+	}
+}
+
+/*static TIMER_CALLBACK( cymfile_callback )
+{
+	if (cymfile)
+	{
+		fputc( (unsigned char)0, cymfile );
+	}
+}*/
+
+/* lock/unlock for common table */
+#if 0
+static int OPL_LockTable(/*const device_config *device*/)
+{
+	num_lock++;
+	if(num_lock>1) return 0;
+
+	/* first time */
+
+	cur_chip = NULL;
+	/* allocate total level table (128kb space) */
+	if( !init_tables() )
+	{
+		num_lock--;
+		return -1;
+	}
+
+#if 0
+	if (LOG_CYM_FILE)
+	{
+		cymfile = fopen("3812_.cym","wb");
+		if (cymfile)
+			timer_pulse ( device->machine, ATTOTIME_IN_HZ(110), NULL, 0, cymfile_callback); /*110 Hz pulse timer*/
+		else
+			logerror("Could not create file 3812_.cym\n");
+	}
+#endif
+
+	return 0;
+}
+
+static void OPL_UnLockTable(void)
+{
+	if(num_lock) num_lock--;
+	if(num_lock) return;
+
+	/* last time */
+
+	cur_chip = NULL;
+	OPLCloseTable();
+
+	/*if (cymfile)
+		fclose (cymfile);
+	cymfile = NULL;*/
+}
+#endif
+
+static void OPLResetChip(FM_OPL *OPL)
+{
+	int c,s;
+	int i;
+
+	OPL->eg_timer = 0;
+	OPL->eg_cnt   = 0;
+
+	OPL->noise_rng = 1;	/* noise shift register */
+	OPL->mode   = 0;	/* normal mode */
+	OPL_STATUS_RESET(OPL,0x7f);
+
+	/* reset with register write */
+	OPLWriteReg(OPL,0x01,0); /* wavesel disable */
+	OPLWriteReg(OPL,0x02,0); /* Timer1 */
+	OPLWriteReg(OPL,0x03,0); /* Timer2 */
+	OPLWriteReg(OPL,0x04,0); /* IRQ mask clear */
+	for(i = 0xff ; i >= 0x20 ; i-- ) OPLWriteReg(OPL,i,0);
+
+	/* reset operator parameters */
+	for( c = 0 ; c < 9 ; c++ )
+	{
+		OPL_CH *CH = &OPL->P_CH[c];
+		for(s = 0 ; s < 2 ; s++ )
+		{
+			/* wave table */
+			CH->SLOT[s].wavetable = 0;
+			CH->SLOT[s].state     = EG_OFF;
+			CH->SLOT[s].volume    = MAX_ATT_INDEX;
+		}
+	}
+#if BUILD_Y8950
+	if(OPL->type&OPL_TYPE_ADPCM)
+	{
+		YM_DELTAT *DELTAT = OPL->deltat;
+
+		DELTAT->freqbase = OPL->freqbase;
+		DELTAT->output_pointer = &OPL->output_deltat[0];
+		DELTAT->portshift = 5;
+		DELTAT->output_range = 1<<23;
+		YM_DELTAT_ADPCM_Reset(DELTAT,0,YM_DELTAT_EMULATION_MODE_NORMAL);
+	}
+#endif
+}
+
+
+#if 0
+static STATE_POSTLOAD( OPL_postload )
+{
+	FM_OPL *OPL = (FM_OPL *)param;
+	int slot, ch;
+
+	for( ch=0 ; ch < 9 ; ch++ )
+	{
+		OPL_CH *CH = &OPL->P_CH[ch];
+
+		/* Look up key scale level */
+		UINT32 block_fnum = CH->block_fnum;
+		CH->ksl_base = ksl_tab[block_fnum >> 6];
+		CH->fc       = OPL->fn_tab[block_fnum & 0x03ff] >> (7 - (block_fnum >> 10));
+
+		for( slot=0 ; slot < 2 ; slot++ )
+		{
+			OPL_SLOT *SLOT = &CH->SLOT[slot];
+
+			/* Calculate key scale rate */
+			SLOT->ksr = CH->kcode >> SLOT->KSR;
+
+			/* Calculate attack, decay and release rates */
+			if ((SLOT->ar + SLOT->ksr) < 16+62)
+			{
+				SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];
+				SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];
+			}
+			else
+			{
+				SLOT->eg_sh_ar  = 0;
+				SLOT->eg_sel_ar = 13*RATE_STEPS;
+			}
+			SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];
+			SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];
+			SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];
+			SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];
+
+			/* Calculate phase increment */
+			SLOT->Incr = CH->fc * SLOT->mul;
+
+			/* Total level */
+			SLOT->TLL = SLOT->TL + (CH->ksl_base >> SLOT->ksl);
+
+			/* Connect output */
+			SLOT->connect1 = SLOT->CON ? &OPL->output[0] : &OPL->phase_modulation;
+		}
+	}
+#if BUILD_Y8950
+	if ( (OPL->type & OPL_TYPE_ADPCM) && (OPL->deltat) )
+	{
+		// We really should call the postlod function for the YM_DELTAT, but it's hard without registers
+		// (see the way the YM2610 does it)
+		//YM_DELTAT_postload(OPL->deltat, REGS);
+	}
+#endif
+}
+
+
+static void OPLsave_state_channel(const device_config *device, OPL_CH *CH)
+{
+	int slot, ch;
+
+	for( ch=0 ; ch < 9 ; ch++, CH++ )
+	{
+		/* channel */
+		state_save_register_device_item(device, ch, CH->block_fnum);
+		state_save_register_device_item(device, ch, CH->kcode);
+		/* slots */
+		for( slot=0 ; slot < 2 ; slot++ )
+		{
+			OPL_SLOT *SLOT = &CH->SLOT[slot];
+
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->ar);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->dr);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->rr);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->KSR);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->ksl);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->mul);
+
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->Cnt);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->FB);
+			state_save_register_device_item_array(device, ch * 2 + slot, SLOT->op1_out);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->CON);
+
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->eg_type);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->state);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->TL);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->volume);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->sl);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->key);
+
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->AMmask);
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->vib);
+
+			state_save_register_device_item(device, ch * 2 + slot, SLOT->wavetable);
+		}
+	}
+}
+
+
+/* Register savestate for a virtual YM3812/YM3526Y8950 */
+
+static void OPL_save_state(FM_OPL *OPL, const device_config *device)
+{
+	OPLsave_state_channel(device, OPL->P_CH);
+
+	state_save_register_device_item(device, 0, OPL->eg_cnt);
+	state_save_register_device_item(device, 0, OPL->eg_timer);
+
+	state_save_register_device_item(device, 0, OPL->rhythm);
+
+	state_save_register_device_item(device, 0, OPL->lfo_am_depth);
+	state_save_register_device_item(device, 0, OPL->lfo_pm_depth_range);
+	state_save_register_device_item(device, 0, OPL->lfo_am_cnt);
+	state_save_register_device_item(device, 0, OPL->lfo_pm_cnt);
+
+	state_save_register_device_item(device, 0, OPL->noise_rng);
+	state_save_register_device_item(device, 0, OPL->noise_p);
+
+	if( OPL->type & OPL_TYPE_WAVESEL )
+	{
+		state_save_register_device_item(device, 0, OPL->wavesel);
+	}
+
+	state_save_register_device_item_array(device, 0, OPL->T);
+	state_save_register_device_item_array(device, 0, OPL->st);
+
+#if BUILD_Y8950
+	if ( (OPL->type & OPL_TYPE_ADPCM) && (OPL->deltat) )
+	{
+		YM_DELTAT_savestate(device, OPL->deltat);
+	}
+
+	if ( OPL->type & OPL_TYPE_IO )
+	{
+		state_save_register_device_item(device, 0, OPL->portDirection);
+		state_save_register_device_item(device, 0, OPL->portLatch);
+	}
+#endif
+
+	state_save_register_device_item(device, 0, OPL->address);
+	state_save_register_device_item(device, 0, OPL->status);
+	state_save_register_device_item(device, 0, OPL->statusmask);
+	state_save_register_device_item(device, 0, OPL->mode);
+
+	state_save_register_postload(device->machine, OPL_postload, OPL);
+}
+#endif
+
+
+/* Create one of virtual YM3812/YM3526/Y8950 */
+/* 'clock' is chip clock in Hz  */
+/* 'rate'  is sampling rate  */
+static FM_OPL *OPLCreate(UINT32 clock, UINT32 rate, int type)
+{
+	char *ptr;
+	FM_OPL *OPL;
+	int state_size;
+
+	//if (OPL_LockTable(device) == -1) return NULL;
+	init_tables();
+
+	/* calculate OPL state size */
+	state_size  = sizeof(FM_OPL);
+
+#if BUILD_Y8950
+	if (type&OPL_TYPE_ADPCM) state_size+= sizeof(YM_DELTAT);
+#endif
+
+	/* allocate memory block */
+	ptr = (char *)malloc(state_size);
+
+	if (ptr==NULL)
+		return 0;
+
+	/* clear */
+	memset(ptr,0,state_size);
+
+	OPL  = (FM_OPL *)ptr;
+
+	ptr += sizeof(FM_OPL);
+
+#if BUILD_Y8950
+	if (type&OPL_TYPE_ADPCM)
+	{
+		OPL->deltat = (YM_DELTAT *)ptr;
+	}
+	ptr += sizeof(YM_DELTAT);
+#endif
+
+	OPL->type  = type;
+	OPL->clock = clock;
+	OPL->rate  = rate;
+
+	/* init global tables */
+	OPL_initalize(OPL);
+
+	return OPL;
+}
+
+/* Destroy one of virtual YM3812 */
+static void OPLDestroy(FM_OPL *OPL)
+{
+	//OPL_UnLockTable();
+	free(OPL);
+	OPL = NULL;
+}
+
+/* Optional handlers */
+
+/*static void OPLSetTimerHandler(FM_OPL *OPL,OPL_TIMERHANDLER timer_handler,void *param)
+{
+	OPL->timer_handler   = timer_handler;
+	OPL->TimerParam = param;
+}*/
+static void OPLSetIRQHandler(FM_OPL *OPL,OPL_IRQHANDLER IRQHandler,void *param)
+{
+	OPL->IRQHandler     = IRQHandler;
+	OPL->IRQParam = param;
+}
+static void OPLSetUpdateHandler(FM_OPL *OPL,OPL_UPDATEHANDLER UpdateHandler,void *param)
+{
+	OPL->UpdateHandler = UpdateHandler;
+	OPL->UpdateParam = param;
+}
+
+static int OPLWrite(FM_OPL *OPL,int a,int v)
+{
+	if( !(a&1) )
+	{	/* address port */
+		OPL->address = v & 0xff;
+	}
+	else
+	{	/* data port */
+		if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);
+		OPLWriteReg(OPL,OPL->address,v);
+	}
+	return OPL->status>>7;
+}
+
+static unsigned char OPLRead(FM_OPL *OPL,int a)
+{
+	if( !(a&1) )
+	{
+		/* status port */
+
+		#if BUILD_Y8950
+
+		if(OPL->type&OPL_TYPE_ADPCM)	/* Y8950 */
+		{
+			return (OPL->status & (OPL->statusmask|0x80)) | (OPL->deltat->PCM_BSY&1);
+		}
+
+		#endif
+
+		/* OPL and OPL2 */
+		return OPL->status & (OPL->statusmask|0x80);
+	}
+
+#if BUILD_Y8950
+	/* data port */
+	switch(OPL->address)
+	{
+	case 0x05: /* KeyBoard IN */
+		if(OPL->type&OPL_TYPE_KEYBOARD)
+		{
+			if(OPL->keyboardhandler_r)
+				return OPL->keyboardhandler_r(OPL->keyboard_param);
+			else
+				logerror("Y8950: read unmapped KEYBOARD port\n");
+		}
+		return 0;
+
+	case 0x0f: /* ADPCM-DATA  */
+		if(OPL->type&OPL_TYPE_ADPCM)
+		{
+			UINT8 val;
+
+			val = YM_DELTAT_ADPCM_Read(OPL->deltat);
+			/*logerror("Y8950: read ADPCM value read=%02x\n",val);*/
+			return val;
+		}
+		return 0;
+
+	case 0x19: /* I/O DATA    */
+		if(OPL->type&OPL_TYPE_IO)
+		{
+			if(OPL->porthandler_r)
+				return OPL->porthandler_r(OPL->port_param);
+			else
+				logerror("Y8950:read unmapped I/O port\n");
+		}
+		return 0;
+	case 0x1a: /* PCM-DATA    */
+		if(OPL->type&OPL_TYPE_ADPCM)
+		{
+			logerror("Y8950 A/D convertion is accessed but not implemented !\n");
+			return 0x80; /* 2's complement PCM data - result from A/D convertion */
+		}
+		return 0;
+	}
+#endif
+
+	return 0xff;
+}
+
+/* CSM Key Controll */
+INLINE void CSMKeyControll(OPL_CH *CH)
+{
+	FM_KEYON (&CH->SLOT[SLOT1], 4);
+	FM_KEYON (&CH->SLOT[SLOT2], 4);
+
+	/* The key off should happen exactly one sample later - not implemented correctly yet */
+
+	FM_KEYOFF(&CH->SLOT[SLOT1], ~4);
+	FM_KEYOFF(&CH->SLOT[SLOT2], ~4);
+}
+
+
+static int OPLTimerOver(FM_OPL *OPL,int c)
+{
+	if( c )
+	{	/* Timer B */
+		OPL_STATUS_SET(OPL,0x20);
+	}
+	else
+	{	/* Timer A */
+		OPL_STATUS_SET(OPL,0x40);
+		/* CSM mode key,TL controll */
+		if( OPL->mode & 0x80 )
+		{	/* CSM mode total level latch and auto key on */
+			int ch;
+			if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);
+			for(ch=0; ch<9; ch++)
+				CSMKeyControll( &OPL->P_CH[ch] );
+		}
+	}
+	/* reload timer */
+	//if (OPL->timer_handler) (OPL->timer_handler)(OPL->TimerParam,c,attotime_mul(OPL->TimerBase, OPL->T[c]));
+	return OPL->status>>7;
+}
+
+
+#define MAX_OPL_CHIPS 2
+
+
+#if (BUILD_YM3812)
+
+void * ym3812_init(UINT32 clock, UINT32 rate)
+{
+	/* emulator create */
+	FM_OPL *YM3812 = OPLCreate(clock,rate,OPL_TYPE_YM3812);
+	if (YM3812)
+	{
+		//OPL_save_state(YM3812);
+		ym3812_reset_chip(YM3812);
+	}
+	return YM3812;
+}
+
+void ym3812_shutdown(void *chip)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+
+	/* emulator shutdown */
+	OPLDestroy(YM3812);
+}
+void ym3812_reset_chip(void *chip)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+	OPLResetChip(YM3812);
+}
+
+int ym3812_write(void *chip, int a, int v)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+	return OPLWrite(YM3812, a, v);
+}
+
+unsigned char ym3812_read(void *chip, int a)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+	/* YM3812 always returns bit2 and bit1 in HIGH state */
+	return OPLRead(YM3812, a) | 0x06 ;
+}
+int ym3812_timer_over(void *chip, int c)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+	return OPLTimerOver(YM3812, c);
+}
+
+/*void ym3812_set_timer_handler(void *chip, OPL_TIMERHANDLER timer_handler, void *param)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+	OPLSetTimerHandler(YM3812, timer_handler, param);
+}*/
+void ym3812_set_irq_handler(void *chip,OPL_IRQHANDLER IRQHandler,void *param)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+	OPLSetIRQHandler(YM3812, IRQHandler, param);
+}
+void ym3812_set_update_handler(void *chip,OPL_UPDATEHANDLER UpdateHandler,void *param)
+{
+	FM_OPL *YM3812 = (FM_OPL *)chip;
+	OPLSetUpdateHandler(YM3812, UpdateHandler, param);
+}
+
+
+/*
+** Generate samples for one of the YM3812's
+**
+** 'which' is the virtual YM3812 number
+** '*buffer' is the output buffer pointer
+** 'length' is the number of samples that should be generated
+*/
+void ym3812_update_one(void *chip, OPLSAMPLE *buffer, int length)
+{
+	FM_OPL		*OPL = (FM_OPL *)chip;
+	UINT8		rhythm = OPL->rhythm&0x20;
+	OPLSAMPLE	*buf = buffer;
+	int i;
+
+	/* rhythm slots */
+	OPL->SLOT7_1 = &OPL->P_CH[7].SLOT[SLOT1];
+	OPL->SLOT7_2 = &OPL->P_CH[7].SLOT[SLOT2];
+	OPL->SLOT8_1 = &OPL->P_CH[8].SLOT[SLOT1];
+	OPL->SLOT8_2 = &OPL->P_CH[8].SLOT[SLOT2];
+	for( i=0; i < length ; i++ )
+	{
+		int lt;
+
+		OPL->output[0] = 0;
+
+		advance_lfo(OPL);
+
+		/* FM part */
+		OPL_CALC_CH(OPL, &OPL->P_CH[0]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[1]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[2]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[3]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[4]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[5]);
+
+		if(!rhythm)
+		{
+			OPL_CALC_CH(OPL, &OPL->P_CH[6]);
+			OPL_CALC_CH(OPL, &OPL->P_CH[7]);
+			OPL_CALC_CH(OPL, &OPL->P_CH[8]);
+		}
+		else		/* Rhythm part */
+		{
+			OPL_CALC_RH(OPL, &OPL->P_CH[0], (OPL->noise_rng>>0)&1 );
+		}
+
+		lt = OPL->output[0];
+
+		lt >>= FINAL_SH;
+
+		/* limit check */
+		lt = limit( lt , MAXOUT, MINOUT );
+
+		#ifdef SAVE_SAMPLE
+		if (which==0)
+		{
+			SAVE_ALL_CHANNELS
+		}
+		#endif
+
+		/* store to sound buffer */
+		buf[i] = lt;
+
+		advance(OPL);
+	}
+
+}
+#endif /* BUILD_YM3812 */
+
+
+
+#if (BUILD_YM3526)
+
+void *ym3526_init(UINT32 clock, UINT32 rate)
+{
+	/* emulator create */
+	FM_OPL *YM3526 = OPLCreate(clock,rate,OPL_TYPE_YM3526);
+	if (YM3526)
+	{
+		/*OPL_save_state(YM3526);*/
+		ym3526_reset_chip(YM3526);
+	}
+	return YM3526;
+}
+
+void ym3526_shutdown(void *chip)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	/* emulator shutdown */
+	OPLDestroy(YM3526);
+}
+void ym3526_reset_chip(void *chip)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	OPLResetChip(YM3526);
+}
+
+int ym3526_write(void *chip, int a, int v)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	return OPLWrite(YM3526, a, v);
+}
+
+unsigned char ym3526_read(void *chip, int a)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	/* YM3526 always returns bit2 and bit1 in HIGH state */
+	return OPLRead(YM3526, a) | 0x06 ;
+}
+int ym3526_timer_over(void *chip, int c)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	return OPLTimerOver(YM3526, c);
+}
+
+/*void ym3526_set_timer_handler(void *chip, OPL_TIMERHANDLER timer_handler, void *param)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	OPLSetTimerHandler(YM3526, timer_handler, param);
+}*/
+void ym3526_set_irq_handler(void *chip,OPL_IRQHANDLER IRQHandler,void *param)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	OPLSetIRQHandler(YM3526, IRQHandler, param);
+}
+void ym3526_set_update_handler(void *chip,OPL_UPDATEHANDLER UpdateHandler,void *param)
+{
+	FM_OPL *YM3526 = (FM_OPL *)chip;
+	OPLSetUpdateHandler(YM3526, UpdateHandler, param);
+}
+
+
+/*
+** Generate samples for one of the YM3526's
+**
+** 'which' is the virtual YM3526 number
+** '*buffer' is the output buffer pointer
+** 'length' is the number of samples that should be generated
+*/
+void ym3526_update_one(void *chip, OPLSAMPLE *buffer, int length)
+{
+	FM_OPL		*OPL = (FM_OPL *)chip;
+	UINT8		rhythm = OPL->rhythm&0x20;
+	OPLSAMPLE	*buf = buffer;
+	int i;
+
+	/* rhythm slots */
+	OPL->SLOT7_1 = &OPL->P_CH[7].SLOT[SLOT1];
+	OPL->SLOT7_2 = &OPL->P_CH[7].SLOT[SLOT2];
+	OPL->SLOT8_1 = &OPL->P_CH[8].SLOT[SLOT1];
+	OPL->SLOT8_2 = &OPL->P_CH[8].SLOT[SLOT2];
+	for( i=0; i < length ; i++ )
+	{
+		int lt;
+
+		OPL->output[0] = 0;
+
+		advance_lfo(OPL);
+
+		/* FM part */
+		OPL_CALC_CH(OPL, &OPL->P_CH[0]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[1]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[2]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[3]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[4]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[5]);
+
+		if(!rhythm)
+		{
+			OPL_CALC_CH(OPL, &OPL->P_CH[6]);
+			OPL_CALC_CH(OPL, &OPL->P_CH[7]);
+			OPL_CALC_CH(OPL, &OPL->P_CH[8]);
+		}
+		else		/* Rhythm part */
+		{
+			OPL_CALC_RH(OPL, &OPL->P_CH[0], (OPL->noise_rng>>0)&1 );
+		}
+
+		lt = OPL->output[0];
+
+		lt >>= FINAL_SH;
+
+		/* limit check */
+		lt = limit( lt , MAXOUT, MINOUT );
+
+		#ifdef SAVE_SAMPLE
+		if (which==0)
+		{
+			SAVE_ALL_CHANNELS
+		}
+		#endif
+
+		/* store to sound buffer */
+		buf[i] = lt;
+
+		advance(OPL);
+	}
+
+}
+#endif /* BUILD_YM3526 */
+
+
+
+
+#if BUILD_Y8950
+
+static void Y8950_deltat_status_set(void *chip, UINT8 changebits)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	OPL_STATUS_SET(Y8950, changebits);
+}
+static void Y8950_deltat_status_reset(void *chip, UINT8 changebits)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	OPL_STATUS_RESET(Y8950, changebits);
+}
+
+void *y8950_init(UINT32 clock, UINT32 rate)
+{
+	/* emulator create */
+	FM_OPL *Y8950 = OPLCreate(clock,rate,OPL_TYPE_Y8950);
+	if (Y8950)
+	{
+		Y8950->deltat->status_set_handler = Y8950_deltat_status_set;
+		Y8950->deltat->status_reset_handler = Y8950_deltat_status_reset;
+		Y8950->deltat->status_change_which_chip = Y8950;
+		Y8950->deltat->status_change_EOS_bit = 0x10;		/* status flag: set bit4 on End Of Sample */
+		Y8950->deltat->status_change_BRDY_bit = 0x08;	/* status flag: set bit3 on BRDY (End Of: ADPCM analysis/synthesis, memory reading/writing) */
+
+		/*Y8950->deltat->write_time = 10.0 / clock;*/		/* a single byte write takes 10 cycles of main clock */
+		/*Y8950->deltat->read_time  = 8.0 / clock;*/		/* a single byte read takes 8 cycles of main clock */
+		/* reset */
+		/*OPL_save_state(Y8950);*/
+		y8950_reset_chip(Y8950);
+	}
+
+	return Y8950;
+}
+
+void y8950_shutdown(void *chip)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	/* emulator shutdown */
+	OPLDestroy(Y8950);
+}
+void y8950_reset_chip(void *chip)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	OPLResetChip(Y8950);
+}
+
+int y8950_write(void *chip, int a, int v)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	return OPLWrite(Y8950, a, v);
+}
+
+unsigned char y8950_read(void *chip, int a)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	return OPLRead(Y8950, a);
+}
+int y8950_timer_over(void *chip, int c)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	return OPLTimerOver(Y8950, c);
+}
+
+/*void y8950_set_timer_handler(void *chip, OPL_TIMERHANDLER timer_handler, void *param)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	OPLSetTimerHandler(Y8950, timer_handler, param);
+}*/
+void y8950_set_irq_handler(void *chip,OPL_IRQHANDLER IRQHandler,void *param)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	OPLSetIRQHandler(Y8950, IRQHandler, param);
+}
+void y8950_set_update_handler(void *chip,OPL_UPDATEHANDLER UpdateHandler,void *param)
+{
+	FM_OPL *Y8950 = (FM_OPL *)chip;
+	OPLSetUpdateHandler(Y8950, UpdateHandler, param);
+}
+
+void y8950_set_delta_t_memory(void *chip, void * deltat_mem_ptr, int deltat_mem_size )
+{
+	FM_OPL		*OPL = (FM_OPL *)chip;
+	OPL->deltat->memory = (UINT8 *)(deltat_mem_ptr);
+	OPL->deltat->memory_size = deltat_mem_size;
+}
+
+/*
+** Generate samples for one of the Y8950's
+**
+** 'which' is the virtual Y8950 number
+** '*buffer' is the output buffer pointer
+** 'length' is the number of samples that should be generated
+*/
+void y8950_update_one(void *chip, OPLSAMPLE *buffer, int length)
+{
+	int i;
+	FM_OPL		*OPL = (FM_OPL *)chip;
+	UINT8		rhythm  = OPL->rhythm&0x20;
+	YM_DELTAT	*DELTAT = OPL->deltat;
+	OPLSAMPLE	*buf    = buffer;
+
+	/* rhythm slots */
+	OPL->SLOT7_1 = &OPL->P_CH[7].SLOT[SLOT1];
+	OPL->SLOT7_2 = &OPL->P_CH[7].SLOT[SLOT2];
+	OPL->SLOT8_1 = &OPL->P_CH[8].SLOT[SLOT1];
+	OPL->SLOT8_2 = &OPL->P_CH[8].SLOT[SLOT2];
+
+	for( i=0; i < length ; i++ )
+	{
+		int lt;
+
+		OPL->output[0] = 0;
+		OPL->output_deltat[0] = 0;
+
+		advance_lfo(OPL);
+
+		/* deltaT ADPCM */
+		if( DELTAT->portstate&0x80 )
+			YM_DELTAT_ADPCM_CALC(DELTAT);
+
+		/* FM part */
+		OPL_CALC_CH(OPL, &OPL->P_CH[0]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[1]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[2]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[3]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[4]);
+		OPL_CALC_CH(OPL, &OPL->P_CH[5]);
+
+		if(!rhythm)
+		{
+			OPL_CALC_CH(OPL, &OPL->P_CH[6]);
+			OPL_CALC_CH(OPL, &OPL->P_CH[7]);
+			OPL_CALC_CH(OPL, &OPL->P_CH[8]);
+		}
+		else		/* Rhythm part */
+		{
+			OPL_CALC_RH(OPL, &OPL->P_CH[0], (OPL->noise_rng>>0)&1 );
+		}
+
+		lt = OPL->output[0] + (OPL->output_deltat[0]>>11);
+
+		lt >>= FINAL_SH;
+
+		/* limit check */
+		lt = limit( lt , MAXOUT, MINOUT );
+
+		#ifdef SAVE_SAMPLE
+		if (which==0)
+		{
+			SAVE_ALL_CHANNELS
+		}
+		#endif
+
+		/* store to sound buffer */
+		buf[i] = lt;
+
+		advance(OPL);
+	}
+
+}
+
+void y8950_set_port_handler(void *chip,OPL_PORTHANDLER_W PortHandler_w,OPL_PORTHANDLER_R PortHandler_r,void * param)
+{
+	FM_OPL		*OPL = (FM_OPL *)chip;
+	OPL->porthandler_w = PortHandler_w;
+	OPL->porthandler_r = PortHandler_r;
+	OPL->port_param = param;
+}
+
+void y8950_set_keyboard_handler(void *chip,OPL_PORTHANDLER_W KeyboardHandler_w,OPL_PORTHANDLER_R KeyboardHandler_r,void * param)
+{
+	FM_OPL		*OPL = (FM_OPL *)chip;
+	OPL->keyboardhandler_w = KeyboardHandler_w;
+	OPL->keyboardhandler_r = KeyboardHandler_r;
+	OPL->keyboard_param = param;
+}
+
+#endif
+
diff -Nur orig/source/gme/src/fmopl.h mod/source/gme/src/fmopl.h
--- orig/source/gme/src/fmopl.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/fmopl.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,116 @@
+#pragma once
+
+#ifndef __FMOPL_H__
+#define __FMOPL_H__
+
+/* --- select emulation chips --- */
+#define BUILD_YM3812 (1)
+#define BUILD_YM3526 (1)
+#define BUILD_Y8950  (1)
+
+/* select output bits size of output : 8 or 16 */
+#define OPL_SAMPLE_BITS 16
+
+/* compiler dependence */
+#ifndef __OSDCOMM_H__
+#define __OSDCOMM_H__
+typedef unsigned char	UINT8;   /* unsigned  8bit */
+typedef unsigned short	UINT16;  /* unsigned 16bit */
+typedef unsigned int	UINT32;  /* unsigned 32bit */
+typedef signed char		INT8;    /* signed  8bit   */
+typedef signed short	INT16;   /* signed 16bit   */
+typedef signed int		INT32;   /* signed 32bit   */
+
+typedef INT32 stream_sample_t;
+
+#endif /* __OSDCOMM_H__ */
+
+typedef stream_sample_t OPLSAMPLE;
+/*
+#if (OPL_SAMPLE_BITS==16)
+typedef INT16 OPLSAMPLE;
+#endif
+#if (OPL_SAMPLE_BITS==8)
+typedef INT8 OPLSAMPLE;
+#endif
+*/
+
+//typedef void (*OPL_TIMERHANDLER)(void *param,int timer,attotime period);
+typedef void (*OPL_IRQHANDLER)(void *param,int irq);
+typedef void (*OPL_UPDATEHANDLER)(void *param,int min_interval_us);
+typedef void (*OPL_PORTHANDLER_W)(void *param,unsigned char data);
+typedef unsigned char (*OPL_PORTHANDLER_R)(void *param);
+
+
+#if BUILD_YM3812
+
+void *ym3812_init(UINT32 clock, UINT32 rate);
+void ym3812_shutdown(void *chip);
+void ym3812_reset_chip(void *chip);
+int  ym3812_write(void *chip, int a, int v);
+unsigned char ym3812_read(void *chip, int a);
+int  ym3812_timer_over(void *chip, int c);
+void ym3812_update_one(void *chip, OPLSAMPLE *buffer, int length);
+
+//void ym3812_set_timer_handler(void *chip, OPL_TIMERHANDLER TimerHandler, void *param);
+void ym3812_set_irq_handler(void *chip, OPL_IRQHANDLER IRQHandler, void *param);
+void ym3812_set_update_handler(void *chip, OPL_UPDATEHANDLER UpdateHandler, void *param);
+
+#endif /* BUILD_YM3812 */
+
+
+#if BUILD_YM3526
+
+/*
+** Initialize YM3526 emulator(s).
+**
+** 'num' is the number of virtual YM3526's to allocate
+** 'clock' is the chip clock in Hz
+** 'rate' is sampling rate
+*/
+void *ym3526_init(UINT32 clock, UINT32 rate);
+/* shutdown the YM3526 emulators*/
+void ym3526_shutdown(void *chip);
+void ym3526_reset_chip(void *chip);
+int  ym3526_write(void *chip, int a, int v);
+unsigned char ym3526_read(void *chip, int a);
+int  ym3526_timer_over(void *chip, int c);
+/*
+** Generate samples for one of the YM3526's
+**
+** 'which' is the virtual YM3526 number
+** '*buffer' is the output buffer pointer
+** 'length' is the number of samples that should be generated
+*/
+void ym3526_update_one(void *chip, OPLSAMPLE *buffer, int length);
+
+//void ym3526_set_timer_handler(void *chip, OPL_TIMERHANDLER TimerHandler, void *param);
+void ym3526_set_irq_handler(void *chip, OPL_IRQHANDLER IRQHandler, void *param);
+void ym3526_set_update_handler(void *chip, OPL_UPDATEHANDLER UpdateHandler, void *param);
+
+#endif /* BUILD_YM3526 */
+
+
+#if BUILD_Y8950
+
+/* Y8950 port handlers */
+void y8950_set_port_handler(void *chip, OPL_PORTHANDLER_W PortHandler_w, OPL_PORTHANDLER_R PortHandler_r, void *param);
+void y8950_set_keyboard_handler(void *chip, OPL_PORTHANDLER_W KeyboardHandler_w, OPL_PORTHANDLER_R KeyboardHandler_r, void *param);
+void y8950_set_delta_t_memory(void *chip, void * deltat_mem_ptr, int deltat_mem_size );
+
+void * y8950_init(UINT32 clock, UINT32 rate);
+void y8950_shutdown(void *chip);
+void y8950_reset_chip(void *chip);
+int  y8950_write(void *chip, int a, int v);
+unsigned char y8950_read (void *chip, int a);
+int  y8950_timer_over(void *chip, int c);
+void y8950_update_one(void *chip, OPLSAMPLE *buffer, int length);
+
+//void y8950_set_timer_handler(void *chip, OPL_TIMERHANDLER TimerHandler, void *param);
+void y8950_set_irq_handler(void *chip, OPL_IRQHANDLER IRQHandler, void *param);
+void y8950_set_update_handler(void *chip, OPL_UPDATEHANDLER UpdateHandler, void *param);
+
+#endif /* BUILD_Y8950 */
+
+
+#endif /* __FMOPL_H__ */
diff -Nur orig/source/gme/src/Gb_Apu.cpp mod/source/gme/src/Gb_Apu.cpp
--- orig/source/gme/src/Gb_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gb_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,407 @@
+// Gb_Snd_Emu 0.1.4. http://www.slack.net/~ant/
+
+#include "Gb_Apu.h"
+
+//#include "gb_apu_logger.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const vol_reg    = 0xFF24;
+int const stereo_reg = 0xFF25;
+int const status_reg = 0xFF26;
+int const wave_ram   = 0xFF30;
+
+int const power_mask = 0x80;
+
+void Gb_Apu::treble_eq( blip_eq_t const& eq )
+{
+	norm_synth.treble_eq( eq );
+	fast_synth.treble_eq( eq );
+}
+
+inline int Gb_Apu::calc_output( int osc ) const
+{
+	int bits = regs [stereo_reg - io_addr] >> osc;
+	return (bits >> 3 & 2) | (bits & 1);
+}
+
+void Gb_Apu::set_output( int i, Blip_Buffer* center, Blip_Buffer* left, Blip_Buffer* right )
+{
+	// Must be silent (all NULL), mono (left and right NULL), or stereo (none NULL)
+	require( !center || (center && !left && !right) || (center && left && right) );
+	require( (unsigned) i < osc_count ); // fails if you pass invalid osc index
+	
+	if ( !center || !left || !right )
+	{
+		left  = center;
+		right = center;
+	}
+	
+	Gb_Osc& o = *oscs [i];
+	o.outputs [1] = right;
+	o.outputs [2] = left;
+	o.outputs [3] = center;
+	o.output = o.outputs [calc_output( i )];
+}
+
+void Gb_Apu::synth_volume( int iv )
+{
+	double v = volume_ * 0.60 / osc_count / 15 /*steps*/ / 8 /*master vol range*/ * iv;
+	norm_synth.volume( v );
+	fast_synth.volume( v );
+}
+
+void Gb_Apu::apply_volume()
+{
+	// TODO: Doesn't handle differing left and right volumes (panning).
+	// Not worth the complexity.
+	int data  = regs [vol_reg - io_addr];
+	int left  = data >> 4 & 7;
+	int right = data & 7;
+	//if ( data & 0x88 ) dprintf( "Vin: %02X\n", data & 0x88 );
+	//if ( left != right ) dprintf( "l: %d r: %d\n", left, right );
+	synth_volume( max( left, right ) + 1 );
+}
+
+void Gb_Apu::volume( double v )
+{
+	if ( volume_ != v )
+	{
+		volume_ = v;
+		apply_volume();
+	}
+}
+
+void Gb_Apu::reset_regs()
+{
+	for ( int i = 0; i < 0x20; i++ )
+		regs [i] = 0;
+	
+	square1.reset();
+	square2.reset();
+	wave   .reset();
+	noise  .reset();
+	
+	apply_volume();
+}
+
+void Gb_Apu::reset_lengths()
+{
+	square1.length_ctr = 64;
+	square2.length_ctr = 64;
+	wave   .length_ctr = 256;
+	noise  .length_ctr = 64;
+}
+
+void Gb_Apu::reduce_clicks( bool reduce )
+{
+	reduce_clicks_ = reduce;
+	
+	// Click reduction makes DAC off generate same output as volume 0
+	int dac_off_amp = 0;
+	if ( reduce && wave.mode != mode_agb ) // AGB already eliminates clicks
+		dac_off_amp = -Gb_Osc::dac_bias;
+	
+	for ( int i = 0; i < osc_count; i++ )
+		oscs [i]->dac_off_amp = dac_off_amp;
+	
+	// AGB always eliminates clicks on wave channel using same method
+	if ( wave.mode == mode_agb )
+		wave.dac_off_amp = -Gb_Osc::dac_bias;
+}
+
+void Gb_Apu::reset( mode_t mode, bool agb_wave )
+{
+	// Hardware mode
+	if ( agb_wave )
+		mode = mode_agb; // using AGB wave features implies AGB hardware
+	wave.agb_mask = agb_wave ? 0xFF : 0;
+	for ( int i = 0; i < osc_count; i++ )
+		oscs [i]->mode = mode;
+	reduce_clicks( reduce_clicks_ );
+	
+	// Reset state
+	frame_time  = 0;
+	last_time   = 0;
+	frame_phase = 0;
+	
+	reset_regs();
+	reset_lengths();
+	
+	// Load initial wave RAM
+	static byte const initial_wave [2] [16] = {
+		{0x84,0x40,0x43,0xAA,0x2D,0x78,0x92,0x3C,0x60,0x59,0x59,0xB0,0x34,0xB8,0x2E,0xDA},
+		{0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF},
+	};
+	for ( int b = 2; --b >= 0; )
+	{
+		// Init both banks (does nothing if not in AGB mode)
+		// TODO: verify that this works
+		write_register( 0, 0xFF1A, b * 0x40 );
+		for ( unsigned i = 0; i < sizeof initial_wave [0]; i++ )
+			write_register( 0, i + wave_ram, initial_wave [(mode != mode_dmg)] [i] );
+	}
+}
+
+void Gb_Apu::set_tempo( double t )
+{
+	frame_period = 4194304 / 512; // 512 Hz
+	if ( t != 1.0 )
+		frame_period = t ? blip_time_t (frame_period / t) : blip_time_t(0);
+}
+
+Gb_Apu::Gb_Apu()
+{
+	wave.wave_ram = &regs [wave_ram - io_addr];
+	
+	oscs [0] = &square1;
+	oscs [1] = &square2;
+	oscs [2] = &wave;
+	oscs [3] = &noise;
+	
+	for ( int i = osc_count; --i >= 0; )
+	{
+		Gb_Osc& o = *oscs [i];
+		o.regs        = &regs [i * 5];
+		o.output      = NULL;
+		o.outputs [0] = NULL;
+		o.outputs [1] = NULL;
+		o.outputs [2] = NULL;
+		o.outputs [3] = NULL;
+		o.norm_synth  = &norm_synth;
+		o.fast_synth  = &fast_synth;
+	}
+	
+	reduce_clicks_ = false;
+	set_tempo( 1.0 );
+	volume_ = 1.0;
+	reset();
+}
+
+void Gb_Apu::run_until_( blip_time_t end_time )
+{
+	if ( !frame_period )
+		frame_time += end_time - last_time;
+	
+	while ( true )
+	{
+		// run oscillators
+		blip_time_t time = end_time;
+		if ( time > frame_time )
+			time = frame_time;
+		
+		square1.run( last_time, time );
+		square2.run( last_time, time );
+		wave   .run( last_time, time );
+		noise  .run( last_time, time );
+		last_time = time;
+		
+		if ( time == end_time )
+			break;
+		
+		// run frame sequencer
+		assert( frame_period );
+		frame_time += frame_period * Gb_Osc::clk_mul;
+		switch ( frame_phase++ )
+		{
+		case 2:
+		case 6:
+			// 128 Hz
+			square1.clock_sweep();
+		case 0:
+		case 4:
+			// 256 Hz
+			square1.clock_length();
+			square2.clock_length();
+			wave   .clock_length();
+			noise  .clock_length();
+			break;
+		
+		case 7:
+			// 64 Hz
+			frame_phase = 0;
+			square1.clock_envelope();
+			square2.clock_envelope();
+			noise  .clock_envelope();
+		}
+	}
+}
+
+inline void Gb_Apu::run_until( blip_time_t time )
+{
+	require( time >= last_time ); // end_time must not be before previous time
+	if ( time > last_time )
+		run_until_( time );
+}
+
+void Gb_Apu::end_frame( blip_time_t end_time )
+{
+	#ifdef LOG_FRAME
+		LOG_FRAME( end_time );
+	#endif
+	
+	if ( end_time > last_time )
+		run_until( end_time );
+	
+	frame_time -= end_time;
+	assert( frame_time >= 0 );
+	
+	last_time -= end_time;
+	assert( last_time >= 0 );
+}
+
+void Gb_Apu::silence_osc( Gb_Osc& o )
+{
+	int delta = -o.last_amp;
+	if ( reduce_clicks_ )
+		delta += o.dac_off_amp;
+	
+	if ( delta )
+	{
+		o.last_amp = o.dac_off_amp;
+		if ( o.output )
+		{
+			o.output->set_modified();
+			fast_synth.offset( last_time, delta, o.output );
+		}
+	}
+}
+
+void Gb_Apu::apply_stereo()
+{
+	for ( int i = osc_count; --i >= 0; )
+	{
+		Gb_Osc& o = *oscs [i];
+		Blip_Buffer* out = o.outputs [calc_output( i )];
+		if ( o.output != out )
+		{
+			silence_osc( o );
+			o.output = out;
+		}
+	}
+}
+
+void Gb_Apu::write_register( blip_time_t time, int addr, int data )
+{
+	require( (unsigned) data < 0x100 );
+	
+	int reg = addr - io_addr;
+	if ( (unsigned) reg >= io_size )
+	{
+		require( false );
+		return;
+	}
+	
+	#ifdef LOG_WRITE
+		LOG_WRITE( time, addr, data );
+	#endif
+	
+	if ( addr < status_reg && !(regs [status_reg - io_addr] & power_mask) )
+	{
+		// Power is off
+		
+		// length counters can only be written in DMG mode
+		if ( wave.mode != mode_dmg || (reg != 1 && reg != 5+1 && reg != 10+1 && reg != 15+1) )
+			return;
+		
+		if ( reg < 10 )
+			data &= 0x3F; // clear square duty
+	}
+	
+	run_until( time );
+	
+	if ( addr >= wave_ram )
+	{
+		wave.write( addr, data );
+	}
+	else
+	{
+		int old_data = regs [reg];
+		regs [reg] = data;
+		
+		if ( addr < vol_reg )
+		{
+			// Oscillator
+			write_osc( reg, old_data, data );
+		}
+		else if ( addr == vol_reg && data != old_data )
+		{
+			// Master volume
+			for ( int i = osc_count; --i >= 0; )
+				silence_osc( *oscs [i] );
+			
+			apply_volume();
+		}
+		else if ( addr == stereo_reg )
+		{
+			// Stereo panning
+			apply_stereo();
+		}
+		else if ( addr == status_reg && (data ^ old_data) & power_mask )
+		{
+			// Power control
+			frame_phase = 0;
+			for ( int i = osc_count; --i >= 0; )
+				silence_osc( *oscs [i] );
+		
+			reset_regs();
+			if ( wave.mode != mode_dmg )
+				reset_lengths();
+			
+			regs [status_reg - io_addr] = data;
+		}
+	}
+}
+
+int Gb_Apu::read_register( blip_time_t time, int addr )
+{
+	if ( addr >= status_reg )
+		run_until( time );
+	
+	int reg = addr - io_addr;
+	if ( (unsigned) reg >= io_size )
+	{
+		require( false );
+		return 0;
+	}
+	
+	if ( addr >= wave_ram )
+		return wave.read( addr );
+	
+	// Value read back has some bits always set
+	static byte const masks [] = {
+		0x80,0x3F,0x00,0xFF,0xBF,
+		0xFF,0x3F,0x00,0xFF,0xBF,
+		0x7F,0xFF,0x9F,0xFF,0xBF,
+		0xFF,0xFF,0x00,0x00,0xBF,
+		0x00,0x00,0x70,
+		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
+	};
+	int mask = masks [reg];
+	if ( wave.agb_mask && (reg == 10 || reg == 12) )
+		mask = 0x1F; // extra implemented bits in wave regs on AGB
+	int data = regs [reg] | mask;
+	
+	// Status register
+	if ( addr == status_reg )
+	{
+		data &= 0xF0;
+		data |= (int) square1.enabled << 0;
+		data |= (int) square2.enabled << 1;
+		data |= (int) wave   .enabled << 2;
+		data |= (int) noise  .enabled << 3;
+	}
+	
+	return data;
+}
diff -Nur orig/source/gme/src/Gb_Apu.h mod/source/gme/src/Gb_Apu.h
--- orig/source/gme/src/Gb_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gb_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,193 @@
+// Nintendo Game Boy sound hardware emulator with save state support
+
+// Gb_Snd_Emu 0.1.4
+#ifndef GB_APU_H
+#define GB_APU_H
+
+#include "Gb_Oscs.h"
+
+struct gb_apu_state_t;
+
+class Gb_Apu {
+public:
+// Basics
+
+	// Sets buffer(s) to generate sound into, or NULL to mute. If only center is not NULL,
+	// output is mono.
+	void set_output( Blip_Buffer* center, Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+	
+	// Emulates to time t, then writes data to addr
+	void write_register( blip_time_t t, int addr, int data );
+	
+	// Emulates to time t, then subtracts t from the current time.
+	// OK if previous write call had time slightly after t.
+	void end_frame( blip_time_t t );
+	
+// More features
+	
+	// Clock rate sound hardware runs at
+	enum { clock_rate = 4194304 * GB_APU_OVERCLOCK };
+	
+	// Registers are at io_addr to io_addr+io_size-1
+	enum { io_addr = 0xFF10 };
+	enum { io_size = 0x30 };
+	
+	// Emulates to time t, then reads from addr
+	int read_register( blip_time_t t, int addr );
+	
+	// Resets hardware to state after power, BEFORE boot ROM runs. Mode selects
+	// sound hardware. If agb_wave is true, enables AGB's extra wave features.
+	enum mode_t {
+		mode_dmg,   // Game Boy monochrome
+		mode_cgb,   // Game Boy Color
+		mode_agb    // Game Boy Advance
+	};
+	void reset( mode_t mode = mode_cgb, bool agb_wave = false );
+	
+	// Same as set_output(), but for a particular channel
+	// 0: Square 1, 1: Square 2, 2: Wave, 3: Noise
+	enum { osc_count = 4 }; // 0 <= chan < osc_count
+	void set_output( int chan, Blip_Buffer* center,
+			Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+	
+	// Sets overall volume, where 1.0 is normal
+	void volume( double );
+	
+	// Sets treble equalization
+	void treble_eq( blip_eq_t const& );
+	
+	// Treble and bass values for various hardware.
+	enum {
+		speaker_treble =  -47, // speaker on system
+		speaker_bass   = 2000,
+		dmg_treble     =    0, // headphones on each system
+		dmg_bass       =   30,
+		cgb_treble     =    0,
+		cgb_bass       =  300, // CGB has much less bass
+		agb_treble     =    0,
+		agb_bass       =   30
+	};
+	
+	// If true, reduces clicking by disabling DAC biasing. Note that this reduces
+	// emulation accuracy, since the clicks are authentic.
+	void reduce_clicks( bool reduce = true );
+	
+	// Sets frame sequencer rate, where 1.0 is normal. Meant for adjusting the
+	// tempo in a music player.
+	void set_tempo( double );
+	
+	// Saves full emulation state to state_out. Data format is portable and
+	// includes some extra space to avoid expansion in case more state needs
+	// to be stored in the future.
+	void save_state( gb_apu_state_t* state_out );
+	
+	// Loads state. You should call reset() BEFORE this.
+	blargg_err_t load_state( gb_apu_state_t const& in );
+
+private:
+	// noncopyable
+	Gb_Apu( const Gb_Apu& );
+	Gb_Apu& operator = ( const Gb_Apu& );
+
+// Implementation
+public:
+	Gb_Apu();
+	
+	// Use set_output() in place of these
+	BLARGG_DEPRECATED( void output    (        Blip_Buffer* c                                 ); )
+	BLARGG_DEPRECATED( void output    (        Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r ); )
+	BLARGG_DEPRECATED( void osc_output( int i, Blip_Buffer* c                                 ) { set_output( i, c, c, c ); } )
+	BLARGG_DEPRECATED( void osc_output( int i, Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r ) { set_output( i, c, l, r ); } )
+	
+	BLARGG_DEPRECATED_TEXT( enum { start_addr = 0xFF10 }; )
+	BLARGG_DEPRECATED_TEXT( enum { end_addr   = 0xFF3F }; )
+	BLARGG_DEPRECATED_TEXT( enum { register_count = end_addr - start_addr + 1 }; )
+
+private:    
+	Gb_Osc*     oscs [osc_count];
+	blip_time_t last_time;          // time sound emulator has been run to
+	blip_time_t frame_period;       // clocks between each frame sequencer step
+	double      volume_;
+	bool        reduce_clicks_;
+	
+	Gb_Sweep_Square square1;
+	Gb_Square       square2;
+	Gb_Wave         wave;
+	Gb_Noise        noise;
+	blip_time_t     frame_time;     // time of next frame sequencer action
+	int             frame_phase;    // phase of next frame sequencer step
+	enum { regs_size = io_size + 0x10 };
+	BOOST::uint8_t  regs [regs_size];// last values written to registers
+	
+	// large objects after everything else
+	Blip_Synth_Norm norm_synth;
+	Blip_Synth_Fast fast_synth;
+	
+	void reset_lengths();
+	void reset_regs();
+	int calc_output( int osc ) const;
+	void apply_stereo();
+	void apply_volume();
+	void synth_volume( int );
+	void run_until_( blip_time_t );
+	void run_until( blip_time_t );
+	void silence_osc( Gb_Osc& );
+	void write_osc( int reg, int old_data, int data );
+	const char* save_load( gb_apu_state_t*, bool save );
+	void save_load2( gb_apu_state_t*, bool save );
+	friend class Gb_Apu2;
+};
+
+// Format of save state. Should be stable across versions of the library,
+// with earlier versions properly opening later save states. Includes some
+// room for expansion so the state size shouldn't increase.
+struct gb_apu_state_t
+{
+#if GB_APU_CUSTOM_STATE
+	// Values stored as plain int so your code can read/write them easily.
+	// Structure can NOT be written to disk, since format is not portable.
+	typedef int val_t;
+#else
+	// Values written in portable little-endian format, allowing structure
+	// to be written directly to disk.
+	typedef unsigned char val_t [4];
+#endif
+	
+	enum { format0 = 0x50414247 }; // 'GBAP'
+	
+	val_t format;   // format of all following data
+	val_t version;  // later versions just add fields to end
+	
+	unsigned char regs [0x40];
+	val_t frame_time;
+	val_t frame_phase;
+	
+	val_t sweep_freq;
+	val_t sweep_delay;
+	val_t sweep_enabled;
+	val_t sweep_neg;
+	val_t noise_divider;
+	val_t wave_buf;
+	
+	val_t delay      [4];
+	val_t length_ctr [4];
+	val_t phase      [4];
+	val_t enabled    [4];
+	
+	val_t env_delay   [3];
+	val_t env_volume  [3];
+	val_t env_enabled [3];
+	
+	val_t unused  [13]; // for future expansion
+};
+
+inline void Gb_Apu::set_output( Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	for ( int i = osc_count; --i >= 0; )
+		set_output( i, c, l, r );
+}
+
+BLARGG_DEPRECATED_TEXT( inline void Gb_Apu::output( Blip_Buffer* c                                 ) { set_output(    c, c, c ); } )
+BLARGG_DEPRECATED_TEXT( inline void Gb_Apu::output( Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r ) { set_output(    c, l, r ); } )
+
+#endif
diff -Nur orig/source/gme/src/Gb_Cpu.cpp mod/source/gme/src/Gb_Cpu.cpp
--- orig/source/gme/src/Gb_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gb_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,51 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Gb_Cpu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+inline void Gb_Cpu::set_code_page( int i, void* p )
+{
+	byte* p2 = STATIC_CAST(byte*,p) - GB_CPU_OFFSET( i * page_size );
+	cpu_state_.code_map [i] = p2;
+	cpu_state->code_map [i] = p2;
+}
+
+void Gb_Cpu::reset( void* unmapped )
+{
+	check( cpu_state == &cpu_state_ );
+	cpu_state = &cpu_state_;
+	
+	cpu_state_.time = 0;
+	
+	for ( int i = 0; i < page_count + 1; ++i )
+		set_code_page( i, unmapped );
+	
+	memset( &r, 0, sizeof r );
+	
+	blargg_verify_byte_order();
+}
+
+void Gb_Cpu::map_code( addr_t start, int size, void* data )
+{
+	// address range must begin and end on page boundaries
+	require( start % page_size == 0 );
+	require( size  % page_size == 0 );
+	require( start + size <= mem_size );
+	
+	for ( int offset = 0; offset < size; offset += page_size )
+		set_code_page( (start + offset) >> page_bits, STATIC_CAST(char*,data) + offset );
+}
diff -Nur orig/source/gme/src/Gb_Cpu.h mod/source/gme/src/Gb_Cpu.h
--- orig/source/gme/src/Gb_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gb_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,82 @@
+// Nintendo Game Boy CPU emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef GB_CPU_H
+#define GB_CPU_H
+
+#include "blargg_common.h"
+
+class Gb_Cpu {
+public:
+	typedef int addr_t;
+	typedef BOOST::uint8_t byte;
+	
+	enum { mem_size = 0x10000 };
+	
+	// Clears registers and map all pages to unmapped
+	void reset( void* unmapped = NULL );
+	
+	// Maps code memory (memory accessed via the program counter). Start and size
+	// must be multiple of page_size.
+	enum { page_bits = 13 };
+	enum { page_size = 1 << page_bits };
+	void map_code( addr_t start, int size, void* code );
+	
+	// Accesses emulated memory as CPU does
+	byte* get_code( addr_t );
+	
+	// Game Boy Z-80 registers. NOT kept updated during emulation.
+	struct core_regs_t {
+		BOOST::uint16_t bc, de, hl, fa;
+	};
+	
+	struct registers_t : core_regs_t {
+		int pc; // more than 16 bits to allow overflow detection
+		BOOST::uint16_t sp;
+	};
+	registers_t r;
+	
+	// Base address for RST vectors, to simplify GBS player (normally 0)
+	addr_t rst_base;
+	
+	// Current time.
+	int time() const { return cpu_state->time; }
+	
+	// Changes time. Must not be called during emulation.
+	// Should be negative, because emulation stops once it becomes >= 0.
+	void set_time( int t ) { cpu_state->time = t; }
+	
+	// Emulator reads this many bytes past end of a page
+	enum { cpu_padding = 8 };
+
+	
+// Implementation
+public:
+	Gb_Cpu() : rst_base( 0 ) { cpu_state = &cpu_state_; }
+	enum { page_count = mem_size >> page_bits };
+	
+	struct cpu_state_t {
+		byte* code_map [page_count + 1];
+		int time;
+	};
+	cpu_state_t* cpu_state; // points to state_ or a local copy within run()
+	cpu_state_t cpu_state_;
+	
+private:
+	void set_code_page( int, void* );
+};
+
+#define GB_CPU_PAGE( addr ) ((unsigned) (addr) >> Gb_Cpu::page_bits)
+
+#if BLARGG_NONPORTABLE
+	#define GB_CPU_OFFSET( addr ) (addr)
+#else
+	#define GB_CPU_OFFSET( addr ) ((addr) & (Gb_Cpu::page_size - 1))
+#endif
+
+inline BOOST::uint8_t* Gb_Cpu::get_code( addr_t addr )
+{
+	return cpu_state_.code_map [GB_CPU_PAGE( addr )] + GB_CPU_OFFSET( addr );
+}
+
+#endif
diff -Nur orig/source/gme/src/gb_cpu_io.h mod/source/gme/src/gb_cpu_io.h
--- orig/source/gme/src/gb_cpu_io.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/gb_cpu_io.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,72 @@
+
+#include "Gbs_Emu.h"
+
+#include "blargg_source.h"
+
+int Gbs_Emu::cpu_read( gb_addr_t addr )
+{
+	int result = *cpu::get_code( addr );
+	if ( unsigned (addr - Gb_Apu::start_addr) < Gb_Apu::register_count )
+		result = apu.read_register( clock(), addr );
+#ifndef NDEBUG
+	else if ( unsigned (addr - 0x8000) < 0x2000 || unsigned (addr - 0xE000) < 0x1F00 )
+		debug_printf( "Read from unmapped memory $%.4x\n", (unsigned) addr );
+	else if ( unsigned (addr - 0xFF01) < 0xFF80 - 0xFF01 )
+		debug_printf( "Unhandled I/O read 0x%4X\n", (unsigned) addr );
+#endif
+	return result;
+}
+
+void Gbs_Emu::cpu_write( gb_addr_t addr, int data )
+{
+	unsigned offset = addr - ram_addr;
+	if ( offset <= 0xFFFF - ram_addr )
+	{
+		ram [offset] = data;
+		if ( (addr ^ 0xE000) <= 0x1F80 - 1 )
+		{
+			if ( unsigned (addr - Gb_Apu::start_addr) < Gb_Apu::register_count )
+			{
+				GME_APU_HOOK( this, addr - Gb_Apu::start_addr, data );
+				apu.write_register( clock(), addr, data );
+			}
+			else if ( (addr ^ 0xFF06) < 2 )
+				update_timer();
+			else if ( addr == joypad_addr )
+				ram [offset] = 0; // keep joypad return value 0
+			else
+				ram [offset] = 0xFF;
+
+			//if ( addr == 0xFFFF )
+			//  debug_printf( "Wrote interrupt mask\n" );
+		}
+	}
+	else if ( (addr ^ 0x2000) <= 0x2000 - 1 )
+	{
+		set_bank( data );
+	}
+#ifndef NDEBUG
+	else if ( unsigned (addr - 0x8000) < 0x2000 || unsigned (addr - 0xE000) < 0x1F00 )
+	{
+		debug_printf( "Wrote to unmapped memory $%.4x\n", (unsigned) addr );
+	}
+#endif
+}
+
+#define CPU_READ_FAST( cpu, addr, time, out ) \
+	CPU_READ_FAST_( STATIC_CAST(Gbs_Emu*,cpu), addr, time, out )
+
+#define CPU_READ_FAST_( emu, addr, time, out ) \
+{\
+	out = READ_PROG( addr );\
+	if ( unsigned (addr - Gb_Apu::start_addr) <= Gb_Apu::register_count )\
+		out = emu->apu.read_register( emu->cpu_time - time * clocks_per_instr, addr );\
+	else\
+		check( out == emu->cpu_read( addr ) );\
+}
+
+#define CPU_READ( cpu, addr, time ) \
+	STATIC_CAST(Gbs_Emu*,cpu)->cpu_read( addr )
+
+#define CPU_WRITE( cpu, addr, data, time ) \
+	STATIC_CAST(Gbs_Emu*,cpu)->cpu_write( addr, data )
diff -Nur orig/source/gme/src/Gb_Cpu_run.h mod/source/gme/src/Gb_Cpu_run.h
--- orig/source/gme/src/Gb_Cpu_run.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gb_Cpu_run.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1183 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#if 0
+/* Define these macros in the source file before #including this file.
+- Parameters might be expressions, so they are best evaluated only once,
+though they NEVER have side-effects, so multiple evaluation is OK.
+- Output parameters might be a multiple-assignment expression like "a=x",
+so they must NOT be parenthesized.
+- Macros "returning" void may use a {} statement block. */
+
+	// 0 <= addr <= 0xFFFF + page_size
+	// time functions can be used
+	int  READ_MEM(  addr_t );
+	void WRITE_MEM( addr_t, int data );
+	
+	// Access of 0xFF00 + offset
+	// 0 <= offset <= 0xFF
+	int  READ_IO(  int offset );
+	void WRITE_IO( int offset, int data );
+
+	// Often-used instructions use this instead of READ_MEM
+	void READ_FAST( addr_t, int& out );
+
+// The following can be used within macros:
+	
+	// Current time
+	cpu_time_t TIME();
+#endif
+
+/* Copyright (C) 2003-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+// Common instructions:
+//
+// 365880   FA      LD   A,(nn)
+// 355863   20      JR   NZ
+// 313655   21      LD   HL,nn
+// 274580   28      JR   Z
+// 252878   FE      CP   n
+// 230541   7E      LD   A,(HL)
+// 226209   2A      LD   A,(HL+)
+// 217467   CD      CALL
+// 212034   C9      RET
+// 208376   CB      CB prefix
+//
+//  27486   CB 7E   BIT  7,(HL)
+//  15925   CB 76   BIT  6,(HL)
+//  13035   CB 19   RR   C
+//  11557   CB 7F   BIT  7,A
+//  10898   CB 37   SWAP A
+//  10208   CB 66   BIT  4,(HL)
+
+// Allows MWCW debugger to step through code properly
+#ifdef CPU_BEGIN
+	CPU_BEGIN
+#endif
+
+#define TIME()  s.time
+
+#define CODE_PAGE( addr )   s.code_map [GB_CPU_PAGE( addr )]
+#define READ_CODE( addr )   (CODE_PAGE( addr ) [GB_CPU_OFFSET( addr )])
+
+// Flags with hex value for clarity when used as mask.
+// Stored in indicated variable during emulation.
+int const z80 = 0x80; // cz
+int const n40 = 0x40; // ph
+int const h20 = 0x20; // ph
+int const c10 = 0x10; // cz
+
+#define SET_FLAGS( in )\
+{\
+	cz = ((in) << 4 & 0x100) + (~(in) >> 7 & 1);\
+	ph = (~(in) << 2 & 0x100) + ((in) >> 1 & 0x10);\
+}
+
+// random bits in cz to catch misuse of them
+#define SET_FLAGS_DEBUG( in )\
+{\
+	cz = ((in) << 4 & 0x100) | (rand() & ~0x1FF) | ((in) & 0x80 ? 0 : (rand() & 0xFF) | 1);\
+	ph = (~(in) << 2 & 0x100) | (((in) >> 1 & 0x10) ^ BYTE( cz ));\
+}
+
+#define GET_FLAGS( out )\
+{\
+	out = (cz >> 4 & c10);\
+	out += ~ph >> 2 & n40;\
+	out += (ph ^ cz) << 1 & h20;\
+	if ( !BYTE( cz ) )\
+		out += z80;\
+}
+
+#define CC_NZ() ( BYTE( cz ))
+#define CC_Z()  (!BYTE( cz ))
+#define CC_NC() (!(cz & 0x100))
+#define CC_C()  (  cz & 0x100 )
+
+// Truncation
+#define BYTE(  n ) ((BOOST::uint8_t ) (n)) /* (unsigned) n & 0xFF */
+#define SBYTE( n ) ((BOOST::int8_t  ) (n)) /* (BYTE( n ) ^ 0x80) - 0x80 */
+#define WORD(  n ) ((BOOST::uint16_t) (n)) /* (unsigned) n & 0xFFFF */
+
+{
+	Gb_Cpu::cpu_state_t s;
+	CPU.cpu_state = &s;
+	memcpy( &s, &CPU.cpu_state_, sizeof s );
+	
+	union {
+		struct {
+		#if BLARGG_BIG_ENDIAN
+			byte b, c, d, e, h, l, flags, a;
+		#else
+			byte c, b, e, d, l, h, a, flags;
+		#endif
+		} rg; // individual registers
+		Gb_Cpu::core_regs_t rp; // pairs
+		
+		byte r8_ [8]; // indexed registers (use R8 macro due to endian dependence)
+		BOOST::uint16_t r16 [4]; // indexed pairs
+	};
+	BLARGG_STATIC_ASSERT( sizeof rg == 8 && sizeof rp == 8 );
+
+	#if BLARGG_BIG_ENDIAN
+		#define R8( n ) (r8_ [n]) 
+	#elif BLARGG_LITTLE_ENDIAN
+		#define R8( n ) (r8_ [(n) ^ 1]) 
+	#else
+		// Be sure "blargg_endian.h" has been #included in the file that #includes this
+		#error "Byte order of CPU must be known"
+	#endif
+	
+	rp = CPU.r;
+	int pc = CPU.r.pc;
+	int sp = CPU.r.sp;
+	int ph;
+	int cz;
+	SET_FLAGS( rg.flags );
+	
+	int time = s.time;
+	
+loop:
+	
+	check( (unsigned) pc < 0x10000 + 1 ); // +1 so emulator can catch wrap-around
+	check( (unsigned) sp < 0x10000 );
+	
+	byte const* instr = CODE_PAGE( pc );
+	int op;
+	
+	if ( GB_CPU_OFFSET(~0) == ~0 )
+	{
+		op = instr [pc];
+		pc++;
+		instr += pc;
+	}
+	else
+	{
+		instr += GB_CPU_OFFSET( pc );
+		op = *instr++;
+		pc++;
+	}
+	
+#define GET_ADDR()  GET_LE16( instr )
+	
+	static byte const instr_times [256*2] = {
+	//   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
+		 4,12, 8, 8, 4, 4, 8, 4,20, 8, 8, 8, 4, 4, 8, 4,// 0
+		 4,12, 8, 8, 4, 4, 8, 4,12, 8, 8, 8, 4, 4, 8, 4,// 1
+		 8,12, 8, 8, 4, 4, 8, 4, 8, 8, 8, 8, 4, 4, 8, 4,// 2
+		 8,12, 8, 8,12,12,12, 4, 8, 8, 8, 8, 4, 4, 8, 4,// 3
+		 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,// 4
+		 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,// 5
+		 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,// 6
+		 8, 8, 8, 8, 8, 8, 0, 8, 4, 4, 4, 4, 4, 4, 8, 4,// 7
+		 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,// 8
+		 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,// 9
+		 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,// A
+		 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 4, 4, 4, 8, 4,// B
+		 8,12,16,16,12,16, 8,16, 8,16,16, 0,12,24, 8,16,// C
+		 8,12,16, 0,12,16, 8,16, 8,16,16, 0,12, 0, 8,16,// D
+		12,12, 8, 0, 0,16, 8,16,16, 4,16, 0, 0, 0, 8,16,// E
+		12,12, 8, 4, 0,16, 8,16,12, 8,16, 4, 0, 0, 8,16,// F
+		
+	// CB prefixed
+	//   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// 0
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// 1
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// 2
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// 3
+		 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,// 4
+		 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,// 5
+		 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,// 6
+		 8, 8, 8, 8, 8, 8,12, 8, 8, 8, 8, 8, 8, 8,12, 8,// 7
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// 8
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// 9
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// A
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// B
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// C
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// D
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// E
+		 8, 8, 8, 8, 8, 8,16, 8, 8, 8, 8, 8, 8, 8,16, 8,// F
+	};
+	
+	if ( time >= 0 )
+		goto stop;
+	
+	time += instr_times [op];
+	
+	int data;
+	data = *instr;
+	s.time = time;
+	
+	#ifdef CPU_INSTR_HOOK
+	{ CPU_INSTR_HOOK( (pc-1), (instr-1), rg.a, rp.bc, rp.de, rp.hl, sp ); }
+	#endif
+	
+	switch ( op )
+	{
+
+// TODO: more efficient way to handle negative branch that wraps PC around
+#define BRANCH_( cond, clocks )\
+{\
+	pc++;\
+	if ( !(cond) )\
+		goto loop;\
+	pc = WORD( pc + SBYTE( data ) );\
+	time += clocks;\
+	goto loop;\
+}
+
+#define BRANCH( cond ) BRANCH_( cond, 4 )
+
+// Most Common
+
+	case 0x20: // JR NZ
+		BRANCH( CC_NZ() )
+	
+	case 0x21: // LD HL,IMM (common)
+		rp.hl = GET_ADDR();
+		pc += 2;
+		goto loop;
+	
+	case 0x28: // JR Z
+		BRANCH( CC_Z() )
+	
+	case 0xF2: // LD A,(0xFF00+C)
+		READ_IO( rg.c, rg.a );
+		goto loop;
+	
+	case 0xF0: // LD A,(0xFF00+imm)
+		pc++;
+		READ_IO( data, rg.a );
+		goto loop;
+	
+	{
+		int temp;
+	case 0x0A: // LD A,(BC)
+		temp = rp.bc;
+		goto ld_a_ind_comm;
+	
+	case 0x3A: // LD A,(HL-)
+		temp = rp.hl;
+		rp.hl = temp - 1;
+		goto ld_a_ind_comm;
+	
+	case 0x1A: // LD A,(DE)
+		temp = rp.de;
+		goto ld_a_ind_comm;
+	
+	case 0x2A: // LD A,(HL+) (common)
+		temp = rp.hl;
+		rp.hl = temp + 1;
+		goto ld_a_ind_comm;
+		
+	case 0xFA: // LD A,IND16 (common)
+		temp = GET_ADDR();
+		pc += 2;
+	ld_a_ind_comm:
+		READ_FAST( temp, rg.a );
+		goto loop;
+	}
+	
+	{
+		int temp;
+	case 0xBE: // CP (HL)
+		temp = READ_MEM( rp.hl );
+		goto cmp_comm;
+	
+	case 0xB8: // CP B
+	case 0xB9: // CP C
+	case 0xBA: // CP D
+	case 0xBB: // CP E
+	case 0xBC: // CP H
+	case 0xBD: // CP L
+	case 0xBF: // CP A
+		temp = R8( op & 7 );
+	cmp_comm:
+		ph = rg.a ^ temp; // N=1 H=*
+		cz = rg.a - temp; // C=* Z=*
+		goto loop;
+	}
+	
+	case 0xFE: // CP IMM
+		pc++;
+		ph = rg.a ^ data; // N=1 H=*
+		cz = rg.a - data; // C=* Z=*
+		goto loop;
+	
+	case 0x46: // LD B,(HL)
+	case 0x4E: // LD C,(HL)
+	case 0x56: // LD D,(HL)
+	case 0x5E: // LD E,(HL)
+	case 0x66: // LD H,(HL)
+	case 0x6E: // LD L,(HL)
+	case 0x7E:{// LD A,(HL)
+		int addr = rp.hl;
+		READ_FAST( addr, R8( op >> 3 & 7 ) );
+		goto loop;
+	}
+	
+	case 0xC4: // CNZ (next-most-common)
+		pc += 2;
+		if ( CC_Z() )
+			goto loop;
+	call:
+		time += 12;
+		pc -= 2;
+	case 0xCD: // CALL (most-common)
+		data = pc + 2;
+		pc = GET_ADDR();
+	push: {
+		int addr = WORD( sp - 1 );
+		WRITE_MEM( addr, (data >> 8) );
+		sp = WORD( sp - 2 );
+		WRITE_MEM( sp, data );
+		goto loop;
+	}
+	
+	case 0xC8: // RET Z (next-most-common)
+		if ( CC_NZ() )
+			goto loop;
+	ret:
+		time += 12;
+	case 0xD9: // RETI
+	case 0xC9:{// RET (most common)
+		pc = READ_MEM( sp );
+		int addr = sp + 1;
+		sp = WORD( sp + 2 );
+		pc += 0x100 * READ_MEM( addr );
+		goto loop;
+	}
+	
+	case 0x00: // NOP
+	case 0x40: // LD B,B
+	case 0x49: // LD C,C
+	case 0x52: // LD D,D
+	case 0x5B: // LD E,E
+	case 0x64: // LD H,H
+	case 0x6D: // LD L,L
+	case 0x7F: // LD A,A
+		goto loop;
+	
+// CB Instructions
+
+	case 0xCB:
+		time += (instr_times + 256) [data];
+		pc++;
+		// now data is the opcode
+		switch ( data ) {
+			
+		case 0x46: // BIT b,(HL)
+		case 0x4E:
+		case 0x56:
+		case 0x5E:
+		case 0x66:
+		case 0x6E:
+		case 0x76:
+		case 0x7E: {
+			int addr = rp.hl;
+			READ_FAST( addr, op );
+			goto bit_comm;
+		}
+		
+		case 0x40: case 0x41: case 0x42: case 0x43: // BIT b,r
+		case 0x44: case 0x45: case 0x47: case 0x48:
+		case 0x49: case 0x4A: case 0x4B: case 0x4C:
+		case 0x4D: case 0x4F: case 0x50: case 0x51:
+		case 0x52: case 0x53: case 0x54: case 0x55:
+		case 0x57: case 0x58: case 0x59: case 0x5A:
+		case 0x5B: case 0x5C: case 0x5D: case 0x5F:
+		case 0x60: case 0x61: case 0x62: case 0x63:
+		case 0x64: case 0x65: case 0x67: case 0x68:
+		case 0x69: case 0x6A: case 0x6B: case 0x6C:
+		case 0x6D: case 0x6F: case 0x70: case 0x71:
+		case 0x72: case 0x73: case 0x74: case 0x75:
+		case 0x77: case 0x78: case 0x79: case 0x7A:
+		case 0x7B: case 0x7C: case 0x7D: case 0x7F:
+			op = R8( data & 7 );
+		bit_comm:
+			ph = op >> (data >> 3 & 7) & 1;
+			cz = (cz & 0x100) + ph;
+			ph ^= 0x110; // N=0 H=1
+			goto loop;
+		
+		case 0x86: // RES b,(HL)
+		case 0x8E:
+		case 0x96:
+		case 0x9E:
+		case 0xA6:
+		case 0xAE:
+		case 0xB6:
+		case 0xBE: {
+			int temp = READ_MEM( rp.hl );
+			temp &= ~(1 << (data >> 3 & 7));
+			WRITE_MEM( rp.hl, temp );
+			goto loop;
+		}
+		
+		case 0xC6: // SET b,(HL)
+		case 0xCE:
+		case 0xD6:
+		case 0xDE:
+		case 0xE6:
+		case 0xEE:
+		case 0xF6:
+		case 0xFE: {
+			int temp = READ_MEM( rp.hl );
+			temp |= 1 << (data >> 3 & 7);
+			WRITE_MEM( rp.hl, temp );
+			goto loop;
+		}
+		
+		case 0xC0: case 0xC1: case 0xC2: case 0xC3: // SET b,r
+		case 0xC4: case 0xC5: case 0xC7: case 0xC8:
+		case 0xC9: case 0xCA: case 0xCB: case 0xCC:
+		case 0xCD: case 0xCF: case 0xD0: case 0xD1:
+		case 0xD2: case 0xD3: case 0xD4: case 0xD5:
+		case 0xD7: case 0xD8: case 0xD9: case 0xDA:
+		case 0xDB: case 0xDC: case 0xDD: case 0xDF:
+		case 0xE0: case 0xE1: case 0xE2: case 0xE3:
+		case 0xE4: case 0xE5: case 0xE7: case 0xE8:
+		case 0xE9: case 0xEA: case 0xEB: case 0xEC:
+		case 0xED: case 0xEF: case 0xF0: case 0xF1:
+		case 0xF2: case 0xF3: case 0xF4: case 0xF5:
+		case 0xF7: case 0xF8: case 0xF9: case 0xFA:
+		case 0xFB: case 0xFC: case 0xFD: case 0xFF:
+			R8( data & 7 ) |= 1 << (data >> 3 & 7);
+			goto loop;
+
+		case 0x80: case 0x81: case 0x82: case 0x83: // RES b,r
+		case 0x84: case 0x85: case 0x87: case 0x88:
+		case 0x89: case 0x8A: case 0x8B: case 0x8C:
+		case 0x8D: case 0x8F: case 0x90: case 0x91:
+		case 0x92: case 0x93: case 0x94: case 0x95:
+		case 0x97: case 0x98: case 0x99: case 0x9A:
+		case 0x9B: case 0x9C: case 0x9D: case 0x9F:
+		case 0xA0: case 0xA1: case 0xA2: case 0xA3:
+		case 0xA4: case 0xA5: case 0xA7: case 0xA8:
+		case 0xA9: case 0xAA: case 0xAB: case 0xAC:
+		case 0xAD: case 0xAF: case 0xB0: case 0xB1:
+		case 0xB2: case 0xB3: case 0xB4: case 0xB5:
+		case 0xB7: case 0xB8: case 0xB9: case 0xBA:
+		case 0xBB: case 0xBC: case 0xBD: case 0xBF:
+			R8( data & 7 ) &= ~(1 << (data >> 3 & 7));
+			goto loop;
+		
+		case 0x36: // SWAP (HL)
+			op = READ_MEM( rp.hl );
+			goto swap_comm;
+		
+		case 0x30: // SWAP B
+		case 0x31: // SWAP C
+		case 0x32: // SWAP D
+		case 0x33: // SWAP E
+		case 0x34: // SWAP H
+		case 0x35: // SWAP L
+		case 0x37: // SWAP A
+			op = R8( data & 7 );
+		swap_comm:
+			op = (op >> 4) + (op << 4);
+			cz = BYTE( op );
+			ph = cz + 0x100;
+			if ( data == 0x36 )
+				goto write_hl_op_ff;
+			R8( data & 7 ) = op;
+			goto loop;
+		
+// Shift/Rotate
+
+		case 0x26: // SLA (HL)
+			cz = 0;
+		case 0x16: // RL (HL)
+			cz = (cz >> 8 & 1) + (READ_MEM( rp.hl ) << 1);
+			goto rl_hl_common;
+		
+		case 0x06: // RLC (HL)
+			cz = READ_MEM( rp.hl );
+			cz = (cz << 1) + (cz >> 7 & 1);
+		rl_hl_common:
+			// Z=* C=*
+			ph = cz | 0x100; // N=0 H=0
+			WRITE_MEM( rp.hl, cz );
+			goto loop;
+		
+		case 0x20: case 0x21: case 0x22: case 0x23: case 0x24: case 0x25: case 0x27: // SLA r
+			cz = 0;
+		case 0x10: case 0x11: case 0x12: case 0x13: case 0x14: case 0x15: case 0x17: // RL r
+			cz = (cz >> 8 & 1) + (R8( data & 7 ) << 1);
+			goto rl_common;
+		
+		case 0x00: case 0x01: case 0x02: case 0x03: case 0x04: case 0x05: case 0x07: // RLC r
+			cz = R8( data & 7 );
+			cz = (cz << 1) + (cz >> 7 & 1);
+		rl_common:
+			// Z=* C=*
+			ph = cz | 0x100; // N=0 H=0
+			R8( data & 7 ) = cz;
+			goto loop;
+		
+		case 0x0E: // RRC (HL)
+			cz = READ_MEM( rp.hl );
+			cz += cz << 8 & 0x100;
+			goto rr_hl_common;
+		
+		case 0x2E: // SRA (HL)
+			cz = READ_MEM( rp.hl );
+			cz += cz << 1 & 0x100;
+			goto rr_hl_common;
+		
+		case 0x3E: // SRL (HL)
+			cz = 0;
+		case 0x1E: // RR (HL)
+			cz = (cz & 0x100) + READ_MEM( rp.hl );
+		rr_hl_common:
+			cz = (cz << 8) + (cz >> 1); // Z=* C=*
+			ph = cz | 0x100; // N=0 H=0
+			WRITE_MEM( rp.hl, cz );
+			goto loop;
+		
+		case 0x08: case 0x09: case 0x0A: case 0x0B: case 0x0C: case 0x0D: case 0x0F: // RRC r
+			cz = R8( data & 7 );
+			cz += cz << 8 & 0x100;
+			goto rr_common;
+		
+		case 0x28: case 0x29: case 0x2A: case 0x2B: case 0x2C: case 0x2D: case 0x2F: // SRA r
+			cz = R8( data & 7 );
+			cz += cz << 1 & 0x100;
+			goto rr_common;
+		
+		case 0x38: case 0x39: case 0x3A: case 0x3B: case 0x3C: case 0x3D: case 0x3F: // SRL r
+			cz = 0;
+		case 0x18: case 0x19: case 0x1A: case 0x1B: case 0x1C: case 0x1D: case 0x1F: // RR r
+			cz = (cz & 0x100) + R8( data & 7 );
+		rr_common:
+			cz = (cz << 8) + (cz >> 1); // Z=* C=*
+			ph = cz | 0x100; // N=0 H=0
+			R8( data & 7 ) = cz;
+			goto loop;
+		
+	} // CB op
+	assert( false ); // unhandled CB op
+	
+	case 0x07: // RLCA
+		cz = rg.a >> 7;
+		goto rlc_common;
+	case 0x17: // RLA
+		cz = cz >> 8 & 1;
+	rlc_common:
+		cz  += rg.a << 1;
+		ph   = cz | 0x100;
+		rg.a = BYTE( cz );
+		cz  |= 1;
+		goto loop;
+	
+	case 0x0F: // RRCA
+		ph = rg.a << 8;
+		goto rrc_common;
+	case 0x1F: // RRA
+		ph = cz;
+	rrc_common:
+		cz = (rg.a << 8) + 1; // Z=0 C=*
+		rg.a = ((ph & 0x100) + rg.a) >> 1;
+		ph = 0x100; // N=0 H=0
+		goto loop;
+
+// Load
+
+	case 0x70: // LD (HL),B
+	case 0x71: // LD (HL),C
+	case 0x72: // LD (HL),D
+	case 0x73: // LD (HL),E
+	case 0x74: // LD (HL),H
+	case 0x75: // LD (HL),L
+	case 0x77: // LD (HL),A
+		op = R8( op & 7 );
+	write_hl_op_ff:
+		WRITE_MEM( rp.hl, op );
+		goto loop;
+
+	case 0x41: case 0x42: case 0x43: case 0x44: case 0x45: case 0x47: // LD r,r
+	case 0x48: case 0x4A: case 0x4B: case 0x4C: case 0x4D: case 0x4F:
+	case 0x50: case 0x51: case 0x53: case 0x54: case 0x55: case 0x57:
+	case 0x58: case 0x59: case 0x5A: case 0x5C: case 0x5D: case 0x5F:
+	case 0x60: case 0x61: case 0x62: case 0x63: case 0x65: case 0x67:
+	case 0x68: case 0x69: case 0x6A: case 0x6B: case 0x6C: case 0x6F:
+	case 0x78: case 0x79: case 0x7A: case 0x7B: case 0x7C: case 0x7D:
+		R8( op >> 3 & 7 ) = R8( op & 7 );
+		goto loop;
+
+	case 0x08: // LD IND16,SP
+		data = GET_ADDR();
+		pc += 2;
+		WRITE_MEM( data, sp );
+		data++;
+		WRITE_MEM( data, (sp >> 8) );
+		goto loop;
+	
+	case 0xF9: // LD SP,HL
+		sp = rp.hl;
+		goto loop;
+
+	case 0x31: // LD SP,IMM
+		sp = GET_ADDR();
+		pc += 2;
+		goto loop;
+	
+	case 0x01: // LD BC,IMM
+	case 0x11: // LD DE,IMM
+		r16 [(unsigned) op >> 4] = GET_ADDR();
+		pc += 2;
+		goto loop;
+	
+	case 0xE2: // LD (0xFF00+C),A
+		WRITE_IO( rg.c, rg.a );
+		goto loop;
+	
+	case 0xE0: // LD (0xFF00+imm),A
+		pc++;
+		WRITE_IO( data, rg.a );
+		goto loop;
+	
+	{
+		int temp;
+	case 0x32: // LD (HL-),A
+		temp = rp.hl;
+		rp.hl = temp - 1;
+		goto write_data_rg_a;
+	
+	case 0x02: // LD (BC),A
+		temp = rp.bc;
+		goto write_data_rg_a;
+	
+	case 0x12: // LD (DE),A
+		temp = rp.de;
+		goto write_data_rg_a;
+	
+	case 0x22: // LD (HL+),A
+		temp = rp.hl;
+		rp.hl = temp + 1;
+		goto write_data_rg_a;
+		
+	case 0xEA: // LD IND16,A (common)
+		temp = GET_ADDR();
+		pc += 2;
+	write_data_rg_a:
+		WRITE_MEM( temp, rg.a );
+		goto loop;
+	}
+	
+	case 0x06: // LD B,IMM
+		rg.b = data;
+		pc++;
+		goto loop;
+	
+	case 0x0E: // LD C,IMM
+		rg.c = data;
+		pc++;
+		goto loop;
+	
+	case 0x16: // LD D,IMM
+		rg.d = data;
+		pc++;
+		goto loop;
+	
+	case 0x1E: // LD E,IMM
+		rg.e = data;
+		pc++;
+		goto loop;
+	
+	case 0x26: // LD H,IMM
+		rg.h = data;
+		pc++;
+		goto loop;
+	
+	case 0x2E: // LD L,IMM
+		rg.l = data;
+		pc++;
+		goto loop;
+	
+	case 0x36: // LD (HL),IMM
+		WRITE_MEM( rp.hl, data );
+		pc++;
+		goto loop;
+	
+	case 0x3E: // LD A,IMM
+		rg.a = data;
+		pc++;
+		goto loop;
+
+// Increment/decrement
+
+	case 0x03: // INC BC
+	case 0x13: // INC DE
+	case 0x23: // INC HL
+		r16 [(unsigned) op >> 4]++;
+		goto loop;
+	
+	case 0x33: // INC SP
+		sp = WORD( sp + 1 );
+		goto loop;
+
+	case 0x0B: // DEC BC
+	case 0x1B: // DEC DE
+	case 0x2B: // DEC HL
+		r16 [(unsigned) op >> 4]--;
+		goto loop;
+	
+	case 0x3B: // DEC SP
+		sp = WORD( sp - 1 );
+		goto loop;
+	
+	case 0x34: // INC (HL)
+		op = rp.hl;
+		data = READ_MEM( op );
+		data++;
+		WRITE_MEM( op, data );
+		goto inc_comm;
+	
+	case 0x04: // INC B
+	case 0x0C: // INC C (common)
+	case 0x14: // INC D
+	case 0x1C: // INC E
+	case 0x24: // INC H
+	case 0x2C: // INC L
+	case 0x3C: // INC A
+		op = op >> 3 & 7;
+		data = R8( op ) + 1;
+		R8( op ) = data;
+	inc_comm:
+		ph = data - 0x101; // N=0 H=*
+		cz = (cz & 0x100) + BYTE( data ); // C=- Z=*
+		goto loop;
+	
+	case 0x35: // DEC (HL)
+		op = rp.hl;
+		data = READ_MEM( op );
+		data--;
+		WRITE_MEM( op, data );
+		goto dec_comm;
+	
+	case 0x05: // DEC B
+	case 0x0D: // DEC C
+	case 0x15: // DEC D
+	case 0x1D: // DEC E
+	case 0x25: // DEC H
+	case 0x2D: // DEC L
+	case 0x3D: // DEC A
+		op = op >> 3 & 7;
+		data = R8( op ) - 1;
+		R8( op ) = data;
+	dec_comm:
+		ph = data + 1; // N=1 H=*
+		cz = (cz & 0x100) + BYTE( data ); // C=- Z=*
+		goto loop;
+
+// Add 16-bit
+
+	case 0xF8: // LD  HL,SP+n
+	case 0xE8:{// ADD SP,n
+		pc++;
+		int t = WORD( sp + SBYTE( data ) );
+		cz = ((BYTE( sp ) + data) & 0x100) + 1; // Z=0 C=*
+		ph = (sp ^ data ^ t) | 0x100; // N=0 H=*
+		if ( op == 0xF8 )
+		{
+			rp.hl = t;
+			goto loop;
+		}
+		sp = t;
+		goto loop;
+	}
+
+	case 0x39: // ADD HL,SP
+		data = sp;
+		goto add_hl_comm;
+	
+	case 0x09: // ADD HL,BC
+	case 0x19: // ADD HL,DE
+	case 0x29: // ADD HL,HL
+		data = r16 [(unsigned) op >> 4];
+	add_hl_comm:
+		ph = rp.hl ^ data;
+		data += rp.hl;
+		rp.hl = WORD( data );
+		ph ^= data;
+		cz = BYTE( cz ) + (data >> 8 & 0x100); // C=* Z=-
+		ph = ((ph >> 8) ^ cz) | 0x100; // N=0 H=*
+		goto loop;
+	
+	case 0x86: // ADD (HL)
+		data = READ_MEM( rp.hl );
+		goto add_comm;
+	
+	case 0x80: // ADD B
+	case 0x81: // ADD C
+	case 0x82: // ADD D
+	case 0x83: // ADD E
+	case 0x84: // ADD H
+	case 0x85: // ADD L
+	case 0x87: // ADD A
+		data = R8( op & 7 );
+		goto add_comm;
+	
+	case 0xC6: // ADD IMM
+		pc++;
+	add_comm:
+		ph   = (rg.a ^ data) | 0x100; // N=1 H=*
+		cz   = rg.a + data; // C=* Z=*
+		rg.a = cz;
+		goto loop;
+	
+// Add/Subtract
+
+	case 0x8E: // ADC (HL)
+		data = READ_MEM( rp.hl );
+		goto adc_comm;
+	
+	case 0x88: // ADC B
+	case 0x89: // ADC C
+	case 0x8A: // ADC D
+	case 0x8B: // ADC E
+	case 0x8C: // ADC H
+	case 0x8D: // ADC L
+	case 0x8F: // ADC A
+		data = R8( op & 7 );
+		goto adc_comm;
+	
+	case 0xCE: // ADC IMM
+		pc++;
+	adc_comm:
+		ph   = (rg.a ^ data) | 0x100; // N=1 H=*
+		cz   = rg.a + data + (cz >> 8 & 1); // C=* Z=*
+		rg.a = cz;
+		goto loop;
+	
+	case 0x96: // SUB (HL)
+		data = READ_MEM( rp.hl );
+		goto sub_comm;
+	
+	case 0x90: // SUB B
+	case 0x91: // SUB C
+	case 0x92: // SUB D
+	case 0x93: // SUB E
+	case 0x94: // SUB H
+	case 0x95: // SUB L
+	case 0x97: // SUB A
+		data = R8( op & 7 );
+		goto sub_comm;
+	
+	case 0xD6: // SUB IMM
+		pc++;
+	sub_comm:
+		ph   = rg.a ^ data; // N=1 H=*
+		cz   = rg.a - data; // C=* Z=*
+		rg.a = cz;
+		goto loop;
+	
+	case 0x9E: // SBC (HL)
+		data = READ_MEM( rp.hl );
+		goto sbc_comm;
+	
+	case 0x98: // SBC B
+	case 0x99: // SBC C
+	case 0x9A: // SBC D
+	case 0x9B: // SBC E
+	case 0x9C: // SBC H
+	case 0x9D: // SBC L
+	case 0x9F: // SBC A
+		data = R8( op & 7 );
+		goto sbc_comm;
+	
+	case 0xDE: // SBC IMM
+		pc++;
+	sbc_comm:
+		ph   = rg.a ^ data; // N=1 H=*
+		cz   = rg.a - data - (cz >> 8 & 1); // C=* Z=*
+		rg.a = cz;
+		goto loop;
+
+// Logical
+
+	case 0xA0: // AND B
+	case 0xA1: // AND C
+	case 0xA2: // AND D
+	case 0xA3: // AND E
+	case 0xA4: // AND H
+	case 0xA5: // AND L
+		data = R8( op & 7 );
+		goto and_comm;
+	
+	case 0xA6: // AND (HL)
+		data = READ_MEM( rp.hl );
+		goto and_comm;
+	case 0xE6: // AND IMM
+		pc++;
+	and_comm:
+		cz = rg.a & data; // C=0 Z=*
+		ph = ~cz; // N=0 H=1
+		rg.a = cz;
+		goto loop;
+	
+	case 0xA7: // AND A
+		cz = rg.a; // C=0 Z=*
+		ph = ~rg.a; // N=0 H=1
+		goto loop;
+
+	case 0xB0: // OR B
+	case 0xB1: // OR C
+	case 0xB2: // OR D
+	case 0xB3: // OR E
+	case 0xB4: // OR H
+	case 0xB5: // OR L
+		data = R8( op & 7 );
+		goto or_comm;
+	
+	case 0xB6: // OR (HL)
+		data = READ_MEM( rp.hl );
+		goto or_comm;
+	case 0xF6: // OR IMM
+		pc++;
+	or_comm:
+		cz = rg.a | data; // C=0 Z=*
+		ph = cz | 0x100; // N=0 H=0
+		rg.a = cz;
+		goto loop;
+	
+	case 0xB7: // OR A
+		cz = rg.a; // C=0 Z=*
+		ph = rg.a + 0x100; // N=0 H=0
+		goto loop;
+
+	case 0xA8: // XOR B
+	case 0xA9: // XOR C
+	case 0xAA: // XOR D
+	case 0xAB: // XOR E
+	case 0xAC: // XOR H
+	case 0xAD: // XOR L
+		data = R8( op & 7 );
+		goto xor_comm;
+	
+	case 0xAE: // XOR (HL)
+		data = READ_MEM( rp.hl );
+		pc--;
+	case 0xEE: // XOR IMM
+		pc++;
+	xor_comm:
+		cz = rg.a ^ data; // C=0 Z=*
+		ph = cz + 0x100; // N=0 H=0
+		rg.a = cz;
+		goto loop;
+	
+	case 0xAF: // XOR A
+		rg.a = 0;
+		cz   = 0; // C=0 Z=*
+		ph   = 0x100; // N=0 H=0
+		goto loop;
+
+// Stack
+
+	case 0xF1: // POP AF
+	case 0xC1: // POP BC
+	case 0xD1: // POP DE
+	case 0xE1: // POP HL (common)
+		data = READ_MEM( sp );
+		r16 [op >> 4 & 3] = data + 0x100 * READ_MEM( (sp + 1) );
+		sp = WORD( sp + 2 );
+		if ( op != 0xF1 )
+			goto loop;
+		
+		SET_FLAGS( rg.a );
+		rg.a = rg.flags;
+		goto loop;
+	
+	case 0xC5: // PUSH BC
+		data = rp.bc;
+		goto push;
+	
+	case 0xD5: // PUSH DE
+		data = rp.de;
+		goto push;
+	
+	case 0xE5: // PUSH HL
+		data = rp.hl;
+		goto push;
+	
+	case 0xF5: // PUSH AF
+		GET_FLAGS( data );
+		data += rg.a << 8;
+		goto push;
+
+// Flow control
+	
+	case 0xFF: case 0xC7: case 0xCF: case 0xD7: // RST
+	case 0xDF: case 0xE7: case 0xEF: case 0xF7:
+		data = pc;
+		pc = (op & 0x38) + CPU.rst_base;
+		goto push;
+	
+	case 0xCC: // CALL Z
+		pc += 2;
+		if ( CC_Z() )
+			goto call;
+		goto loop;
+	
+	case 0xD4: // CALL NC
+		pc += 2;
+		if ( CC_NC() )
+			goto call;
+		goto loop;
+	
+	case 0xDC: // CALL C
+		pc += 2;
+		if ( CC_C() )
+			goto call;
+		goto loop;
+
+	case 0xC0: // RET NZ
+		if ( CC_NZ() )
+			goto ret;
+		goto loop;
+	
+	case 0xD0: // RET NC
+		if ( CC_NC() )
+			goto ret;
+		goto loop;
+	
+	case 0xD8: // RET C
+		if ( CC_C() )
+			goto ret;
+		goto loop;
+
+	case 0x18: // JR
+		BRANCH_( true, 0 )
+	
+	case 0x30: // JR NC
+		BRANCH( CC_NC() )
+	
+	case 0x38: // JR C
+		BRANCH( CC_C() )
+	
+	case 0xE9: // LD PC,HL
+		pc = rp.hl;
+		goto loop;
+
+	case 0xC3: // JP (next-most-common)
+		pc = GET_ADDR();
+		goto loop;
+	
+	case 0xC2: // JP NZ
+		pc += 2;
+		if ( CC_NZ() )
+			goto jp_taken;
+		time -= 4;
+		goto loop;
+	
+	case 0xCA: // JP Z (most common)
+		pc += 2;
+		if ( CC_Z() )
+			goto jp_taken;
+		time -= 4;
+		goto loop;
+	
+	jp_taken:
+		pc -= 2;
+		pc = GET_ADDR();
+		goto loop;
+	
+	case 0xD2: // JP NC
+		pc += 2;
+		if ( CC_NC() )
+			goto jp_taken;
+		time -= 4;
+		goto loop;
+	
+	case 0xDA: // JP C
+		pc += 2;
+		if ( CC_C() )
+			goto jp_taken;
+		time -= 4;
+		goto loop;
+
+// Flags
+
+	case 0x2F: // CPL
+		rg.a = ~rg.a;
+		ph = BYTE( ~cz ); // N=1 H=1
+		goto loop;
+
+	case 0x3F: // CCF
+		ph = cz | 0x100; // N=0 H=0
+		cz ^= 0x100; // C=* Z=-
+		goto loop;
+
+	case 0x37: // SCF
+		ph = cz | 0x100; // N=0 H=0
+		cz |= 0x100; // C=1 Z=-
+		goto loop;
+
+	case 0xF3: // DI
+		goto loop;
+
+	case 0xFB: // EI
+		goto loop;
+
+	case 0x27:{// DAA
+		unsigned a = rg.a;
+		int h = ph ^ cz;
+		if ( ph & 0x100 )
+		{
+			if ( (h & 0x10) || (a & 0x0F) > 9 )
+				a += 6;
+			
+			if ( (cz & 0x100) || a > 0x9F )
+				a += 0x60;
+		}
+		else
+		{
+			if ( h & 0x10 )
+				a = (a - 6) & 0xFF;
+			
+			if ( cz & 0x100 )
+				a -= 0x60;
+		}
+		cz = (cz & 0x100) | a; // C=- Z=*
+		rg.a = a;
+		ph = (ph & 0x100) + BYTE( a ); // N=- H=0
+		goto loop;
+	}
+	
+// Special
+
+	case 0x76: // HALT
+	case 0x10: // STOP
+	case 0xD3:            case 0xDB:            case 0xDD: // Illegal
+	case 0xE3: case 0xE4: case 0xEB: case 0xEC: case 0xED: // (all freeze CPU)
+	           case 0xF4:            case 0xFC: case 0xFD:
+		goto stop;
+	}
+	
+	// If this fails then an opcode isn't handled above
+	assert( false );
+	
+stop:
+	pc--;
+	
+	// copy state back
+	CPU.cpu_state_.time = time;
+	CPU.r.pc = pc;
+	CPU.r.sp = sp;
+	{
+		int t;
+		GET_FLAGS( t );
+		rg.flags = t;
+	}
+	CPU.cpu_state = &CPU.cpu_state_;
+	STATIC_CAST(Gb_Cpu::core_regs_t&,CPU.r) = rp;
+}
diff -Nur orig/source/gme/src/Gb_Oscs.cpp mod/source/gme/src/Gb_Oscs.cpp
--- orig/source/gme/src/Gb_Oscs.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gb_Oscs.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,712 @@
+// Gb_Snd_Emu 0.1.4. http://www.slack.net/~ant/
+
+#include "Gb_Apu.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+bool const cgb_02 = false; // enables bug in early CGB units that causes problems in some games
+bool const cgb_05 = false; // enables CGB-05 zombie behavior
+
+int const trigger_mask   = 0x80;
+int const length_enabled = 0x40;
+
+void Gb_Osc::reset()
+{
+	output   = NULL;
+	last_amp = 0;
+	delay    = 0;
+	phase    = 0;
+	enabled  = false;
+}
+
+inline void Gb_Osc::update_amp( blip_time_t time, int new_amp )
+{
+	output->set_modified();
+	int delta = new_amp - last_amp;
+	if ( delta )
+	{
+		last_amp = new_amp;
+		fast_synth->offset( time, delta, output );
+	}
+}
+
+// Units
+
+void Gb_Osc::clock_length()
+{
+	if ( (regs [4] & length_enabled) && length_ctr )
+	{
+		if ( --length_ctr <= 0 )
+			enabled = false;
+	}
+}
+
+inline int Gb_Env::reload_env_timer()
+{
+	int raw = regs [2] & 7;
+	env_delay = (raw ? raw : 8);
+	return raw;
+}
+
+void Gb_Env::clock_envelope()
+{
+	if ( env_enabled && --env_delay <= 0 && reload_env_timer() )
+	{
+		int v = volume + (regs [2] & 0x08 ? +1 : -1);
+		if ( 0 <= v && v <= 15 )
+			volume = v;
+		else
+			env_enabled = false;
+	}
+}
+
+inline void Gb_Sweep_Square::reload_sweep_timer()
+{
+	sweep_delay = (regs [0] & period_mask) >> 4;
+	if ( !sweep_delay )
+		sweep_delay = 8;
+}
+
+void Gb_Sweep_Square::calc_sweep( bool update )
+{
+	int const shift = regs [0] & shift_mask;
+	int const delta = sweep_freq >> shift;
+	sweep_neg = (regs [0] & 0x08) != 0;
+	int const freq = sweep_freq + (sweep_neg ? -delta : delta);
+	
+	if ( freq > 0x7FF )
+	{
+		enabled = false;
+	}
+	else if ( shift && update )
+	{
+		sweep_freq = freq;
+		
+		regs [3] = freq & 0xFF;
+		regs [4] = (regs [4] & ~0x07) | (freq >> 8 & 0x07);
+	}
+}
+
+void Gb_Sweep_Square::clock_sweep()
+{
+	if ( --sweep_delay <= 0 )
+	{
+		reload_sweep_timer();
+		if ( sweep_enabled && (regs [0] & period_mask) )
+		{
+			calc_sweep( true  );
+			calc_sweep( false );
+		}
+	}
+}
+
+int Gb_Wave::access( int addr ) const
+{
+	if ( enabled )
+	{
+		addr = phase & (bank_size - 1);
+		if ( mode == Gb_Apu::mode_dmg )
+		{
+			addr++;
+			if ( delay > clk_mul )
+				return -1; // can only access within narrow time window while playing
+		}
+		addr >>= 1;
+	}
+	return addr & 0x0F;
+}
+
+// write_register
+
+int Gb_Osc::write_trig( int frame_phase, int max_len, int old_data )
+{
+	int data = regs [4];
+	
+	if ( (frame_phase & 1) && !(old_data & length_enabled) && length_ctr )
+	{
+		if ( (data & length_enabled) || cgb_02 )
+			length_ctr--;
+	}
+	
+	if ( data & trigger_mask )
+	{
+		enabled = true;
+		if ( !length_ctr )
+		{
+			length_ctr = max_len;
+			if ( (frame_phase & 1) && (data & length_enabled) )
+				length_ctr--;
+		}
+	}
+	
+	if ( !length_ctr )
+		enabled = false;
+	
+	return data & trigger_mask;
+}
+
+inline void Gb_Env::zombie_volume( int old, int data )
+{
+	int v = volume;
+	if ( mode == Gb_Apu::mode_agb || cgb_05 )
+	{
+		// CGB-05 behavior, very close to AGB behavior as well
+		if ( (old ^ data) & 8 )
+		{
+			if ( !(old & 8) )
+			{
+				v++;
+				if ( old & 7 )
+					v++;
+			}
+			
+			v = 16 - v;
+		}
+		else if ( (old & 0x0F) == 8 )
+		{
+			v++;
+		}
+	}
+	else
+	{
+		// CGB-04&02 behavior, very close to MGB behavior as well
+		if ( !(old & 7) && env_enabled )
+			v++;
+		else if ( !(old & 8) )
+			v += 2;
+		
+		if ( (old ^ data) & 8 )
+			v = 16 - v;
+	}
+	volume = v & 0x0F;
+}
+
+bool Gb_Env::write_register( int frame_phase, int reg, int old, int data )
+{
+	int const max_len = 64;
+	
+	switch ( reg )
+	{
+	case 1:
+		length_ctr = max_len - (data & (max_len - 1));
+		break;
+	
+	case 2:
+		if ( !dac_enabled() )
+			enabled = false;
+		
+		zombie_volume( old, data );
+		
+		if ( (data & 7) && env_delay == 8 )
+		{
+			env_delay = 1;
+			clock_envelope(); // TODO: really happens at next length clock
+		}
+		break;
+	
+	case 4:
+		if ( write_trig( frame_phase, max_len, old ) )
+		{
+			volume = regs [2] >> 4;
+			reload_env_timer();
+			env_enabled = true;
+			if ( frame_phase == 7 )
+				env_delay++;
+			if ( !dac_enabled() )
+				enabled = false;
+			return true;
+		}
+	}
+	return false;
+}
+
+bool Gb_Square::write_register( int frame_phase, int reg, int old_data, int data )
+{
+	bool result = Gb_Env::write_register( frame_phase, reg, old_data, data );
+	if ( result )
+		delay = (delay & (4 * clk_mul - 1)) + period();
+	return result;
+}
+
+inline void Gb_Noise::write_register( int frame_phase, int reg, int old_data, int data )
+{
+	if ( Gb_Env::write_register( frame_phase, reg, old_data, data ) )
+	{
+		phase = 0x7FFF;
+		delay += 8 * clk_mul;
+	}
+}
+
+inline void Gb_Sweep_Square::write_register( int frame_phase, int reg, int old_data, int data )
+{
+	if ( reg == 0 && sweep_enabled && sweep_neg && !(data & 0x08) )
+		enabled = false; // sweep negate disabled after used
+	
+	if ( Gb_Square::write_register( frame_phase, reg, old_data, data ) )
+	{
+		sweep_freq = frequency();
+		sweep_neg = false;
+		reload_sweep_timer();
+		sweep_enabled = (regs [0] & (period_mask | shift_mask)) != 0;
+		if ( regs [0] & shift_mask )
+			calc_sweep( false );
+	}
+}
+
+void Gb_Wave::corrupt_wave()
+{
+	int pos = ((phase + 1) & (bank_size - 1)) >> 1;
+	if ( pos < 4 )
+		wave_ram [0] = wave_ram [pos];
+	else
+		for ( int i = 4; --i >= 0; )
+			wave_ram [i] = wave_ram [(pos & ~3) + i];
+}
+
+inline void Gb_Wave::write_register( int frame_phase, int reg, int old_data, int data )
+{
+	int const max_len = 256;
+	
+	switch ( reg )
+	{
+	case 0:
+		if ( !dac_enabled() )
+			enabled = false;
+		break;
+	
+	case 1:
+		length_ctr = max_len - data;
+		break;
+	
+	case 4:
+		bool was_enabled = enabled;
+		if ( write_trig( frame_phase, max_len, old_data ) )
+		{
+			if ( !dac_enabled() )
+				enabled = false;
+			else if ( mode == Gb_Apu::mode_dmg && was_enabled &&
+					(unsigned) (delay - 2 * clk_mul) < 2 * clk_mul )
+				corrupt_wave();
+			
+			phase = 0;
+			delay = period() + 6 * clk_mul;
+		}
+	}
+}
+
+void Gb_Apu::write_osc( int reg, int old_data, int data )
+{
+	int index = (reg * 3 + 3) >> 4; // avoids divide
+	assert( index == reg / 5 );
+	reg -= index * 5;
+	switch ( index )
+	{
+	case 0: square1.write_register( frame_phase, reg, old_data, data ); break;
+	case 1: square2.write_register( frame_phase, reg, old_data, data ); break;
+	case 2: wave   .write_register( frame_phase, reg, old_data, data ); break;
+	case 3: noise  .write_register( frame_phase, reg, old_data, data ); break;
+	}
+}
+
+// Synthesis
+
+void Gb_Square::run( blip_time_t time, blip_time_t end_time )
+{
+	// Calc duty and phase
+	static byte const duty_offsets [4] = { 1, 1, 3, 7 };
+	static byte const duties       [4] = { 1, 2, 4, 6 };
+	int const duty_code = regs [1] >> 6;
+	int duty_offset = duty_offsets [duty_code];
+	int duty = duties [duty_code];
+	if ( mode == Gb_Apu::mode_agb )
+	{
+		// AGB uses inverted duty
+		duty_offset -= duty;
+		duty = 8 - duty;
+	}
+	int ph = (this->phase + duty_offset) & 7;
+	
+	// Determine what will be generated
+	int vol = 0;
+	Blip_Buffer* const out = this->output;
+	if ( out )
+	{
+		int amp = dac_off_amp;
+		if ( dac_enabled() )
+		{
+			if ( enabled )
+				vol = this->volume;
+			
+			amp = -dac_bias;
+			if ( mode == Gb_Apu::mode_agb )
+				amp = -(vol >> 1);
+			
+			// Play inaudible frequencies as constant amplitude
+			if ( frequency() >= 0x7FA && delay < 32 * clk_mul )
+			{
+				amp += (vol * duty) >> 3;
+				vol = 0;
+			}
+			
+			if ( ph < duty )
+			{
+				amp += vol;
+				vol = -vol;
+			}
+		}
+		update_amp( time, amp );
+	}
+	
+	// Generate wave
+	time += delay;
+	if ( time < end_time )
+	{
+		int const per = this->period();
+		if ( !vol )
+		{
+			#if GB_APU_FAST
+				time = end_time;
+			#else
+				// Maintain phase when not playing
+				int count = (end_time - time + per - 1) / per;
+				ph += count; // will be masked below
+				time += (blip_time_t) count * per;
+			#endif
+		}
+		else
+		{
+			// Output amplitude transitions
+			int delta = vol;
+			do
+			{
+				ph = (ph + 1) & 7;
+				if ( ph == 0 || ph == duty )
+				{
+					norm_synth->offset_inline( time, delta, out );
+					delta = -delta;
+				}
+				time += per;
+			}
+			while ( time < end_time );
+			
+			if ( delta != vol )
+				last_amp -= delta;
+		}
+		this->phase = (ph - duty_offset) & 7;
+	}
+	delay = time - end_time;
+}
+
+#if !GB_APU_FAST
+// Quickly runs LFSR for a large number of clocks. For use when noise is generating
+// no sound.
+static unsigned run_lfsr( int s, int mask, int count )
+{
+	bool const optimized = true; // set to false to use only unoptimized loop in middle
+	
+	// optimization used in several places:
+	// ((s & (1 << b)) << n) ^ ((s & (1 << b)) << (n + 1)) = (s & (1 << b)) * (3 << n)
+	
+	if ( mask == 0x4000 && optimized )
+	{
+		if ( count >= 32767 )
+			count %= 32767;
+		
+		// Convert from Fibonacci to Galois configuration,
+		// shifted left 1 bit
+		s ^= (s & 1) * 0x8000;
+		
+		// Each iteration is equivalent to clocking LFSR 255 times
+		while ( (count -= 255) > 0 )
+			s ^= ((s & 0xE) << 12) ^ ((s & 0xE) << 11) ^ (s >> 3);
+		count += 255;
+		
+		// Each iteration is equivalent to clocking LFSR 15 times
+		// (interesting similarity to single clocking below)
+		while ( (count -= 15) > 0 )
+			s ^= ((s & 2) * (3 << 13)) ^ (s >> 1);
+		count += 15;
+		
+		// Remaining singles
+		while ( --count >= 0 )
+			s = ((s & 2) * (3 << 13)) ^ (s >> 1);
+		
+		// Convert back to Fibonacci configuration
+		s &= 0x7FFF;
+	}
+	else if ( count < 8 || !optimized )
+	{
+		// won't fully replace upper 8 bits, so have to do the unoptimized way
+		while ( --count >= 0 )
+			s = (s >> 1 | mask) ^ (mask & -((s - 1) & 2));
+	}
+	else
+	{
+		if ( count > 127 )
+		{
+			count %= 127;
+			if ( !count )
+				count = 127; // must run at least once
+		}
+		
+		// Need to keep one extra bit of history
+		s = s << 1 & 0xFF;
+		
+		// Convert from Fibonacci to Galois configuration,
+		// shifted left 2 bits
+		s ^= (s & 2) * 0x80;
+		
+		// Each iteration is equivalent to clocking LFSR 7 times
+		// (interesting similarity to single clocking below)
+		while ( (count -= 7) > 0 )
+			s ^= ((s & 4) * (3 << 5)) ^ (s >> 1);
+		count += 7;
+		
+		// Remaining singles
+		while ( --count >= 0 )
+			s = ((s & 4) * (3 << 5)) ^ (s >> 1);
+		
+		// Convert back to Fibonacci configuration and
+		// repeat last 8 bits above significant 7
+		s = (s << 7 & 0x7F80) | (s >> 1 & 0x7F);
+	}
+	
+	return s;
+}
+#endif
+
+void Gb_Noise::run( blip_time_t time, blip_time_t end_time )
+{
+	// Determine what will be generated
+	int vol = 0;
+	Blip_Buffer* const out = this->output;
+	if ( out )
+	{
+		int amp = dac_off_amp;
+		if ( dac_enabled() )
+		{
+			if ( enabled )
+				vol = this->volume;
+			
+			amp = -dac_bias;
+			if ( mode == Gb_Apu::mode_agb )
+				amp = -(vol >> 1);
+			
+			if ( !(phase & 1) )
+			{
+				amp += vol;
+				vol = -vol;
+			}
+		}
+		
+		// AGB negates final output
+		if ( mode == Gb_Apu::mode_agb )
+		{
+			vol = -vol;
+			amp    = -amp;
+		}
+		
+		update_amp( time, amp );
+	}
+	
+	// Run timer and calculate time of next LFSR clock
+	static byte const period1s [8] = { 1, 2, 4, 6, 8, 10, 12, 14 };
+	int const period1 = period1s [regs [3] & 7] * clk_mul;
+	
+	#if GB_APU_FAST
+		time += delay;
+	#else
+		{
+			int extra = (end_time - time) - delay;
+			int const per2 = this->period2();
+			time += delay + ((divider ^ (per2 >> 1)) & (per2 - 1)) * period1;
+			
+			int count = (extra < 0 ? 0 : (extra + period1 - 1) / period1);
+			divider = (divider - count) & period2_mask;
+			delay = count * period1 - extra;
+		}
+	#endif
+	
+	// Generate wave
+	if ( time < end_time )
+	{
+		unsigned const mask = this->lfsr_mask();
+		unsigned bits = this->phase;
+		
+		int per = period2( period1 * 8 );
+		#if GB_APU_FAST
+			// Noise can be THE biggest time hog; adjust as necessary
+			int const min_period = 24;
+			if ( per < min_period )
+				per = min_period;
+		#endif
+		if ( period2_index() >= 0xE )
+		{
+			time = end_time;
+		}
+		else if ( !vol )
+		{
+			#if GB_APU_FAST
+				time = end_time;
+			#else
+				// Maintain phase when not playing
+				int count = (end_time - time + per - 1) / per;
+				time += (blip_time_t) count * per;
+				bits = run_lfsr( bits, ~mask, count );
+			#endif
+		}
+		else
+		{
+			Blip_Synth_Fast const* const synth = fast_synth; // cache
+			
+			// Output amplitude transitions
+			int delta = -vol;
+			do
+			{
+				unsigned changed = bits + 1;
+				bits = bits >> 1 & mask;
+				if ( changed & 2 )
+				{
+					bits |= ~mask;
+					delta = -delta;
+					synth->offset_inline( time, delta, out );
+				}
+				time += per;
+			}
+			while ( time < end_time );
+			
+			if ( delta == vol )
+				last_amp += delta;
+		}
+		this->phase = bits;
+	}
+	
+	#if GB_APU_FAST
+		delay = time - end_time;
+	#endif
+}
+
+void Gb_Wave::run( blip_time_t time, blip_time_t end_time )
+{
+	// Calc volume
+#if GB_APU_NO_AGB
+	static byte const shifts [4] = { 4+4, 0+4, 1+4, 2+4 };
+	int const volume_idx = regs [2] >> 5 & 3;
+	int const volume_shift = shifts [volume_idx];
+	int const volume_mul = 1;
+#else
+	static byte const volumes [8] = { 0, 4, 2, 1, 3, 3, 3, 3 };
+	int const volume_shift = 2 + 4;
+	int const volume_idx = regs [2] >> 5 & (agb_mask | 3); // 2 bits on DMG/CGB, 3 on AGB
+	int const volume_mul = volumes [volume_idx];
+#endif
+
+	// Determine what will be generated
+	int playing = false;
+	Blip_Buffer* const out = this->output;
+	if ( out )
+	{
+		int amp = dac_off_amp;
+		if ( dac_enabled() )
+		{
+			// Play inaudible frequencies as constant amplitude
+			amp = 8 << 4; // really depends on average of all samples in wave
+			
+			// if delay is larger, constant amplitude won't start yet
+			if ( frequency() <= 0x7FB || delay > 15 * clk_mul )
+			{
+				if ( volume_mul && volume_shift != 4+4 )
+					playing = (int) enabled;
+				
+				amp = (sample_buf << (phase << 2 & 4) & 0xF0) * playing;
+			}
+			
+			amp = ((amp * volume_mul) >> volume_shift) - dac_bias;
+		}
+		update_amp( time, amp );
+	}
+	
+	// Generate wave
+	time += delay;
+	if ( time < end_time )
+	{
+		byte const* wave = this->wave_ram;
+		
+		// wave size and bank
+	#if GB_APU_NO_AGB
+		int const wave_mask = 0x1F;
+		int const swap_banks = 0;
+	#else
+		int const size20_mask = 0x20;
+		int const flags = regs [0] & agb_mask;
+		int const wave_mask = (flags & size20_mask) | 0x1F;
+		int swap_banks = 0;
+		if ( flags & bank40_mask )
+		{
+			swap_banks = flags & size20_mask;
+			wave += bank_size/2 - (swap_banks >> 1);
+		}
+	#endif
+		
+		int ph = this->phase ^ swap_banks;
+		ph = (ph + 1) & wave_mask; // pre-advance
+		
+		int const per = this->period();
+		if ( !playing )
+		{
+			#if GB_APU_FAST
+				time = end_time;
+			#else
+				// Maintain phase when not playing
+				int count = (end_time - time + per - 1) / per;
+				ph += count; // will be masked below
+				time += (blip_time_t) count * per;
+			#endif
+		}
+		else
+		{
+			Blip_Synth_Fast const* const synth = fast_synth; // cache
+			
+			// Output amplitude transitions
+			int lamp = this->last_amp + dac_bias;
+			do
+			{
+				// Extract nibble
+				int nibble = wave [ph >> 1] << (ph << 2 & 4) & 0xF0;
+				ph = (ph + 1) & wave_mask;
+				
+				// Scale by volume
+				int amp = (nibble * volume_mul) >> volume_shift;
+				
+				int delta = amp - lamp;
+				if ( delta )
+				{
+					lamp = amp;
+					synth->offset_inline( time, delta, out );
+				}
+				time += per;
+			}
+			while ( time < end_time );
+			this->last_amp = lamp - dac_bias;
+		}
+		ph = (ph - 1) & wave_mask; // undo pre-advance and mask position
+		
+		// Keep track of last byte read
+		if ( enabled )
+			sample_buf = wave [ph >> 1];
+		
+		this->phase = ph ^ swap_banks; // undo swapped banks
+	}
+	delay = time - end_time;
+}
diff -Nur orig/source/gme/src/Gb_Oscs.h mod/source/gme/src/Gb_Oscs.h
--- orig/source/gme/src/Gb_Oscs.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gb_Oscs.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,188 @@
+// Private oscillators used by Gb_Apu
+
+// Gb_Snd_Emu 0.1.4
+#ifndef GB_OSCS_H
+#define GB_OSCS_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+#ifndef GB_APU_OVERCLOCK
+	#define GB_APU_OVERCLOCK 1
+#endif
+
+#if GB_APU_OVERCLOCK & (GB_APU_OVERCLOCK - 1)
+	#error "GB_APU_OVERCLOCK must be a power of 2"
+#endif
+
+class Gb_Osc {
+protected:
+	
+	// 11-bit frequency in NRx3 and NRx4
+	int frequency() const { return (regs [4] & 7) * 0x100 + regs [3]; }
+	
+	void update_amp( blip_time_t, int new_amp );
+	int write_trig( int frame_phase, int max_len, int old_data );
+public:
+	
+	enum { clk_mul  = GB_APU_OVERCLOCK };
+	enum { dac_bias = 7 };
+	
+	Blip_Buffer*    outputs [4];// NULL, right, left, center
+	Blip_Buffer*    output;     // where to output sound
+	BOOST::uint8_t* regs;       // osc's 5 registers
+	int             mode;       // mode_dmg, mode_cgb, mode_agb
+	int             dac_off_amp;// amplitude when DAC is off
+	int             last_amp;   // current amplitude in Blip_Buffer
+	Blip_Synth_Norm const* norm_synth;
+	Blip_Synth_Fast const* fast_synth;
+	
+	int         delay;      // clocks until frequency timer expires
+	int         length_ctr; // length counter
+	unsigned    phase;      // waveform phase (or equivalent)
+	bool        enabled;    // internal enabled flag
+	
+	void clock_length();
+	void reset();
+};
+
+class Gb_Env : public Gb_Osc {
+public:
+	int  env_delay;
+	int  volume;
+	bool env_enabled;
+	
+	void clock_envelope();
+	bool write_register( int frame_phase, int reg, int old_data, int data );
+	
+	void reset()
+	{
+		env_delay = 0;
+		volume    = 0;
+		Gb_Osc::reset();
+	}
+protected:
+	// Non-zero if DAC is enabled
+	int dac_enabled() const { return regs [2] & 0xF8; }
+private:
+	void zombie_volume( int old, int data );
+	int reload_env_timer();
+};
+
+class Gb_Square : public Gb_Env {
+public:
+	bool write_register( int frame_phase, int reg, int old_data, int data );
+	void run( blip_time_t, blip_time_t );
+	
+	void reset()
+	{
+		Gb_Env::reset();
+		delay = 0x40000000; // TODO: something less hacky (never clocked until first trigger)
+	}
+private:
+	// Frequency timer period
+	int period() const { return (2048 - frequency()) * (4 * clk_mul); }
+};
+
+class Gb_Sweep_Square : public Gb_Square {
+public:
+	int  sweep_freq;
+	int  sweep_delay;
+	bool sweep_enabled;
+	bool sweep_neg;
+
+	void clock_sweep();
+	void write_register( int frame_phase, int reg, int old_data, int data );
+	
+	void reset()
+	{
+		sweep_freq    = 0;
+		sweep_delay   = 0;
+		sweep_enabled = false;
+		sweep_neg     = false;
+		Gb_Square::reset();
+	}
+private:
+	enum { period_mask = 0x70 };
+	enum { shift_mask  = 0x07 };
+	
+	void calc_sweep( bool update );
+	void reload_sweep_timer();
+};
+
+class Gb_Noise : public Gb_Env {
+public:
+	
+	int divider; // noise has more complex frequency divider setup
+	
+	void run( blip_time_t, blip_time_t );
+	void write_register( int frame_phase, int reg, int old_data, int data );
+	
+	void reset()
+	{
+		divider = 0;
+		Gb_Env::reset();
+		delay = 4 * clk_mul; // TODO: remove?
+	}
+private:
+	enum { period2_mask = 0x1FFFF };
+	
+	int period2_index() const { return regs [3] >> 4; }
+	int period2( int base = 8 ) const { return base << period2_index(); }
+	unsigned lfsr_mask() const { return (regs [3] & 0x08) ? ~0x4040 : ~0x4000; }
+};
+
+class Gb_Wave : public Gb_Osc {
+public:
+	int sample_buf; // last wave RAM byte read (hardware has this as well)
+	
+	void write_register( int frame_phase, int reg, int old_data, int data );
+	void run( blip_time_t, blip_time_t );
+	
+	// Reads/writes wave RAM
+	int read( int addr ) const;
+	void write( int addr, int data );
+	
+	void reset()
+	{
+		sample_buf = 0;
+		Gb_Osc::reset();
+	}
+	
+private:
+	enum { bank40_mask = 0x40 };
+	enum { bank_size   = 32 };
+	
+	int agb_mask;               // 0xFF if AGB features enabled, 0 otherwise
+	BOOST::uint8_t* wave_ram;   // 32 bytes (64 nybbles), stored in APU
+	
+	friend class Gb_Apu;
+	
+	// Frequency timer period
+	int period() const { return (2048 - frequency()) * (2 * clk_mul); }
+	
+	// Non-zero if DAC is enabled
+	int dac_enabled() const { return regs [0] & 0x80; }
+	
+	void corrupt_wave();
+	
+	BOOST::uint8_t* wave_bank() const { return &wave_ram [(~regs [0] & bank40_mask) >> 2 & agb_mask]; }
+	
+	// Wave index that would be accessed, or -1 if no access would occur
+	int access( int addr ) const;
+};
+
+inline int Gb_Wave::read( int addr ) const
+{
+	int index = access( addr );
+	return (index < 0 ? 0xFF : wave_bank() [index]);
+}
+
+inline void Gb_Wave::write( int addr, int data )
+{
+	int index = access( addr );
+	if ( index >= 0 )
+		wave_bank() [index] = data;;
+}
+
+#endif
diff -Nur orig/source/gme/src/Gbs_Core.cpp mod/source/gme/src/Gbs_Core.cpp
--- orig/source/gme/src/Gbs_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gbs_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,208 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Gbs_Core.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2003-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const tempo_unit = 16;
+int const idle_addr = 0xF00D;
+int const bank_size = 0x4000;
+
+Gbs_Core::Gbs_Core() : rom( bank_size )
+{
+	tempo = tempo_unit;
+	assert( offsetof (header_t,copyright [32]) == header_t::size );
+}
+
+Gbs_Core::~Gbs_Core() { }
+
+void Gbs_Core::unload()
+{
+	header_.timer_mode = 0; // set_tempo() reads this
+	rom.clear();
+	Gme_Loader::unload();
+}
+
+bool Gbs_Core::header_t::valid_tag() const
+{
+	return 0 == memcmp( tag, "GBS", 3 );
+}
+
+blargg_err_t Gbs_Core::load_( Data_Reader& in )
+{
+	RETURN_ERR( rom.load( in, header_.size, &header_, 0 ) );
+	
+	if ( !header_.valid_tag() )
+		return blargg_err_file_type;
+	
+	if ( header_.vers != 1 )
+		set_warning( "Unknown file version" );
+	
+	if ( header_.timer_mode & 0x78 )
+		set_warning( "Invalid timer mode" );
+	
+	addr_t load_addr = get_le16( header_.load_addr );
+	if ( (header_.load_addr [1] | header_.init_addr [1] | header_.play_addr [1]) > 0x7F ||
+			load_addr < 0x400 )
+		set_warning( "Invalid load/init/play address" );
+	
+	cpu.rst_base = load_addr;
+	rom.set_addr( load_addr );
+	
+	return blargg_ok;
+}
+
+void Gbs_Core::set_bank( int n )
+{
+	addr_t addr = rom.mask_addr( n * bank_size );
+	if ( addr == 0 && rom.size() > bank_size )
+		addr = bank_size; // MBC1&2 behavior, bank 0 acts like bank 1
+	cpu.map_code( bank_size, bank_size, rom.at_addr( addr ) );
+}
+
+void Gbs_Core::update_timer()
+{
+	play_period_ = 70224 / tempo_unit; // 59.73 Hz
+	
+	if ( header_.timer_mode & 0x04 ) 
+	{
+		// Using custom rate
+		static byte const rates [4] = { 6, 0, 2, 4 };
+		// TODO: emulate double speed CPU mode rather than halving timer rate
+		int double_speed = header_.timer_mode >> 7;
+		int shift = rates [ram [hi_page + 7] & 3] - double_speed;
+		play_period_ = (256 - ram [hi_page + 6]) << shift;
+	}
+	
+	play_period_ *= tempo;
+}
+
+void Gbs_Core::set_tempo( double t )
+{
+	tempo = (int) (tempo_unit / t + 0.5);
+	apu_.set_tempo( t );
+	update_timer();
+}
+
+// Jumps to routine, given pointer to address in file header. Pushes idle_addr
+// as return address, NOT old PC.
+void Gbs_Core::jsr_then_stop( byte const addr [] )
+{
+	check( cpu.r.sp == get_le16( header_.stack_ptr ) );
+	cpu.r.pc = get_le16( addr );
+	write_mem( --cpu.r.sp, idle_addr >> 8 );
+	write_mem( --cpu.r.sp, idle_addr      );
+}
+
+blargg_err_t Gbs_Core::start_track( int track, Gb_Apu::mode_t mode )
+{
+	// Reset APU to state expected by most rips
+	static byte const sound_data [] = {
+		0x80, 0xBF, 0x00, 0x00, 0xB8, // square 1 DAC disabled
+		0x00, 0x3F, 0x00, 0x00, 0xB8, // square 2 DAC disabled
+		0x7F, 0xFF, 0x9F, 0x00, 0xB8, // wave     DAC disabled
+		0x00, 0xFF, 0x00, 0x00, 0xB8, // noise    DAC disabled
+		0x77, 0xFF, 0x80, // max volume, all chans in center, power on
+	};
+	apu_.reset( mode );
+	apu_.write_register( 0, 0xFF26, 0x80 ); // power on
+	for ( int i = 0; i < (int) sizeof sound_data; i++ )
+		apu_.write_register( 0, i + apu_.io_addr, sound_data [i] );
+	apu_.end_frame( 1 ); // necessary to get click out of the way
+	
+	// Init memory and I/O registers
+	memset( ram, 0, 0x4000 );
+	memset( ram + 0x4000, 0xFF, 0x1F80 );
+	memset( ram + 0x5F80, 0, sizeof ram - 0x5F80 );
+	ram [hi_page] = 0; // joypad reads back as 0
+	ram [idle_addr - ram_addr] = 0xED; // illegal instruction
+	ram [hi_page + 6] = header_.timer_modulo;
+	ram [hi_page + 7] = header_.timer_mode;
+	
+	// Map memory
+	cpu.reset( rom.unmapped() );
+	cpu.map_code( ram_addr, 0x10000 - ram_addr, ram );
+	cpu.map_code( 0, bank_size, rom.at_addr( 0 ) );
+	set_bank( rom.size() > bank_size );
+	
+	// CPU registers, timing
+	update_timer();
+	next_play = play_period_;
+	cpu.r.fa = track;
+	cpu.r.sp = get_le16( header_.stack_ptr );
+	jsr_then_stop( header_.init_addr );
+	
+	return blargg_ok;
+}
+
+blargg_err_t Gbs_Core::run_until( int end )
+{
+	end_time = end;
+	cpu.set_time( cpu.time() - end );
+	while ( true )
+	{
+		run_cpu();
+		if ( cpu.time() >= 0 )
+			break;
+		
+		if ( cpu.r.pc == idle_addr )
+		{
+			if ( next_play > end_time )
+			{
+				cpu.set_time( 0 );
+				break;
+			}
+			
+			if ( cpu.time() < next_play - end_time )
+				cpu.set_time( next_play - end_time );
+			next_play += play_period_;
+			jsr_then_stop( header_.play_addr );
+		}
+		else if ( cpu.r.pc > 0xFFFF )
+		{
+			dprintf( "PC wrapped around\n" );
+			cpu.r.pc &= 0xFFFF;
+		}
+		else
+		{
+			set_warning( "Emulation error (illegal/unsupported instruction)" );
+			dprintf( "Bad opcode $%02X at $%04X\n",
+					(int) *cpu.get_code( cpu.r.pc ), (int) cpu.r.pc );
+			cpu.r.pc = (cpu.r.pc + 1) & 0xFFFF;
+			cpu.set_time( cpu.time() + 6 );
+		}
+	}
+	
+	return blargg_ok;
+}
+
+blargg_err_t Gbs_Core::end_frame( int end )
+{
+	RETURN_ERR( run_until( end ) );
+	
+	next_play -= end;
+	if ( next_play < 0 ) // happens when play routine takes too long
+	{
+		#if !GBS_IGNORE_STARVED_PLAY
+			check( false );
+		#endif
+		next_play = 0;
+	}
+	
+	apu_.end_frame( end );
+	
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Gbs_Core.h mod/source/gme/src/Gbs_Core.h
--- orig/source/gme/src/Gbs_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gbs_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,106 @@
+// Nintendo Game Boy GBS music file emulator core
+
+// Game_Music_Emu 0.6-pre
+#ifndef GBS_CORE_H
+#define GBS_CORE_H
+
+#include "Gme_Loader.h"
+#include "Rom_Data.h"
+#include "Gb_Cpu.h"
+#include "Gb_Apu.h"
+
+class Gbs_Core : public Gme_Loader {
+public:
+
+	// GBS file header
+	struct header_t
+	{
+		enum { size = 112 };
+		
+		char tag       [ 3];
+		byte vers;
+		byte track_count;
+		byte first_track;
+		byte load_addr [ 2];
+		byte init_addr [ 2];
+		byte play_addr [ 2];
+		byte stack_ptr [ 2];
+		byte timer_modulo;
+		byte timer_mode;
+		char game      [32]; // strings can be 32 chars, NOT terminated
+		char author    [32];
+		char copyright [32];
+		
+		// True if header has valid file signature
+		bool valid_tag() const;
+	};
+	
+	// Header for currently loaded file
+	header_t const& header() const      { return header_; }
+	
+	// Sound chip
+	Gb_Apu& apu()                       { return apu_; }
+	
+	// Adjusts music tempo, where 1.0 is normal. Can be changed while playing.
+	void set_tempo( double );
+	
+	// Starts track, where 0 is the first. Uses specified APU mode.
+	blargg_err_t start_track( int, Gb_Apu::mode_t = Gb_Apu::mode_cgb );
+	
+	// Ends time frame at time t
+	typedef int time_t; // clock count
+	blargg_err_t end_frame( time_t t );
+	
+	// Clocks between calls to play routine
+	time_t play_period() const          { return play_period_; }
+	
+protected:
+	typedef int addr_t;
+	
+	// Current time
+	time_t time() const                 { return cpu.time() + end_time; }
+	
+	// Runs emulator to time t
+	blargg_err_t run_until( time_t t );
+
+	// Runs CPU until time becomes >= 0
+	void run_cpu();
+	
+	// Reads/writes memory and I/O
+	int  read_mem(  addr_t );
+	void write_mem( addr_t, int );
+
+// Implementation
+public:
+	Gbs_Core();
+	~Gbs_Core();
+	virtual void unload();
+
+protected:
+	virtual blargg_err_t load_( Data_Reader& );
+	
+private:
+	enum { ram_addr = 0xA000 };
+	enum { io_base = 0xFF00 };
+	enum { hi_page = io_base - ram_addr };
+	
+	Rom_Data  rom;
+	int       tempo;
+	time_t    end_time;
+	time_t    play_period_;
+	time_t    next_play;
+	header_t  header_;
+	Gb_Cpu    cpu;
+	Gb_Apu    apu_;
+	byte      ram [0x4000 + 0x2000 + Gb_Cpu::cpu_padding];
+	
+	void update_timer();
+	void jsr_then_stop( byte const [] );
+	void set_bank( int n );
+	void write_io_inline( int offset, int data, int base );
+	void write_io_( int offset, int data );
+	int  read_io(  int offset );
+	void write_io( int offset, int data );
+};
+
+#endif
diff -Nur orig/source/gme/src/Gbs_Cpu.cpp mod/source/gme/src/Gbs_Cpu.cpp
--- orig/source/gme/src/Gbs_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gbs_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,134 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Gbs_Core.h"
+
+#include "blargg_endian.h"
+
+//#include "gb_cpu_log.h"
+
+/* Copyright (C) 2003-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#ifndef LOG_MEM
+	#define LOG_MEM( addr, str, data ) data
+#endif
+
+int Gbs_Core::read_mem( addr_t addr )
+{
+	int result = *cpu.get_code( addr );
+	if ( (unsigned) (addr - apu_.io_addr) < apu_.io_size )
+		result = apu_.read_register( time(), addr );
+	
+#ifndef NDEBUG
+	else if ( unsigned (addr - 0x8000) < 0x2000 || unsigned (addr - 0xE000) < 0x1F00 )
+		dprintf( "Unmapped read $%04X\n", (unsigned) addr );
+	else if ( unsigned (addr - 0xFF01) < 0xFF80 - 0xFF01 && addr != 0xFF70 && addr != 0xFF05 )
+		dprintf( "Unmapped read $%04X\n", (unsigned) addr );
+#endif
+
+	return LOG_MEM( addr, ">", result );
+}
+
+inline void Gbs_Core::write_io_inline( int offset, int data, int base )
+{
+	if ( (unsigned) (offset - (apu_.io_addr - base)) < apu_.io_size )
+		apu_.write_register( time(), offset + base, data & 0xFF );
+	else if ( (unsigned) (offset - (0xFF06 - base)) < 2 )
+		update_timer();
+	else if ( offset == io_base - base )
+		ram [base - ram_addr + offset] = 0; // keep joypad return value 0
+	else
+		ram [base - ram_addr + offset] = 0xFF;
+	
+	//if ( offset == 0xFFFF - base )
+	//  dprintf( "Wrote interrupt mask\n" );
+}
+
+void Gbs_Core::write_mem( addr_t addr, int data )
+{
+	(void) LOG_MEM( addr, "<", data );
+	
+	int offset = addr - ram_addr;
+	if ( (unsigned) offset < 0x10000 - ram_addr )
+	{
+		ram [offset] = data;
+		
+		offset -= 0xE000 - ram_addr;
+		if ( (unsigned) offset < 0x1F80 )
+			write_io_inline( offset, data, 0xE000 );
+	}
+	else if ( (unsigned) (offset - (0x2000 - ram_addr)) < 0x2000 )
+	{
+		set_bank( data & 0xFF );
+	}
+#ifndef NDEBUG
+	else if ( unsigned (addr - 0x8000) < 0x2000 || unsigned (addr - 0xE000) < 0x1F00 )
+	{
+		dprintf( "Unmapped write $%04X\n", (unsigned) addr );
+	}
+#endif
+}
+
+void Gbs_Core::write_io_( int offset, int data )
+{
+	write_io_inline( offset, data, io_base );
+}
+
+inline void Gbs_Core::write_io( int offset, int data )
+{
+	(void) LOG_MEM( offset + io_base, "<", data );
+	
+	ram [io_base - ram_addr + offset] = data;
+	if ( (unsigned) offset < 0x80 )
+		write_io_( offset, data );
+}
+
+int Gbs_Core::read_io( int offset )
+{
+	int const io_base = 0xFF00;
+	int result = ram [io_base - ram_addr + offset];
+	
+	if ( (unsigned) (offset - (apu_.io_addr - io_base)) < apu_.io_size )
+	{
+		result = apu_.read_register( time(), offset + io_base );
+		(void) LOG_MEM( offset + io_base, ">", result );
+	}
+	else
+	{
+		check( result == read_mem( offset + io_base ) );
+	}
+	return result;
+}
+
+#define READ_FAST( addr, out ) \
+{\
+	out = READ_CODE( addr );\
+	if ( (unsigned) (addr - apu_.io_addr) < apu_.io_size )\
+		out = LOG_MEM( addr, ">", apu_.read_register( TIME() + end_time, addr ) );\
+	else\
+		check( out == read_mem( addr ) );\
+}
+
+#define READ_MEM(  addr       ) read_mem( addr )
+#define WRITE_MEM( addr, data ) write_mem( addr, data )
+
+#define WRITE_IO( addr, data )  write_io( addr, data )
+#define READ_IO( addr, out )    out = read_io( addr )
+
+#define CPU cpu
+
+#define CPU_BEGIN \
+void Gbs_Core::run_cpu()\
+{
+	#include "Gb_Cpu_run.h"
+}
diff -Nur orig/source/gme/src/Gbs_Emu.cpp mod/source/gme/src/Gbs_Emu.cpp
--- orig/source/gme/src/Gbs_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gbs_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,143 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Gbs_Emu.h"
+
+/* Copyright (C) 2003-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Gbs_Emu::equalizer_t const Gbs_Emu::handheld_eq   = { -47.0, 2000 };
+Gbs_Emu::equalizer_t const Gbs_Emu::cgb_eq        = {   0.0,  300 };
+Gbs_Emu::equalizer_t const Gbs_Emu::headphones_eq = {   0.0,   30 }; // DMG
+
+Gbs_Emu::Gbs_Emu()
+{
+	sound_hardware = sound_gbs;
+	enable_clicking( false );
+	set_type( gme_gbs_type );
+	set_silence_lookahead( 6 );
+	set_max_initial_silence( 21 );
+	set_gain( 1.2 );
+	
+	// kind of midway between headphones and speaker
+	static equalizer_t const eq = { -1.0, 120 };
+	set_equalizer( eq );
+}
+
+Gbs_Emu::~Gbs_Emu() { }
+
+void Gbs_Emu::unload()
+{
+	core_.unload();
+	Music_Emu::unload();
+}
+
+// Track info
+
+static void copy_gbs_fields( Gbs_Emu::header_t const& h, track_info_t* out )
+{
+	GME_COPY_FIELD( h, out, game );
+	GME_COPY_FIELD( h, out, author );
+	GME_COPY_FIELD( h, out, copyright );
+}
+
+blargg_err_t Gbs_Emu::track_info_( track_info_t* out, int ) const
+{
+	copy_gbs_fields( header(), out );
+	return blargg_ok;
+}
+
+struct Gbs_File : Gme_Info_
+{
+	Gbs_Emu::header_t h;
+	
+	Gbs_File() { set_type( gme_gbs_type ); }
+	
+	blargg_err_t load_( Data_Reader& in )
+	{
+		blargg_err_t err = in.read( &h, h.size );
+		if ( err )
+			return (blargg_is_err_type( err, blargg_err_file_eof ) ? blargg_err_file_type : err);
+		
+		set_track_count( h.track_count );
+		if ( !h.valid_tag() )
+			return blargg_err_file_type;
+		
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		copy_gbs_fields( h, out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_gbs_emu () { return BLARGG_NEW Gbs_Emu ; }
+static Music_Emu* new_gbs_file() { return BLARGG_NEW Gbs_File; }
+
+gme_type_t_ const gme_gbs_type [1] = {{ "Game Boy", 0, &new_gbs_emu, &new_gbs_file, "GBS", 1 }};
+
+// Setup
+
+blargg_err_t Gbs_Emu::load_( Data_Reader& in )
+{
+	RETURN_ERR( core_.load( in ) );
+	set_warning( core_.warning() );
+	set_track_count( header().track_count );
+	set_voice_count( Gb_Apu::osc_count );
+	core_.apu().volume( gain() );
+	
+	static const char* const names [Gb_Apu::osc_count] = {
+		"Square 1", "Square 2", "Wave", "Noise"
+	};
+	set_voice_names( names );
+	
+	static int const types [Gb_Apu::osc_count] = {
+		wave_type+1, wave_type+2, wave_type+3, mixed_type+1
+	};
+	set_voice_types( types );
+	
+	return setup_buffer( 4194304 );
+}
+
+void Gbs_Emu::update_eq( blip_eq_t const& eq )
+{
+	core_.apu().treble_eq( eq );
+}
+
+void Gbs_Emu::set_voice( int i, Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	core_.apu().set_output( i, c, l, r );
+}
+
+void Gbs_Emu::set_tempo_( double t )
+{
+	core_.set_tempo( t );
+}
+
+blargg_err_t Gbs_Emu::start_track_( int track )
+{
+	sound_t mode = sound_hardware;
+	if ( mode == sound_gbs )
+		mode = (header().timer_mode & 0x80) ? sound_cgb : sound_dmg;
+	
+	RETURN_ERR( core_.start_track( track, (Gb_Apu::mode_t) mode ) );
+	
+	// clear buffer AFTER track is started, eliminating initial click
+	return Classic_Emu::start_track_( track );
+}
+
+blargg_err_t Gbs_Emu::run_clocks( blip_time_t& duration, int )
+{
+	return core_.end_frame( duration );
+}
diff -Nur orig/source/gme/src/Gbs_Emu.h mod/source/gme/src/Gbs_Emu.h
--- orig/source/gme/src/Gbs_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gbs_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,61 @@
+// Nintendo Game Boy GBS music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef GBS_EMU_H
+#define GBS_EMU_H
+
+#include "Classic_Emu.h"
+#include "Gbs_Core.h"
+
+class Gbs_Emu : public Classic_Emu {
+public:
+	// Equalizer profiles for Game Boy speaker and headphones
+	static equalizer_t const handheld_eq;
+	static equalizer_t const headphones_eq;
+	static equalizer_t const cgb_eq; // Game Boy Color headphones have less bass
+	
+	// GBS file header (see Gbs_Core.h)
+	typedef Gbs_Core::header_t header_t;
+	
+	// Header for currently loaded file
+	header_t const& header() const { return core_.header(); }
+	
+	// Selects which sound hardware to use. AGB hardware is cleaner than the
+	// others. Doesn't take effect until next start_track().
+	enum sound_t {
+		sound_dmg = Gb_Apu::mode_dmg,   // Game Boy monochrome
+		sound_cgb = Gb_Apu::mode_cgb,   // Game Boy Color
+		sound_agb = Gb_Apu::mode_agb,   // Game Boy Advance
+		sound_gbs                       // Use DMG/CGB based on GBS (default)
+	};
+	void set_sound( sound_t s ) { sound_hardware = s; }
+	
+	// If true, makes APU more accurate, which results in more clicking.
+	void enable_clicking( bool enable = true ) { core_.apu().reduce_clicks( !enable ); }
+	
+	static gme_type_t static_type() { return gme_gbs_type; }
+
+	Gbs_Core& core() { return core_; }
+	
+// Internal
+public:
+	Gbs_Emu();
+	~Gbs_Emu();
+
+protected:
+	// Overrides
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+	virtual void unload();
+
+private:
+	sound_t sound_hardware;
+	Gbs_Core core_;
+};
+
+#endif
diff -Nur orig/source/gme/src/gme.cpp mod/source/gme/src/gme.cpp
--- orig/source/gme/src/gme.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/gme.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,431 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Music_Emu.h"
+
+#if !GME_DISABLE_EFFECTS
+#include "Effects_Buffer.h"
+#endif
+#include "blargg_endian.h"
+#include <string.h>
+#include <ctype.h>
+
+/* Copyright (C) 2003-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#ifndef GME_TYPE_LIST
+
+// Default list of all supported game music types (copy this to blargg_config.h
+// if you want to modify it)
+#define GME_TYPE_LIST \
+	gme_ay_type,\
+	gme_gbs_type,\
+	gme_gym_type,\
+	gme_hes_type,\
+	gme_kss_type,\
+	gme_nsf_type,\
+	gme_nsfe_type,\
+	gme_sap_type,\
+	gme_sgc_type,\
+	gme_spc_type,\
+	gme_vgm_type,\
+	gme_vgz_type
+
+#endif
+
+static gme_type_t const gme_type_list_ [] = { GME_TYPE_LIST, 0 };
+
+gme_type_t const* gme_type_list()
+{
+	return gme_type_list_;
+}
+
+const char* gme_identify_header( void const* header )
+{
+	switch ( get_be32( header ) )
+	{
+		case BLARGG_4CHAR('Z','X','A','Y'):  return "AY";
+		case BLARGG_4CHAR('G','B','S',0x01): return "GBS";
+		case BLARGG_4CHAR('G','Y','M','X'):  return "GYM";
+		case BLARGG_4CHAR('H','E','S','M'):  return "HES";
+		case BLARGG_4CHAR('K','S','C','C'):
+		case BLARGG_4CHAR('K','S','S','X'):  return "KSS";
+		case BLARGG_4CHAR('N','E','S','M'):  return "NSF";
+		case BLARGG_4CHAR('N','S','F','E'):  return "NSFE";
+		case BLARGG_4CHAR('S','A','P',0x0D): return "SAP";
+		case BLARGG_4CHAR('S','G','C',0x1A): return "SGC";
+		case BLARGG_4CHAR('S','N','E','S'):  return "SPC";
+		case BLARGG_4CHAR('V','g','m',' '):  return "VGM";
+	}
+	return "";
+}
+
+static void to_uppercase( const char in [], int len, char out [] )
+{
+	for ( int i = 0; i < len; i++ )
+	{
+		if ( !(out [i] = toupper( in [i] )) )
+			return;
+	}
+	*out = 0; // extension too long
+}
+
+gme_type_t gme_identify_extension( const char extension_ [] )
+{
+	char const* end = strrchr( extension_, '.' );
+	if ( end )
+		extension_ = end + 1;
+	
+	char extension [6];
+	to_uppercase( extension_, sizeof extension, extension );
+	
+	gme_type_t const* types = gme_type_list_;
+	for ( ; *types; types++ )
+		if ( !strcmp( extension, (*types)->extension_ ) )
+			break;
+	return *types;
+}
+
+gme_err_t gme_identify_file( const char path [], gme_type_t* type_out )
+{
+	*type_out = gme_identify_extension( path );
+	// TODO: don't examine header if file has extension?
+	if ( !*type_out )
+	{
+		char header [4];
+		GME_FILE_READER in;
+		RETURN_ERR( in.open( path ) );
+		RETURN_ERR( in.read( header, sizeof header ) );
+		*type_out = gme_identify_extension( gme_identify_header( header ) );
+	}
+	return blargg_ok;   
+}
+
+gme_err_t gme_open_data( void const* data, long size, Music_Emu** out, int sample_rate )
+{
+	require( (data || !size) && out );
+	*out = NULL;
+	
+	gme_type_t file_type = 0;
+	if ( size >= 4 )
+		file_type = gme_identify_extension( gme_identify_header( data ) );
+	if ( !file_type )
+		return blargg_err_file_type;
+	
+	Music_Emu* emu = gme_new_emu( file_type, sample_rate );
+	CHECK_ALLOC( emu );
+	
+	gme_err_t err = gme_load_data( emu, data, size );
+	
+	if ( err )
+		delete emu;
+	else
+		*out = emu;
+	
+	return err;
+}
+
+gme_err_t gme_open_file( const char path [], Music_Emu** out, int sample_rate )
+{
+	require( path && out );
+	*out = NULL;
+	
+	GME_FILE_READER in;
+	RETURN_ERR( in.open( path ) );
+	
+	char header [4];
+	int header_size = 0;
+	
+	gme_type_t file_type = gme_identify_extension( path );
+	if ( !file_type )
+	{
+		header_size = sizeof header;
+		RETURN_ERR( in.read( header, sizeof header ) );
+		file_type = gme_identify_extension( gme_identify_header( header ) );
+	}
+	if ( !file_type )
+		return blargg_err_file_type;
+	
+	Music_Emu* emu = gme_new_emu( file_type, sample_rate );
+	CHECK_ALLOC( emu );
+	
+	// optimization: avoids seeking/re-reading header
+	Remaining_Reader rem( header, header_size, &in );
+	gme_err_t err = emu->load( rem );
+	in.close();
+	
+	if ( err )
+		delete emu;
+	else
+		*out = emu;
+	
+	return err;
+}
+
+Music_Emu* gme_new_emu( gme_type_t type, int rate )
+{
+	if ( type )
+	{
+		if ( rate == gme_info_only )
+			return type->new_info();
+		
+		Music_Emu* gme = type->new_emu();
+		if ( gme )
+		{
+		#if !GME_DISABLE_EFFECTS
+			if ( type->flags_ & 1 )
+			{
+				gme->effects_buffer_ = BLARGG_NEW Simple_Effects_Buffer;
+				if ( gme->effects_buffer_ )
+					gme->set_buffer( gme->effects_buffer_ );
+			}
+			
+			if ( !(type->flags_ & 1) || gme->effects_buffer_ )
+		#endif
+			{
+				if ( !gme->set_sample_rate( rate ) )
+				{
+					check( gme->type() == type );
+					return gme;
+				}
+			}
+			delete gme;
+		}
+	}
+	return NULL;
+}
+
+gme_err_t gme_load_file( Music_Emu* gme, const char path [] ) { return gme->load_file( path ); }
+
+gme_err_t gme_load_data( Music_Emu* gme, void const* data, long size )
+{
+	Mem_File_Reader in( data, size );
+	return gme->load( in );
+}
+
+gme_err_t gme_load_custom( Music_Emu* gme, gme_reader_t func, long size, void* data )
+{
+	Callback_Reader in( func, size, data );
+	return gme->load( in );
+}
+
+void gme_delete( Music_Emu* gme ) { delete gme; }
+
+gme_type_t gme_type( Music_Emu const* gme ) { return gme->type(); }
+
+const char* gme_warning( Music_Emu* gme ) { return gme->warning(); }
+
+int gme_track_count( Music_Emu const* gme ) { return gme->track_count(); }
+
+struct gme_info_t_ : gme_info_t
+{
+	track_info_t info;
+	
+	BLARGG_DISABLE_NOTHROW
+};
+
+gme_err_t gme_track_info( Music_Emu const* me, gme_info_t** out, int track )
+{
+	*out = NULL;
+	
+	gme_info_t_* info = BLARGG_NEW gme_info_t_;
+	CHECK_ALLOC( info );
+	
+	gme_err_t err = me->track_info( &info->info, track );
+	if ( err )
+	{
+		gme_free_info( info );
+		return err;
+	}
+	
+	#define COPY(name) info->name = info->info.name;
+	
+	COPY( length );
+	COPY( intro_length );
+	COPY( loop_length );
+	
+	info->i4  = -1;
+	info->i5  = -1;
+	info->i6  = -1;
+	info->i7  = -1;
+	info->i8  = -1;
+	info->i9  = -1;
+	info->i10 = -1;
+	info->i11 = -1;
+	info->i12 = -1;
+	info->i13 = -1;
+	info->i14 = -1;
+	info->i15 = -1;
+	
+	info->s7  = "";
+	info->s8  = "";
+	info->s9  = "";
+	info->s10 = "";
+	info->s11 = "";
+	info->s12 = "";
+	info->s13 = "";
+	info->s14 = "";
+	info->s15 = "";
+	
+	COPY( system );
+	COPY( game );
+	COPY( song );
+	COPY( author );
+	COPY( copyright );
+	COPY( comment );
+	COPY( dumper );
+	
+	#undef COPY
+	
+	info->play_length = info->length;
+	if ( info->play_length <= 0 )
+	{
+		info->play_length = info->intro_length + 2 * info->loop_length; // intro + 2 loops
+		if ( info->play_length <= 0 )
+			info->play_length = 150 * 1000; // 2.5 minutes
+	}
+	
+	*out = info;
+	
+	return blargg_ok;
+}
+
+void gme_free_info( gme_info_t* info )
+{
+	delete STATIC_CAST(gme_info_t_*,info);
+}
+
+void*     gme_user_data      ( Music_Emu const* gme )                   { return gme->user_data(); }
+void      gme_set_user_data  ( Music_Emu* gme, void* new_user_data )    { gme->set_user_data( new_user_data ); }
+void      gme_set_user_cleanup(Music_Emu* gme, gme_user_cleanup_t func ){ gme->set_user_cleanup( func ); }
+
+gme_err_t gme_start_track    ( Music_Emu* gme, int index )              { return gme->start_track( index ); }
+gme_err_t gme_play           ( Music_Emu* gme, int n, short p [] )      { return gme->play( n, p ); }
+void      gme_set_fade       ( Music_Emu* gme, int start_msec )         { gme->set_fade( start_msec ); }
+gme_bool  gme_track_ended    ( Music_Emu const* gme )                   { return gme->track_ended(); }
+int       gme_tell           ( Music_Emu const* gme )                   { return gme->tell(); }
+gme_err_t gme_seek           ( Music_Emu* gme, int msec )               { return gme->seek( msec ); }
+int       gme_voice_count    ( Music_Emu const* gme )                   { return gme->voice_count(); }
+void      gme_ignore_silence ( Music_Emu* gme, gme_bool disable )       { gme->ignore_silence( disable != 0 ); }
+void      gme_set_tempo      ( Music_Emu* gme, double t )               { gme->set_tempo( t ); }
+void      gme_mute_voice     ( Music_Emu* gme, int index, gme_bool mute ){ gme->mute_voice( index, mute != 0 ); }
+void      gme_mute_voices    ( Music_Emu* gme, int mask )               { gme->mute_voices( mask ); }
+void      gme_set_equalizer  ( Music_Emu* gme, gme_equalizer_t const* eq ) { gme->set_equalizer( *eq ); }
+void      gme_equalizer      ( Music_Emu const* gme, gme_equalizer_t* o )  { *o = gme->equalizer(); }
+const char* gme_voice_name   ( Music_Emu const* gme, int i )            { return gme->voice_name( i ); }
+
+void gme_effects( Music_Emu const* gme, gme_effects_t* out )
+{
+	static gme_effects_t const zero = { 0 };
+	*out = zero;
+	
+	#if !GME_DISABLE_EFFECTS
+	{
+		Simple_Effects_Buffer* b = STATIC_CAST(Simple_Effects_Buffer*,gme->effects_buffer_);
+		if ( b )
+		{
+			out->enabled  = b->config().enabled;
+			out->echo     = b->config().echo;
+			out->stereo   = b->config().stereo;
+			out->surround = b->config().surround;
+		}
+	}
+	#endif
+}
+
+void gme_set_effects( Music_Emu* gme, gme_effects_t const* in )
+{
+	#if !GME_DISABLE_EFFECTS
+	{
+		Simple_Effects_Buffer* b = STATIC_CAST(Simple_Effects_Buffer*,gme->effects_buffer_);
+		if ( b )
+		{
+			b->config().enabled = false;
+			if ( in )
+			{
+				b->config().enabled  = in->enabled;
+				b->config().echo     = float(in->echo);
+				b->config().stereo   = float(in->stereo);
+				b->config().surround = in->surround;
+			}
+			b->apply_config();
+		}
+	}
+	#endif
+}
+
+void gme_set_stereo_depth( Music_Emu* gme, double depth )
+{
+	#if !GME_DISABLE_EFFECTS
+	{
+		if ( gme->effects_buffer_ )
+		{
+			gme_effects_t cfg;
+			gme_effects( gme, &cfg );
+			cfg.enabled  = (depth > 0.0);
+			cfg.echo     = depth;
+			cfg.stereo   = depth;
+			cfg.surround = true;
+			gme_set_effects( gme, &cfg );
+		}
+	}
+	#endif
+}
+
+#define ENTRY( name ) { blargg_err_##name, gme_err_##name }
+static blargg_err_to_code_t const gme_codes [] =
+{
+	ENTRY( generic ),
+	ENTRY( memory ),
+	ENTRY( caller ),
+	ENTRY( internal ),
+	ENTRY( limitation ),
+	
+	ENTRY( file_missing ),
+	ENTRY( file_read ),
+	ENTRY( file_io ),
+	ENTRY( file_eof ),
+	
+	ENTRY( file_type ),
+	ENTRY( file_feature ),
+	ENTRY( file_corrupt ),
+	
+	{ 0, -1 }
+};
+#undef ENTRY
+
+static int err_code( gme_err_t err )
+{
+	return blargg_err_to_code( err, gme_codes );
+}
+
+int gme_err_code( gme_err_t err )
+{
+	int code = err_code( err );
+	return (code >= 0 ? code : gme_err_generic);
+}
+
+gme_err_t gme_code_to_err( int code )
+{
+	return blargg_code_to_err( code, gme_codes );
+}
+
+const char* gme_err_details( gme_err_t err )
+{
+	// If we don't have error code assigned, return entire string
+	return (err_code( err ) >= 0 ? blargg_err_details( err ) : blargg_err_str( err ));
+}
+
+const char* gme_err_str( gme_err_t err )
+{
+	return blargg_err_str( err );
+}
diff -Nur orig/source/gme/src/Gme_File.cpp mod/source/gme/src/Gme_File.cpp
--- orig/source/gme/src/Gme_File.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gme_File.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,180 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Gme_File.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void Gme_File::unload()
+{
+	clear_playlist(); // BEFORE clearing track count
+	track_count_     = 0;
+	raw_track_count_ = 0;
+	Gme_Loader::unload();
+}
+
+Gme_File::Gme_File()
+{
+	type_           = NULL;
+	user_data_      = NULL;
+	user_cleanup_   = NULL;
+	Gme_File::unload(); // clears fields
+}
+
+Gme_File::~Gme_File()
+{
+	if ( user_cleanup_ )
+		user_cleanup_( user_data_ );
+}
+
+blargg_err_t Gme_File::post_load()
+{
+	if ( !track_count() )
+		set_track_count( type()->track_count );
+	return Gme_Loader::post_load();
+}
+
+void Gme_File::clear_playlist()
+{
+	playlist.clear();
+	clear_playlist_();
+	track_count_ = raw_track_count_;
+}
+
+void Gme_File::copy_field_( char out [], const char* in, int in_size )
+{
+	if ( !in || !*in )
+		return;
+	
+	// remove spaces/junk from beginning
+	while ( in_size && unsigned (*in - 1) <= ' ' - 1 )
+	{
+		in++;
+		in_size--;
+	}
+	
+	// truncate
+	if ( in_size > max_field_ )
+		in_size = max_field_;
+	
+	// find terminator
+	int len = 0;
+	while ( len < in_size && in [len] )
+		len++;
+	
+	// remove spaces/junk from end
+	while ( len && unsigned (in [len - 1]) <= ' ' )
+		len--;
+	
+	// copy
+	out [len] = 0;
+	memcpy( out, in, len );
+	
+	// strip out stupid fields that should have been left blank
+	if ( !strcmp( out, "?" ) || !strcmp( out, "<?>" ) || !strcmp( out, "< ? >" ) )
+		out [0] = 0;
+}
+
+void Gme_File::copy_field_( char out [], const char* in )
+{
+	copy_field_( out, in, max_field_ );
+}
+
+blargg_err_t Gme_File::remap_track_( int* track_io ) const
+{
+	if ( (unsigned) *track_io >= (unsigned) track_count() )
+		return BLARGG_ERR( BLARGG_ERR_CALLER, "invalid track" );
+	
+	if ( (unsigned) *track_io < (unsigned) playlist.size() )
+	{
+		M3u_Playlist::entry_t const& e = playlist [*track_io];
+		*track_io = 0;
+		if ( e.track >= 0 )
+		{
+			*track_io = e.track;
+			// TODO: really needs to be removed?
+			//if ( !(type_->flags_ & 0x02) )
+			//  *track_io -= e.decimal_track;
+		}
+		if ( *track_io >= raw_track_count_ )
+			return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "invalid track in m3u playlist" );
+	}
+	else
+	{
+		check( !playlist.size() );
+	}
+	return blargg_ok;
+}
+
+blargg_err_t Gme_File::track_info( track_info_t* out, int track ) const
+{
+	out->track_count   = track_count();
+	out->length        = -1;
+	out->loop_length   = -1;
+	out->intro_length  = -1;
+	out->fade_length   = -1;
+	out->play_length   = -1;
+	out->song      [0] = 0;
+	out->game      [0] = 0;
+	out->author    [0] = 0;
+	out->composer  [0] = 0;
+	out->engineer  [0] = 0;
+	out->sequencer [0] = 0;
+	out->tagger    [0] = 0;
+	out->copyright [0] = 0;
+	out->date      [0] = 0;
+	out->comment   [0] = 0;
+	out->dumper    [0] = 0;
+	out->system    [0] = 0;
+	out->disc      [0] = 0;
+	out->track     [0] = 0;
+	out->ost       [0] = 0;
+	
+	copy_field_( out->system, type()->system );
+	
+	int remapped = track;
+	RETURN_ERR( remap_track_( &remapped ) );
+	RETURN_ERR( track_info_( out, remapped ) );
+	
+	// override with m3u info
+	if ( playlist.size() )
+	{
+		M3u_Playlist::info_t const& i = playlist.info();
+		copy_field_( out->game     , i.title );
+		copy_field_( out->author   , i.artist );
+		copy_field_( out->engineer , i.engineer );
+		copy_field_( out->composer , i.composer );
+		copy_field_( out->sequencer, i.sequencer );
+		copy_field_( out->dumper   , i.ripping );
+		copy_field_( out->tagger   , i.tagging );
+		copy_field_( out->date     , i.date );
+		
+		M3u_Playlist::entry_t const& e = playlist [track];
+		if ( e.length >= 0 ) out->length       = e.length;
+		if ( e.intro  >= 0 ) out->intro_length = e.intro;
+		if ( e.loop   >= 0 ) out->loop_length  = e.loop;
+		if ( e.fade   >= 0 ) out->fade_length  = e.fade;
+		copy_field_( out->song, e.name );
+	}
+	
+	// play_length
+	out->play_length = out->length;
+	if ( out->play_length <= 0 )
+	{
+		out->play_length = out->intro_length + 2 * out->loop_length; // intro + 2 loops
+		if ( out->play_length <= 0 )
+			out->play_length = 150 * 1000; // 2.5 minutes
+	}
+	
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Gme_File.h mod/source/gme/src/Gme_File.h
--- orig/source/gme/src/Gme_File.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gme_File.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,151 @@
+// Common interface for track information
+
+// Game_Music_Emu 0.6-pre
+#ifndef GME_FILE_H
+#define GME_FILE_H
+
+#include "gme.h"
+#include "Gme_Loader.h"
+#include "M3u_Playlist.h"
+
+struct track_info_t
+{
+	int track_count;
+	
+	/* times in milliseconds; -1 if unknown */
+	int length;         /* total length, if file specifies it */
+	int intro_length;   /* length of song up to looping section */
+	int loop_length;    /* length of looping section */
+	int fade_length;
+	
+	/* Length if available, otherwise intro_length+loop_length*2 if available,
+	otherwise a default of 150000 (2.5 minutes). */
+	int play_length;
+	
+	/* empty string if not available */
+	char system    [256];
+	char game      [256];
+	char song      [256];
+	char author    [256];
+	char composer  [256];
+	char engineer  [256];
+	char sequencer [256];
+	char tagger    [256];
+	char copyright [256];
+	char date      [256];
+	char comment   [256];
+	char dumper    [256];
+	char disc      [256];
+	char track     [256];
+	char ost       [256];
+};
+enum { gme_max_field = 255 };
+
+class Gme_File : public Gme_Loader {
+public:
+	// Type of emulator. For example if this returns gme_nsfe_type, this object
+	// is an NSFE emulator, and you can downcast to an Nsfe_Emu* if necessary.
+	gme_type_t type() const;
+	
+	// Loads an m3u playlist. Must be done AFTER loading main music file.
+	blargg_err_t load_m3u( const char path [] );
+	blargg_err_t load_m3u( Data_Reader& in );
+	
+	// Clears any loaded m3u playlist and any internal playlist that the music
+	// format supports (NSFE for example).
+	void clear_playlist();
+	
+	// Number of tracks or 0 if no file has been loaded
+	int track_count() const;
+	
+	// Gets information for a track (length, name, author, etc.)
+	// See gme.h for definition of struct track_info_t.
+	blargg_err_t track_info( track_info_t* out, int track ) const;
+
+// User data/cleanup
+	
+	// Sets/gets pointer to data you want to associate with this emulator.
+	// You can use this for whatever you want.
+	void set_user_data( void* p )       { user_data_ = p; }
+	void* user_data() const             { return user_data_; }
+	
+	// Registers cleanup function to be called when deleting emulator, or NULL to
+	// clear it. Passes user_data to cleanup function.
+	void set_user_cleanup( gme_user_cleanup_t func ) { user_cleanup_ = func; }
+
+public:
+	Gme_File();
+	~Gme_File();
+
+protected:
+	// Services
+	void set_type( gme_type_t t )               { type_ = t; }
+	void set_track_count( int n )               { track_count_ = raw_track_count_ = n; }
+	
+	// Must be overridden
+	virtual blargg_err_t track_info_( track_info_t* out, int track ) const BLARGG_PURE( ; )
+	
+	// Optionally overridden
+	virtual void clear_playlist_() { }
+
+protected: // Gme_Loader overrides
+	virtual void unload();
+	virtual blargg_err_t post_load();
+
+protected:
+	blargg_err_t remap_track_( int* track_io ) const; // need by Music_Emu
+private:
+	gme_type_t type_;
+	void* user_data_;
+	gme_user_cleanup_t user_cleanup_;
+	int track_count_;
+	int raw_track_count_;
+	M3u_Playlist playlist;
+	char playlist_warning [64];
+	
+	blargg_err_t load_m3u_( blargg_err_t );
+
+public:
+	// track_info field copying
+	enum { max_field_ = 255 };
+	static void copy_field_( char out [], const char* in );
+	static void copy_field_( char out [], const char* in, int len );
+};
+
+struct gme_type_t_
+{
+	const char* system;      /* name of system this music file type is generally for */
+	int track_count;         /* non-zero for formats with a fixed number of tracks */
+	Music_Emu* (*new_emu)(); /* Create new emulator for this type (C++ only) */
+	Music_Emu* (*new_info)();/* Create new info reader for this type (C++ only) */
+	
+	/* internal */
+	const char* extension_;
+	int flags_;
+};
+
+/* Emulator type constants for each supported file type */
+extern const gme_type_t_
+	gme_ay_type [1],
+	gme_gbs_type [1],
+	gme_gym_type [1],
+	gme_hes_type [1],
+	gme_kss_type [1],
+	gme_nsf_type [1],
+	gme_nsfe_type [1],
+	gme_sap_type [1],
+	gme_sgc_type [1],
+	gme_spc_type [1],
+	gme_vgm_type [1],
+	gme_vgz_type [1];
+
+#define GME_COPY_FIELD( in, out, name ) \
+	{ Gme_File::copy_field_( out->name, in.name, sizeof in.name ); }
+
+inline gme_type_t Gme_File::type() const            { return type_; }
+
+inline int Gme_File::track_count() const            { return track_count_; }
+
+inline blargg_err_t Gme_File::track_info_( track_info_t*, int ) const { return blargg_ok; }
+
+#endif
diff -Nur orig/source/gme/src/gme.h mod/source/gme/src/gme.h
--- orig/source/gme/src/gme.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/gme.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,298 @@
+/* Loads and plays video game music files into sample buffer */
+
+/* Game_Music_Emu 0.6-pre */
+#ifndef GME_H
+#define GME_H
+
+#ifdef __cplusplus
+	extern "C" {
+#endif
+
+/* Pointer to error, or NULL if function was successful. See Errors below. */
+#ifndef gme_err_t /* (#ifndef allows better testing of library) */
+	typedef const char* gme_err_t;
+#endif
+
+/* First parameter of most functions is gme_t*, or const gme_t* if nothing is
+changed. */
+typedef struct gme_t gme_t;
+
+/* Boolean; false = 0, true = 1 */
+typedef bool gme_bool;
+
+
+/******** Basic operations ********/
+
+/* Opens game music file and points *out at it. If error, sets *out to NULL. */
+gme_err_t gme_open_file( const char path [], gme_t** out, int sample_rate );
+
+/* Number of tracks */
+int gme_track_count( const gme_t* );
+
+/* Starts a track, where 0 is the first track. Requires that 0 <= index < gme_track_count(). */
+gme_err_t gme_start_track( gme_t*, int index );
+
+/* Generates 'count' 16-bit signed samples info 'out'. Output is in stereo, so count
+must be even. */
+gme_err_t gme_play( gme_t*, int count, short out [] );
+
+/* Closes file and frees memory. OK to pass NULL. */
+void gme_delete( gme_t* );
+
+
+/******** Track position/length ********/
+
+/* Sets time to start fading track out. Once fade ends track_ended() returns true.
+Fade time can be changed while track is playing. */
+void gme_set_fade( gme_t*, int start_msec );
+
+/* True if a track has reached its end */
+gme_bool gme_track_ended( const gme_t* );
+
+/* Number of milliseconds played since beginning of track (1000 = one second) */
+int gme_tell( const gme_t* );
+
+/* Seeks to new time in track. Seeking backwards or far forward can take a while. */
+gme_err_t gme_seek( gme_t*, int msec );
+
+
+/******** Informational ********/
+
+/* Use in place of sample rate for open/load if you only need to get track
+information from a music file */
+enum { gme_info_only = -1 };
+
+/* Most recent warning string, or NULL if none. Clears current warning after returning.
+Warning is also cleared when loading a file and starting a track. */
+const char* gme_warning( gme_t* );
+
+/* Loads m3u playlist file (must be done after loading music) */
+gme_err_t gme_load_m3u( gme_t*, const char path [] );
+
+/* Clears any loaded m3u playlist and any internal playlist that the music format
+supports (NSFE for example). */
+void gme_clear_playlist( gme_t* );
+
+/* Passes back pointer to information for a particular track (length, name, author, etc.).
+Must be freed after use. */
+typedef struct gme_info_t gme_info_t;
+gme_err_t gme_track_info( const gme_t*, gme_info_t** out, int track );
+
+/* Frees track information */
+void gme_free_info( gme_info_t* );
+
+struct gme_info_t
+{
+	/* times in milliseconds; -1 if unknown */
+	int length;         /* total length, if file specifies it */
+	int intro_length;   /* length of song up to looping section */
+	int loop_length;    /* length of looping section */
+	
+	/* Length if available, otherwise intro_length+loop_length*2 if available,
+	otherwise a default of 150000 (2.5 minutes). */
+	int play_length;
+	
+	int i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15; /* reserved */
+	
+	/* empty string ("") if not available */
+	const char* system;
+	const char* game;
+	const char* song;
+	const char* author;
+	const char* copyright;
+	const char* comment;
+	const char* dumper;
+	
+	const char *s7,*s8,*s9,*s10,*s11,*s12,*s13,*s14,*s15; /* reserved */
+};
+
+
+/******** Advanced playback ********/
+
+/* Disables automatic end-of-track detection and skipping of silence at beginning
+if ignore is true */
+void gme_ignore_silence( gme_t*, gme_bool ignore );
+
+/* Adjusts song tempo, where 1.0 = normal, 0.5 = half speed, 2.0 = double speed, etc.
+Track length as returned by track_info() ignores tempo (assumes it's 1.0). */
+void gme_set_tempo( gme_t*, double tempo );
+
+/* Number of voices used by currently loaded file */
+int gme_voice_count( const gme_t* );
+
+/* Name of voice i, from 0 to gme_voice_count() - 1 */
+const char* gme_voice_name( const gme_t*, int i );
+
+/* Mutes/unmutes single voice i, where voice 0 is first voice */
+void gme_mute_voice( gme_t*, int index, gme_bool mute );
+
+/* Sets muting state of ALL voices at once using a bit mask, where -1 mutes all
+voices, 0 unmutes them all, 0x01 mutes just the first voice, etc. */
+void gme_mute_voices( gme_t*, int muting_mask );
+
+/* Frequency equalizer parameters (see gme.txt) */
+typedef struct gme_equalizer_t
+{
+	double treble; /* -50.0 = muffled, 0 = flat, +5.0 = extra-crisp */
+	double bass;   /* 1 = full bass, 90 = average, 16000 = almost no bass */
+	
+	double d2,d3,d4,d5,d6,d7,d8,d9; /* reserved */
+} gme_equalizer_t;
+
+/* Gets current frequency equalizer parameters */
+void gme_equalizer( const gme_t*, gme_equalizer_t* out );
+
+/* Changes frequency equalizer parameters */
+void gme_set_equalizer( gme_t*, gme_equalizer_t const* eq );
+
+
+
+/******** Effects processor ********/
+
+/* Adds stereo surround and echo to music that's usually mono or has little
+stereo. Has no effect on GYM, SPC, and Sega Genesis VGM music. */
+
+/* Simplified control using a single value, where 0.0 = off and 1.0 = maximum */
+void gme_set_stereo_depth( gme_t*, double depth );
+
+struct gme_effects_t
+{
+	double echo;    /* Amount of echo, where 0.0 = none, 1.0 = lots */
+	double stereo;  /* Separation, where 0.0 = mono, 1.0 = hard left and right */
+	
+	double d2,d3,d4,d5,d6,d7; /* reserved */
+	
+	gme_bool enabled; /* If 0, no effects are added */
+	gme_bool surround;/* If 1, some channels are put in "back", using phase inversion */
+	
+	int i1,i3,i4,i5,i6,i7; /* reserved */
+};
+typedef struct gme_effects_t gme_effects_t;
+
+/* Sets effects configuration, or disables effects if NULL */
+void gme_set_effects( gme_t*, gme_effects_t const* );
+
+/* Passes back current effects configuration */
+void gme_effects( const gme_t*, gme_effects_t* out );
+
+
+/******** Game music types ********/
+
+/* Music file type identifier. Can also hold NULL. */
+typedef const struct gme_type_t_* gme_type_t;
+
+/* Type of this emulator */
+gme_type_t gme_type( const gme_t* );
+
+/* Pointer to array of all music types, with NULL entry at end. Allows a player linked
+to this library to support new music types without having to be updated. */
+gme_type_t const* gme_type_list();
+
+/* Name of game system for this music file type */
+const char* gme_type_system( gme_type_t );
+
+/* True if this music file type supports multiple tracks */
+gme_bool gme_type_multitrack( gme_type_t );
+
+
+/******** Advanced file loading ********/
+
+/* Same as gme_open_file(), but uses file data already in memory. Makes copy of data. */
+gme_err_t gme_open_data( void const* data, long size, gme_t** emu_out, int sample_rate );
+
+/* Determines likely game music type based on first four bytes of file. Returns
+string containing proper file suffix ("NSF", "SPC", etc.) or "" if file header
+is not recognized. */
+const char* gme_identify_header( void const* header );
+
+/* Gets corresponding music type for file path or extension passed in. */
+gme_type_t gme_identify_extension( const char path_or_extension [] );
+
+/* Determines file type based on file's extension or header (if extension isn't recognized).
+Sets *type_out to type, or 0 if unrecognized or error. */
+gme_err_t gme_identify_file( const char path [], gme_type_t* type_out );
+
+/* Creates new emulator and sets sample rate. Returns NULL if out of memory. If you only need
+track information, pass gme_info_only for sample_rate. */
+gme_t* gme_new_emu( gme_type_t, int sample_rate );
+
+/* Loads music file into emulator */
+gme_err_t gme_load_file( gme_t*, const char path [] );
+
+/* Loads music file from memory into emulator. Makes a copy of data passed. */
+gme_err_t gme_load_data( gme_t*, void const* data, long size );
+
+/* Loads music file using custom data reader function that will be called to
+read file data. Most emulators load the entire file in one read call. */
+typedef gme_err_t (*gme_reader_t)( void* your_data, void* out, int count );
+gme_err_t gme_load_custom( gme_t*, gme_reader_t, long file_size, void* your_data );
+
+/* Loads m3u playlist file from memory (must be done after loading music) */
+gme_err_t gme_load_m3u_data( gme_t*, void const* data, long size );
+
+
+/******** User data ********/
+
+/* Sets/gets pointer to data you want to associate with this emulator.
+You can use this for whatever you want. */
+void  gme_set_user_data( gme_t*, void* new_user_data );
+void* gme_user_data( const gme_t* );
+
+/* Registers cleanup function to be called when deleting emulator, or NULL to
+clear it. Passes user_data when calling cleanup function. */
+typedef void (*gme_user_cleanup_t)( void* user_data );
+void gme_set_user_cleanup( gme_t*, gme_user_cleanup_t func );
+
+
+/******** Errors ********/
+
+/* Internally, a gme_err_t is a const char* that points to a normal C string.
+This means that other strings can be passed to the following functions. In the
+descriptions below, these other strings are referred to as being not gme_err_t
+strings. */
+
+/* Error string associated with err. Returns "" if err is NULL. Returns err
+unchanged if it isn't a gme_err_t string. */
+const char* gme_err_str( gme_err_t err );
+
+/* Details of error beyond main cause, or "" if none or err is NULL. Returns
+err unchanged if it isn't a gme_err_t string. */
+const char* gme_err_details( gme_err_t err );
+
+/* Numeric code corresponding to err. Returns gme_ok if err is NULL. Returns
+gme_err_generic if err isn't a gme_err_t string. */
+int gme_err_code( gme_err_t err );
+
+enum {
+	gme_ok               =    0,/* Successful call. Guaranteed to be zero. */
+	gme_err_generic      = 0x01,/* Error of unspecified type */
+	gme_err_memory       = 0x02,/* Out of memory */
+	gme_err_caller       = 0x03,/* Caller violated requirements of function */
+	gme_err_internal     = 0x04,/* Internal problem, corruption, etc. */
+	gme_err_limitation   = 0x05,/* Exceeded program limit */
+	
+	gme_err_file_missing = 0x20,/* File not found at specified path */
+	gme_err_file_read    = 0x21,/* Couldn't open file for reading */
+	gme_err_file_io      = 0x23,/* Read/write error */
+	gme_err_file_eof     = 0x25,/* Tried to read past end of file */
+	
+	gme_err_file_type    = 0x30,/* File is of wrong type */
+	gme_err_file_feature = 0x32,/* File requires unsupported feature */
+	gme_err_file_corrupt = 0x33 /* File is corrupt */
+};
+
+/* gme_err_t corresponding to numeric code. Note that this might not recover
+the original gme_err_t before it was converted to a numeric code; in
+particular, gme_err_details(gme_code_to_err(code)) will be "" in most cases. */
+gme_err_t gme_code_to_err( int code );
+
+
+
+/* Deprecated */
+typedef gme_t Music_Emu;
+
+#ifdef __cplusplus
+	}
+#endif
+
+#endif
diff -Nur orig/source/gme/src/Gme_Loader.cpp mod/source/gme/src/Gme_Loader.cpp
--- orig/source/gme/src/Gme_Loader.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gme_Loader.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,86 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Gme_Loader.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void Gme_Loader::unload()
+{
+	file_begin_ = NULL;
+	file_end_   = NULL;
+	file_data.clear();
+}
+
+Gme_Loader::Gme_Loader()
+{
+	warning_ = NULL;
+	Gme_Loader::unload();
+	blargg_verify_byte_order(); // used by most emulator types, so save them the trouble
+}
+
+Gme_Loader::~Gme_Loader() { }
+
+blargg_err_t Gme_Loader::load_mem_( byte const data [], int size )
+{
+	require( data != file_data.begin() ); // load_mem_() or load_() must be overridden
+	Mem_File_Reader in( data, size );
+	return load_( in );
+}
+
+inline blargg_err_t Gme_Loader::load_mem_wrapper( byte const data [], int size )
+{
+	file_begin_ = data;
+	file_end_   = data + size;
+	return load_mem_( data, size );
+}
+
+blargg_err_t Gme_Loader::load_( Data_Reader& in )
+{
+	RETURN_ERR( file_data.resize( in.remain() ) );
+	RETURN_ERR( in.read( file_data.begin(), file_data.size() ) );
+	return load_mem_wrapper( file_data.begin(), file_data.size() );
+}
+
+blargg_err_t Gme_Loader::post_load_( blargg_err_t err )
+{
+	if ( err )
+	{
+		unload();
+		return err;
+	}
+	
+	return post_load();
+}
+
+blargg_err_t Gme_Loader::load_mem( void const* in, long size )
+{
+	pre_load();
+	return post_load_( load_mem_wrapper( (byte const*) in, (int) size ) );
+}
+
+blargg_err_t Gme_Loader::load( Data_Reader& in )
+{
+	pre_load();
+	return post_load_( load_( in ) );
+}
+
+blargg_err_t Gme_Loader::load_file( const char path [] )
+{
+	pre_load();
+	GME_FILE_READER in;
+	RETURN_ERR( in.open( path ) );
+	return post_load_( load_( in ) );
+}
diff -Nur orig/source/gme/src/Gme_Loader.h mod/source/gme/src/Gme_Loader.h
--- orig/source/gme/src/Gme_Loader.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gme_Loader.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,92 @@
+// Common interface for loading file data from various sources
+
+// Game_Music_Emu 0.6-pre
+#ifndef GME_LOADER_H
+#define GME_LOADER_H
+
+#include "blargg_common.h"
+#include "Data_Reader.h"
+
+class Gme_Loader {
+public:
+
+	// Each loads game music data from a file and returns an error if
+	// file is wrong type or is seriously corrupt. Minor problems are
+	// reported using warning().
+	
+	// Loads from file on disk
+	blargg_err_t load_file( const char path [] );
+	
+	// Loads from custom data source (see Data_Reader.h)
+	blargg_err_t load( Data_Reader& );
+	
+	// Loads from file already read into memory. Object might keep pointer to
+	// data; if it does, you MUST NOT free it until you're done with the file.
+	blargg_err_t load_mem( void const* data, long size );
+	
+	// Most recent warning string, or NULL if none. Clears current warning after
+	// returning.
+	const char* warning();
+	
+	// Unloads file from memory
+	virtual void unload();
+	
+	virtual ~Gme_Loader();
+	
+protected:
+	typedef BOOST::uint8_t byte;
+	
+	// File data in memory, or 0 if data was loaded with load_()
+	byte const* file_begin() const      { return file_begin_; }
+	byte const* file_end() const        { return file_end_; }
+	int file_size() const               { return (int) (file_end_ - file_begin_); }
+	
+	// Sets warning string
+	void set_warning( const char s [] ) { warning_ = s; }
+	
+	// At least one must be overridden
+	virtual blargg_err_t load_( Data_Reader& ); // default loads then calls load_mem_()
+	virtual blargg_err_t load_mem_( byte const data [], int size ); // use data in memory
+	
+	// Optionally overridden
+	virtual void pre_load()             { unload(); } // called before load_()/load_mem_()
+	virtual blargg_err_t post_load()    { return blargg_ok; } // called after load_()/load_mem_() succeeds
+	
+private:
+	// noncopyable
+	Gme_Loader( const Gme_Loader& );
+	Gme_Loader& operator = ( const Gme_Loader& );
+	
+// Implementation
+public:
+	Gme_Loader();
+	BLARGG_DISABLE_NOTHROW
+	
+	blargg_vector<byte> file_data; // used only when loading from file to load_mem_()
+	byte const* file_begin_;
+	byte const* file_end_;
+	const char* warning_;
+	
+	blargg_err_t load_mem_wrapper( byte const [], int );
+	blargg_err_t post_load_( blargg_err_t err );
+};
+
+// Files are read with GME_FILE_READER. Default supports gzip if zlib is available.
+#ifndef GME_FILE_READER
+	#ifdef HAVE_ZLIB_H
+		#define GME_FILE_READER Gzip_File_Reader
+	#else
+		#define GME_FILE_READER Std_File_Reader
+	#endif
+#elif defined (GME_FILE_READER_INCLUDE)
+	#include GME_FILE_READER_INCLUDE
+#endif
+
+inline const char* Gme_Loader::warning()
+{
+	const char* s = warning_;
+	warning_ = NULL;
+	return s;
+}
+
+#endif
diff -Nur orig/source/gme/src/Gym_Emu.cpp mod/source/gme/src/Gym_Emu.cpp
--- orig/source/gme/src/Gym_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gym_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,405 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Gym_Emu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+double const min_tempo  = 0.25;
+double const oversample = 5 / 3.0;
+double const fm_gain    = 3.0;
+
+int const base_clock = 53700300;
+int const clock_rate = base_clock / 15;
+
+Gym_Emu::Gym_Emu()
+{
+	resampler.set_callback( play_frame_, this );
+	pos = NULL;
+	disable_oversampling_ = false;
+	set_type( gme_gym_type );
+	set_silence_lookahead( 1 ); // tracks should already be trimmed
+	pcm_buf = stereo_buf.center();
+}
+
+Gym_Emu::~Gym_Emu() { }
+
+// Track info
+
+static void get_gym_info( Gym_Emu::header_t const& h, int length, track_info_t* out )
+{
+	if ( 0 != memcmp( h.tag, "GYMX", 4 ) )
+		return;
+	
+	length = length * 50 / 3; // 1000 / 60
+	int loop = get_le32( h.loop_start );
+	if ( loop )
+	{
+		out->intro_length = loop * 50 / 3;
+		out->loop_length  = length - out->intro_length;
+	}
+	else
+	{
+		out->length = length;
+		out->intro_length = length; // make it clear that track is no longer than length
+		out->loop_length = 0;
+	}
+	
+	// more stupidity where the field should have been left blank
+	if ( strcmp( h.song, "Unknown Song" ) )
+		GME_COPY_FIELD( h, out, song );
+	
+	if ( strcmp( h.game, "Unknown Game" ) )
+		GME_COPY_FIELD( h, out, game );
+	
+	if ( strcmp( h.copyright, "Unknown Publisher" ) )
+		GME_COPY_FIELD( h, out, copyright );
+	
+	if ( strcmp( h.dumper, "Unknown Person" ) )
+		GME_COPY_FIELD( h, out, dumper );
+	
+	if ( strcmp( h.comment, "Header added by YMAMP" ) )
+		GME_COPY_FIELD( h, out, comment );
+}
+
+static int gym_track_length( byte const p [], byte const* end )
+{
+	int time = 0;
+	while ( p < end )
+	{
+		switch ( *p++ )
+		{
+		case 0:
+			time++;
+			break;
+		
+		case 1:
+		case 2:
+			p += 2;
+			break;
+		
+		case 3:
+			p += 1;
+			break;
+		}
+	}
+	return time;
+}
+
+blargg_err_t Gym_Emu::track_info_( track_info_t* out, int ) const
+{
+	get_gym_info( header_, gym_track_length( log_begin(), file_end() ), out );
+	return blargg_ok;
+}
+
+static blargg_err_t check_header( byte const in [], int size, int* data_offset = NULL )
+{
+	if ( size < 4 )
+		return blargg_err_file_type;
+	
+	if ( memcmp( in, "GYMX", 4 ) == 0 )
+	{
+		if ( size < Gym_Emu::header_t::size + 1 )
+			return blargg_err_file_type;
+		
+		if ( memcmp( ((Gym_Emu::header_t const*) in)->packed, "\0\0\0\0", 4 ) != 0 )
+			return BLARGG_ERR( BLARGG_ERR_FILE_FEATURE, "packed GYM file" );
+		
+		if ( data_offset )
+			*data_offset = Gym_Emu::header_t::size;
+	}
+	else if ( *in > 3 )
+	{
+		return blargg_err_file_type;
+	}
+	
+	return blargg_ok;
+}
+
+struct Gym_File : Gme_Info_
+{
+	int data_offset;
+	
+	Gym_File() { set_type( gme_gym_type ); }
+	
+	blargg_err_t load_mem_( byte const in [], int size )
+	{
+		data_offset = 0;
+		return check_header( in, size, &data_offset );
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		int length = gym_track_length( &file_begin() [data_offset], file_end() );
+		get_gym_info( *(Gym_Emu::header_t const*) file_begin(), length, out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_gym_emu () { return BLARGG_NEW Gym_Emu ; }
+static Music_Emu* new_gym_file() { return BLARGG_NEW Gym_File; }
+
+gme_type_t_ const gme_gym_type [1] = {{ "Sega Genesis", 1, &new_gym_emu, &new_gym_file, "GYM", 0 }};
+
+// Setup
+
+blargg_err_t Gym_Emu::set_sample_rate_( int sample_rate )
+{
+	blip_eq_t eq( -32, 8000, sample_rate );
+	apu.treble_eq( eq );
+	pcm_synth.treble_eq( eq );
+	
+	apu.volume( 0.135 * fm_gain * gain() );
+	
+	double factor = oversample;
+	if ( disable_oversampling_ )
+		factor = (double) base_clock / 7 / 144 / sample_rate;
+	RETURN_ERR( resampler.setup( factor, 0.990, fm_gain * gain() ) );
+	factor = resampler.rate();
+	double fm_rate = sample_rate * factor;
+	
+	RETURN_ERR( stereo_buf.set_sample_rate( sample_rate, int (1000 / 60.0 / min_tempo) ) );
+	stereo_buf.clock_rate( clock_rate );
+	
+	RETURN_ERR( fm.set_rate( fm_rate, base_clock / 7.0 ) );
+	RETURN_ERR( resampler.reset( (int) (1.0 / 60 / min_tempo * sample_rate) ) );
+	
+	return blargg_ok;
+}
+
+void Gym_Emu::set_tempo_( double t )
+{
+	if ( t < min_tempo )
+	{
+		set_tempo( min_tempo );
+		return;
+	}
+	
+	if ( stereo_buf.sample_rate() )
+	{
+		double denom = tempo() * 60;
+		clocks_per_frame = (int) (clock_rate / denom);
+		resampler.resize( (int) (sample_rate() / denom) );
+	}
+}
+
+void Gym_Emu::mute_voices_( int mask )
+{
+	Music_Emu::mute_voices_( mask );
+	fm.mute_voices( mask );
+	apu.set_output( (mask & 0x80) ? 0 : stereo_buf.center() );
+	pcm_synth.volume( (mask & 0x40) ? 0.0 : 0.125 / 256 * fm_gain * gain() );
+}
+
+blargg_err_t Gym_Emu::load_mem_( byte const in [], int size )
+{
+	assert( offsetof (header_t,packed [4]) == header_t::size );
+	log_offset = 0;
+	RETURN_ERR( check_header( in, size, &log_offset ) );
+	
+	loop_begin = NULL;
+	
+	static const char* const names [] = {
+		"FM 1", "FM 2", "FM 3", "FM 4", "FM 5", "FM 6", "PCM", "PSG"
+	};
+	set_voice_names( names );
+	
+	set_voice_count( 8 );
+	
+	if ( log_offset )
+		header_ = *(header_t const*) in;
+	else
+		memset( &header_, 0, sizeof header_ );
+	
+	return blargg_ok;
+}
+
+// Emulation
+
+blargg_err_t Gym_Emu::start_track_( int track )
+{
+	RETURN_ERR( Music_Emu::start_track_( track ) );
+	
+	pos         = log_begin();
+	loop_remain = get_le32( header_.loop_start );
+	
+	prev_pcm_count = 0;
+	pcm_enabled    = 0;
+	pcm_amp        = -1;
+	
+	fm.reset();
+	apu.reset();
+	stereo_buf.clear();
+	resampler.clear();
+	pcm_buf = stereo_buf.center();
+	return blargg_ok;
+}
+
+void Gym_Emu::run_pcm( byte const pcm_in [], int pcm_count )
+{
+	// Guess beginning and end of sample and adjust rate and buffer position accordingly.
+	
+	// count dac samples in next frame
+	int next_pcm_count = 0;
+	const byte* p = this->pos;
+	int cmd;
+	while ( (cmd = *p++) != 0 )
+	{
+		int data = *p++;
+		if ( cmd <= 2 )
+			++p;
+		if ( cmd == 1 && data == 0x2A )
+			next_pcm_count++;
+	}
+	
+	// detect beginning and end of sample
+	int rate_count = pcm_count;
+	int start = 0;
+	if ( !prev_pcm_count && next_pcm_count && pcm_count < next_pcm_count )
+	{
+		rate_count = next_pcm_count;
+		start = next_pcm_count - pcm_count;
+	}
+	else if ( prev_pcm_count && !next_pcm_count && pcm_count < prev_pcm_count )
+	{
+		rate_count = prev_pcm_count;
+	}
+	
+	// Evenly space samples within buffer section being used
+	blip_resampled_time_t period = pcm_buf->resampled_duration( clocks_per_frame ) / rate_count;
+	
+	blip_resampled_time_t time = pcm_buf->resampled_time( 0 ) + period * start + (unsigned) period / 2;
+	
+	int pcm_amp = this->pcm_amp;
+	if ( pcm_amp < 0 )
+		pcm_amp = pcm_in [0];
+	
+	for ( int i = 0; i < pcm_count; i++ )
+	{
+		int delta = pcm_in [i] - pcm_amp;
+		pcm_amp += delta;
+		pcm_synth.offset_resampled( time, delta, pcm_buf );
+		time += period;
+	}
+	this->pcm_amp = pcm_amp;
+	pcm_buf->set_modified();
+}
+
+void Gym_Emu::parse_frame()
+{
+	byte pcm [1024]; // all PCM writes for frame
+	int pcm_size = 0;
+	const byte* pos = this->pos;
+	
+	if ( loop_remain && !--loop_remain )
+		loop_begin = pos; // find loop on first time through sequence
+	
+	int cmd;
+	while ( (cmd = *pos++) != 0 )
+	{
+		int data = *pos++;
+		if ( cmd == 1 )
+		{
+			int data2 = *pos++;
+			if ( data == 0x2A )
+			{
+				pcm [pcm_size] = data2;
+				if ( pcm_size < (int) sizeof pcm - 1 )
+					pcm_size += pcm_enabled;
+			}
+			else
+			{
+				if ( data == 0x2B )
+					pcm_enabled = data2 >> 7 & 1;
+				
+				fm.write0( data, data2 );
+			}
+		}
+		else if ( cmd == 2 )
+		{
+			int data2 = *pos++;
+			if ( data == 0xB6 )
+			{
+				Blip_Buffer * pcm_buf = NULL;
+				switch ( data2 >> 6 )
+				{
+				case 0: pcm_buf = NULL; break;
+				case 1: pcm_buf = stereo_buf.right(); break;
+				case 2: pcm_buf = stereo_buf.left(); break;
+				case 3: pcm_buf = stereo_buf.center(); break;
+				}
+				/*if ( this->pcm_buf != pcm_buf )
+				{
+					if ( this->pcm_buf ) pcm_synth.offset_inline( 0, -pcm_amp, this->pcm_buf );
+					if ( pcm_buf )       pcm_synth.offset_inline( 0,  pcm_amp, pcm_buf );
+				}*/
+				this->pcm_buf = pcm_buf;
+			}
+			fm.write1( data, data2 );
+		}
+		else if ( cmd == 3 )
+		{
+			apu.write_data( 0, data );
+		}
+		else
+		{
+			// to do: many GYM streams are full of errors, and error count should
+			// reflect cases where music is really having problems
+			//log_error(); 
+			--pos; // put data back
+		}
+	}
+	
+	if ( pos >= file_end() )
+	{
+		// Reached end
+		check( pos == file_end() );
+		
+		if ( loop_begin )
+			pos = loop_begin;
+		else
+			set_track_ended();
+	}
+	this->pos = pos;
+	
+	// PCM
+	if ( pcm_buf && pcm_size )
+		run_pcm( pcm, pcm_size );
+	prev_pcm_count = pcm_size;
+}
+
+inline int Gym_Emu::play_frame( blip_time_t blip_time, int sample_count, sample_t buf [] )
+{
+	if ( !track_ended() )
+		parse_frame();
+	
+	apu.end_frame( blip_time );
+	
+	memset( buf, 0, sample_count * sizeof *buf );
+	fm.run( sample_count >> 1, buf );
+	
+	return sample_count;
+}
+
+int Gym_Emu::play_frame_( void* p, blip_time_t a, int b, sample_t c [] )
+{
+	return STATIC_CAST(Gym_Emu*,p)->play_frame( a, b, c );
+}
+
+blargg_err_t Gym_Emu::play_( int count, sample_t out [] )
+{
+	resampler.dual_play( count, out, stereo_buf );
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Gym_Emu.h mod/source/gme/src/Gym_Emu.h
--- orig/source/gme/src/Gym_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Gym_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,86 @@
+// Sega Genesis/Mega Drive GYM music file emulator
+// Performs PCM timing recovery to improve sample quality.
+
+// Game_Music_Emu 0.6-pre
+#ifndef GYM_EMU_H
+#define GYM_EMU_H
+
+#include "Dual_Resampler.h"
+#include "Ym2612_Emu.h"
+#include "Music_Emu.h"
+#include "Sms_Apu.h"
+
+class Gym_Emu : public Music_Emu {
+public:
+	
+	// GYM file header (optional; many files have NO header at all)
+	struct header_t
+	{
+		enum { size = 428 };
+		
+	    char tag        [  4];
+	    char song       [ 32];
+	    char game       [ 32];
+	    char copyright  [ 32];
+	    char emulator   [ 32];
+	    char dumper     [ 32];
+	    char comment    [256];
+	    byte loop_start [  4]; // in 1/60 seconds, 0 if not looped
+	    byte packed     [  4];
+	};
+	
+	// Header for currently loaded file
+	header_t const& header() const          { return header_; }
+	
+	static gme_type_t static_type()         { return gme_gym_type; }
+	
+	// Disables running FM chips at higher than normal rate. Will result in slightly
+	// more aliasing of high notes.
+	void disable_oversampling( bool disable = true ) { disable_oversampling_ = disable; }
+	
+// Implementation
+public:
+	Gym_Emu();
+	~Gym_Emu();
+
+protected:
+	virtual blargg_err_t load_mem_( byte const [], int );
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t set_sample_rate_( int sample_rate );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t play_( int count, sample_t [] );
+	virtual void mute_voices_( int );
+	virtual void set_tempo_( double );
+
+private:
+	// Log
+	byte const* pos;        // current position
+	byte const* loop_begin;
+	int log_offset;         // size of header (0 or header_t::size)
+	int loop_remain;        // frames remaining until loop_begin has been located
+	int clocks_per_frame;
+
+	bool disable_oversampling_;
+	
+	// PCM
+	int pcm_amp;
+	int prev_pcm_count;     // for detecting beginning/end of group of samples
+	int pcm_enabled;
+	
+	// large objects
+	Dual_Resampler  resampler;
+	Stereo_Buffer   stereo_buf;
+	Blip_Buffer   * pcm_buf;
+	Ym2612_Emu      fm;
+	Sms_Apu         apu;
+	Blip_Synth_Fast pcm_synth;
+	header_t        header_;
+	
+	byte const* log_begin() const { return file_begin() + log_offset; }
+	void parse_frame();
+	void run_pcm( byte const in [], int count );
+	int play_frame( blip_time_t blip_time, int sample_count, sample_t buf [] );
+	static int play_frame_( void*, blip_time_t, int, sample_t [] );
+};
+
+#endif
diff -Nur orig/source/gme/src/Hes_Apu_Adpcm.cpp mod/source/gme/src/Hes_Apu_Adpcm.cpp
--- orig/source/gme/src/Hes_Apu_Adpcm.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Apu_Adpcm.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,309 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Hes_Apu_Adpcm.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Hes_Apu_Adpcm::Hes_Apu_Adpcm()
+{
+	output = NULL;
+
+	memset( &state, 0, sizeof( state ) );
+
+	reset();
+}
+
+void Hes_Apu_Adpcm::reset()
+{
+	last_time = 0;
+	next_timer = 0;
+	last_amp = 0;
+
+	memset( &state.pcmbuf, 0, sizeof(state.pcmbuf) );
+	memset( &state.port, 0, sizeof(state.port) );
+
+	state.ad_sample = 0;
+	state.ad_ref_index = 0;
+
+	state.addr = 0;
+	state.freq = 0;
+	state.writeptr = 0;
+	state.readptr = 0;
+	state.playflag = 0;
+	state.repeatflag = 0;
+	state.length = 0;
+	state.volume = 0xFF;
+	state.fadetimer = 0;
+	state.fadecount = 0;
+}
+
+void Hes_Apu_Adpcm::set_output( int i, Blip_Buffer* center, Blip_Buffer* left, Blip_Buffer* right )
+{
+	// Must be silent (all NULL), mono (left and right NULL), or stereo (none NULL)
+	require( !center || (center && !left && !right) || (center && left && right) );
+	require( (unsigned) i < osc_count ); // fails if you pass invalid osc index
+	
+	if ( !center || !left || !right )
+	{
+		left  = center;
+		right = center;
+	}
+	
+	output = center;
+}
+
+void Hes_Apu_Adpcm::run_until( blip_time_t end_time )
+{
+	int volume = state.volume;
+	int fadetimer = state.fadetimer;
+	int fadecount = state.fadecount;
+	int last_time = this->last_time;
+	double next_timer = this->next_timer;
+	int last_amp = this->last_amp;
+	
+	Blip_Buffer* output = this->output; // cache often-used values
+
+	while ( state.playflag && last_time < end_time )
+	{
+		while ( last_time >= next_timer )
+		{
+			if ( fadetimer )
+			{
+				if ( fadecount > 0 )
+				{
+					fadecount--;
+					volume = 0xFF * fadecount / fadetimer;
+				}
+				else if ( fadecount < 0 )
+				{
+					fadecount++;
+					volume = 0xFF - ( 0xFF * fadecount / fadetimer );
+				}
+			}
+			next_timer += 7159.091;
+		}
+		int amp;
+		if ( state.ad_low_nibble )
+		{
+			amp = adpcm_decode( state.pcmbuf[ state.playptr ] & 0x0F );
+			state.ad_low_nibble = false;
+			state.playptr++;
+			state.playedsamplecount++;
+			if ( state.playedsamplecount == state.playlength )
+			{
+				state.playflag = 0;
+			}
+		}
+		else
+		{
+			amp = adpcm_decode( state.pcmbuf[ state.playptr ] >> 4 );
+			state.ad_low_nibble = true;
+		}
+		amp = amp * volume / 0xFF;
+		int delta = amp - last_amp;
+		if ( output && delta )
+		{
+			last_amp = amp;
+			synth.offset_inline( last_time, delta, output );
+		}
+		last_time += state.freq;
+	}
+
+	if ( !state.playflag )
+	{
+		while ( next_timer <= end_time ) next_timer += 7159.091;
+		last_time = end_time;
+	}
+	
+	this->last_time  = last_time;
+	this->next_timer = next_timer;
+	this->last_amp   = last_amp;
+	state.volume = volume;
+	state.fadetimer = fadetimer;
+	state.fadecount = fadecount;
+}
+
+void Hes_Apu_Adpcm::write_data( blip_time_t time, int addr, int data )
+{
+	if ( time > last_time ) run_until( time );
+
+	data &= 0xFF;
+	state.port[ addr & 15 ] = data;
+	switch ( addr & 15 )
+	{
+	case 8:
+		state.addr &= 0xFF00;
+		state.addr |= data;
+		break;
+	case 9:
+		state.addr &= 0xFF;
+		state.addr |= data << 8;
+		break;
+	case 10:
+		state.pcmbuf[ state.writeptr++ ] = data;
+		state.playlength ++;
+		break;
+	case 11:
+		dprintf("ADPCM DMA 0x%02X", data);
+		break;
+	case 13:
+		if ( data & 0x80 )
+		{
+			state.addr = 0;
+			state.freq = 0;
+			state.writeptr = 0;
+			state.readptr = 0;
+			state.playflag = 0;
+			state.repeatflag = 0;
+			state.length = 0;
+			state.volume = 0xFF;
+		}
+		if ( ( data & 3 ) == 3 )
+		{
+			state.writeptr = state.addr;
+		}
+		if ( data & 8 )
+		{
+			state.readptr = state.addr ? state.addr - 1 : state.addr;
+		}
+		if ( data & 0x10 )
+		{
+			state.length = state.addr;
+		}
+		state.repeatflag = data & 0x20;
+		state.playflag = data & 0x40;
+		if ( state.playflag )
+		{
+			state.playptr = state.readptr;
+			state.playlength = state.length + 1;
+			state.playedsamplecount = 0;
+			state.ad_sample = 0;
+			state.ad_low_nibble = false;
+		}
+		break;
+	case 14:
+		state.freq = 7159091 / ( 32000 / ( 16 - ( data & 15 ) ) );
+		break;
+	case 15:
+		switch ( data & 15 )
+		{
+		case 0:
+		case 8:
+		case 12:
+			state.fadetimer = -100;
+			state.fadecount = state.fadetimer;
+			break;
+		case 10:
+			state.fadetimer = 5000;
+			state.fadecount = state.fadetimer;
+			break;
+		case 14:
+			state.fadetimer = 1500;
+			state.fadecount = state.fadetimer;
+			break;
+		}
+		break;
+	}
+}
+
+int Hes_Apu_Adpcm::read_data( blip_time_t time, int addr )
+{
+	if ( time > last_time ) run_until( time );
+
+	switch ( addr & 15 )
+	{
+	case 10:
+		return state.pcmbuf [state.readptr++];
+	case 11:
+		return state.port [11] & ~1;
+	case 12:
+		if (!state.playflag)
+		{
+			state.port [12] |= 1;
+			state.port [12] &= ~8;
+		}
+		else
+		{
+			state.port [12] &= ~1;
+			state.port [12] |= 8;
+		}
+		return state.port [12];
+	case 13:
+		return state.port [13];
+	}
+
+	return 0xFF;
+}
+
+void Hes_Apu_Adpcm::end_frame( blip_time_t end_time )
+{
+	run_until( end_time );
+	last_time -= end_time;
+	next_timer -= (double)end_time;
+	check( last_time >= 0 );
+	if ( output )
+		output->set_modified();
+}
+
+static short stepsize[49] = {
+  16,  17,  19,  21,  23,  25,  28,
+  31,  34,  37,  41,  45,  50,  55,
+  60,  66,  73,  80,  88,  97, 107,
+ 118, 130, 143, 157, 173, 190, 209,
+ 230, 253, 279, 307, 337, 371, 408,
+ 449, 494, 544, 598, 658, 724, 796,
+ 876, 963,1060,1166,1282,1411,1552
+};
+
+int Hes_Apu_Adpcm::adpcm_decode( int code )
+{
+	int step = stepsize[state.ad_ref_index];
+	int delta;
+	int c = code & 7;
+#if 1
+	delta = 0;
+	if ( c & 4 ) delta += step;
+	step >>= 1;
+	if ( c & 2 ) delta += step;
+	step >>= 1;
+	if ( c & 1 ) delta += step;
+	step >>= 1;
+	delta += step;
+#else
+	delta = ( ( c + c + 1 ) * step ) / 8; // maybe faster, but introduces rounding
+#endif
+	if ( c != code )
+	{
+		state.ad_sample -= delta;
+		if ( state.ad_sample < -2048 )
+			state.ad_sample = -2048;
+	}
+	else
+	{
+		state.ad_sample += delta;
+		if ( state.ad_sample > 2047 )
+			state.ad_sample = 2047;
+	}
+
+	static int const steps [8] = {
+		-1, -1, -1, -1, 2, 4, 6, 8
+	};
+	state.ad_ref_index += steps [c];
+	if ( state.ad_ref_index < 0 )
+		state.ad_ref_index = 0;
+	else if ( state.ad_ref_index > 48 )
+		state.ad_ref_index = 48;
+
+	return state.ad_sample;
+}
\ Nincs új sor a fájl végén
diff -Nur orig/source/gme/src/Hes_Apu_Adpcm.h mod/source/gme/src/Hes_Apu_Adpcm.h
--- orig/source/gme/src/Hes_Apu_Adpcm.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Apu_Adpcm.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,94 @@
+// Turbo Grafx 16 (PC Engine) ADPCM sound chip emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef HES_APU_ADPCM_H
+#define HES_APU_ADPCM_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+class Hes_Apu_Adpcm {
+public:
+// Basics
+
+	// Sets buffer(s) to generate sound into, or 0 to mute. If only center is not 0,
+	// output is mono.
+	void set_output( Blip_Buffer* center, Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+
+	// Emulates to time t, then writes data to addr
+	void write_data( blip_time_t t, int addr, int data );
+
+	// Emulates to time t, then reads from addr
+	int read_data( blip_time_t t, int addr );
+	
+	// Emulates to time t, then subtracts t from the current time.
+	// OK if previous write call had time slightly after t.
+	void end_frame( blip_time_t t );
+	
+// More features
+	
+	// Resets sound chip
+	void reset();
+	
+	// Same as set_output(), but for a particular channel
+	enum { osc_count = 1 }; // 0 <= chan < osc_count
+	void set_output( int chan, Blip_Buffer* center, Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+	
+	// Sets treble equalization
+	void treble_eq( blip_eq_t const& eq )   { synth.treble_eq( eq ); }
+	
+	// Sets overall volume, where 1.0 is normal
+	void volume( double v )                 { synth.volume( 0.6 / osc_count / amp_range * v ); }
+	
+	// Registers are at io_addr to io_addr+io_size-1
+	enum { io_addr = 0x1800 };
+	enum { io_size = 0x400 };
+	
+// Implementation
+public:
+	Hes_Apu_Adpcm();
+	typedef BOOST::uint8_t byte;
+
+private:
+	enum { amp_range = 2048 };
+
+	struct State
+	{
+		byte           pcmbuf [0x10000];
+		byte           port [0x10];
+		int            ad_sample;
+		int            ad_ref_index;
+		bool           ad_low_nibble;
+		int            freq;
+		unsigned short addr;
+		unsigned short writeptr;
+		unsigned short readptr;
+		unsigned short playptr;
+		byte           playflag;
+		byte           repeatflag;
+		int            length;
+		int            playlength;
+		int            playedsamplecount;
+		int            volume;
+		int            fadetimer;
+		int            fadecount;
+	};
+	State state;
+	Blip_Synth_Fast synth;
+
+	Blip_Buffer* output;
+	blip_time_t  last_time;
+	double       next_timer;
+	int          last_amp;
+
+	void run_until( blip_time_t );
+
+	int adpcm_decode( int );
+};
+
+inline void Hes_Apu_Adpcm::set_output( Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	set_output( 0, c, l, r );
+}
+
+#endif
diff -Nur orig/source/gme/src/Hes_Apu.cpp mod/source/gme/src/Hes_Apu.cpp
--- orig/source/gme/src/Hes_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,361 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Hes_Apu.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+bool const center_waves = true; // reduces asymmetry and clamping when starting notes
+
+Hes_Apu::Hes_Apu()
+{
+	for ( Osc* osc = &oscs [osc_count]; osc != oscs; )
+	{
+		osc--;
+		osc->output  [0] = NULL;
+		osc->output  [1] = NULL;
+		osc->outputs [0] = NULL;
+		osc->outputs [1] = NULL;
+		osc->outputs [2] = NULL;
+	}
+	
+	reset();
+}
+
+void Hes_Apu::reset()
+{
+	latch   = 0;
+	balance = 0xFF;
+	
+	for ( Osc* osc = &oscs [osc_count]; osc != oscs; )
+	{
+		osc--;
+		memset( osc, 0, offsetof (Osc,output) );
+		osc->lfsr    = 0;
+		osc->control = 0x40;
+		osc->balance = 0xFF;
+	}
+	
+	// Only last two oscs support noise
+	oscs [osc_count - 2].lfsr = 0x200C3; // equivalent to 1 in Fibonacci LFSR
+	oscs [osc_count - 1].lfsr = 0x200C3;
+}
+
+void Hes_Apu::set_output( int i, Blip_Buffer* center, Blip_Buffer* left, Blip_Buffer* right )
+{
+	// Must be silent (all NULL), mono (left and right NULL), or stereo (none NULL)
+	require( !center || (center && !left && !right) || (center && left && right) );
+	require( (unsigned) i < osc_count ); // fails if you pass invalid osc index
+	
+	if ( !center || !left || !right )
+	{
+		left  = center;
+		right = center;
+	}
+	
+	Osc& o = oscs [i];
+	o.outputs [0] = center;
+	o.outputs [1] = right;
+	o.outputs [2] = left;
+	balance_changed( o );
+}
+
+void Hes_Apu::run_osc( Blip_Synth_Fast& syn, Osc& o, blip_time_t end_time )
+{
+	int vol0 = o.volume [0];
+	int vol1 = o.volume [1];
+	int dac  = o.dac;
+	
+	Blip_Buffer* out0 = o.output [0]; // cache often-used values
+	Blip_Buffer* out1 = o.output [1];
+	if ( !(o.control & 0x80) )
+		out0 = NULL;
+	
+	if ( out0 )
+	{
+		// Update amplitudes
+		if ( out1 )
+		{
+			int delta = dac * vol1 - o.last_amp [1];
+			if ( delta )
+			{
+				syn.offset( o.last_time, delta, out1 );
+				out1->set_modified();
+			}
+		}
+		int delta = dac * vol0 - o.last_amp [0];
+		if ( delta )
+		{
+			syn.offset( o.last_time, delta, out0 );
+			out0->set_modified();
+		}
+		
+		// Don't generate if silent
+		if ( !(vol0 | vol1) )
+			out0 = NULL;
+	}
+	
+	// Generate noise
+	int noise = 0;
+	if ( o.lfsr )
+	{
+		noise = o.noise & 0x80;
+		
+		blip_time_t time = o.last_time + o.noise_delay;
+		if ( time < end_time )
+		{
+			int period = (~o.noise & 0x1F) * 128;
+			if ( !period )
+				period = 64;
+			
+			if ( noise && out0 )
+			{
+				int lfsr = o.lfsr;
+				do
+				{
+					int new_dac = -(lfsr & 1);
+					lfsr = (lfsr >> 1) ^ (0x30061 & new_dac);
+					
+					int delta = (new_dac &= 0x1F) - dac;
+					if ( delta )
+					{
+						dac = new_dac;
+						syn.offset( time, delta * vol0, out0 );
+						if ( out1 )
+							syn.offset( time, delta * vol1, out1 );
+					}
+					time += period;
+				}
+				while ( time < end_time );
+				
+				if ( !lfsr )
+				{
+					lfsr = 1;
+					check( false );
+				}
+				o.lfsr = lfsr;
+				
+				out0->set_modified();
+				if ( out1 )
+					out1->set_modified();
+			}
+			else
+			{
+				// Maintain phase when silent
+				int count = (end_time - time + period - 1) / period;
+				time += count * period;
+				
+				// not worth it
+				//while ( count-- )
+				//  o.lfsr = (o.lfsr >> 1) ^ (0x30061 * (o.lfsr & 1));
+			}
+		}
+		o.noise_delay = time - end_time;
+	}
+	
+	// Generate wave
+	blip_time_t time = o.last_time + o.delay;
+	if ( time < end_time )
+	{
+		int phase = (o.phase + 1) & 0x1F; // pre-advance for optimal inner loop
+		int period = o.period * 2;
+		
+		if ( period >= 14 && out0 && !((o.control & 0x40) | noise) )
+		{
+			do
+			{
+				int new_dac = o.wave [phase];
+				phase = (phase + 1) & 0x1F;
+				int delta = new_dac - dac;
+				if ( delta )
+				{
+					dac = new_dac;
+					syn.offset( time, delta * vol0, out0 );
+					if ( out1 )
+						syn.offset( time, delta * vol1, out1 );
+				}
+				time += period;
+			}
+			while ( time < end_time );
+			out0->set_modified();
+			if ( out1 )
+				out1->set_modified();
+		}
+		else
+		{
+			// Maintain phase when silent
+			int count = end_time - time;
+			if ( !period )
+				period = 1;
+			count = (count + period - 1) / period;
+			
+			phase += count; // phase will be masked below
+			time  += count * period;
+		}
+		
+		// TODO: Find whether phase increments even when both volumes are zero.
+		// CAN'T simply check for out0 being non-NULL, since it could be NULL
+		// if channel is muted in player, but still has non-zero volume.
+		// City Hunter breaks when this check is removed.
+		if ( !(o.control & 0x40) && (vol0 | vol1) )
+			o.phase = (phase - 1) & 0x1F; // undo pre-advance
+	}
+	o.delay = time - end_time;
+	check( o.delay >= 0 );
+	
+	o.last_time = end_time;
+	o.dac          = dac;
+	o.last_amp [0] = dac * vol0;
+	o.last_amp [1] = dac * vol1;
+}
+
+void Hes_Apu::balance_changed( Osc& osc )
+{
+	static short const log_table [32] = { // ~1.5 db per step
+		#define ENTRY( factor ) short (factor * amp_range / 31.0 + 0.5)
+		ENTRY( 0.000000 ),ENTRY( 0.005524 ),ENTRY( 0.006570 ),ENTRY( 0.007813 ),
+		ENTRY( 0.009291 ),ENTRY( 0.011049 ),ENTRY( 0.013139 ),ENTRY( 0.015625 ),
+		ENTRY( 0.018581 ),ENTRY( 0.022097 ),ENTRY( 0.026278 ),ENTRY( 0.031250 ),
+		ENTRY( 0.037163 ),ENTRY( 0.044194 ),ENTRY( 0.052556 ),ENTRY( 0.062500 ),
+		ENTRY( 0.074325 ),ENTRY( 0.088388 ),ENTRY( 0.105112 ),ENTRY( 0.125000 ),
+		ENTRY( 0.148651 ),ENTRY( 0.176777 ),ENTRY( 0.210224 ),ENTRY( 0.250000 ),
+		ENTRY( 0.297302 ),ENTRY( 0.353553 ),ENTRY( 0.420448 ),ENTRY( 0.500000 ),
+		ENTRY( 0.594604 ),ENTRY( 0.707107 ),ENTRY( 0.840896 ),ENTRY( 1.000000 ),
+		#undef ENTRY
+	};
+	
+	int vol = (osc.control & 0x1F) - 0x1E * 2;
+	
+	int left  = vol + (osc.balance >> 3 & 0x1E) + (balance >> 3 & 0x1E);
+	if ( left  < 0 ) left  = 0;
+	
+	int right = vol + (osc.balance << 1 & 0x1E) + (balance << 1 & 0x1E);
+	if ( right < 0 ) right = 0;
+	
+	// optimizing for the common case of being centered also allows easy
+	// panning using Effects_Buffer
+	
+	// Separate balance into center volume and additional on either left or right
+	osc.output [0] = osc.outputs [0]; // center
+	osc.output [1] = osc.outputs [2]; // right
+	int base = log_table [left ];
+	int side = log_table [right] - base;
+	if ( side < 0 )
+	{
+		base += side;
+		side = -side;
+		osc.output [1] = osc.outputs [1]; // left
+	}
+	
+	// Optimize when output is far left, center, or far right
+	if ( !base || osc.output [0] == osc.output [1] )
+	{
+		base += side;
+		side = 0;
+		osc.output [0] = osc.output [1];
+		osc.output [1] = NULL;
+		osc.last_amp [1] = 0;
+	}
+	
+	if ( center_waves )
+	{
+		// TODO: this can leave a non-zero level in a buffer (minor)
+		osc.last_amp [0] += (base - osc.volume [0]) * 16;
+		osc.last_amp [1] += (side - osc.volume [1]) * 16;
+	}
+	
+	osc.volume [0] = base;
+	osc.volume [1] = side;
+}
+
+void Hes_Apu::write_data( blip_time_t time, int addr, int data )
+{
+	if ( addr == 0x800 )
+	{
+		latch = data & 7;
+	}
+	else if ( addr == 0x801 )
+	{
+		if ( balance != data )
+		{
+			balance = data;
+			
+			for ( Osc* osc = &oscs [osc_count]; osc != oscs; )
+			{
+				osc--;
+				run_osc( synth, *osc, time );
+				balance_changed( *oscs );
+			}
+		}
+	}
+	else if ( latch < osc_count )
+	{
+		Osc& osc = oscs [latch];
+		run_osc( synth, osc, time );
+		switch ( addr )
+		{
+		case 0x802:
+			osc.period = (osc.period & 0xF00) | data;
+			break;
+		
+		case 0x803:
+			osc.period = (osc.period & 0x0FF) | ((data & 0x0F) << 8);
+			break;
+		
+		case 0x804:
+			if ( osc.control & 0x40 & ~data )
+				osc.phase = 0;
+			osc.control = data;
+			balance_changed( osc );
+			break;
+		
+		case 0x805:
+			osc.balance = data;
+			balance_changed( osc );
+			break;
+		
+		case 0x806:
+			data &= 0x1F;
+			if ( !(osc.control & 0x40) )
+			{
+				osc.wave [osc.phase] = data;
+				osc.phase = (osc.phase + 1) & 0x1F;
+			}
+			else if ( osc.control & 0x80 )
+			{
+				osc.dac = data;
+			}
+			break;
+		
+		 case 0x807:
+		 	osc.noise = data;
+		 	break;
+		 
+		 case 0x809:
+		 	if ( !(data & 0x80) && (data & 0x03) != 0 )
+		 		dprintf( "HES LFO not supported\n" );
+		}
+	}
+}
+
+void Hes_Apu::end_frame( blip_time_t end_time )
+{
+	for ( Osc* osc = &oscs [osc_count]; osc != oscs; )
+	{
+		osc--;
+		if ( end_time > osc->last_time )
+			run_osc( synth, *osc, end_time );
+		osc->last_time -= end_time;
+		check( osc->last_time >= 0 );
+	}
+}
diff -Nur orig/source/gme/src/Hes_Apu.h mod/source/gme/src/Hes_Apu.h
--- orig/source/gme/src/Hes_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,87 @@
+// Turbo Grafx 16 (PC Engine) PSG sound chip emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef HES_APU_H
+#define HES_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+class Hes_Apu {
+public:
+// Basics
+
+	// Sets buffer(s) to generate sound into, or 0 to mute. If only center is not 0,
+	// output is mono.
+	void set_output( Blip_Buffer* center, Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+
+	// Emulates to time t, then writes data to addr
+	void write_data( blip_time_t t, int addr, int data );
+	
+	// Emulates to time t, then subtracts t from the current time.
+	// OK if previous write call had time slightly after t.
+	void end_frame( blip_time_t t );
+	
+// More features
+	
+	// Resets sound chip
+	void reset();
+	
+	// Same as set_output(), but for a particular channel
+	enum { osc_count = 6 }; // 0 <= chan < osc_count
+	void set_output( int chan, Blip_Buffer* center, Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+	
+	// Sets treble equalization
+	void treble_eq( blip_eq_t const& eq )   { synth.treble_eq( eq ); }
+	
+	// Sets overall volume, where 1.0 is normal
+	void volume( double v )                 { synth.volume( 1.8 / osc_count / amp_range * v ); }
+	
+	// Registers are at io_addr to io_addr+io_size-1
+	enum { io_addr = 0x0800 };
+	enum { io_size = 10 };
+	
+// Implementation
+public:
+	Hes_Apu();
+	typedef BOOST::uint8_t byte;
+
+private:
+	enum { amp_range = 0x8000 };
+	struct Osc
+	{
+		byte wave [32];
+		int  delay;
+		int  period;
+		int  phase;
+		
+		int  noise_delay;
+		byte noise;
+		unsigned lfsr;
+		
+		byte control;
+		byte balance;
+		byte dac;
+		short volume [2];
+		int last_amp [2];
+		
+		blip_time_t last_time;
+		Blip_Buffer* output [2];
+		Blip_Buffer* outputs [3];
+	};
+	Osc oscs [osc_count];
+	int latch;
+	int balance;
+	Blip_Synth_Fast synth;
+	
+	void balance_changed( Osc& );
+	static void run_osc( Blip_Synth_Fast&, Osc&, blip_time_t );
+};
+
+inline void Hes_Apu::set_output( Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	for ( int i = osc_count; --i >= 0; )
+		set_output( i, c, l, r );
+}
+
+#endif
diff -Nur orig/source/gme/src/Hes_Core.cpp mod/source/gme/src/Hes_Core.cpp
--- orig/source/gme/src/Hes_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,408 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Hes_Core.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const timer_mask  = 0x04;
+int const vdp_mask    = 0x02;
+int const i_flag_mask = 0x04;
+int const unmapped    = 0xFF;
+
+int const period_60hz = 262 * 455; // scanlines * clocks per scanline
+
+Hes_Core::Hes_Core() : rom( Hes_Cpu::page_size )
+{
+	timer.raw_load = 0;
+}
+
+Hes_Core::~Hes_Core() { }
+
+void Hes_Core::unload()
+{
+	rom.clear();
+	Gme_Loader::unload();
+}
+
+bool Hes_Core::header_t::valid_tag() const
+{
+	return 0 == memcmp( tag, "HESM", 4 );
+}
+
+blargg_err_t Hes_Core::load_( Data_Reader& in )
+{
+	assert( offsetof (header_t,unused [4]) == header_t::size );
+	RETURN_ERR( rom.load( in, header_t::size, &header_, unmapped ) );
+	
+	if ( !header_.valid_tag() )
+		return blargg_err_file_type;
+	
+	if ( header_.vers != 0 )
+		set_warning( "Unknown file version" );
+	
+	if ( memcmp( header_.data_tag, "DATA", 4 ) )
+		set_warning( "Data header missing" );
+	
+	if ( memcmp( header_.unused, "\0\0\0\0", 4 ) )
+		set_warning( "Unknown header data" );
+	
+	// File spec supports multiple blocks, but I haven't found any, and
+	// many files have bad sizes in the only block, so it's simpler to
+	// just try to load the damn data as best as possible.
+	
+	int addr = get_le32( header_.addr );
+	int size = get_le32( header_.data_size );
+	int const rom_max = 0x100000;
+	if ( (unsigned) addr >= (unsigned) rom_max )
+	{
+		set_warning( "Invalid address" );
+		addr &= rom_max - 1;
+	}
+	if ( (unsigned) (addr + size) > (unsigned) rom_max )
+		set_warning( "Invalid size" );
+	
+	if ( size != rom.file_size() )
+	{
+		if ( size <= rom.file_size() - 4 && !memcmp( rom.begin() + size, "DATA", 4 ) )
+			set_warning( "Multiple DATA not supported" );
+		else if ( size < rom.file_size() )
+			set_warning( "Extra file data" );
+		else
+			set_warning( "Missing file data" );
+	}
+	
+	rom.set_addr( addr );
+	
+	return blargg_ok;
+}
+
+void Hes_Core::recalc_timer_load()
+{
+	timer.load = timer.raw_load * timer_base + 1;
+}
+
+void Hes_Core::set_tempo( double t )
+{
+	play_period = (time_t) (period_60hz / t);
+	timer_base = (int) (1024 / t);
+	recalc_timer_load();
+}
+
+blargg_err_t Hes_Core::start_track( int track )
+{
+	memset( ram, 0, sizeof ram ); // some HES music relies on zero fill
+	memset( sgx, 0, sizeof sgx );
+	
+	apu_.reset();
+	adpcm_.reset();
+	cpu.reset();
+	
+	for ( int i = 0; i < (int) sizeof header_.banks; i++ )
+		set_mmr( i, header_.banks [i] );
+	set_mmr( cpu.page_count, 0xFF ); // unmapped beyond end of address space
+	
+	irq.disables  = timer_mask | vdp_mask;
+	irq.timer     = cpu.future_time;
+	irq.vdp       = cpu.future_time;
+	
+	timer.enabled   = false;
+	timer.raw_load  = 0x80;
+	timer.count     = timer.load;
+	timer.fired     = false;
+	timer.last_time = 0;
+	
+	vdp.latch     = 0;
+	vdp.control   = 0;
+	vdp.next_vbl  = 0;
+	
+	ram [0x1FF] = (idle_addr - 1) >> 8;
+	ram [0x1FE] = (idle_addr - 1) & 0xFF;
+	cpu.r.sp = 0xFD;
+	cpu.r.pc = get_le16( header_.init_addr );
+	cpu.r.a  = track;
+	
+	recalc_timer_load();
+	
+	return blargg_ok;
+}
+
+// Hardware
+
+void Hes_Core::run_until( time_t present )
+{
+	while ( vdp.next_vbl < present )
+		vdp.next_vbl += play_period;
+	
+	time_t elapsed = present - timer.last_time;
+	if ( elapsed > 0 )
+	{
+		if ( timer.enabled )
+		{
+			timer.count -= elapsed;
+			if ( timer.count <= 0 )
+				timer.count += timer.load;
+		}
+		timer.last_time = present;
+	}
+}
+
+void Hes_Core::write_vdp( int addr, int data )
+{
+	switch ( addr )
+	{
+	case 0:
+		vdp.latch = data & 0x1F;
+		break;
+	
+	case 2:
+		if ( vdp.latch == 5 )
+		{
+			if ( data & 0x04 )
+				set_warning( "Scanline interrupt unsupported" );
+			run_until( cpu.time() );
+			vdp.control = data;
+			irq_changed();
+		}
+		else
+		{
+			dprintf( "VDP not supported: $%02X <- $%02X\n", vdp.latch, data );
+		}
+		break;
+	
+	case 3:
+		dprintf( "VDP MSB not supported: $%02X <- $%02X\n", vdp.latch, data );
+		break;
+	}
+}
+
+void Hes_Core::write_mem_( addr_t addr, int data )
+{
+	time_t time = cpu.time();
+	if ( (unsigned) (addr - apu_.io_addr) < apu_.io_size )
+	{
+		// Avoid going way past end when a long block xfer is writing to I/O space.
+		// Not a problem for other registers below because they don't write to
+		// Blip_Buffer.
+		time_t t = min( time, cpu.end_time() + 8 );
+		apu_.write_data( t, addr, data );
+		return;
+	}
+	if ( (unsigned) (addr - adpcm_.io_addr) < adpcm_.io_size )
+	{
+		time_t t = min( time, cpu.end_time() + 6 );
+		adpcm_.write_data( t, addr, data );
+		return;
+	}
+	
+	switch ( addr )
+	{
+	case 0x0000:
+	case 0x0002:
+	case 0x0003:
+		write_vdp( addr, data );
+		return;
+	
+	case 0x0C00: {
+		run_until( time );
+		timer.raw_load = (data & 0x7F) + 1;
+		recalc_timer_load();
+		timer.count = timer.load;
+		break;
+	}
+	
+	case 0x0C01:
+		data &= 1;
+		if ( timer.enabled == data )
+			return;
+		run_until( time );
+		timer.enabled = data;
+		if ( data )
+			timer.count = timer.load;
+		break;
+	
+	case 0x1402:
+		run_until( time );
+		irq.disables = data;
+		if ( (data & 0xF8) && (data & 0xF8) != 0xF8 ) // flag questionable values
+			dprintf( "Int mask: $%02X\n", data );
+		break;
+	
+	case 0x1403:
+		run_until( time );
+		if ( timer.enabled )
+			timer.count = timer.load;
+		timer.fired = false;
+		break;
+	
+#ifndef NDEBUG
+	case 0x1000: // I/O port
+	case 0x0402: // palette
+	case 0x0403:
+	case 0x0404:
+	case 0x0405:
+		return;
+		
+	default:
+		dprintf( "unmapped write $%04X <- $%02X\n", addr, data );
+		return;
+#endif
+	}
+	
+	irq_changed();
+}
+
+int Hes_Core::read_mem_( addr_t addr )
+{
+	time_t time = cpu.time();
+	addr &= cpu.page_size - 1;
+	switch ( addr )
+	{
+	case 0x0000:
+		if ( irq.vdp > time )
+			return 0;
+		irq.vdp = cpu.future_time;
+		run_until( time );
+		irq_changed();
+		return 0x20;
+		
+	case 0x0002:
+	case 0x0003:
+		dprintf( "VDP read not supported: %d\n", addr );
+		return 0;
+	
+	case 0x0C01:
+		//return timer.enabled; // TODO: remove?
+	case 0x0C00:
+		run_until( time );
+		dprintf( "Timer count read\n" );
+		return (unsigned) (timer.count - 1) / timer_base;
+	
+	case 0x1402:
+		return irq.disables;
+	
+	case 0x1403:
+		{
+			int status = 0;
+			if ( irq.timer <= time ) status |= timer_mask;
+			if ( irq.vdp   <= time ) status |= vdp_mask;
+			return status;
+		}
+
+	case 0x180A:
+	case 0x180B:
+	case 0x180C:
+	case 0x180D:
+		return adpcm_.read_data( time, addr );
+		
+	#ifndef NDEBUG
+		case 0x1000: // I/O port
+		//case 0x180C: // CD-ROM
+		//case 0x180D:
+			break;
+		
+		default:
+			dprintf( "unmapped read  $%04X\n", addr );
+	#endif
+	}
+	
+	return unmapped;
+}
+
+void Hes_Core::irq_changed()
+{
+	time_t present = cpu.time();
+	
+	if ( irq.timer > present )
+	{
+		irq.timer = cpu.future_time;
+		if ( timer.enabled && !timer.fired )
+			irq.timer = present + timer.count;
+	}
+	
+	if ( irq.vdp > present )
+	{
+		irq.vdp = cpu.future_time;
+		if ( vdp.control & 0x08 )
+			irq.vdp = vdp.next_vbl;
+	}
+	
+	time_t time = cpu.future_time;
+	if ( !(irq.disables & timer_mask) ) time = irq.timer;
+	if ( !(irq.disables &   vdp_mask) ) time = min( time, irq.vdp );
+	
+	cpu.set_irq_time( time );
+}
+
+int Hes_Core::cpu_done()
+{
+	check( cpu.time() >= cpu.end_time() ||
+			(!(cpu.r.flags & i_flag_mask) && cpu.time() >= cpu.irq_time()) );
+	
+	if ( !(cpu.r.flags & i_flag_mask) )
+	{
+		time_t present = cpu.time();
+		
+		if ( irq.timer <= present && !(irq.disables & timer_mask) )
+		{
+			timer.fired = true;
+			irq.timer = cpu.future_time;
+			irq_changed(); // overkill, but not worth writing custom code
+			return 0x0A;
+		}
+		
+		if ( irq.vdp <= present && !(irq.disables & vdp_mask) )
+		{
+			// work around for bugs with music not acknowledging VDP
+			//run_until( present );
+			//irq.vdp = cpu.future_time;
+			//irq_changed();
+			return 0x08;
+		}
+	}
+	return -1;
+}
+
+static void adjust_time( Hes_Core::time_t& time, Hes_Core::time_t delta )
+{
+	if ( time < Hes_Cpu::future_time )
+	{
+		time -= delta;
+		if ( time < 0 )
+			time = 0;
+	}
+}
+
+blargg_err_t Hes_Core::end_frame( time_t duration )
+{
+	if ( run_cpu( duration ) )
+		set_warning( "Emulation error (illegal instruction)" );
+	
+	check( cpu.time() >= duration );
+	//check( time() - duration < 20 ); // Txx instruction could cause going way over
+	
+	run_until( duration );
+	
+	// end time frame
+	timer.last_time -= duration;
+	vdp.next_vbl    -= duration;
+	cpu.end_frame( duration );
+	::adjust_time( irq.timer, duration );
+	::adjust_time( irq.vdp,   duration );
+	apu_.end_frame( duration );
+	adpcm_.end_frame( duration );
+	
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Hes_Core.h mod/source/gme/src/Hes_Core.h
--- orig/source/gme/src/Hes_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,119 @@
+// TurboGrafx-16/PC Engine HES music file emulator core
+
+// Game_Music_Emu 0.6-pre
+#ifndef HES_CORE_H
+#define HES_CORE_H
+
+#include "Gme_Loader.h"
+#include "Rom_Data.h"
+#include "Hes_Apu.h"
+#include "Hes_Apu_Adpcm.h"
+#include "Hes_Cpu.h"
+
+class Hes_Core : public Gme_Loader {
+public:
+
+	// HES file header
+	enum { info_offset = 0x20 };
+	struct header_t
+	{
+		enum { size = 0x20 };
+		
+		byte tag       [4];
+		byte vers;
+		byte first_track;
+		byte init_addr [2];
+		byte banks     [8];
+		byte data_tag  [4];
+		byte data_size [4];
+		byte addr      [4];
+		byte unused    [4];
+		
+		// True if header has valid file signature
+		bool valid_tag() const;
+	};
+	
+	// Header for currently loaded file
+	header_t const& header() const      { return header_; }
+	
+	// Pointer to ROM data, for getting track information from
+	byte const* data() const            { return rom.begin(); }
+	
+	// Adjusts rate play routine is called at, where 1.0 is normal.
+	// Can be changed while track is playing.
+	void set_tempo( double );
+	
+	// Sound chip
+	Hes_Apu& apu()                      { return apu_; }
+
+	Hes_Apu_Adpcm& adpcm()              { return adpcm_; }
+	
+	// Starts track
+	blargg_err_t start_track( int );
+	
+	// Ends time frame at time t
+	typedef int time_t;
+	blargg_err_t end_frame( time_t );
+
+// Implementation
+public:
+	Hes_Core();
+	~Hes_Core();
+	virtual void unload();
+	
+protected:
+	virtual blargg_err_t load_( Data_Reader& );
+
+private:
+	enum { idle_addr = 0x1FFF };
+	
+	typedef int addr_t;
+	Hes_Cpu  cpu;
+	Rom_Data rom;
+	header_t header_;
+	time_t   play_period;
+	int      timer_base;
+	
+	struct {
+		time_t last_time;
+		int    count;
+		int    load;
+		int    raw_load;
+		byte   enabled;
+		byte   fired;
+	} timer;
+	
+	struct {
+		time_t next_vbl;
+		byte   latch;
+		byte   control;
+	} vdp;
+	
+	struct {
+		time_t timer;
+		time_t vdp;
+		byte   disables;
+	} irq;
+	
+	void recalc_timer_load();
+	
+	// large items
+	byte*   write_pages [Hes_Cpu::page_count + 1]; // 0 if unmapped or I/O space
+	Hes_Apu apu_;
+	Hes_Apu_Adpcm adpcm_;
+	byte    ram [Hes_Cpu::page_size];
+	byte    sgx [3 * Hes_Cpu::page_size + Hes_Cpu::cpu_padding];
+	
+	void irq_changed();
+	void run_until( time_t );
+	bool run_cpu( time_t end );
+	int  read_mem_( addr_t );
+	int  read_mem( addr_t );
+	void write_mem_( addr_t, int data );
+	void write_mem( addr_t, int );
+	void write_vdp( int addr, int data );
+	void set_mmr( int reg, int bank );
+	int  cpu_done();
+};
+
+#endif
diff -Nur orig/source/gme/src/Hes_Cpu.cpp mod/source/gme/src/Hes_Cpu.cpp
--- orig/source/gme/src/Hes_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,123 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Hes_Cpu.h"
+
+#include "blargg_endian.h"
+#include "Hes_Core.h"
+
+//#include "hes_cpu_log.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#define PAGE HES_CPU_PAGE
+
+int Hes_Core::read_mem( addr_t addr )
+{
+	check( addr < 0x10000 );
+	int result = *cpu.get_code( addr );
+	if ( cpu.mmr [PAGE( addr )] == 0xFF )
+		result = read_mem_( addr );
+	return result;
+}
+
+void Hes_Core::write_mem( addr_t addr, int data )
+{
+	check( addr < 0x10000 );
+	byte* out = write_pages [PAGE( addr )];
+	if ( out )
+		out [addr & (cpu.page_size - 1)] = data;
+	else if ( cpu.mmr [PAGE( addr )] == 0xFF )
+		write_mem_( addr, data );
+}
+
+void Hes_Core::set_mmr( int page, int bank )
+{
+	write_pages [page] = 0;
+	byte* data = rom.at_addr( bank * cpu.page_size );
+	if ( bank >= 0x80 )
+	{
+		data = 0;
+		switch ( bank )
+		{
+		case 0xF8:
+			data = ram;
+			break;
+		
+		case 0xF9:
+		case 0xFA:
+		case 0xFB:
+			data = &sgx [(bank - 0xF9) * cpu.page_size];
+			break;
+		
+		default:
+			if ( bank != 0xFF )
+				dprintf( "Unmapped bank $%02X\n", bank );
+			data = rom.unmapped();
+			goto end;
+		}
+		
+		write_pages [page] = data;
+	}
+end:
+	cpu.set_mmr( page, bank, data );
+}
+
+#define READ_FAST( addr, out ) \
+{\
+	out = READ_CODE( addr );\
+	if ( CPU.mmr [PAGE( addr )] == 0xFF )\
+	{\
+		FLUSH_TIME();\
+		out = read_mem_( addr );\
+		CACHE_TIME();\
+	}\
+}
+
+#define WRITE_FAST( addr, data ) \
+{\
+	int page = PAGE( addr );\
+	byte* out = write_pages [page];\
+	addr &= CPU.page_size - 1;\
+	if ( out )\
+	{\
+		out [addr] = data;\
+	}\
+	else if ( CPU.mmr [page] == 0xFF )\
+	{\
+		FLUSH_TIME();\
+		write_mem_( addr, data );\
+		CACHE_TIME();\
+	}\
+}
+
+#define READ_LOW(  addr )           (ram [addr])
+#define WRITE_LOW( addr, data )     (ram [addr] = data)
+#define READ_MEM(  addr )           read_mem(  addr )
+#define WRITE_MEM( addr, data )     write_mem( addr, data )
+#define WRITE_VDP( addr, data )     write_vdp( addr, data )
+#define CPU_DONE( result_out )      { FLUSH_TIME(); result_out = cpu_done(); CACHE_TIME(); }
+#define SET_MMR( reg, bank )        set_mmr( reg, bank )
+
+#define CPU         cpu
+#define IDLE_ADDR   idle_addr
+
+#define CPU_BEGIN \
+bool Hes_Core::run_cpu( time_t end_time )\
+{\
+	cpu.set_end_time( end_time );
+	
+	#include "Hes_Cpu_run.h"
+	
+	return illegal_encountered;
+}
diff -Nur orig/source/gme/src/Hes_Cpu.h mod/source/gme/src/Hes_Cpu.h
--- orig/source/gme/src/Hes_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,139 @@
+// PC Engine CPU emulator for use with HES music files
+
+// Game_Music_Emu 0.6-pre
+#ifndef HES_CPU_H
+#define HES_CPU_H
+
+#include "blargg_common.h"
+
+class Hes_Cpu {
+public:
+	typedef BOOST::uint8_t byte;
+	typedef int time_t;
+	typedef int addr_t;
+	enum { future_time = INT_MAX/2 + 1 };
+	
+	void reset();
+	
+	enum { page_bits = 13 };
+	enum { page_size = 1 << page_bits };
+	enum { page_count = 0x10000 / page_size };
+	void set_mmr( int reg, int bank, void const* code );
+	
+	byte const* get_code( addr_t );
+	
+	// NOT kept updated during emulation.
+	struct registers_t {
+		BOOST::uint16_t pc;
+		byte a;
+		byte x;
+		byte y;
+		byte flags;
+		byte sp;
+	};
+	registers_t r;
+	
+	// page mapping registers
+	byte mmr [page_count + 1];
+	
+	// Time of beginning of next instruction to be executed
+	time_t time() const             { return cpu_state->time + cpu_state->base; }
+	void set_time( time_t t )       { cpu_state->time = t - cpu_state->base; }
+	void adjust_time( int delta )   { cpu_state->time += delta; }
+	
+	// Clocks past end (negative if before)
+	int time_past_end() const           { return cpu_state->time; }
+	
+	// Time of next IRQ
+	time_t irq_time() const         { return irq_time_; }
+	void set_irq_time( time_t );
+	
+	// Emulation stops once time >= end_time
+	time_t end_time() const         { return end_time_; }
+	void set_end_time( time_t );
+	
+	// Subtracts t from all times
+	void end_frame( time_t t );
+	
+	// Can read this many bytes past end of a page
+	enum { cpu_padding = 8 };
+	
+private:
+	// noncopyable
+	Hes_Cpu( const Hes_Cpu& );
+	Hes_Cpu& operator = ( const Hes_Cpu& );
+
+
+// Implementation
+public:
+	Hes_Cpu() { cpu_state = &cpu_state_; }
+	enum { irq_inhibit_mask = 0x04 };
+
+	struct cpu_state_t {
+		byte const* code_map [page_count + 1];
+		time_t base;
+		int time;
+	};
+	cpu_state_t* cpu_state; // points to cpu_state_ or a local copy
+	cpu_state_t cpu_state_;
+	time_t irq_time_;
+	time_t end_time_;
+	
+private:
+	void set_code_page( int, void const* );
+	inline void update_end_time( time_t end, time_t irq );
+};
+
+#define HES_CPU_PAGE( addr ) ((unsigned) (addr) >> Hes_Cpu::page_bits)
+
+#if BLARGG_NONPORTABLE
+	#define HES_CPU_OFFSET( addr ) (addr)
+#else
+	#define HES_CPU_OFFSET( addr ) ((addr) & (Hes_Cpu::page_size - 1))
+#endif
+
+inline BOOST::uint8_t const* Hes_Cpu::get_code( addr_t addr )
+{
+	return cpu_state_.code_map [HES_CPU_PAGE( addr )] + HES_CPU_OFFSET( addr );
+}
+
+inline void Hes_Cpu::update_end_time( time_t end, time_t irq )
+{
+	if ( end > irq && !(r.flags & irq_inhibit_mask) )
+		end = irq;
+	
+	cpu_state->time += cpu_state->base - end;
+	cpu_state->base = end;
+}
+
+inline void Hes_Cpu::set_irq_time( time_t t )
+{
+	irq_time_ = t;
+	update_end_time( end_time_, t );
+}
+
+inline void Hes_Cpu::set_end_time( time_t t )
+{
+	end_time_ = t;
+	update_end_time( t, irq_time_ );
+}
+
+inline void Hes_Cpu::end_frame( time_t t )
+{
+	assert( cpu_state == &cpu_state_ );
+	cpu_state_.base -= t;
+	if ( irq_time_ < future_time ) irq_time_ -= t;
+	if ( end_time_ < future_time ) end_time_ -= t;
+}
+
+inline void Hes_Cpu::set_mmr( int reg, int bank, void const* code )
+{
+	assert( (unsigned) reg <= page_count ); // allow page past end to be set
+	assert( (unsigned) bank < 0x100 );
+	mmr [reg] = bank;
+	byte const* p = STATIC_CAST(byte const*,code) - HES_CPU_OFFSET( reg << page_bits );
+	cpu_state->code_map [reg] = p;
+	cpu_state_.code_map [reg] = p;
+}
+
+#endif
diff -Nur orig/source/gme/src/hes_cpu_io.h mod/source/gme/src/hes_cpu_io.h
--- orig/source/gme/src/hes_cpu_io.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/hes_cpu_io.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,101 @@
+
+#include "Hes_Emu.h"
+
+#include "blargg_source.h"
+
+int Hes_Emu::cpu_read( hes_addr_t addr )
+{
+	check( addr <= 0xFFFF );
+	int result = *cpu::get_code( addr );
+	if ( mmr [addr >> page_shift] == 0xFF )
+		result = cpu_read_( addr );
+	return result;
+}
+
+void Hes_Emu::cpu_write( hes_addr_t addr, int data )
+{
+	check( addr <= 0xFFFF );
+	byte* out = write_pages [addr >> page_shift];
+	addr &= page_size - 1;
+	if ( out )
+		out [addr] = data;
+	else if ( mmr [addr >> page_shift] == 0xFF )
+		cpu_write_( addr, data );
+}
+
+inline byte const* Hes_Emu::cpu_set_mmr( int page, int bank )
+{
+	write_pages [page] = 0;
+	if ( bank < 0x80 )
+		return rom.at_addr( bank * (blargg_long) page_size );
+	
+	byte* data = 0;
+	switch ( bank )
+	{
+		case 0xF8:
+			data = cpu::ram;
+			break;
+		
+		case 0xF9:
+		case 0xFA:
+		case 0xFB:
+			data = &sgx [(bank - 0xF9) * page_size];
+			break;
+		
+		default:
+			if ( bank != 0xFF )
+				debug_printf( "Unmapped bank $%02X\n", bank );
+			return rom.unmapped();
+	}
+	
+	write_pages [page] = data;
+	return data;
+}
+
+#define CPU_READ_FAST( cpu, addr, time, out ) \
+	CPU_READ_FAST_( STATIC_CAST(Hes_Emu*,cpu), addr, time, out )
+
+#define CPU_READ_FAST_( cpu, addr, time, out ) \
+{\
+	out = READ_PROG( addr );\
+	if ( mmr [addr >> page_shift] == 0xFF )\
+	{\
+		FLUSH_TIME();\
+		out = cpu->cpu_read_( addr );\
+		CACHE_TIME();\
+	}\
+}
+
+#define CPU_WRITE_FAST( cpu, addr, data, time ) \
+	CPU_WRITE_FAST_( STATIC_CAST(Hes_Emu*,cpu), addr, data, time )
+
+#define CPU_WRITE_FAST_( cpu, addr, data, time ) \
+{\
+	byte* out = cpu->write_pages [addr >> page_shift];\
+	addr &= page_size - 1;\
+	if ( out )\
+	{\
+		out [addr] = data;\
+	}\
+	else if ( mmr [addr >> page_shift] == 0xFF )\
+	{\
+		FLUSH_TIME();\
+		cpu->cpu_write_( addr, data );\
+		CACHE_TIME();\
+	}\
+}
+
+#define CPU_READ( cpu, addr, time ) \
+	STATIC_CAST(Hes_Emu*,cpu)->cpu_read( addr )
+
+#define CPU_WRITE( cpu, addr, data, time ) \
+	STATIC_CAST(Hes_Emu*,cpu)->cpu_write( addr, data )
+
+#define CPU_WRITE_VDP( cpu, addr, data, time ) \
+	STATIC_CAST(Hes_Emu*,cpu)->cpu_write_vdp( addr, data )
+
+#define CPU_SET_MMR( cpu, page, bank ) \
+	STATIC_CAST(Hes_Emu*,cpu)->cpu_set_mmr( page, bank )
+
+#define CPU_DONE( cpu, time, result_out ) \
+	result_out = STATIC_CAST(Hes_Emu*,cpu)->cpu_done()
diff -Nur orig/source/gme/src/Hes_Cpu_run.h mod/source/gme/src/Hes_Cpu_run.h
--- orig/source/gme/src/Hes_Cpu_run.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Cpu_run.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1342 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#if 0
+/* Define these macros in the source file before #including this file.
+- Parameters might be expressions, so they are best evaluated only once,
+though they NEVER have side-effects, so multiple evaluation is OK.
+- Output parameters might be a multiple-assignment expression like "a=x",
+so they must NOT be parenthesized.
+- Except where noted, time() and related functions will NOT work
+correctly inside a macro. TIME() is always correct, and FLUSH_TIME() and
+CACHE_TIME() allow the time changing functions to work.
+- Macros "returning" void may use a {} statement block. */
+
+	// 0 <= addr <= 0xFFFF + page_size
+	// time functions can be used
+	int  READ_MEM(  addr_t );
+	void WRITE_MEM( addr_t, int data );
+	
+	// 0 <= addr <= 0x1FF
+	int  READ_LOW(  addr_t );
+	void WRITE_LOW( addr_t, int data );
+
+	// 0 <= addr <= 0xFFFF + page_size
+	// Used by common instructions.
+	int  READ_FAST(  addr_t, int& out );
+	void WRITE_FAST( addr_t, int data );
+
+	// 0 <= addr <= 2
+	// ST0, ST1, ST2 instructions
+	void WRITE_VDP( int addr, int data );
+
+// The following can be used within macros:
+	
+	// Current time
+	time_t TIME();
+	
+	// Allows use of time functions
+	void FLUSH_TIME();
+	
+	// Must be used before end of macro if FLUSH_TIME() was used earlier
+	void CACHE_TIME();
+
+// Configuration (optional; commented behavior if defined)
+	
+	// Expanded just before beginning of code, to help debugger
+	#define CPU_BEGIN void my_run_cpu() {
+#endif
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+// TODO: support T flag, including clearing it at appropriate times?
+
+// all zero-page should really use whatever is at page 1, but that would
+// reduce efficiency quite a bit
+int const ram_addr = 0x2000;
+
+void Hes_Cpu::reset()
+{
+	check( cpu_state == &cpu_state_ );
+	cpu_state = &cpu_state_;
+	
+	cpu_state_.time = 0;
+	cpu_state_.base = 0;
+	irq_time_   = future_time;
+	end_time_   = future_time;
+	
+	r.flags = 0x04;
+	r.sp    = 0;
+	r.pc    = 0;
+	r.a     = 0;
+	r.x     = 0;
+	r.y     = 0;
+	
+	// Be sure "blargg_endian.h" has been #included
+	blargg_verify_byte_order();
+}
+
+// Allows MWCW debugger to step through code properly
+#ifdef CPU_BEGIN
+	CPU_BEGIN
+#endif
+
+// Time
+#define TIME()          (s_time + s.base)
+#define FLUSH_TIME()    {s.time = s_time;}
+#define CACHE_TIME()    {s_time = s.time;}
+
+// Memory
+#define READ_STACK          READ_LOW
+#define WRITE_STACK         WRITE_LOW
+
+#define CODE_PAGE( addr )   s.code_map [HES_CPU_PAGE( addr )]
+#define CODE_OFFSET( addr ) HES_CPU_OFFSET( addr )
+#define READ_CODE( addr )   CODE_PAGE( addr ) [CODE_OFFSET( addr )]
+
+// Stack
+#define SET_SP( v )     (sp = ((v) + 1) | 0x100)
+#define GET_SP()        ((sp - 1) & 0xFF)
+#define SP( o )         ((sp + (o - (o>0)*0x100)) | 0x100)
+
+// Truncation
+#define BYTE(  n ) ((BOOST::uint8_t ) (n)) /* (unsigned) n & 0xFF */
+#define SBYTE( n ) ((BOOST::int8_t  ) (n)) /* (BYTE( n ) ^ 0x80) - 0x80 */
+#define WORD(  n ) ((BOOST::uint16_t) (n)) /* (unsigned) n & 0xFFFF */
+
+// Flags with hex value for clarity when used as mask.
+// Stored in indicated variable during emulation.
+int const n80 = 0x80; // nz
+int const v40 = 0x40; // flags
+//int const t20 = 0x20;
+int const b10 = 0x10;
+int const d08 = 0x08; // flags
+int const i04 = 0x04; // flags
+int const z02 = 0x02; // nz
+int const c01 = 0x01; // c
+
+#define IS_NEG (nz & 0x8080)
+
+#define GET_FLAGS( out ) \
+{\
+	out = flags & (v40 | d08 | i04);\
+	out += ((nz >> 8) | nz) & n80;\
+	out += c >> 8 & c01;\
+	if ( !BYTE( nz ) )\
+		out += z02;\
+}
+
+#define SET_FLAGS( in ) \
+{\
+	flags = in & (v40 | d08 | i04);\
+	c = nz = in << 8;\
+	nz += ~in & z02;\
+}
+
+bool illegal_encountered = false;
+{
+	Hes_Cpu::cpu_state_t s = CPU.cpu_state_;
+	CPU.cpu_state = &s;
+	// even on x86, using s.time in place of s_time was slower
+	int s_time = s.time;
+	
+	// registers
+	int pc = CPU.r.pc;
+	int a  = CPU.r.a;
+	int x  = CPU.r.x;
+	int y  = CPU.r.y;
+	int sp;
+	SET_SP( CPU.r.sp );
+	
+	// Flags
+	int flags;
+	int c;  // carry set if (c & 0x100) != 0
+	int nz; // Z set if (nz & 0xFF) == 0, N set if (nz & 0x8080) != 0
+	{
+		int temp = CPU.r.flags;
+		SET_FLAGS( temp );
+	}
+	
+loop:
+	
+	#ifndef NDEBUG
+	{
+		time_t correct = CPU.end_time_;
+		if ( !(flags & i04) && correct > CPU.irq_time_ )
+			correct = CPU.irq_time_;
+		check( s.base == correct );
+		/*
+		static int count;
+		if ( count == 1844 ) Debugger();
+		if ( s.base != correct ) dprintf( "%ld\n", count );
+		count++;
+		*/
+	}
+	#endif
+
+	// Check all values
+	check( (unsigned) sp - 0x100 < 0x100 );
+	check( (unsigned) pc < 0x10000 + 0x100 ); // +0x100 so emulator can catch wrap-around
+	check( (unsigned) a < 0x100 );
+	check( (unsigned) x < 0x100 );
+	check( (unsigned) y < 0x100 );
+	
+	// Read instruction
+	byte const* instr = CODE_PAGE( pc );
+	int opcode;
+	
+	if ( CODE_OFFSET(~0) == ~0 )
+	{
+		opcode = instr [pc];
+		pc++;
+		instr += pc;
+	}
+	else
+	{
+		instr += CODE_OFFSET( pc );
+		opcode = *instr++;
+		pc++;
+	}
+	
+	// TODO: each reference lists slightly different timing values, ugh
+	static byte const clock_table [256] =
+	{// 0 1 2  3 4 5 6 7 8 9 A B C D E F
+		1,7,3, 4,6,4,6,7,3,2,2,2,7,5,7,4,// 0
+		2,7,7, 4,6,4,6,7,2,5,2,2,7,5,7,4,// 1
+		7,7,3, 4,4,4,6,7,4,2,2,2,5,5,7,4,// 2
+		2,7,7, 2,4,4,6,7,2,5,2,2,5,5,7,4,// 3
+		7,7,3, 4,8,4,6,7,3,2,2,2,4,5,7,4,// 4
+		2,7,7, 5,2,4,6,7,2,5,3,2,2,5,7,4,// 5
+		7,7,2, 2,4,4,6,7,4,2,2,2,7,5,7,4,// 6
+		2,7,7,17,4,4,6,7,2,5,4,2,7,5,7,4,// 7
+		4,7,2, 7,4,4,4,7,2,2,2,2,5,5,5,4,// 8
+		2,7,7, 8,4,4,4,7,2,5,2,2,5,5,5,4,// 9
+		2,7,2, 7,4,4,4,7,2,2,2,2,5,5,5,4,// A
+		2,7,7, 8,4,4,4,7,2,5,2,2,5,5,5,4,// B
+		2,7,2,17,4,4,6,7,2,2,2,2,5,5,7,4,// C
+		2,7,7,17,2,4,6,7,2,5,3,2,2,5,7,4,// D
+		2,7,2,17,4,4,6,7,2,2,2,2,5,5,7,4,// E
+		2,7,7,17,2,4,6,7,2,5,4,2,2,5,7,4 // F
+	}; // 0x00 was 8
+	
+	// Update time
+	if ( s_time >= 0 )
+		goto out_of_time;
+	
+	#ifdef HES_CPU_LOG_H
+		log_cpu( "new", pc - 1, opcode, instr [0], instr [1], instr [2],
+				instr [3], instr [4], instr [5], a, x, y );
+		//log_opcode( opcode );
+	#endif
+
+	s_time += clock_table [opcode];
+	
+	int data;
+	data = *instr;
+	
+	switch ( opcode )
+	{
+// Macros
+
+#define GET_MSB()       (instr [1])
+#define ADD_PAGE( out ) (pc++, out = data + 0x100 * GET_MSB());
+#define GET_ADDR()      GET_LE16( instr )
+
+// TODO: is the penalty really always added? the original 6502 was much better
+//#define PAGE_PENALTY( lsb )   (void) (s_time += (lsb) >> 8)
+#define PAGE_PENALTY( lsb )
+
+// Branch
+
+// TODO: more efficient way to handle negative branch that wraps PC around
+#define BRANCH_( cond, adj )\
+{\
+	pc++;\
+	if ( !(cond) ) goto loop;\
+	pc = (BOOST::uint16_t) (pc + SBYTE( data ));\
+	s_time += adj;\
+	goto loop;\
+}
+
+#define BRANCH( cond ) BRANCH_( cond, 2 )
+
+	case 0xF0: // BEQ
+		BRANCH( !BYTE( nz ) );
+	
+	case 0xD0: // BNE
+		BRANCH( BYTE( nz ) );
+	
+	case 0x10: // BPL
+		BRANCH( !IS_NEG );
+	
+	case 0x90: // BCC
+		BRANCH( !(c & 0x100) )
+	
+	case 0x30: // BMI
+		BRANCH( IS_NEG )
+	
+	case 0x50: // BVC
+		BRANCH( !(flags & v40) )
+	
+	case 0x70: // BVS
+		BRANCH( flags & v40 )
+	
+	case 0xB0: // BCS
+		BRANCH( c & 0x100 )
+	
+	case 0x80: // BRA
+	branch_taken:
+		BRANCH_( true, 0 );
+	
+	case 0xFF:
+		#ifdef IDLE_ADDR
+			if ( pc == IDLE_ADDR + 1 )
+				goto idle_done;
+		#endif
+
+		pc = (BOOST::uint16_t) pc;
+
+	case 0x0F: // BBRn
+	case 0x1F:
+	case 0x2F:
+	case 0x3F:
+	case 0x4F:
+	case 0x5F:
+	case 0x6F:
+	case 0x7F:
+	case 0x8F: // BBSn
+	case 0x9F:
+	case 0xAF:
+	case 0xBF:
+	case 0xCF:
+	case 0xDF:
+	case 0xEF: {
+		// Make two copies of bits, one negated
+		int t = 0x101 * READ_LOW( data );
+		t ^= 0xFF;
+		pc++;
+		data = GET_MSB();
+		BRANCH( t & (1 << (opcode >> 4)) )
+	}
+	
+	case 0x4C: // JMP abs
+		pc = GET_ADDR();
+		goto loop;
+	
+	case 0x7C: // JMP (ind+X)
+		data += x;
+	case 0x6C:{// JMP (ind)
+		data += 0x100 * GET_MSB();
+		pc = GET_LE16( &READ_CODE( data ) );
+		goto loop;
+	}
+	
+// Subroutine
+
+	case 0x44: // BSR
+		WRITE_STACK( SP( -1 ), pc >> 8 );
+		sp = SP( -2 );
+		WRITE_STACK( sp, pc );
+		goto branch_taken;
+	
+	case 0x20: { // JSR
+		int temp = pc + 1;
+		pc = GET_ADDR();
+		WRITE_STACK( SP( -1 ), temp >> 8 );
+		sp = SP( -2 );
+		WRITE_STACK( sp, temp );
+		goto loop;
+	}
+	
+	case 0x60: // RTS
+		pc = 1 + READ_STACK( sp );
+		pc += 0x100 * READ_STACK( SP( 1 ) );
+		sp = SP( 2 );
+		goto loop;
+	
+	case 0x00: // BRK
+		goto handle_brk;
+	
+// Common
+
+	case 0xBD:{// LDA abs,X
+		PAGE_PENALTY( data + x );
+		int addr = GET_ADDR() + x;
+		pc += 2;
+		READ_FAST( addr, nz );
+		a = nz;
+		goto loop;
+	}
+	
+	case 0x9D:{// STA abs,X
+		int addr = GET_ADDR() + x;
+		pc += 2;
+		WRITE_FAST( addr, a );
+		goto loop;
+	}
+	
+	case 0x95: // STA zp,x
+		data = BYTE( data + x );
+	case 0x85: // STA zp
+		pc++;
+		WRITE_LOW( data, a );
+		goto loop;
+	
+	case 0xAE:{// LDX abs
+		int addr = GET_ADDR();
+		pc += 2;
+		READ_FAST( addr, nz );
+		x = nz;
+		goto loop;
+	}
+	
+	case 0xA5: // LDA zp
+		a = nz = READ_LOW( data );
+		pc++;
+		goto loop;
+	
+// Load/store
+	
+	{
+		int addr;
+	case 0x91: // STA (ind),Y
+		addr = 0x100 * READ_LOW( BYTE( data + 1 ) );
+		addr += READ_LOW( data ) + y;
+		pc++;
+		goto sta_ptr;
+	
+	case 0x81: // STA (ind,X)
+		data = BYTE( data + x );
+	case 0x92: // STA (ind)
+		addr = 0x100 * READ_LOW( BYTE( data + 1 ) );
+		addr += READ_LOW( data );
+		pc++;
+		goto sta_ptr;
+	
+	case 0x99: // STA abs,Y
+		data += y;
+	case 0x8D: // STA abs
+		addr = data + 0x100 * GET_MSB();
+		pc += 2;
+	sta_ptr:
+		WRITE_FAST( addr, a );
+		goto loop;
+	}
+	
+	{
+		int addr;
+	case 0xA1: // LDA (ind,X)
+		data = BYTE( data + x );
+	case 0xB2: // LDA (ind)
+		addr = 0x100 * READ_LOW( BYTE( data + 1 ) );
+		addr += READ_LOW( data );
+		pc++;
+		goto a_nz_read_addr;
+	
+	case 0xB1:// LDA (ind),Y
+		addr = READ_LOW( data ) + y;
+		PAGE_PENALTY( addr );
+		addr += 0x100 * READ_LOW( BYTE( data + 1 ) );
+		pc++;
+		goto a_nz_read_addr;
+	
+	case 0xB9: // LDA abs,Y
+		data += y;
+		PAGE_PENALTY( data );
+	case 0xAD: // LDA abs
+		addr = data + 0x100 * GET_MSB();
+		pc += 2;
+	a_nz_read_addr:
+		READ_FAST( addr, nz );
+		a = nz;
+		goto loop;
+	}
+
+	case 0xBE:{// LDX abs,y
+		PAGE_PENALTY( data + y );
+		int addr = GET_ADDR() + y;
+		pc += 2;
+		FLUSH_TIME();
+		x = nz = READ_MEM( addr );
+		CACHE_TIME();
+		goto loop;
+	}
+	
+	case 0xB5: // LDA zp,x
+		a = nz = READ_LOW( BYTE( data + x ) );
+		pc++;
+		goto loop;
+	
+	case 0xA9: // LDA #imm
+		pc++;
+		a  = data;
+		nz = data;
+		goto loop;
+
+// Bit operations
+
+	case 0x3C: // BIT abs,x
+		data += x;
+	case 0x2C:{// BIT abs
+		int addr;
+		ADD_PAGE( addr );
+		FLUSH_TIME();
+		nz = READ_MEM( addr );
+		CACHE_TIME();
+		goto bit_common;
+	}
+	case 0x34: // BIT zp,x
+		data = BYTE( data + x );
+	case 0x24: // BIT zp
+		data = READ_LOW( data );
+	case 0x89: // BIT imm
+		nz = data;
+	bit_common:
+		pc++;
+		flags = (flags & ~v40) + (nz & v40);
+		if ( nz & a )
+			goto loop; // Z should be clear, and nz must be non-zero if nz & a is
+		nz <<= 8; // set Z flag without affecting N flag
+		goto loop;
+		
+	{
+		int addr;
+		
+	case 0xB3: // TST abs,x
+		addr = GET_MSB() + x;
+		goto tst_abs;
+	
+	case 0x93: // TST abs
+		addr = GET_MSB();
+	tst_abs:
+		addr += 0x100 * instr [2];
+		pc++;
+		FLUSH_TIME();
+		nz = READ_MEM( addr );
+		CACHE_TIME();
+		goto tst_common;
+	}
+	
+	case 0xA3: // TST zp,x
+		nz = READ_LOW( BYTE( GET_MSB() + x ) );
+		goto tst_common;
+	
+	case 0x83: // TST zp
+		nz = READ_LOW( GET_MSB() );
+	tst_common:
+		pc += 2;
+		flags = (flags & ~v40) + (nz & v40);
+		if ( nz & data )
+			goto loop; // Z should be clear, and nz must be non-zero if nz & data is
+		nz <<= 8; // set Z flag without affecting N flag
+		goto loop;
+	
+	{
+		int addr;
+	case 0x0C: // TSB abs
+	case 0x1C: // TRB abs
+		addr = GET_ADDR();
+		pc++;
+		goto txb_addr;
+	
+	// TODO: everyone lists different behaviors for the flags flags, ugh
+	case 0x04: // TSB zp
+	case 0x14: // TRB zp
+		addr = data + ram_addr;
+	txb_addr:
+		FLUSH_TIME();
+		nz = a | READ_MEM( addr );
+		if ( opcode & 0x10 )
+			nz ^= a; // bits from a will already be set, so this clears them
+		flags = (flags & ~v40) + (nz & v40);
+		pc++;
+		WRITE_MEM( addr, nz );
+		CACHE_TIME();
+		goto loop;
+	}
+	
+	case 0x07: // RMBn
+	case 0x17:
+	case 0x27:
+	case 0x37:
+	case 0x47:
+	case 0x57:
+	case 0x67:
+	case 0x77:
+		pc++;
+		READ_LOW( data ) &= ~(1 << (opcode >> 4));
+		goto loop;
+	
+	case 0x87: // SMBn
+	case 0x97:
+	case 0xA7:
+	case 0xB7:
+	case 0xC7:
+	case 0xD7:
+	case 0xE7:
+	case 0xF7:
+		pc++;
+		READ_LOW( data ) |= 1 << ((opcode >> 4) - 8);
+		goto loop;
+	
+// Load/store
+	
+	case 0x9E: // STZ abs,x
+		data += x;
+	case 0x9C: // STZ abs
+		ADD_PAGE( data );
+		pc++;
+		FLUSH_TIME();
+		WRITE_MEM( data, 0 );
+		CACHE_TIME();
+		goto loop;
+	
+	case 0x74: // STZ zp,x
+		data = BYTE( data + x );
+	case 0x64: // STZ zp
+		pc++;
+		WRITE_LOW( data, 0 );
+		goto loop;
+	
+	case 0x94: // STY zp,x
+		data = BYTE( data + x );
+	case 0x84: // STY zp
+		pc++;
+		WRITE_LOW( data, y );
+		goto loop;
+	
+	case 0x96: // STX zp,y
+		data = BYTE( data + y );
+	case 0x86: // STX zp
+		pc++;
+		WRITE_LOW( data, x );
+		goto loop;
+	
+	case 0xB6: // LDX zp,y
+		data = BYTE( data + y );
+	case 0xA6: // LDX zp
+		data = READ_LOW( data );
+	case 0xA2: // LDX #imm
+		pc++;
+		x = data;
+		nz = data;
+		goto loop;
+	
+	case 0xB4: // LDY zp,x
+		data = BYTE( data + x );
+	case 0xA4: // LDY zp
+		data = READ_LOW( data );
+	case 0xA0: // LDY #imm
+		pc++;
+		y = data;
+		nz = data;
+		goto loop;
+	
+	case 0xBC: // LDY abs,X
+		data += x;
+		PAGE_PENALTY( data );
+	case 0xAC:{// LDY abs
+		int addr = data + 0x100 * GET_MSB();
+		pc += 2;
+		FLUSH_TIME();
+		y = nz = READ_MEM( addr );
+		CACHE_TIME();
+		goto loop;
+	}
+	
+	{
+		int temp;
+	case 0x8C: // STY abs
+		temp = y;
+		if ( 0 )
+	case 0x8E: // STX abs
+			temp = x;
+		int addr = GET_ADDR();
+		pc += 2;
+		FLUSH_TIME();
+		WRITE_MEM( addr, temp );
+		CACHE_TIME();
+		goto loop;
+	}
+
+// Compare
+
+	case 0xEC:{// CPX abs
+		int addr = GET_ADDR();
+		pc++;
+		FLUSH_TIME();
+		data = READ_MEM( addr );
+		CACHE_TIME();
+		goto cpx_data;
+	}
+	
+	case 0xE4: // CPX zp
+		data = READ_LOW( data );
+	case 0xE0: // CPX #imm
+	cpx_data:
+		nz = x - data;
+		pc++;
+		c = ~nz;
+		nz = BYTE( nz );
+		goto loop;
+	
+	case 0xCC:{// CPY abs
+		int addr = GET_ADDR();
+		pc++;
+		FLUSH_TIME();
+		data = READ_MEM( addr );
+		CACHE_TIME();
+		goto cpy_data;
+	}
+	
+	case 0xC4: // CPY zp
+		data = READ_LOW( data );
+	case 0xC0: // CPY #imm
+	cpy_data:
+		nz = y - data;
+		pc++;
+		c = ~nz;
+		nz = BYTE( nz );
+		goto loop;
+	
+// Logical
+
+#define ARITH_ADDR_MODES( op )\
+	case op - 0x04: /* (ind,x) */\
+		data = BYTE( data + x );\
+	case op + 0x0D: /* (ind) */\
+		data = 0x100 * READ_LOW( BYTE( data + 1 ) ) + READ_LOW( data );\
+		goto ptr##op;\
+	case op + 0x0C:{/* (ind),y */\
+		int temp = READ_LOW( data ) + y;\
+		PAGE_PENALTY( temp );\
+		data = temp + 0x100 * READ_LOW( BYTE( data + 1 ) );\
+		goto ptr##op;\
+	}\
+	case op + 0x10: /* zp,X */\
+		data = BYTE( data + x );\
+	case op + 0x00: /* zp */\
+		data = READ_LOW( data );\
+		goto imm##op;\
+	case op + 0x14: /* abs,Y */\
+		data += y;\
+		goto ind##op;\
+	case op + 0x18: /* abs,X */\
+		data += x;\
+	ind##op:\
+		PAGE_PENALTY( data );\
+	case op + 0x08: /* abs */\
+		ADD_PAGE( data );\
+	ptr##op:\
+		FLUSH_TIME();\
+		data = READ_MEM( data );\
+		CACHE_TIME();\
+	case op + 0x04: /* imm */\
+	imm##op:
+
+	ARITH_ADDR_MODES( 0xC5 ) // CMP
+		nz = a - data;
+		pc++;
+		c = ~nz;
+		nz = BYTE( nz );
+		goto loop;
+	
+	ARITH_ADDR_MODES( 0x25 ) // AND
+		nz = (a &= data);
+		pc++;
+		goto loop;
+	
+	ARITH_ADDR_MODES( 0x45 ) // EOR
+		nz = (a ^= data);
+		pc++;
+		goto loop;
+	
+	ARITH_ADDR_MODES( 0x05 ) // ORA
+		nz = (a |= data);
+		pc++;
+		goto loop;
+	
+// Add/subtract
+
+	ARITH_ADDR_MODES( 0xE5 ) // SBC
+		data ^= 0xFF;
+		goto adc_imm;
+	
+	ARITH_ADDR_MODES( 0x65 ) // ADC
+	adc_imm: {
+		if ( flags & d08 )
+			dprintf( "Decimal mode not supported\n" );
+		int carry = c >> 8 & 1;
+		int ov = (a ^ 0x80) + carry + SBYTE( data );
+		flags = (flags & ~v40) + (ov >> 2 & v40);
+		c = nz = a + data + carry;
+		pc++;
+		a = BYTE( nz );
+		goto loop;
+	}
+	
+// Shift/rotate
+
+	case 0x4A: // LSR A
+		c = 0;
+	case 0x6A: // ROR A
+		nz = c >> 1 & 0x80;
+		c = a << 8;
+		nz += a >> 1;
+		a = nz;
+		goto loop;
+
+	case 0x0A: // ASL A
+		nz = a << 1;
+		c = nz;
+		a = BYTE( nz );
+		goto loop;
+
+	case 0x2A: { // ROL A
+		nz = a << 1;
+		int temp = c >> 8 & 1;
+		c = nz;
+		nz += temp;
+		a = BYTE( nz );
+		goto loop;
+	}
+	
+	case 0x5E: // LSR abs,X
+		data += x;
+	case 0x4E: // LSR abs
+		c = 0;
+	case 0x6E: // ROR abs
+	ror_abs: {
+		ADD_PAGE( data );
+		FLUSH_TIME();
+		int temp = READ_MEM( data );
+		nz = (c >> 1 & 0x80) + (temp >> 1);
+		c = temp << 8;
+		goto rotate_common;
+	}
+	
+	case 0x3E: // ROL abs,X
+		data += x;
+		goto rol_abs;
+	
+	case 0x1E: // ASL abs,X
+		data += x;
+	case 0x0E: // ASL abs
+		c = 0;
+	case 0x2E: // ROL abs
+	rol_abs:
+		ADD_PAGE( data );
+		nz = c >> 8 & 1;
+		FLUSH_TIME();
+		nz += (c = READ_MEM( data ) << 1);
+	rotate_common:
+		pc++;
+		WRITE_MEM( data, BYTE( nz ) );
+		CACHE_TIME();
+		goto loop;
+	
+	case 0x7E: // ROR abs,X
+		data += x;
+		goto ror_abs;
+	
+	case 0x76: // ROR zp,x
+		data = BYTE( data + x );
+		goto ror_zp;
+	
+	case 0x56: // LSR zp,x
+		data = BYTE( data + x );
+	case 0x46: // LSR zp
+		c = 0;
+	case 0x66: // ROR zp
+	ror_zp: {
+		int temp = READ_LOW( data );
+		nz = (c >> 1 & 0x80) + (temp >> 1);
+		c = temp << 8;
+		goto write_nz_zp;
+	}
+	
+	case 0x36: // ROL zp,x
+		data = BYTE( data + x );
+		goto rol_zp;
+	
+	case 0x16: // ASL zp,x
+		data = BYTE( data + x );
+	case 0x06: // ASL zp
+		c = 0;
+	case 0x26: // ROL zp
+	rol_zp:
+		nz = c >> 8 & 1;
+		nz += (c = READ_LOW( data ) << 1);
+		goto write_nz_zp;
+	
+// Increment/decrement
+
+#define INC_DEC( reg, n ) reg = BYTE( nz = reg + n ); goto loop;
+
+	case 0x1A: // INA
+		INC_DEC( a, +1 )
+	
+	case 0xE8: // INX
+		INC_DEC( x, +1 )
+	
+	case 0xC8: // INY
+		INC_DEC( y, +1 )
+
+	case 0x3A: // DEA
+		INC_DEC( a, -1 )
+	
+	case 0xCA: // DEX
+		INC_DEC( x, -1 )
+	
+	case 0x88: // DEY
+		INC_DEC( y, -1 )
+	
+	case 0xF6: // INC zp,x
+		data = BYTE( data + x );
+	case 0xE6: // INC zp
+		nz = 1;
+		goto add_nz_zp;
+	
+	case 0xD6: // DEC zp,x
+		data = BYTE( data + x );
+	case 0xC6: // DEC zp
+		nz = -1;
+	add_nz_zp:
+		nz += READ_LOW( data );
+	write_nz_zp:
+		pc++;
+		WRITE_LOW( data, nz );
+		goto loop;
+	
+	case 0xFE: // INC abs,x
+		data = x + GET_ADDR();
+		goto inc_ptr;
+	
+	case 0xEE: // INC abs
+		data = GET_ADDR();
+	inc_ptr:
+		nz = 1;
+		goto inc_common;
+	
+	case 0xDE: // DEC abs,x
+		data = x + GET_ADDR();
+		goto dec_ptr;
+	
+	case 0xCE: // DEC abs
+		data = GET_ADDR();
+	dec_ptr:
+		nz = -1;
+	inc_common:
+		FLUSH_TIME();
+		pc += 2;
+		nz += READ_MEM( data );
+		WRITE_MEM( data, BYTE( nz ) );
+		CACHE_TIME();
+		goto loop;
+		
+// Transfer
+
+	case 0xA8: // TAY
+		y = nz = a;
+		goto loop;
+	
+	case 0x98: // TYA
+		a = nz = y;
+		goto loop;
+	
+	case 0xAA: // TAX
+		x = nz = a;
+		goto loop;
+		
+	case 0x8A: // TXA
+		a = nz = x;
+		goto loop;
+
+	case 0x9A: // TXS
+		SET_SP( x ); // verified (no flag change)
+		goto loop;
+	
+	case 0xBA: // TSX
+		x = nz = GET_SP();
+		goto loop;
+	
+	#define SWAP_REGS( r1, r2 ) {\
+		int t = r1;\
+		r1 = r2;\
+		r2 = t;\
+		goto loop;\
+	}
+	
+	case 0x02: // SXY
+		SWAP_REGS( x, y );
+	
+	case 0x22: // SAX
+		SWAP_REGS( a, x );
+	
+	case 0x42: // SAY
+		SWAP_REGS( a, y );
+	
+	case 0x62: // CLA
+		a = 0;
+		goto loop;
+	
+	case 0x82: // CLX
+		x = 0;
+		goto loop;
+	
+	case 0xC2: // CLY
+		y = 0;
+		goto loop;
+	
+// Stack
+	
+	case 0x48: // PHA
+		sp = SP( -1 );
+		WRITE_STACK( sp, a );
+		goto loop;
+		
+	case 0x68: // PLA
+		a = nz = READ_STACK( sp );
+		sp = SP( 1 );
+		goto loop;
+	
+	case 0xDA: // PHX
+		sp = SP( -1 );
+		WRITE_STACK( sp, x );
+		goto loop;
+		
+	case 0x5A: // PHY
+		sp = SP( -1 );
+		WRITE_STACK( sp, y );
+		goto loop;
+		
+	case 0x40:{// RTI
+		pc  = READ_STACK( SP( 1 ) );
+		pc += READ_STACK( SP( 2 ) ) * 0x100;
+		int temp = READ_STACK( sp );
+		sp = SP( 3 );
+		data = flags;
+		SET_FLAGS( temp );
+		CPU.r.flags = flags; // update externally-visible I flag
+		if ( (data ^ flags) & i04 )
+		{
+			time_t new_time = CPU.end_time_;
+			if ( !(flags & i04) && new_time > CPU.irq_time_ )
+				new_time = CPU.irq_time_;
+			int delta = s.base - new_time;
+			s.base = new_time;
+			s_time += delta;
+		}
+		goto loop;
+	}
+	
+	case 0xFA: // PLX
+		x = nz = READ_STACK( sp );
+		sp = SP( 1 );
+		goto loop;
+	
+	case 0x7A: // PLY
+		y = nz = READ_STACK( sp );
+		sp = SP( 1 );
+		goto loop;
+	
+	case 0x28:{// PLP
+		int temp = READ_STACK( sp );
+		sp = SP( 1 );
+		int changed = flags ^ temp;
+		SET_FLAGS( temp );
+		if ( !(changed & i04) )
+			goto loop; // I flag didn't change
+		if ( flags & i04 )
+			goto handle_sei;
+		goto handle_cli;
+	}
+	
+	case 0x08:{// PHP
+		int temp;
+		GET_FLAGS( temp );
+		sp = SP( -1 );
+		WRITE_STACK( sp, temp | b10 );
+		goto loop;
+	}
+	
+// Flags
+
+	case 0x38: // SEC
+		c = 0x100;
+		goto loop;
+	
+	case 0x18: // CLC
+		c = 0;
+		goto loop;
+		
+	case 0xB8: // CLV
+		flags &= ~v40;
+		goto loop;
+	
+	case 0xD8: // CLD
+		flags &= ~d08;
+		goto loop;
+	
+	case 0xF8: // SED
+		flags |= d08;
+		goto loop;
+	
+	case 0x58: // CLI
+		if ( !(flags & i04) )
+			goto loop;
+		flags &= ~i04;
+	handle_cli: {
+		//dprintf( "CLI at %d\n", TIME );
+		CPU.r.flags = flags; // update externally-visible I flag
+		int delta = s.base - CPU.irq_time_;
+		if ( delta <= 0 )
+		{
+			if ( TIME() < CPU.irq_time_ )
+				goto loop;
+			goto delayed_cli;
+		}
+		s.base = CPU.irq_time_;
+		s_time += delta;
+		if ( s_time < 0 )
+			goto loop;
+		
+		if ( delta >= s_time + 1 )
+		{
+			// delayed irq until after next instruction
+			s.base += s_time + 1;
+			s_time = -1;
+			CPU.irq_time_ = s.base; // TODO: remove, as only to satisfy debug check in loop
+			goto loop;
+		}
+		
+		// TODO: implement
+	delayed_cli:
+		dprintf( "Delayed CLI not supported\n" );
+		goto loop;
+	}
+	
+	case 0x78: // SEI
+		if ( flags & i04 )
+			goto loop;
+		flags |= i04;
+	handle_sei: {
+		CPU.r.flags = flags; // update externally-visible I flag
+		int delta = s.base - CPU.end_time_;
+		s.base = CPU.end_time_;
+		s_time += delta;
+		if ( s_time < 0 )
+			goto loop;
+		
+		dprintf( "Delayed SEI not supported\n" );
+		goto loop;
+	}
+	
+// Special
+	
+	case 0x53:{// TAM
+		int bits = data; // avoid using data across function call
+		pc++;
+		for ( int i = 0; i < 8; i++ )
+			if ( bits & (1 << i) )
+				SET_MMR( i, a );
+		goto loop;
+	}
+	
+	case 0x43:{// TMA
+		pc++;
+		byte const* in = CPU.mmr;
+		do
+		{
+			if ( data & 1 )
+				a = *in;
+			in++;
+		}
+		while ( (data >>= 1) != 0 );
+		goto loop;
+	}
+	
+	case 0x03: // ST0
+	case 0x13: // ST1
+	case 0x23:{// ST2
+		int addr = opcode >> 4;
+		if ( addr )
+			addr++;
+		pc++;
+		FLUSH_TIME();
+		WRITE_VDP( addr, data );
+		CACHE_TIME();
+		goto loop;
+	}
+	
+	case 0xEA: // NOP
+		goto loop;
+
+	case 0x54: // CSL
+		dprintf( "CSL not supported\n" );
+		illegal_encountered = true;
+		goto loop;
+	
+	case 0xD4: // CSH
+		goto loop;
+	
+	case 0xF4: { // SET
+		//int operand = GET_MSB();
+		dprintf( "SET not handled\n" );
+		//switch ( data )
+		//{
+		//}
+		illegal_encountered = true;
+		goto loop;
+	}
+	
+// Block transfer
+
+	{
+		int in_alt;
+		int in_inc;
+		int out_alt;
+		int out_inc;
+		
+	case 0xE3: // TIA
+		in_alt  = 0;
+		goto bxfer_alt;
+	
+	case 0xF3: // TAI
+		in_alt  = 1;
+	bxfer_alt:
+		in_inc  = in_alt ^ 1;
+		out_alt = in_inc;
+		out_inc = in_alt;
+		goto bxfer;
+	
+	case 0xD3: // TIN
+		in_inc  = 1;
+		out_inc = 0;
+		goto bxfer_no_alt;
+	
+	case 0xC3: // TDD
+		in_inc  = -1;
+		out_inc = -1;
+		goto bxfer_no_alt;
+	
+	case 0x73: // TII
+		in_inc  = 1;
+		out_inc = 1;
+	bxfer_no_alt:
+		in_alt  = 0;
+		out_alt = 0;
+	bxfer:
+		int in    = GET_LE16( instr + 0 );
+		int out   = GET_LE16( instr + 2 );
+		int count = GET_LE16( instr + 4 );
+		if ( !count )
+			count = 0x10000;
+		pc += 6;
+		WRITE_STACK( SP( -1 ), y );
+		WRITE_STACK( SP( -2 ), a );
+		WRITE_STACK( SP( -3 ), x );
+		FLUSH_TIME();
+		do
+		{
+			// TODO: reads from $0800-$1400 in I/O page should do I/O
+			int t = READ_MEM( in );
+			in = WORD( in + in_inc );
+			s.time += 6;
+			if ( in_alt )
+				in_inc = -in_inc;
+			WRITE_MEM( out, t );
+			out = WORD( out + out_inc );
+			if ( out_alt )
+				out_inc = -out_inc;
+		}
+		while ( --count );
+		CACHE_TIME();
+		goto loop;
+	}
+
+// Illegal
+
+	default:
+		check( (unsigned) opcode <= 0xFF );
+		dprintf( "Illegal opcode $%02X at $%04X\n", (int) opcode, (int) pc - 1 );
+		illegal_encountered = true;
+		goto loop;
+	}
+	assert( false ); // catch missing 'goto loop' or accidental 'break'
+	
+	int result_;
+handle_brk:
+	pc++;
+	result_ = 6;
+	
+interrupt:
+	{
+		s_time += 7;
+		
+		// Save PC and read vector
+		WRITE_STACK( SP( -1 ), pc >> 8 );
+		WRITE_STACK( SP( -2 ), pc );
+		pc = GET_LE16( &READ_CODE( 0xFFF0 ) + result_ );
+		
+		// Save flags
+		int temp;
+		GET_FLAGS( temp );
+		if ( result_ == 6 )
+			temp |= b10; // BRK sets B bit
+		sp = SP( -3 );
+		WRITE_STACK( sp, temp );
+		
+		// Update I flag in externally-visible flags
+		flags &= ~d08;
+		CPU.r.flags = (flags |= i04);
+		
+		// Update time
+		int delta = s.base - CPU.end_time_;
+		if ( delta >= 0 )
+			goto loop;
+		s_time += delta;
+		s.base = CPU.end_time_;
+		goto loop;
+	}
+	
+idle_done:
+	s_time = 0;
+	
+out_of_time:
+	pc--;
+	
+	// Optional action that triggers interrupt or changes irq/end time
+	#ifdef CPU_DONE
+	{
+		CPU_DONE( result_ );
+		if ( result_ >= 0 )
+			goto interrupt;
+		if ( s_time < 0 )
+			goto loop;
+	}
+	#endif
+	
+	// Flush cached state
+	CPU.r.pc = pc;
+	CPU.r.sp = GET_SP();
+	CPU.r.a  = a;
+	CPU.r.x  = x;
+	CPU.r.y  = y;
+	
+	int temp;
+	GET_FLAGS( temp );
+	CPU.r.flags = temp;
+	
+	CPU.cpu_state_.base = s.base;
+	CPU.cpu_state_.time = s_time;
+	CPU.cpu_state = &CPU.cpu_state_;
+}
diff -Nur orig/source/gme/src/Hes_Emu.cpp mod/source/gme/src/Hes_Emu.cpp
--- orig/source/gme/src/Hes_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,163 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Hes_Emu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Hes_Emu::Hes_Emu()
+{
+	set_type( gme_hes_type );
+	set_silence_lookahead( 6 );
+	set_gain( 1.11 );
+}
+
+Hes_Emu::~Hes_Emu() { }
+
+void Hes_Emu::unload()
+{
+	core.unload();
+	Music_Emu::unload();
+}
+
+static byte const* copy_field( byte const in [], char* out )
+{
+	if ( in )
+	{
+		int len = 0x20;
+		if ( in [0x1F] && !in [0x2F] )
+			len = 0x30; // fields are sometimes 16 bytes longer (ugh)
+		
+		// since text fields are where any data could be, detect non-text
+		// and fields with data after zero byte terminator
+		
+		int i = 0;
+		for ( ; i < len && in [i]; i++ )
+			if ( (unsigned) (in [i] - ' ') >= 0xFF - ' ' ) // also treat 0xFF as non-text
+				return 0; // non-ASCII found
+		
+		for ( ; i < len; i++ )
+			if ( in [i] )
+				return 0; // data after terminator
+		
+		Gme_File::copy_field_( out, (char const*) in, len );
+		in += len;
+	}
+	return in;
+}
+
+static void copy_hes_fields( byte const in [], track_info_t* out )
+{
+	if ( *in >= ' ' )
+	{
+		in = copy_field( in, out->game      );
+		in = copy_field( in, out->author    );
+		in = copy_field( in, out->copyright );
+	}
+}
+
+blargg_err_t Hes_Emu::track_info_( track_info_t* out, int ) const
+{
+	copy_hes_fields( core.data() + core.info_offset, out );
+	return blargg_ok;
+}
+
+struct Hes_File : Gme_Info_
+{
+	enum { fields_offset = Hes_Core::header_t::size + Hes_Core::info_offset };
+	
+	union header_t {
+		Hes_Core::header_t header;
+		byte data [fields_offset + 0x30 * 3];
+	} h;
+	
+	Hes_File()
+	{
+		set_type( gme_hes_type );
+	}
+	
+	blargg_err_t load_( Data_Reader& in )
+	{
+		blargg_err_t err = in.read( &h, sizeof h );
+		if ( err )
+			return (blargg_is_err_type( err, blargg_err_file_eof ) ? blargg_err_file_type : err);
+		
+		if ( !h.header.valid_tag() )
+			return blargg_err_file_type;
+		
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		copy_hes_fields( h.data + fields_offset, out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_hes_emu () { return BLARGG_NEW Hes_Emu ; }
+static Music_Emu* new_hes_file() { return BLARGG_NEW Hes_File; }
+
+gme_type_t_ const gme_hes_type [1] = {{ "PC Engine", 256, &new_hes_emu, &new_hes_file, "HES", 1 }};
+
+blargg_err_t Hes_Emu::load_( Data_Reader& in )
+{
+	RETURN_ERR( core.load( in ) );
+	
+	static const char* const names [Hes_Apu::osc_count + Hes_Apu_Adpcm::osc_count] = {
+		"Wave 1", "Wave 2", "Wave 3", "Wave 4", "Multi 1", "Multi 2", "ADPCM"
+	};
+	set_voice_names( names );
+	
+	static int const types [Hes_Apu::osc_count + Hes_Apu_Adpcm::osc_count] = {
+		wave_type+0, wave_type+1, wave_type+2, wave_type+3, mixed_type+0, mixed_type+1, mixed_type+2
+	};
+	set_voice_types( types );
+	
+	set_voice_count( core.apu().osc_count + core.adpcm().osc_count );
+	core.apu().volume( gain() );
+	core.adpcm().volume( gain() );
+	
+	return setup_buffer( 7159091 );
+}
+
+void Hes_Emu::update_eq( blip_eq_t const& eq )
+{
+	core.apu().treble_eq( eq );
+}
+
+void Hes_Emu::set_voice( int i, Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	if ( i < core.apu().osc_count )
+		core.apu().set_output( i, c, l, r );
+	else if ( i == core.apu().osc_count )
+		core.adpcm().set_output( 0, c, l, r );
+}
+
+void Hes_Emu::set_tempo_( double t )
+{
+	core.set_tempo( t );
+}
+
+blargg_err_t Hes_Emu::start_track_( int track )
+{
+	RETURN_ERR( Classic_Emu::start_track_( track ) );
+	return core.start_track( track );
+}
+
+blargg_err_t Hes_Emu::run_clocks( blip_time_t& duration_, int )
+{
+	return core.end_frame( duration_ );
+}
diff -Nur orig/source/gme/src/Hes_Emu.h mod/source/gme/src/Hes_Emu.h
--- orig/source/gme/src/Hes_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Hes_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,40 @@
+// TurboGrafx-16/PC Engine HES music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef HES_EMU_H
+#define HES_EMU_H
+
+#include "Classic_Emu.h"
+#include "Hes_Core.h"
+
+class Hes_Emu : public Classic_Emu {
+public:
+
+	static gme_type_t static_type() { return gme_hes_type; }
+	
+	// HES file header (see Hes_Core.h)
+	typedef Hes_Core::header_t header_t;
+	
+	// Header for currently loaded file
+	header_t const& header() const { return core.header(); }
+
+// Implementation
+public:
+	Hes_Emu();
+	~Hes_Emu();
+	virtual void unload();
+
+protected:
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+
+private:
+	Hes_Core core;
+};
+
+#endif
diff -Nur orig/source/gme/src/i_fmpac.h mod/source/gme/src/i_fmpac.h
--- orig/source/gme/src/i_fmpac.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/i_fmpac.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,38 @@
+	0x49, 0x4C, 0x4C, 0x32, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x33, 0x21, 0x09, 0x0E, 0x94, 0x90, 0x48, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x13, 0x41, 0x0F, 0x0D, 0xCE, 0xD3, 0x43, 0x13, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x01, 0x12, 0x1B, 0x06, 0xFF, 0xD2, 0x00, 0x32, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x61, 0x1B, 0x07, 0xAF, 0x63, 0x20, 0x28, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x22, 0x21, 0x1E, 0x06, 0xF0, 0x76, 0x08, 0x28, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x66, 0x21, 0x15, 0x00, 0x93, 0x94, 0x20, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x21, 0x61, 0x1C, 0x07, 0x82, 0x81, 0x10, 0x17, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x23, 0x21, 0x20, 0x1F, 0xC0, 0x71, 0x07, 0x47, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x25, 0x31, 0x26, 0x05, 0x64, 0x41, 0x18, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x17, 0x21, 0x28, 0x07, 0xFF, 0x83, 0x02, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x97, 0x81, 0x25, 0x07, 0xCF, 0xC8, 0x02, 0x14, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x21, 0x21, 0x54, 0x0F, 0x80, 0x7F, 0x07, 0x07, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x01, 0x01, 0x56, 0x03, 0xD3, 0xB2, 0x43, 0x58, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x31, 0x21, 0x0C, 0x03, 0x82, 0xC0, 0x40, 0x07, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x21, 0x01, 0x0C, 0x03, 0xD4, 0xD3, 0x40, 0x84, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x04, 0x21, 0x28, 0x00, 0xDF, 0xF8, 0xFF, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x23, 0x22, 0x00, 0x00, 0xA8, 0xF8, 0xF8, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x25, 0x18, 0x00, 0x00, 0xF8, 0xA9, 0xF8, 0x55, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
diff -Nur orig/source/gme/src/i_fmunit.h mod/source/gme/src/i_fmunit.h
--- orig/source/gme/src/i_fmunit.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/i_fmunit.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,38 @@
+	0x49, 0x4C, 0x4C, 0x32, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x61, 0x1E, 0x07, 0xF0, 0x7E, 0x07, 0x17, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x13, 0x41, 0x0F, 0x1D, 0xCE, 0xD2, 0x43, 0x13, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x03, 0x01, 0x99, 0x04, 0xFF, 0xC3, 0x03, 0x73, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x21, 0x61, 0x1B, 0x07, 0xAF, 0x63, 0x40, 0x28, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x22, 0x21, 0x1E, 0x06, 0xF0, 0x76, 0x08, 0x28, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x31, 0x22, 0x16, 0x05, 0x90, 0x71, 0x00, 0x18, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x31, 0x61, 0x1D, 0x07, 0x32, 0x81, 0x10, 0x17, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x23, 0x21, 0x2D, 0x16, 0xC0, 0x70, 0x07, 0x07, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x21, 0x1B, 0x06, 0x64, 0x65, 0x18, 0x18, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x61, 0x0C, 0x18, 0x85, 0xA0, 0x79, 0x07, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x23, 0x21, 0x87, 0x11, 0xF0, 0xA4, 0x00, 0xF7, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x97, 0xE1, 0x28, 0x07, 0xFF, 0xF3, 0x02, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x10, 0x0C, 0x05, 0xF2, 0xC4, 0x40, 0xC8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x01, 0x01, 0x56, 0x03, 0xB4, 0xB2, 0x23, 0x58, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x41, 0x89, 0x03, 0xF1, 0xF4, 0xF0, 0x13, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x04, 0x21, 0x28, 0x00, 0xDF, 0xF8, 0xFF, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x0F, 0x02, 0x00, 0x00, 0xA7, 0xF7, 0x07, 0x07, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x04, 0x1F, 0x00, 0x00, 0xF8, 0xA9, 0x08, 0x05, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
diff -Nur orig/source/gme/src/i_vrc7.h mod/source/gme/src/i_vrc7.h
--- orig/source/gme/src/i_vrc7.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/i_vrc7.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,38 @@
+	0x49, 0x4C, 0x4C, 0x32, 0x00, 0x00, 0x00, 0x00, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x61, 0x1E, 0x07, 0xF0, 0x7E, 0x07, 0x17, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x13, 0x41, 0x0F, 0x1D, 0xCE, 0xD2, 0x43, 0x13, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x03, 0x01, 0x99, 0x04, 0xFF, 0xC3, 0x03, 0x73, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x21, 0x61, 0x1B, 0x07, 0xAF, 0x63, 0x40, 0x28, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x22, 0x21, 0x1E, 0x06, 0xF0, 0x76, 0x08, 0x28, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x31, 0x22, 0x16, 0x05, 0x90, 0x71, 0x00, 0x18, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x31, 0x61, 0x1D, 0x07, 0x32, 0x81, 0x10, 0x17, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x23, 0x21, 0x2D, 0x16, 0xC0, 0x70, 0x07, 0x07, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x21, 0x1B, 0x06, 0x64, 0x65, 0x18, 0x18, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x61, 0x0C, 0x18, 0x85, 0xA0, 0x79, 0x07, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x23, 0x21, 0x87, 0x11, 0xF0, 0xA4, 0x00, 0xF7, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x97, 0xE1, 0x28, 0x07, 0xFF, 0xF3, 0x02, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x10, 0x0C, 0x05, 0xF2, 0xC4, 0x40, 0xC8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x01, 0x01, 0x56, 0x03, 0xB4, 0xB2, 0x23, 0x58, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x61, 0x41, 0x89, 0x03, 0xF1, 0xF4, 0xF0, 0x13, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x04, 0x21, 0x28, 0x00, 0xDF, 0xF8, 0xFF, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x28, 0x21, 0x00, 0x00, 0xA8, 0xF8, 0xF8, 0xF8, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+	0x25, 0x18, 0x00, 0x00, 0xF8, 0xA9, 0xF8, 0x55, 
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
diff -Nur orig/source/gme/src/kmsnddev.h mod/source/gme/src/kmsnddev.h
--- orig/source/gme/src/kmsnddev.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/kmsnddev.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,31 @@
+/* libnezp by Mamiya */
+
+#ifndef KMSNDDEV_H__
+#define KMSNDDEV_H__
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "nestypes.h"
+
+typedef struct KMIF_SOUND_DEVICE {
+	void *ctx;
+	void (*release)(void *ctx);
+	void (*reset)(void *ctx, Uint32 clock, Uint32 freq);
+	int (*synth)(void *ctx);
+	void (*volume)(void *ctx, Int32 v);
+	void (*write)(void *ctx, Uint32 a, Uint32 v);
+	Uint32 (*read)(void *ctx, Uint32 a);
+	void (*setinst)(void *ctx, Uint32 n, void *p, Uint32 l);
+#if 0
+	void (*setrate)(void *ctx, Uint32 clock, Uint32 freq);
+	void (*getinfo)(void *ctx, KMCH_INFO *cip, );
+	void (*volume2)(void *ctx, Uint8 *volp, Uint32 numch);
+	/* 0x00(mute),0x70(x1/2),0x80(x1),0x90(x2) */
+#endif
+} KMIF_SOUND_DEVICE;
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* KMSNDDEV_H__ */
diff -Nur orig/source/gme/src/Kss_Core.cpp mod/source/gme/src/Kss_Core.cpp
--- orig/source/gme/src/Kss_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,214 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Kss_Core.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2006-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Kss_Core::Kss_Core() : rom( Kss_Cpu::page_size )
+{
+	memset( unmapped_read, 0xFF, sizeof unmapped_read );
+}
+
+Kss_Core::~Kss_Core() { }
+
+void Kss_Core::unload()
+{
+	rom.clear();
+}
+
+static blargg_err_t check_kss_header( void const* header )
+{
+	if ( memcmp( header, "KSCC", 4 ) && memcmp( header, "KSSX", 4 ) )
+		return blargg_err_file_type;
+	return blargg_ok;
+}
+
+blargg_err_t Kss_Core::load_( Data_Reader& in )
+{
+	memset( &header_, 0, sizeof header_ );
+	assert( offsetof (header_t,msx_audio_vol) == header_t::size - 1 );
+	RETURN_ERR( rom.load( in, header_t::base_size, &header_, 0 ) );
+	
+	RETURN_ERR( check_kss_header( header_.tag ) );
+	
+	header_.last_track [0] = 255;
+	if ( header_.tag [3] == 'C' )
+	{
+		if ( header_.extra_header )
+		{
+			header_.extra_header = 0;
+			set_warning( "Unknown data in header" );
+		}
+		if ( header_.device_flags & ~0x0F )
+		{
+			header_.device_flags &= 0x0F;
+			set_warning( "Unknown data in header" );
+		}
+	}
+	else if ( header_.extra_header )
+	{
+		if ( header_.extra_header != header_.ext_size )
+		{
+			header_.extra_header = 0;
+			set_warning( "Invalid extra_header_size" );
+		}
+		else
+		{
+			memcpy( header_.data_size, rom.begin(), header_.ext_size );
+		}
+	}
+	
+	#ifndef NDEBUG
+	{
+		int ram_mode = header_.device_flags & 0x84; // MSX
+		if ( header_.device_flags & 0x02 ) // SMS
+			ram_mode = (header_.device_flags & 0x88);
+		
+		if ( ram_mode )
+			dprintf( "RAM not supported\n" ); // TODO: support
+	}
+	#endif
+	
+	return blargg_ok;
+}
+
+void Kss_Core::jsr( byte const (&addr) [2] )
+{
+	ram [--cpu.r.sp] = idle_addr >> 8;
+	ram [--cpu.r.sp] = idle_addr & 0xFF;
+	cpu.r.pc = get_le16( addr );
+}
+
+blargg_err_t Kss_Core::start_track( int track )
+{
+	memset( ram, 0xC9, 0x4000 );
+	memset( ram + 0x4000, 0, sizeof ram - 0x4000 );
+	
+	// copy driver code to lo RAM
+	static byte const bios [] = {
+		0xD3, 0xA0, 0xF5, 0x7B, 0xD3, 0xA1, 0xF1, 0xC9, // $0001: WRTPSG
+		0xD3, 0xA0, 0xDB, 0xA2, 0xC9                    // $0009: RDPSG
+	};
+	static byte const vectors [] = {
+		0xC3, 0x01, 0x00,   // $0093: WRTPSG vector
+		0xC3, 0x09, 0x00,   // $0096: RDPSG vector
+	};
+	memcpy( ram + 0x01, bios,    sizeof bios );
+	memcpy( ram + 0x93, vectors, sizeof vectors );
+	
+	// copy non-banked data into RAM
+	int load_addr = get_le16( header_.load_addr );
+	int orig_load_size = get_le16( header_.load_size );
+	int load_size = min( orig_load_size, rom.file_size() );
+	load_size = min( load_size, (int) mem_size - load_addr );
+	if ( load_size != orig_load_size )
+		set_warning( "Excessive data size" );
+	memcpy( ram + load_addr, rom.begin() + header_.extra_header, load_size );
+	
+	rom.set_addr( -load_size - header_.extra_header );
+	
+	// check available bank data
+	int const bank_size = this->bank_size();
+	int max_banks = (rom.file_size() - load_size + bank_size - 1) / bank_size;
+	bank_count = header_.bank_mode & 0x7F;
+	if ( bank_count > max_banks )
+	{
+		bank_count = max_banks;
+		set_warning( "Bank data missing" );
+	}
+	//dprintf( "load_size : $%X\n", load_size );
+	//dprintf( "bank_size : $%X\n", bank_size );
+	//dprintf( "bank_count: %d (%d claimed)\n", bank_count, header_.bank_mode & 0x7F );
+	
+	ram [idle_addr] = 0xFF;
+	cpu.reset( unmapped_write, unmapped_read );
+	cpu.map_mem( 0, mem_size, ram, ram );
+	
+	cpu.r.sp = 0xF380;
+	cpu.r.b.a = track;
+	cpu.r.b.h = 0;
+	next_play = play_period;
+	gain_updated = false;
+	jsr( header_.init_addr );
+	
+	return blargg_ok;
+}
+
+void Kss_Core::set_bank( int logical, int physical )
+{
+	int const bank_size = this->bank_size();
+	
+	int addr = 0x8000;
+	if ( logical && bank_size == 8 * 1024 )
+		addr = 0xA000;
+	
+	physical -= header_.first_bank;
+	if ( (unsigned) physical >= (unsigned) bank_count )
+	{
+		byte* data = ram + addr;
+		cpu.map_mem( addr, bank_size, data, data );
+	}
+	else
+	{
+		int phys = physical * bank_size;
+		for ( int offset = 0; offset < bank_size; offset += cpu.page_size )
+			cpu.map_mem( addr + offset, cpu.page_size,
+					unmapped_write, rom.at_addr( phys + offset ) );
+	}
+}
+
+void Kss_Core::cpu_out( time_t, addr_t addr, int data )
+{
+	dprintf( "OUT $%04X,$%02X\n", addr, data );
+}
+
+int Kss_Core::cpu_in( time_t, addr_t addr )
+{
+	dprintf( "IN $%04X\n", addr );
+	return 0xFF;
+}
+
+blargg_err_t Kss_Core::end_frame( time_t end )
+{
+	while ( cpu.time() < end )
+	{
+		time_t next = min( end, next_play );
+		run_cpu( next );
+		if ( cpu.r.pc == idle_addr )
+			cpu.set_time( next );
+		
+		if ( cpu.time() >= next_play )
+		{
+			next_play += play_period;
+			if ( cpu.r.pc == idle_addr )
+			{
+				if ( !gain_updated )
+				{
+					gain_updated = true;
+					update_gain();
+				}
+				
+				jsr( header_.play_addr );
+			}
+		}
+	}
+	
+	next_play -= end;
+	check( next_play >= 0 );
+	cpu.adjust_time( -end );
+	
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Kss_Core.h mod/source/gme/src/Kss_Core.h
--- orig/source/gme/src/Kss_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,97 @@
+// MSX computer KSS music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef KSS_CORE_H
+#define KSS_CORE_H
+
+#include "Gme_Loader.h"
+#include "Rom_Data.h"
+#include "Z80_Cpu.h"
+
+class Kss_Core : public Gme_Loader {
+public:
+	// KSS file header
+	struct header_t
+	{
+		enum { size = 0x20 };
+		enum { base_size = 0x10 };
+		enum { ext_size = size - base_size };
+		
+		byte tag [4];
+		byte load_addr [2];
+		byte load_size [2];
+		byte init_addr [2];
+		byte play_addr [2];
+		byte first_bank;
+		byte bank_mode;
+		byte extra_header;
+		byte device_flags;
+		
+		// KSSX extended data, if extra_header==0x10
+		byte data_size [4];
+		byte unused [4];
+		byte first_track [2];
+		byte last_track [2]; // if no extended data, we set this to 0xFF
+		byte psg_vol;
+		byte scc_vol;
+		byte msx_music_vol;
+		byte msx_audio_vol;
+	};
+	
+	// Header for currently loaded file
+	header_t const& header() const { return header_; }
+	
+	typedef int time_t;
+	void set_play_period( time_t p )        { play_period = p; }
+	
+	blargg_err_t start_track( int );
+	
+	blargg_err_t end_frame( time_t );
+
+protected:
+	typedef Z80_Cpu Kss_Cpu;
+	Kss_Cpu cpu;
+	
+	void set_bank( int logical, int physical );
+	
+	typedef int addr_t;
+	virtual void cpu_write( addr_t, int ) = 0;
+	virtual int  cpu_in(  time_t, addr_t );
+	virtual void cpu_out( time_t, addr_t, int );
+	
+	// Called after one frame of emulation
+	virtual void update_gain() = 0;
+	
+// Implementation
+public:
+	Kss_Core();
+	virtual ~Kss_Core();
+
+protected:
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual void unload();
+
+private:
+	enum { idle_addr = 0xFFFF };
+	
+	Rom_Data rom;
+	header_t header_;
+	bool gain_updated;
+	int bank_count;
+	time_t play_period;
+	time_t next_play;
+	
+	// large items
+	enum { mem_size = 0x10000 };
+	byte ram [mem_size + Kss_Cpu::cpu_padding];
+	byte unmapped_read  [0x100]; // TODO: why isn't this page_size?
+	// because CPU can't read beyond this in last page? or because it will spill into unmapped_write?
+	
+	byte unmapped_write [Kss_Cpu::page_size];
+	
+	int bank_size() const { return (16 * 1024) >> (header_.bank_mode >> 7 & 1); }
+	bool run_cpu( time_t end );
+	void jsr( byte const (&addr) [2] );
+};
+
+#endif
diff -Nur orig/source/gme/src/Kss_Cpu.cpp mod/source/gme/src/Kss_Cpu.cpp
--- orig/source/gme/src/Kss_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,35 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Kss_Core.h"
+
+#include "blargg_endian.h"
+//#include "z80_cpu_log.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#define OUT_PORT(  addr, data ) cpu_out( TIME(), addr, data )
+#define IN_PORT(   addr       ) cpu_in( TIME(), addr )
+#define WRITE_MEM( addr, data ) {FLUSH_TIME(); cpu_write( addr, data );}
+#define IDLE_ADDR               idle_addr
+#define CPU                     cpu
+
+#define CPU_BEGIN \
+bool Kss_Core::run_cpu( time_t end_time )\
+{\
+	cpu.set_end_time( end_time );
+
+	#include "Z80_Cpu_run.h"
+	
+	return warning;
+}
diff -Nur orig/source/gme/src/Kss_Cpu.h mod/source/gme/src/Kss_Cpu.h
--- orig/source/gme/src/Kss_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,124 @@
+// Z80 CPU emulator
+
+// Game_Music_Emu 0.5.5
+#ifndef KSS_CPU_H
+#define KSS_CPU_H
+
+#include "blargg_endian.h"
+
+typedef blargg_long cpu_time_t;
+
+// must be defined by caller
+void kss_cpu_out( class Kss_Cpu*, cpu_time_t, unsigned addr, int data );
+int  kss_cpu_in( class Kss_Cpu*, cpu_time_t, unsigned addr );
+void kss_cpu_write( class Kss_Cpu*, unsigned addr, int data );
+
+class Kss_Cpu {
+public:
+	typedef BOOST::uint8_t uint8_t;
+	
+	// Clear registers and map all pages to unmapped
+	void reset( void* unmapped_write, void const* unmapped_read );
+	
+	// Map memory. Start and size must be multiple of page_size.
+	enum { page_size = 0x2000 };
+	void map_mem( unsigned addr, blargg_ulong size, void* write, void const* read );
+	
+	// Map address to page
+	uint8_t* write( unsigned addr );
+	uint8_t const* read( unsigned addr );
+	
+	// Run until specified time is reached. Returns true if suspicious/unsupported
+	// instruction was encountered at any point during run.
+	bool run( cpu_time_t end_time );
+	
+	// Time of beginning of next instruction
+	cpu_time_t time() const             { return state->time + state->base; }
+	
+	// Alter current time. Not supported during run() call.
+	void set_time( cpu_time_t t )       { state->time = t - state->base; }
+	void adjust_time( int delta )       { state->time += delta; }
+	
+	typedef BOOST::uint16_t uint16_t;
+	
+	#if BLARGG_BIG_ENDIAN
+		struct regs_t { uint8_t b, c, d, e, h, l, flags, a; };
+	#else
+		struct regs_t { uint8_t c, b, e, d, l, h, a, flags; };
+	#endif
+	BOOST_STATIC_ASSERT( sizeof (regs_t) == 8 );
+	
+	struct pairs_t { uint16_t bc, de, hl, fa; };
+	
+	// Registers are not updated until run() returns
+	struct registers_t {
+		uint16_t pc;
+		uint16_t sp;
+		uint16_t ix;
+		uint16_t iy;
+		union {
+			regs_t b; //  b.b, b.c, b.d, b.e, b.h, b.l, b.flags, b.a
+			pairs_t w; // w.bc, w.de, w.hl. w.fa
+		};
+		union {
+			regs_t b;
+			pairs_t w;
+		} alt;
+		uint8_t iff1;
+		uint8_t iff2;
+		uint8_t r;
+		uint8_t i;
+		uint8_t im;
+	};
+	//registers_t r; (below for efficiency)
+	
+	enum { idle_addr = 0xFFFF };
+	
+	// can read this far past end of a page
+	enum { cpu_padding = 0x100 };
+	
+public:
+	Kss_Cpu();
+	enum { page_shift = 13 };
+	enum { page_count = 0x10000 >> page_shift };
+private:
+	uint8_t szpc [0x200];
+	cpu_time_t end_time_;
+	struct state_t {
+		uint8_t const* read  [page_count + 1];
+		uint8_t      * write [page_count + 1];
+		cpu_time_t base;
+		cpu_time_t time;
+	};
+	state_t* state; // points to state_ or a local copy within run()
+	state_t state_;
+	void set_end_time( cpu_time_t t );
+	void set_page( int i, void* write, void const* read );
+public:
+	registers_t r;
+};
+
+#if BLARGG_NONPORTABLE
+	#define KSS_CPU_PAGE_OFFSET( addr ) (addr)
+#else
+	#define KSS_CPU_PAGE_OFFSET( addr ) ((addr) & (page_size - 1))
+#endif
+
+inline BOOST::uint8_t* Kss_Cpu::write( unsigned addr )
+{
+	return state->write [addr >> page_shift] + KSS_CPU_PAGE_OFFSET( addr );
+}
+
+inline BOOST::uint8_t const* Kss_Cpu::read( unsigned addr )
+{
+	return state->read [addr >> page_shift] + KSS_CPU_PAGE_OFFSET( addr );
+}
+
+inline void Kss_Cpu::set_end_time( cpu_time_t t )
+{
+	cpu_time_t delta = state->base - t;
+	state->base = t;
+	state->time += delta;
+}
+
+#endif
diff -Nur orig/source/gme/src/Kss_Emu.cpp mod/source/gme/src/Kss_Emu.cpp
--- orig/source/gme/src/Kss_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,470 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Kss_Emu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2006-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#define IF_PTR( ptr ) if ( ptr ) (ptr)
+
+int const clock_rate = 3579545;
+
+#define FOR_EACH_APU( macro )\
+{\
+	macro( sms.psg   );\
+	macro( sms.fm    );\
+	macro( msx.psg   );\
+	macro( msx.scc   );\
+	macro( msx.music );\
+	macro( msx.audio );\
+}
+
+Kss_Emu::Kss_Emu() :
+	core( this )
+{
+	#define ACTION( apu ) { core.apu = NULL; }
+	FOR_EACH_APU( ACTION );
+	#undef ACTION
+
+	set_type( gme_kss_type );
+}
+
+Kss_Emu::~Kss_Emu()
+{
+	unload();
+}
+
+inline void Kss_Emu::Core::unload()
+{
+	#define ACTION( ptr ) { delete (ptr); (ptr) = 0; }
+	FOR_EACH_APU( ACTION );
+	#undef ACTION
+}
+
+void Kss_Emu::unload()
+{
+	core.unload();
+	Classic_Emu::unload();
+}
+
+// Track info
+
+static void copy_kss_fields( Kss_Core::header_t const& h, track_info_t* out )
+{
+	const char* system = "MSX";
+
+	if ( h.device_flags & 0x02 )
+	{
+		system = "Sega Master System";
+		if ( h.device_flags & 0x04 )
+			system = "Game Gear";
+
+		if ( h.device_flags & 0x01 )
+			system = "Sega Mark III";
+	}
+	else
+	{
+		if ( h.device_flags & 0x09 )
+			system = "MSX + FM Sound";
+	}
+	Gme_File::copy_field_( out->system, system );
+}
+
+blargg_err_t Kss_Emu::track_info_( track_info_t* out, int ) const
+{
+	copy_kss_fields( header(), out );
+// TODO: remove
+//if ( msx.music ) strcpy( out->system, "msxmusic" );
+//if ( msx.audio ) strcpy( out->system, "msxaudio" );
+//if ( sms.fm    ) strcpy( out->system, "fmunit"   );
+	return blargg_ok;
+}
+
+static blargg_err_t check_kss_header( void const* header )
+{
+	if ( memcmp( header, "KSCC", 4 ) && memcmp( header, "KSSX", 4 ) )
+		return blargg_err_file_type;
+
+	return blargg_ok;
+}
+
+struct Kss_File : Gme_Info_
+{
+	Kss_Emu::header_t header_;
+
+	Kss_File() { set_type( gme_kss_type ); }
+
+	blargg_err_t load_( Data_Reader& in )
+	{
+		memset( &header_, 0, sizeof header_ );
+		blargg_err_t err = in.read( &header_, header_.size );
+		if ( err )
+			return (err == blargg_err_file_eof ? blargg_err_file_type : err);
+
+		if ( header_.tag [3] == 'X' && header_.extra_header == 0x10 )
+			set_track_count( get_le16( header_.last_track ) + 1 );
+
+		return check_kss_header( &header_ );
+	}
+
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		copy_kss_fields( header_, out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_kss_emu () { return BLARGG_NEW Kss_Emu ; }
+static Music_Emu* new_kss_file() { return BLARGG_NEW Kss_File; }
+
+gme_type_t_ const gme_kss_type [1] = {{
+	"MSX",
+	256,
+	&new_kss_emu,
+	&new_kss_file,
+	"KSS",
+	0x03
+}};
+
+// Setup
+
+void Kss_Emu::Core::update_gain_()
+{
+	double g = emu.gain();
+	if ( msx.music || msx.audio || sms.fm )
+	{
+		g *= 0.3;
+	}
+	else
+	{
+		g *= 1.2;
+		if ( scc_accessed )
+			g *= 1.4;
+	}
+
+	#define ACTION( apu ) IF_PTR( apu )->volume( g )
+	FOR_EACH_APU( ACTION );
+	#undef ACTION
+}
+
+static blargg_err_t new_opl_apu( Opl_Apu::type_t type, Opl_Apu** out )
+{
+	check( !*out );
+	CHECK_ALLOC( *out = BLARGG_NEW( Opl_Apu ) );
+	blip_time_t const period = 72;
+	int const rate = clock_rate / period;
+	return (*out)->init( rate * period, rate, period, type );
+}
+
+blargg_err_t Kss_Emu::load_( Data_Reader& in )
+{
+	RETURN_ERR( core.load( in ) );
+	set_warning( core.warning() );
+
+	set_track_count( get_le16( header().last_track ) + 1 );
+
+	core.scc_enabled = false;
+	if ( header().device_flags & 0x02 ) // Sega Master System
+	{
+		int const osc_count = Sms_Apu::osc_count + Opl_Apu::osc_count;
+		static const char* const names [osc_count] = {
+			"Square 1", "Square 2", "Square 3", "Noise", "FM"
+		};
+		set_voice_names( names );
+
+		static int const types [osc_count] = {
+			wave_type+1, wave_type+3, wave_type+2, mixed_type+1, wave_type+0
+		};
+		set_voice_types( types );
+
+		// sms.psg
+		set_voice_count( Sms_Apu::osc_count );
+		check( !core.sms.psg );
+		CHECK_ALLOC( core.sms.psg = BLARGG_NEW Sms_Apu );
+
+		// sms.fm
+		if ( header().device_flags & 0x01 )
+		{
+			set_voice_count( osc_count );
+			RETURN_ERR( new_opl_apu( Opl_Apu::type_smsfmunit, &core.sms.fm ) );
+		}
+
+	}
+	else // MSX
+	{
+		int const osc_count = Ay_Apu::osc_count + Opl_Apu::osc_count;
+		static const char* const names [osc_count] = {
+			"Square 1", "Square 2", "Square 3", "FM"
+		};
+		set_voice_names( names );
+
+		static int const types [osc_count] = {
+			wave_type+1, wave_type+3, wave_type+2, wave_type+0
+		};
+		set_voice_types( types );
+
+		// msx.psg
+		set_voice_count( Ay_Apu::osc_count );
+		check( !core.msx.psg );
+		CHECK_ALLOC( core.msx.psg = BLARGG_NEW Ay_Apu );
+
+		if ( header().device_flags & 0x10 )
+			set_warning( "MSX stereo not supported" );
+
+		// msx.music
+		if ( header().device_flags & 0x01 )
+		{
+			set_voice_count( osc_count );
+			RETURN_ERR( new_opl_apu( Opl_Apu::type_msxmusic, &core.msx.music ) );
+		}
+
+		// msx.audio
+		if ( header().device_flags & 0x08 )
+		{
+			set_voice_count( osc_count );
+			RETURN_ERR( new_opl_apu( Opl_Apu::type_msxaudio, &core.msx.audio ) );
+		}
+
+		if ( !(header().device_flags & 0x80) )
+		{
+			if ( !(header().device_flags & 0x84) )
+				core.scc_enabled = core.scc_enabled_true;
+
+			// msx.scc
+			check( !core.msx.scc );
+			CHECK_ALLOC( core.msx.scc = BLARGG_NEW Scc_Apu );
+
+			int const osc_count2 = Ay_Apu::osc_count + Scc_Apu::osc_count;
+			static const char* const names2 [osc_count2] = {
+				"Square 1", "Square 2", "Square 3",
+				"Wave 1", "Wave 2", "Wave 3", "Wave 4", "Wave 5"
+			};
+			set_voice_names( names2 );
+
+			static int const types2 [osc_count2] = {
+				wave_type+1, wave_type+3, wave_type+2,
+				wave_type+0, wave_type+4, wave_type+5, wave_type+6, wave_type+7,
+			};
+			set_voice_types( types2 );
+
+			set_voice_count( osc_count2 );
+		}
+	}
+
+	set_silence_lookahead( 6 );
+	if ( core.sms.fm || core.msx.music || core.msx.audio )
+	{
+		if ( !Opl_Apu::supported() )
+			set_warning( "FM sound not supported" );
+		else
+			set_silence_lookahead( 3 ); // Opl_Apu is really slow
+	}
+
+	return setup_buffer( ::clock_rate );
+}
+
+void Kss_Emu::update_eq( blip_eq_t const& eq )
+{
+	#define ACTION( apu ) IF_PTR( core.apu )->treble_eq( eq )
+	FOR_EACH_APU( ACTION );
+	#undef ACTION
+}
+
+void Kss_Emu::set_voice( int i, Blip_Buffer* center, Blip_Buffer* left, Blip_Buffer* right )
+{
+	if ( core.sms.psg ) // Sega Master System
+	{
+		i -= core.sms.psg->osc_count;
+		if ( i < 0 )
+		{
+			core.sms.psg->set_output( i + core.sms.psg->osc_count, center, left, right );
+			return;
+		}
+
+		if ( core.sms.fm && i < core.sms.fm->osc_count )
+			core.sms.fm->set_output( i, center, NULL, NULL );
+	}
+	else if ( core.msx.psg ) // MSX
+	{
+		i -= core.msx.psg->osc_count;
+		if ( i < 0 )
+		{
+			core.msx.psg->set_output( i + core.msx.psg->osc_count, center );
+			return;
+		}
+
+		if ( core.msx.scc   && i < core.msx.scc->osc_count   ) core.msx.scc  ->set_output( i, center );
+		if ( core.msx.music && i < core.msx.music->osc_count ) core.msx.music->set_output( i, center, NULL, NULL );
+		if ( core.msx.audio && i < core.msx.audio->osc_count ) core.msx.audio->set_output( i, center, NULL, NULL );
+	}
+}
+
+void Kss_Emu::set_tempo_( double t )
+{
+	int period = (header().device_flags & 0x40 ? ::clock_rate / 50 : ::clock_rate / 60);
+	core.set_play_period( (Kss_Core::time_t) (period / t) );
+}
+
+blargg_err_t Kss_Emu::start_track_( int track )
+{
+	RETURN_ERR( Classic_Emu::start_track_( track ) );
+
+	#define ACTION( apu ) IF_PTR( core.apu )->reset()
+	FOR_EACH_APU( ACTION );
+	#undef ACTION
+
+	core.scc_accessed = false;
+	core.update_gain_();
+
+	return core.start_track( track );
+}
+
+void Kss_Emu::Core::cpu_write_( addr_t addr, int data )
+{
+	// TODO: SCC+ support
+
+	data &= 0xFF;
+	switch ( addr )
+	{
+	case 0x9000:
+		set_bank( 0, data );
+		return;
+
+	case 0xB000:
+		set_bank( 1, data );
+		return;
+
+	case 0xBFFE: // selects between mapping areas (we just always enable both)
+		if ( data == 0 || data == 0x20 )
+			return;
+	}
+
+	int scc_addr = (addr & 0xDFFF) - 0x9800;
+	if ( (unsigned) scc_addr < 0xB0 && msx.scc )
+	{
+		scc_accessed = true;
+		//if ( (unsigned) (scc_addr - 0x90) < 0x10 )
+		//  scc_addr -= 0x10; // 0x90-0x9F mirrors to 0x80-0x8F
+		if ( scc_addr < Scc_Apu::reg_count )
+			msx.scc->write( cpu.time(), addr, data );
+		return;
+	}
+
+	dprintf( "LD ($%04X),$%02X\n", addr, data );
+}
+
+void Kss_Emu::Core::cpu_write( addr_t addr, int data )
+{
+	*cpu.write( addr ) = data;
+	if ( (addr & scc_enabled) == 0x8000 )
+		cpu_write_( addr, data );
+}
+
+void Kss_Emu::Core::cpu_out( time_t time, addr_t addr, int data )
+{
+	data &= 0xFF;
+	switch ( addr & 0xFF )
+	{
+	case 0xA0:
+		if ( msx.psg )
+			msx.psg->write_addr( data );
+		return;
+
+	case 0xA1:
+		if ( msx.psg )
+			msx.psg->write_data( time, data );
+		return;
+
+	case 0x06:
+		if ( sms.psg && (header().device_flags & 0x04) )
+		{
+			sms.psg->write_ggstereo( time, data );
+			return;
+		}
+		break;
+
+	case 0x7E:
+	case 0x7F:
+		if ( sms.psg )
+		{
+			sms.psg->write_data( time, data );
+			return;
+		}
+		break;
+
+	#define OPL_WRITE_HANDLER( base, opl )\
+		case base  : if ( opl ) { opl->write_addr(       data ); return; } break;\
+		case base+1: if ( opl ) { opl->write_data( time, data ); return; } break;
+
+	OPL_WRITE_HANDLER( 0x7C, msx.music )
+	OPL_WRITE_HANDLER( 0xC0, msx.audio )
+	OPL_WRITE_HANDLER( 0xF0, sms.fm    )
+
+	case 0xFE:
+		set_bank( 0, data );
+		return;
+
+	#ifndef NDEBUG
+	case 0xA8: // PPI
+		return;
+	#endif
+	}
+
+	Kss_Core::cpu_out( time, addr, data );
+}
+
+int Kss_Emu::Core::cpu_in( time_t time, addr_t addr )
+{
+	switch ( addr & 0xFF )
+	{
+	case 0xC0:
+	case 0xC1:
+		if ( msx.audio )
+			return msx.audio->read( time, addr & 1 );
+		break;
+
+	case 0xA2:
+		if ( msx.psg )
+			return msx.psg->read();
+		break;
+
+	#ifndef NDEBUG
+	case 0xA8: // PPI
+		return 0;
+	#endif
+	}
+
+	return Kss_Core::cpu_in( time, addr );
+}
+
+void Kss_Emu::Core::update_gain()
+{
+	if ( scc_accessed )
+	{
+		dprintf( "SCC accessed\n" );
+		update_gain_();
+	}
+}
+
+blargg_err_t Kss_Emu::run_clocks( blip_time_t& duration, int )
+{
+	RETURN_ERR( core.end_frame( duration ) );
+
+	#define ACTION( apu ) IF_PTR( core.apu )->end_frame( duration )
+	FOR_EACH_APU( ACTION );
+	#undef ACTION
+
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Kss_Emu.h mod/source/gme/src/Kss_Emu.h
--- orig/source/gme/src/Kss_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,77 @@
+// MSX computer KSS music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef KSS_EMU_H
+#define KSS_EMU_H
+
+#include "Classic_Emu.h"
+#include "Kss_Core.h"
+#include "Kss_Scc_Apu.h"
+#include "Sms_Apu.h"
+#include "Ay_Apu.h"
+#include "Opl_Apu.h"
+
+class Kss_Emu : public Classic_Emu {
+public:
+	// KSS file header (see Kss_Core.h)
+	typedef Kss_Core::header_t header_t;
+	
+	// Header for currently loaded file
+	header_t const& header() const { return core.header(); }
+	
+	static gme_type_t static_type() { return gme_kss_type; }
+
+// Implementation
+public:
+	Kss_Emu();
+	~Kss_Emu();
+
+protected:
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+	virtual void unload();
+	
+private:
+	struct Core;
+	friend struct Core;
+	struct Core : Kss_Core {
+		Kss_Emu& emu;
+		
+		// detection of tunes that use SCC so they can be made louder
+		bool scc_accessed;
+		
+		enum { scc_enabled_true = 0xC000 };
+		unsigned scc_enabled; // 0 or 0xC000
+		int ay_latch;
+		
+		struct {
+			Sms_Apu* psg;
+			Opl_Apu* fm;
+		} sms;
+		
+		struct {
+			Ay_Apu*  psg;
+			Scc_Apu* scc;
+			Opl_Apu* music;
+			Opl_Apu* audio;
+		} msx;
+		
+		Core( Kss_Emu* e ) : emu( *e ) { }
+		
+		virtual void cpu_write( addr_t, int );
+		virtual int  cpu_in(  time_t, addr_t );
+		virtual void cpu_out( time_t, addr_t, int );
+		virtual void update_gain();
+
+		void cpu_write_( addr_t addr, int data );
+		void update_gain_();
+		void unload();
+	} core;
+};
+
+#endif
diff -Nur orig/source/gme/src/Kss_Scc_Apu.cpp mod/source/gme/src/Kss_Scc_Apu.cpp
--- orig/source/gme/src/Kss_Scc_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Scc_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,124 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Kss_Scc_Apu.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// Tones above this frequency are treated as disabled tone at half volume.
+// Power of two is more efficient (avoids division).
+int const inaudible_freq = 16384;
+
+int const wave_size = 0x20;
+
+void Scc_Apu::set_output( Blip_Buffer* buf )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		set_output( i, buf );
+}
+
+void Scc_Apu::volume( double v )
+{
+	synth.volume( 0.43 / osc_count / amp_range * v );
+}
+
+void Scc_Apu::reset()
+{
+	last_time = 0;
+
+	for ( int i = osc_count; --i >= 0; )
+		memset( &oscs [i], 0, offsetof (osc_t,output) );
+
+	memset( regs, 0, sizeof regs );
+}
+
+Scc_Apu::Scc_Apu()
+{
+	set_output( NULL );
+	volume( 1.0 );
+	reset();
+}
+
+void Scc_Apu::run_until( blip_time_t end_time )
+{
+	for ( int index = 0; index < osc_count; index++ )
+	{
+		osc_t& osc = oscs [index];
+
+		Blip_Buffer* const output = osc.output;
+		if ( !output )
+			continue;
+
+		blip_time_t period = (regs [0xA0 + index * 2 + 1] & 0x0F) * 0x100 +
+				regs [0xA0 + index * 2] + 1;
+		int volume = 0;
+		if ( regs [0xAF] & (1 << index) )
+		{
+			blip_time_t inaudible_period = (unsigned) (output->clock_rate() +
+					inaudible_freq * 32) / (unsigned) (inaudible_freq * 16);
+			if ( period > inaudible_period )
+				volume = (regs [0xAA + index] & 0x0F) * (amp_range / 256 / 15);
+		}
+
+		BOOST::int8_t const* wave = (BOOST::int8_t*) regs + index * wave_size;
+		/*if ( index == osc_count - 1 )
+			wave -= wave_size; // last two oscs share same wave RAM*/
+
+		{
+			int delta = wave [osc.phase] * volume - osc.last_amp;
+			if ( delta )
+			{
+				osc.last_amp += delta;
+				output->set_modified();
+				synth.offset( last_time, delta, output );
+			}
+		}
+
+		blip_time_t time = last_time + osc.delay;
+		if ( time < end_time )
+		{
+			int phase = osc.phase;
+			if ( !volume )
+			{
+				// maintain phase
+				int count = (end_time - time + period - 1) / period;
+				phase += count; // will be masked below
+				time  += count * period;
+			}
+			else
+			{
+				int last_wave = wave [phase];
+				phase = (phase + 1) & (wave_size - 1); // pre-advance for optimal inner loop
+				do
+				{
+					int delta = wave [phase] - last_wave;
+					phase = (phase + 1) & (wave_size - 1);
+					if ( delta )
+					{
+						last_wave += delta;
+						synth.offset_inline( time, delta * volume, output );
+					}
+					time += period;
+				}
+				while ( time < end_time );
+
+				osc.last_amp = last_wave * volume;
+				output->set_modified();
+				phase--; // undo pre-advance
+			}
+			osc.phase = phase & (wave_size - 1);
+		}
+		osc.delay = time - end_time;
+	}
+	last_time = end_time;
+}
diff -Nur orig/source/gme/src/Kss_Scc_Apu.h mod/source/gme/src/Kss_Scc_Apu.h
--- orig/source/gme/src/Kss_Scc_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Kss_Scc_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,111 @@
+// Konami SCC sound chip emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef KSS_SCC_APU_H
+#define KSS_SCC_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+class Scc_Apu {
+public:
+// Basics
+
+	// Sets buffer to generate sound into, or 0 to mute.
+	void set_output( Blip_Buffer* );
+
+	// Emulates to time t, then writes data to reg
+	enum { reg_count = 0xB0 }; // 0 <= reg < reg_count
+	void write( blip_time_t t, int reg, int data );
+
+	// Emulates to time t, then subtracts t from the current time.
+	// OK if previous write call had time slightly after t.
+	void end_frame( blip_time_t t );
+
+// More features
+
+	// Resets sound chip
+	void reset();
+
+	// Same as set_output(), but for a particular channel
+	enum { osc_count = 5 };
+	void set_output( int chan, Blip_Buffer* );
+
+	// Set overall volume, where 1.0 is normal
+	void volume( double );
+
+	// Set treble equalization
+	void treble_eq( blip_eq_t const& eq )   { synth.treble_eq( eq ); }
+
+private:
+	// noncopyable
+	Scc_Apu( const Scc_Apu& );
+	Scc_Apu& operator = ( const Scc_Apu& );
+
+
+// Implementation
+public:
+	Scc_Apu();
+	BLARGG_DISABLE_NOTHROW
+
+private:
+	enum { amp_range = 0x8000 };
+	struct osc_t
+	{
+		int delay;
+		int phase;
+		int last_amp;
+		Blip_Buffer* output;
+	};
+	osc_t oscs [osc_count];
+	blip_time_t last_time;
+	unsigned char regs [reg_count];
+	Blip_Synth_Fast synth;
+
+	void run_until( blip_time_t );
+};
+
+inline void Scc_Apu::set_output( int index, Blip_Buffer* b )
+{
+	assert( (unsigned) index < osc_count );
+	oscs [index].output = b;
+}
+
+inline void Scc_Apu::write( blip_time_t time, int addr, int data )
+{
+	//assert( (unsigned) addr < reg_count );
+	assert( ( addr >= 0x9800 && addr <= 0x988F ) || ( addr >= 0xB800 && addr <= 0xB8AF ) );
+	run_until( time );
+
+	addr -= 0x9800;
+	if ( ( unsigned ) addr < 0x90 )
+	{
+	    if ( ( unsigned ) addr < 0x60 )
+            regs [addr] = data;
+        else if ( ( unsigned ) addr < 0x80 )
+        {
+            regs [addr] = regs[addr + 0x20] = data;
+        }
+        else if ( ( unsigned ) addr < 0x90 )
+        {
+            regs [addr + 0x20] = data;
+        }
+	}
+	else
+	{
+	    addr -= 0xB800 - 0x9800;
+	    if ( ( unsigned ) addr < 0xB0 )
+            regs [addr] = data;
+	}
+}
+
+inline void Scc_Apu::end_frame( blip_time_t end_time )
+{
+	if ( end_time > last_time )
+		run_until( end_time );
+
+	last_time -= end_time;
+	assert( last_time >= 0 );
+}
+
+#endif
diff -Nur orig/source/gme/src/M3u_Playlist.cpp mod/source/gme/src/M3u_Playlist.cpp
--- orig/source/gme/src/M3u_Playlist.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/M3u_Playlist.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,471 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "M3u_Playlist.h"
+#include "Music_Emu.h"
+
+/* Copyright (C) 2006 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// gme functions defined here to avoid linking in m3u code unless it's used
+
+blargg_err_t Gme_File::load_m3u_( blargg_err_t err )
+{
+	if ( !err )
+	{
+		require( raw_track_count_ ); // file must be loaded first
+		if ( playlist.size() )
+			track_count_ = playlist.size();
+		
+		int line = playlist.first_error();
+		if ( line )
+		{
+			// avoid using bloated printf()
+			char* out = &playlist_warning [sizeof playlist_warning];
+			*--out = 0;
+			do {
+				*--out = line % 10 + '0';
+			} while ( (line /= 10) > 0 );
+			
+			static const char str [] = "Problem in m3u at line ";
+			out -= sizeof str - 1;
+			memcpy( out, str, sizeof str - 1 );
+			set_warning( out );
+		}
+	}
+	return err;
+}
+
+blargg_err_t Gme_File::load_m3u( const char path [] ) { return load_m3u_( playlist.load( path ) ); }
+
+blargg_err_t Gme_File::load_m3u( Data_Reader& in )  { return load_m3u_( playlist.load( in ) ); }
+
+gme_err_t gme_load_m3u( Music_Emu* me, const char path [] ) { return me->load_m3u( path ); }
+
+gme_err_t gme_load_m3u_data( Music_Emu* me, const void* data, long size )
+{
+	Mem_File_Reader in( data, size );
+	return me->load_m3u( in );
+}
+
+static char* skip_white( char* in )
+{
+	while ( unsigned (*in - 1) <= ' ' - 1 )
+		in++;
+	return in;
+}
+
+inline unsigned from_dec( unsigned n ) { return n - '0'; }
+
+static char* parse_filename( char* in, M3u_Playlist::entry_t& entry )
+{
+	entry.file = in;
+	entry.type = "";
+	char* out = in;
+	while ( 1 )
+	{
+		int c = *in;
+		if ( !c ) break;
+		in++;
+		
+		if ( c == ',' ) // commas in filename
+		{
+			char* p = skip_white( in );
+			if ( *p == '$' || from_dec( *p ) <= 9 )
+			{
+				in = p;
+				break;
+			}
+		}
+		
+		if ( c == ':' && in [0] == ':' && in [1] && in [2] != ',' ) // ::type suffix
+		{
+			entry.type = ++in;
+			while ( (c = *in) != 0 && c != ',' )
+				in++;
+			if ( c == ',' )
+			{
+				*in++ = 0; // terminate type
+				in = skip_white( in );
+			}
+			break;
+		}
+		
+		if ( c == '\\' ) // \ prefix for special characters
+		{
+			c = *in;
+			if ( !c ) break;
+			in++;
+		}
+		*out++ = (char) c;
+	}
+	*out = 0; // terminate string
+	return in;
+}
+
+static char* next_field( char* in, int* result )
+{
+	while ( 1 )
+	{
+		in = skip_white( in );
+		
+		if ( !*in )
+			break;
+		
+		if ( *in == ',' )
+		{
+			in++;
+			break;
+		}
+		
+		*result = 1;
+		in++;
+	}
+	return skip_white( in );
+}
+
+static char* parse_int_( char* in, int* out )
+{
+	int n = 0;
+	while ( 1 )
+	{
+		unsigned d = from_dec( *in );
+		if ( d > 9 )
+			break;
+		in++;
+		n = n * 10 + d;
+		*out = n;
+	}
+	return in;
+}
+
+static char* parse_int( char* in, int* out, int* result )
+{
+	return next_field( parse_int_( in, out ), result );
+}
+
+// Returns 16 or greater if not hex
+inline int from_hex_char( int h )
+{
+	h -= 0x30;
+	if ( (unsigned) h > 9 )
+		h = ((h - 0x11) & 0xDF) + 10;
+	return h;
+}
+
+static char* parse_track( char* in, M3u_Playlist::entry_t& entry, int* result )
+{
+	if ( *in == '$' )
+	{
+		in++;
+		int n = 0;
+		while ( 1 )
+		{
+			int h = from_hex_char( *in );
+			if ( h > 15 )
+				break;
+			in++;
+			n = n * 16 + h;
+			entry.track = n;
+		}
+	}
+	else
+	{
+		in = parse_int_( in, &entry.track );
+		if ( entry.track >= 0 )
+			entry.decimal_track = 1;
+	}
+	return next_field( in, result );
+}
+
+static char* parse_time_( char* in, int* out )
+{
+	*out = -1;
+	int n = -1;
+	in = parse_int_( in, &n );
+	if ( n >= 0 )
+	{
+		*out = n;
+		while ( *in == ':' )
+		{
+			n = -1;
+			in = parse_int_( in + 1, &n );
+			if ( n >= 0 )
+				*out = *out * 60 + n;
+		}
+		*out *= 1000;
+		if ( *in == '.' )
+		{
+			n = -1;
+			in = parse_int_( in + 1, &n );
+			if ( n >= 0 )
+				*out = *out + n; 
+		}
+	}
+	return in;
+}
+
+static char* parse_time( char* in, int* out, int* result )
+{
+	return next_field( parse_time_( in, out ), result );
+}
+
+static char* parse_name( char* in )
+{
+	char* out = in;
+	while ( 1 )
+	{
+		int c = *in;
+		if ( !c ) break;
+		in++;
+		
+		if ( c == ',' ) // commas in string
+		{
+			char* p = skip_white( in );
+			if ( *p == ',' || *p == '-' || from_dec( *p ) <= 9 )
+			{
+				in = p;
+				break;
+			}
+		}
+		
+		if ( c == '\\' ) // \ prefix for special characters
+		{
+			c = *in;
+			if ( !c ) break;
+			in++;
+		}
+		*out++ = (char) c;
+	}
+	*out = 0; // terminate string
+	return in;
+}
+
+static int parse_line( char* in, M3u_Playlist::entry_t& entry )
+{
+	int result = 0;
+	
+	// file
+	entry.file = in;
+	entry.type = "";
+	in = parse_filename( in, entry );
+	
+	// track
+	entry.track = -1;
+	entry.decimal_track = 0;
+	in = parse_track( in, entry, &result );
+	
+	// name
+	entry.name = in;
+	in = parse_name( in );
+	
+	// time
+	entry.length = -1;
+	in = parse_time( in, &entry.length, &result );
+	
+	// loop
+	entry.intro = -1;
+	entry.loop  = -1;
+	if ( *in == '-' )
+	{
+		entry.loop = entry.length;
+		in++;
+	}
+	else
+	{
+		in = parse_time_( in, &entry.loop );
+		if ( entry.loop >= 0 )
+		{
+			entry.intro = 0;
+			if ( *in == '-' ) // trailing '-' means that intro length was specified 
+			{
+				in++;
+				entry.intro = entry.loop;
+				entry.loop  = entry.length - entry.intro;
+			}
+		}
+	}
+	in = next_field( in, &result );
+	
+	// fade
+	entry.fade = -1;
+	in = parse_time( in, &entry.fade, &result );
+	
+	// repeat
+	entry.repeat = -1;
+	in = parse_int( in, &entry.repeat, &result );
+	
+	return result;
+}
+
+static void parse_comment( char* in, M3u_Playlist::info_t& info, char *& last_comment_value, bool first )
+{
+	in = skip_white( in + 1 );
+	const char* field = in;
+	while ( *in && *in != ':' )
+		in++;
+	
+	if ( *in == ':' )
+	{
+		const char* text = skip_white( in + 1 );
+		if ( *text )
+		{
+			*in = 0;
+			     if ( !strcmp( "Composer", field ) ) info.composer = text;
+			else if ( !strcmp( "Engineer", field ) ) info.engineer = text;
+			else if ( !strcmp( "Ripping" , field ) ) info.ripping  = text;
+			else if ( !strcmp( "Tagging" , field ) ) info.tagging  = text;
+			else
+				text = 0;
+			if ( text )
+				return;
+			*in = ':';
+		}
+	}
+	else if ( *field == '@' )
+	{
+		++field;
+		in = (char*)field;
+		while ( *in && *in > ' ' )
+			in++;
+		const char* text = skip_white( in );
+		if ( *text )
+		{
+			char saved = *in;
+			*in = 0;
+			     if ( !strcmp( "TITLE" ,    field ) ) info.title     = text;
+			else if ( !strcmp( "ARTIST",    field ) ) info.artist    = text;
+			else if ( !strcmp( "DATE",      field ) ) info.date      = text;
+			else if ( !strcmp( "COMPOSER",  field ) ) info.composer  = text;
+			else if ( !strcmp( "SEQUENCER", field ) ) info.sequencer = text;
+			else if ( !strcmp( "ENGINEER",  field ) ) info.engineer  = text;
+			else if ( !strcmp( "RIPPER",    field ) ) info.ripping   = text;
+			else if ( !strcmp( "TAGGER",    field ) ) info.tagging   = text;
+			else
+				text = 0;
+			if ( text )
+			{
+				last_comment_value = (char*)text;
+				return;
+			}
+			*in = saved;
+		}
+	}
+	else if ( last_comment_value )
+	{
+		size_t len = strlen( last_comment_value );
+		last_comment_value[ len ] = ',';
+		last_comment_value[ len + 1 ] = ' ';
+		size_t field_len = strlen( field );
+		memmove( last_comment_value + len + 2, field, field_len );
+		last_comment_value[ len + 2 + field_len ] = 0;
+		return;
+	}
+	
+	if ( first )
+		info.title = field;
+}
+
+blargg_err_t M3u_Playlist::parse_()
+{
+	info_.title     = "";
+	info_.artist    = "";
+	info_.date      = "";
+	info_.composer  = "";
+	info_.sequencer = "";
+	info_.engineer  = "";
+	info_.ripping   = "";
+	info_.tagging   = "";
+	
+	int const CR = 13;
+	int const LF = 10;
+	
+	data.end() [-1] = LF; // terminate input
+	
+	first_error_ = 0;
+	bool first_comment = true;
+	int line  = 0;
+	int count = 0;
+	char* in  = data.begin();
+	char* last_comment_value = 0;
+	while ( in < data.end() )
+	{
+		// find end of line and terminate it
+		line++;
+		char* begin = in;
+		while ( *in != CR && *in != LF )
+		{
+			if ( !*in )
+				return blargg_err_file_type;
+			in++;
+		}
+		if ( in [0] == CR && in [1] == LF ) // treat CR,LF as a single line
+			*in++ = 0;
+		*in++ = 0;
+		
+		// parse line
+		if ( *begin == '#' )
+		{
+			parse_comment( begin, info_, last_comment_value, first_comment );
+			first_comment = false;
+		}
+		else if ( *begin )
+		{
+			if ( (int) entries.size() <= count )
+				RETURN_ERR( entries.resize( count * 2 + 64 ) );
+			
+			if ( !parse_line( begin, entries [count] ) )
+				count++;
+			else if ( !first_error_ )
+				first_error_ = line;
+			first_comment = false;
+		}
+		else last_comment_value = 0;
+	}
+	if ( count <= 0 )
+		return blargg_err_file_type;
+	
+	// Treat first comment as title only if another field is also specified
+	if ( !(info_.artist [0] | info_.composer [0] | info_.date [0] | info_.engineer [0] | info_.ripping [0] | info_.sequencer [0] | info_.tagging [0]) )
+		info_.title = "";
+	
+	return entries.resize( count );
+}
+
+blargg_err_t M3u_Playlist::parse()
+{
+	blargg_err_t err = parse_();
+	if ( err )
+		clear_();
+	return err;
+}
+
+blargg_err_t M3u_Playlist::load( Data_Reader& in )
+{
+	RETURN_ERR( data.resize( in.remain() + 1 ) );
+	RETURN_ERR( in.read( data.begin(), data.size() - 1 ) );
+	return parse();
+}
+
+blargg_err_t M3u_Playlist::load( const char path [] )
+{
+	GME_FILE_READER in;
+	RETURN_ERR( in.open( path ) );
+	return load( in );
+}
+
+blargg_err_t M3u_Playlist::load( void const* in, long size )
+{
+	RETURN_ERR( data.resize( size + 1 ) );
+	memcpy( data.begin(), in, size );
+	return parse();
+}
diff -Nur orig/source/gme/src/M3u_Playlist.h mod/source/gme/src/M3u_Playlist.h
--- orig/source/gme/src/M3u_Playlist.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/M3u_Playlist.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,82 @@
+// M3U playlist file parser, with support for subtrack information
+
+// Game_Music_Emu 0.6-pre
+#ifndef M3U_PLAYLIST_H
+#define M3U_PLAYLIST_H
+
+#include "blargg_common.h"
+#include "Data_Reader.h"
+
+class M3u_Playlist {
+public:
+	// Load playlist data
+	blargg_err_t load( const char* path );
+	blargg_err_t load( Data_Reader& in );
+	blargg_err_t load( void const* data, long size );
+	
+	// Line number of first parse error, 0 if no error. Any lines with parse
+	// errors are ignored.
+	int first_error() const { return first_error_; }
+	
+	// All string pointers point to valid string, or "" if not available
+	struct info_t
+	{
+		const char* title;
+		const char* artist;
+		const char* date;
+		const char* composer;
+		const char* sequencer;
+		const char* engineer;
+		const char* ripping;
+		const char* tagging;
+	};
+	info_t const& info() const { return info_; }
+	
+	struct entry_t
+	{
+		const char* file; // filename without stupid ::TYPE suffix
+		const char* type; // if filename has ::TYPE suffix, this is "TYPE", otherwise ""
+		const char* name;
+		bool decimal_track; // true if track was specified in decimal
+		// integers are -1 if not present
+		int track;
+		int length; // milliseconds
+		int intro;
+		int loop;
+		int fade;
+		int repeat; // count
+	};
+	entry_t const& operator [] ( int i ) const { return entries [i]; }
+	int size() const { return entries.size(); }
+	
+	void clear();
+	
+private:
+	blargg_vector<entry_t> entries;
+	blargg_vector<char> data;
+	int first_error_;
+	info_t info_;
+	
+	blargg_err_t parse();
+	blargg_err_t parse_();
+	void clear_();
+};
+
+inline void M3u_Playlist::clear_()
+{
+	info_.title    = "";
+	info_.composer = "";
+	info_.engineer = "";
+	info_.ripping  = "";
+	info_.tagging  = "";
+	entries.clear();
+	data.clear();
+}
+
+inline void M3u_Playlist::clear()
+{
+	first_error_ = 0;
+	clear_();
+}
+
+#endif
diff -Nur orig/source/gme/src/Multi_Buffer.cpp mod/source/gme/src/Multi_Buffer.cpp
--- orig/source/gme/src/Multi_Buffer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Multi_Buffer.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,290 @@
+// Blip_Buffer 0.4.0. http://www.slack.net/~ant/
+
+#include "Multi_Buffer.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Multi_Buffer::Multi_Buffer( int spf ) : samples_per_frame_( spf )
+{
+	length_                 = 0;
+	sample_rate_            = 0;
+	channels_changed_count_ = 1;
+	channel_types_          = NULL;
+	channel_count_          = 0;
+	immediate_removal_      = true;
+}
+
+Multi_Buffer::channel_t Multi_Buffer::channel( int /*index*/ )
+{
+	channel_t ch;
+	ch.center = ch.left = ch.right = NULL;
+	return ch;
+}
+
+// Silent_Buffer
+
+Silent_Buffer::Silent_Buffer() : Multi_Buffer( 1 ) // 0 channels would probably confuse
+{
+	// TODO: better to use empty Blip_Buffer so caller never has to check for NULL?
+	chan.left   = NULL;
+	chan.center = NULL;
+	chan.right  = NULL;
+}
+
+// Mono_Buffer
+
+Mono_Buffer::Mono_Buffer() : Multi_Buffer( 1 )
+{
+	chan.center = &buf;
+	chan.left   = &buf;
+	chan.right  = &buf;
+}
+
+Mono_Buffer::~Mono_Buffer() { }
+
+blargg_err_t Mono_Buffer::set_sample_rate( int rate, int msec )
+{
+	RETURN_ERR( buf.set_sample_rate( rate, msec ) );
+	return Multi_Buffer::set_sample_rate( buf.sample_rate(), buf.length() );
+}
+
+
+// Tracked_Blip_Buffer
+
+int const blip_buffer_extra = 32; // TODO: explain why this value
+
+Tracked_Blip_Buffer::Tracked_Blip_Buffer()
+{
+	last_non_silence = 0;
+}
+
+void Tracked_Blip_Buffer::clear()
+{
+	last_non_silence = 0;
+	Blip_Buffer::clear();
+}
+
+void Tracked_Blip_Buffer::end_frame( blip_time_t t )
+{
+	Blip_Buffer::end_frame( t );
+	if ( modified() )
+	{
+		clear_modified();
+		last_non_silence = samples_avail() + blip_buffer_extra;
+	}
+}
+
+unsigned Tracked_Blip_Buffer::non_silent() const
+{
+	return last_non_silence | unsettled();
+}
+
+inline void Tracked_Blip_Buffer::remove_( int n )
+{
+	if ( (last_non_silence -= n) < 0 )
+		last_non_silence = 0;
+}
+
+void Tracked_Blip_Buffer::remove_silence( int n )
+{
+	remove_( n );
+	Blip_Buffer::remove_silence( n );
+}
+
+void Tracked_Blip_Buffer::remove_samples( int n )
+{
+	remove_( n );
+	Blip_Buffer::remove_samples( n );
+}
+
+void Tracked_Blip_Buffer::remove_all_samples()
+{
+	int avail = samples_avail();
+	if ( !non_silent() )
+		remove_silence( avail );
+	else
+		remove_samples( avail );
+}
+
+int Tracked_Blip_Buffer::read_samples( blip_sample_t out [], int count )
+{
+	count = Blip_Buffer::read_samples( out, count );
+	remove_( count );
+	return count;
+}
+
+// Stereo_Buffer
+
+int const stereo = 2;
+
+Stereo_Buffer::Stereo_Buffer() : Multi_Buffer( 2 )
+{
+	chan.center = mixer.bufs [2] = &bufs [2];
+	chan.left   = mixer.bufs [0] = &bufs [0];
+	chan.right  = mixer.bufs [1] = &bufs [1];
+	mixer.samples_read = 0;
+}
+
+Stereo_Buffer::~Stereo_Buffer() { }
+
+blargg_err_t Stereo_Buffer::set_sample_rate( int rate, int msec )
+{
+	mixer.samples_read = 0;
+	for ( int i = bufs_size; --i >= 0; )
+		RETURN_ERR( bufs [i].set_sample_rate( rate, msec ) );
+	return Multi_Buffer::set_sample_rate( bufs [0].sample_rate(), bufs [0].length() );
+}
+
+void Stereo_Buffer::clock_rate( int rate )
+{
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].clock_rate( rate );
+}
+
+void Stereo_Buffer::bass_freq( int bass )
+{
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].bass_freq( bass );
+}
+
+void Stereo_Buffer::clear()
+{
+	mixer.samples_read = 0;
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].clear();
+}
+
+void Stereo_Buffer::end_frame( blip_time_t time )
+{
+	for ( int i = bufs_size; --i >= 0; )
+		bufs [i].end_frame( time );
+}
+
+int Stereo_Buffer::read_samples( blip_sample_t out [], int out_size )
+{
+	require( (out_size & 1) == 0 ); // must read an even number of samples
+	out_size = min( out_size, samples_avail() );
+
+	int pair_count = int (out_size >> 1);
+	if ( pair_count )
+	{
+		mixer.read_pairs( out, pair_count );
+		
+		if ( samples_avail() <= 0 || immediate_removal() )
+		{
+			for ( int i = bufs_size; --i >= 0; )
+			{
+				buf_t& b = bufs [i];
+				// TODO: might miss non-silence settling since it checks END of last read
+				if ( !b.non_silent() )
+					b.remove_silence( mixer.samples_read );
+				else
+					b.remove_samples( mixer.samples_read );
+			}
+			mixer.samples_read = 0;
+		}
+	}
+	return out_size;
+}
+
+
+// Stereo_Mixer
+
+// mixers use a single index value to improve performance on register-challenged processors
+// offset goes from negative to zero
+
+void Stereo_Mixer::read_pairs( blip_sample_t out [], int count )
+{
+	// TODO: if caller never marks buffers as modified, uses mono
+	// except that buffer isn't cleared, so caller can encounter
+	// subtle problems and not realize the cause.
+	samples_read += count;
+	if ( bufs [0]->non_silent() | bufs [1]->non_silent() )
+		mix_stereo( out, count );
+	else
+		mix_mono( out, count );
+}
+
+void Stereo_Mixer::mix_mono( blip_sample_t out_ [], int count )
+{
+	int const bass = bufs [2]->highpass_shift();
+	Blip_Buffer::delta_t const* center = bufs [2]->read_pos() + samples_read;
+	int center_sum = bufs [2]->integrator();
+	
+	typedef blip_sample_t stereo_blip_sample_t [stereo];
+	stereo_blip_sample_t* BLARGG_RESTRICT out = (stereo_blip_sample_t*) out_ + count;
+	int offset = -count;
+	do
+	{
+		int s = center_sum >> bufs [2]->delta_bits;
+		
+		center_sum -= center_sum >> bass;
+		center_sum += center [offset];
+		
+		BLIP_CLAMP( s, s );
+		
+		out [offset] [0] = (blip_sample_t) s;
+		out [offset] [1] = (blip_sample_t) s;
+	}
+	while ( ++offset );
+	
+	bufs [2]->set_integrator( center_sum );
+}
+
+void Stereo_Mixer::mix_stereo( blip_sample_t out_ [], int count )
+{
+	blip_sample_t* BLARGG_RESTRICT out = out_ + count * stereo;
+	
+	// do left + center and right + center separately to reduce register load
+	Tracked_Blip_Buffer* const* buf = &bufs [2];
+	while ( true ) // loop runs twice
+	{
+		--buf;
+		--out;
+		
+		int const bass = bufs [2]->highpass_shift();
+		Blip_Buffer::delta_t const* side = (*buf)->read_pos() + samples_read;
+		Blip_Buffer::delta_t const* center = bufs [2]->read_pos() + samples_read;
+	
+		int side_sum = (*buf)->integrator();
+		int center_sum = bufs [2]->integrator();
+		
+		int offset = -count;
+		do
+		{
+			int s = (center_sum + side_sum) >> Blip_Buffer::delta_bits;
+			
+			side_sum   -= side_sum   >> bass;
+			center_sum -= center_sum >> bass;
+			
+			side_sum   += side   [offset];
+			center_sum += center [offset];
+			
+			BLIP_CLAMP( s, s );
+			
+			++offset; // before write since out is decremented to slightly before end
+			out [offset * stereo] = (blip_sample_t) s;
+		}
+		while ( offset );
+		
+		(*buf)->set_integrator( side_sum );
+		
+		if ( buf != bufs )
+			continue;
+		
+		// only end center once
+		bufs [2]->set_integrator( center_sum );
+		break;
+	}
+}
diff -Nur orig/source/gme/src/Multi_Buffer.h mod/source/gme/src/Multi_Buffer.h
--- orig/source/gme/src/Multi_Buffer.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Multi_Buffer.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,219 @@
+// Multi-channel sound buffer interface, and basic mono and stereo buffers
+
+// Blip_Buffer 0.4.0
+#ifndef MULTI_BUFFER_H
+#define MULTI_BUFFER_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+// Interface to one or more Blip_Buffers mapped to one or more channels
+// consisting of left, center, and right buffers.
+class Multi_Buffer {
+public:
+
+	// 1=mono, 2=stereo
+	Multi_Buffer( int samples_per_frame );
+	virtual ~Multi_Buffer()                             { }
+	
+	// Sets the number of channels available and optionally their types
+	// (type information used by Effects_Buffer)
+	enum { type_index_mask = 0xFF };
+	enum { wave_type = 0x100, noise_type = 0x200, mixed_type = wave_type | noise_type };
+	virtual blargg_err_t set_channel_count( int, int const types [] = NULL );
+	int channel_count() const                           { return channel_count_; }
+	
+	// Gets indexed channel, from 0 to channel_count()-1
+	struct channel_t {
+		Blip_Buffer* center;
+		Blip_Buffer* left;
+		Blip_Buffer* right;
+	};
+	virtual channel_t channel( int index )              BLARGG_PURE( ; )
+	
+	// Number of samples per output frame (1 = mono, 2 = stereo)
+	int samples_per_frame() const;
+	
+	// Count of changes to channel configuration. Incremented whenever
+	// a change is made to any of the Blip_Buffers for any channel.
+	unsigned channels_changed_count()                   { return channels_changed_count_; }
+	
+	// See Blip_Buffer.h
+	virtual blargg_err_t set_sample_rate( int rate, int msec = blip_default_length ) BLARGG_PURE( ; )
+	int sample_rate() const;
+	int length() const;
+	virtual void clock_rate( int )                      BLARGG_PURE( ; )
+	virtual void bass_freq( int )                       BLARGG_PURE( ; )
+	virtual void clear()                                BLARGG_PURE( ; )
+	virtual void end_frame( blip_time_t )               BLARGG_PURE( ; )
+	virtual int read_samples( blip_sample_t [], int )   BLARGG_PURE( ; )
+	virtual int samples_avail() const                   BLARGG_PURE( ; )
+
+private:
+	// noncopyable
+	Multi_Buffer( const Multi_Buffer& );
+	Multi_Buffer& operator = ( const Multi_Buffer& );
+
+// Implementation
+public:
+	BLARGG_DISABLE_NOTHROW
+	void disable_immediate_removal()                    { immediate_removal_ = false; }
+
+protected:
+	bool immediate_removal() const                      { return immediate_removal_; }
+	int const* channel_types() const                    { return channel_types_; }
+	void channels_changed()                             { channels_changed_count_++; }
+		
+private:
+	unsigned channels_changed_count_;
+	int sample_rate_;
+	int length_;
+	int channel_count_;
+	int const samples_per_frame_;
+	int const* channel_types_;
+	bool immediate_removal_;
+};
+
+
+// Uses a single buffer and outputs mono samples.
+class Mono_Buffer : public Multi_Buffer {
+public:
+	// Buffer used for all channels
+	Blip_Buffer* center()                       { return &buf; }
+	
+// Implementation
+public:
+	Mono_Buffer();
+	~Mono_Buffer();
+	virtual blargg_err_t set_sample_rate( int rate, int msec = blip_default_length );
+	virtual void clock_rate( int rate )                     { buf.clock_rate( rate ); }
+	virtual void bass_freq( int freq )                      { buf.bass_freq( freq ); }
+	virtual void clear()                                    { buf.clear(); }
+	virtual int samples_avail() const                       { return buf.samples_avail(); }
+	virtual int read_samples( blip_sample_t p [], int s )   { return buf.read_samples( p, s ); }
+	virtual channel_t channel( int )                        { return chan; }
+	virtual void end_frame( blip_time_t t )                 { buf.end_frame( t ); }
+
+private:
+	Blip_Buffer buf;
+	channel_t chan;
+};
+
+	class Tracked_Blip_Buffer : public Blip_Buffer {
+	public:
+		// Non-zero if buffer still has non-silent samples in it. Requires that you call
+		// set_modified() appropriately.
+		unsigned non_silent() const;
+		
+		// remove_samples( samples_avail() )
+		void remove_all_samples();
+		
+	// Implementation
+	public:
+		BLARGG_DISABLE_NOTHROW
+		int read_samples( blip_sample_t [], int );
+		void remove_silence( int );
+		void remove_samples( int );
+		Tracked_Blip_Buffer();
+		void clear();
+		void end_frame( blip_time_t );
+	
+	private:
+		int last_non_silence;
+		
+		delta_t unsettled() const { return integrator() >> delta_bits; }
+		void remove_( int );
+	};
+	
+	class Stereo_Mixer {
+	public:
+		Tracked_Blip_Buffer* bufs [3];
+		int samples_read;
+		
+		Stereo_Mixer() : samples_read( 0 ) { }
+		void read_pairs( blip_sample_t out [], int count );
+	
+	private:
+		void mix_mono  ( blip_sample_t out [], int pair_count );
+		void mix_stereo( blip_sample_t out [], int pair_count );
+	};
+
+
+// Uses three buffers (one for center) and outputs stereo sample pairs.
+class Stereo_Buffer : public Multi_Buffer {
+public:
+	
+	// Buffers used for all channels
+	Blip_Buffer* center()   { return &bufs [2]; }
+	Blip_Buffer* left()     { return &bufs [0]; }
+	Blip_Buffer* right()    { return &bufs [1]; }
+	
+// Implementation
+public:
+	Stereo_Buffer();
+	~Stereo_Buffer();
+	virtual blargg_err_t set_sample_rate( int, int msec = blip_default_length );
+	virtual void clock_rate( int );
+	virtual void bass_freq( int );
+	virtual void clear();
+	virtual channel_t channel( int )            { return chan; }
+	virtual void end_frame( blip_time_t );
+	virtual int samples_avail() const           { return (bufs [0].samples_avail() - mixer.samples_read) * 2; }
+	virtual int read_samples( blip_sample_t [], int );
+	
+private:
+	enum { bufs_size = 3 };
+	typedef Tracked_Blip_Buffer buf_t;
+	buf_t bufs [bufs_size];
+	Stereo_Mixer mixer;
+	channel_t chan;
+	int samples_avail_;
+};
+
+
+// Silent_Buffer generates no samples, useful where no sound is wanted
+class Silent_Buffer : public Multi_Buffer {
+	channel_t chan;
+public:
+	Silent_Buffer();
+	virtual blargg_err_t set_sample_rate( int rate, int msec = blip_default_length );
+	virtual void clock_rate( int )                  { }
+	virtual void bass_freq( int )                   { }
+	virtual void clear()                            { }
+	virtual channel_t channel( int )                { return chan; }
+	virtual void end_frame( blip_time_t )           { }
+	virtual int samples_avail() const               { return 0; }
+	virtual int read_samples( blip_sample_t [], int ) { return 0; }
+};
+
+
+inline blargg_err_t Multi_Buffer::set_sample_rate( int rate, int msec )
+{
+	sample_rate_ = rate;
+	length_ = msec;
+	return blargg_ok;
+}
+
+inline int  Multi_Buffer::samples_per_frame() const             { return samples_per_frame_; }
+inline int  Multi_Buffer::sample_rate() const                   { return sample_rate_; }
+inline int  Multi_Buffer::length() const                        { return length_; }
+inline void Multi_Buffer::clock_rate( int )                     { }
+inline void Multi_Buffer::bass_freq( int )                      { }
+inline void Multi_Buffer::clear()                               { }
+inline void Multi_Buffer::end_frame( blip_time_t )              { }
+inline int  Multi_Buffer::read_samples( blip_sample_t [], int ) { return 0; }
+inline int  Multi_Buffer::samples_avail() const                 { return 0; }
+
+inline blargg_err_t Multi_Buffer::set_channel_count( int n, int const types [] )
+{
+	channel_count_ = n;
+	channel_types_ = types;
+	return blargg_ok;
+}
+
+inline blargg_err_t Silent_Buffer::set_sample_rate( int rate, int msec )
+{
+	return Multi_Buffer::set_sample_rate( rate, msec );
+}
+
+#endif
diff -Nur orig/source/gme/src/Music_Emu.cpp mod/source/gme/src/Music_Emu.cpp
--- orig/source/gme/src/Music_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Music_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,235 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Music_Emu.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const stereo = 2; // number of channels for stereo
+
+Music_Emu::equalizer_t const Music_Emu::tv_eq = { -8.0, 180 };
+
+void Music_Emu::clear_track_vars()
+{
+	current_track_ = -1;
+	warning(); // clear warning
+	track_filter.stop();
+}
+
+void Music_Emu::unload()
+{
+	voice_count_ = 0;
+	clear_track_vars();
+	Gme_File::unload();
+}
+
+Music_Emu::gme_t()
+{
+	effects_buffer_ = NULL;
+	sample_rate_    = 0;
+	mute_mask_      = 0;
+	tempo_          = 1.0;
+	gain_           = 1.0;
+	
+	// defaults
+	tfilter = track_filter.setup();
+	set_max_initial_silence( 15 );
+	set_silence_lookahead( 3 );
+	ignore_silence( false );
+	
+	equalizer_.treble = -1.0;
+	equalizer_.bass   = 60;
+	
+	static const char* const names [] = {
+		"Voice 1", "Voice 2", "Voice 3", "Voice 4",
+		"Voice 5", "Voice 6", "Voice 7", "Voice 8"
+	};
+	set_voice_names( names );
+	Music_Emu::unload(); // clears fields
+}
+
+Music_Emu::~gme_t()
+{
+	assert( !effects_buffer_ );
+}
+
+blargg_err_t Music_Emu::set_sample_rate( int rate )
+{
+	require( !sample_rate() ); // sample rate can't be changed once set
+	RETURN_ERR( set_sample_rate_( rate ) );
+	RETURN_ERR( track_filter.init( this ) );
+	sample_rate_ = rate;
+	tfilter.max_silence = 6 * stereo * sample_rate();
+	return blargg_ok;
+}
+
+void Music_Emu::pre_load()
+{
+	require( sample_rate() ); // set_sample_rate() must be called before loading a file
+	Gme_File::pre_load();
+}
+
+void Music_Emu::set_equalizer( equalizer_t const& eq )
+{
+	// TODO: why is GCC generating memcpy call here?
+	// Without the 'if', valgrind flags it.
+	if ( &eq != &equalizer_ )
+		equalizer_ = eq;
+	set_equalizer_( eq );
+}
+
+void Music_Emu::mute_voice( int index, bool mute )
+{
+	require( (unsigned) index < (unsigned) voice_count() );
+	int bit = 1 << index;
+	int mask = mute_mask_ | bit;
+	if ( !mute )
+		mask ^= bit;
+	mute_voices( mask );
+}
+
+void Music_Emu::mute_voices( int mask )
+{
+	require( sample_rate() ); // sample rate must be set first
+	mute_mask_ = mask;
+	mute_voices_( mask );
+}
+
+const char* Music_Emu::voice_name( int i ) const
+{
+	if ( (unsigned) i < (unsigned) voice_count_ )
+		return voice_names_ [i];
+	
+	//check( false ); // TODO: enable?
+	return "";
+}
+
+void Music_Emu::set_tempo( double t )
+{
+	require( sample_rate() ); // sample rate must be set first
+	double const min = 0.02;
+	double const max = 4.00;
+	if ( t < min ) t = min;
+	if ( t > max ) t = max;
+	tempo_ = t;
+	set_tempo_( t );
+}
+
+blargg_err_t Music_Emu::post_load()
+{
+	set_tempo( tempo_ );
+	remute_voices();
+	return Gme_File::post_load();
+}
+
+// Tell/Seek
+
+int Music_Emu::msec_to_samples( int msec ) const
+{
+	int sec = msec / 1000;
+	msec -= sec * 1000;
+	return (sec * sample_rate() + msec * sample_rate() / 1000) * stereo;
+}
+
+int Music_Emu::tell() const
+{
+	int rate = sample_rate() * stereo;
+	int sec = track_filter.sample_count() / rate;
+	return sec * 1000 + (track_filter.sample_count() - sec * rate) * 1000 / rate;
+}
+
+blargg_err_t Music_Emu::seek( int msec )
+{
+	int time = msec_to_samples( msec );
+	if ( time < track_filter.sample_count() )
+		RETURN_ERR( start_track( current_track_ ) );
+	return skip( time - track_filter.sample_count() );
+}
+
+blargg_err_t Music_Emu::skip( int count )
+{
+	require( current_track() >= 0 ); // start_track() must have been called already
+	return track_filter.skip( count );
+}
+
+blargg_err_t Music_Emu::skip_( int count )
+{
+	// for long skip, mute sound
+	const int threshold = 32768;
+	if ( count > threshold )
+	{
+		int saved_mute = mute_mask_;
+		mute_voices( ~0 );
+		
+		int n = count - threshold/2;
+		n &= ~(2048-1); // round to multiple of 2048
+		count -= n;
+		RETURN_ERR( track_filter.skip_( n ) );
+		
+		mute_voices( saved_mute );
+	}
+	
+	return track_filter.skip_( count );
+}
+
+// Playback
+
+blargg_err_t Music_Emu::start_track( int track )
+{
+	clear_track_vars();
+	
+	int remapped = track;
+	RETURN_ERR( remap_track_( &remapped ) );
+	current_track_ = track;
+	blargg_err_t err = start_track_( remapped );
+	if ( err )
+	{
+		current_track_ = -1;
+		return err;
+	}
+	
+	// convert filter times to samples
+	Track_Filter::setup_t s = tfilter;
+	s.max_initial *= sample_rate() * stereo;
+	#if GME_DISABLE_SILENCE_LOOKAHEAD
+		s.lookahead = 1;
+	#endif
+	track_filter.setup( s );
+	
+	return track_filter.start_track();
+}
+
+void Music_Emu::set_fade( int start_msec, int length_msec )
+{
+	track_filter.set_fade( msec_to_samples( start_msec ),
+			length_msec * sample_rate() / (1000 / stereo) );
+}
+
+blargg_err_t Music_Emu::play( int out_count, sample_t out [] )
+{
+	require( current_track() >= 0 );
+	require( out_count % stereo == 0 );
+	
+	return track_filter.play( out_count, out );
+}
+
+// Gme_Info_
+
+blargg_err_t Gme_Info_::set_sample_rate_( int )             { return blargg_ok; }
+void         Gme_Info_::pre_load()                          { Gme_File::pre_load(); } // skip Music_Emu
+blargg_err_t Gme_Info_::post_load()                         { return Gme_File::post_load(); } // skip Music_Emu
+void         Gme_Info_::set_equalizer_( equalizer_t const& ){ check( false ); }
+void         Gme_Info_::mute_voices_( int )                 { check( false ); }
+void         Gme_Info_::set_tempo_( double )                { }
+blargg_err_t Gme_Info_::start_track_( int )                 { return BLARGG_ERR( BLARGG_ERR_CALLER, "can't play file opened for info only" ); }
+blargg_err_t Gme_Info_::play_( int, sample_t [] )           { return BLARGG_ERR( BLARGG_ERR_CALLER, "can't play file opened for info only" ); }
diff -Nur orig/source/gme/src/Music_Emu.h mod/source/gme/src/Music_Emu.h
--- orig/source/gme/src/Music_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Music_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,242 @@
+// Common interface to game music file emulators
+
+// Game_Music_Emu 0.6-pre
+#ifndef MUSIC_EMU_H
+#define MUSIC_EMU_H
+
+#include "Gme_File.h"
+#include "Track_Filter.h"
+class Multi_Buffer;
+
+struct gme_t : public Gme_File, private Track_Filter::callbacks_t {
+public:
+	// Sets output sample rate. Must be called only once before loading file.
+	blargg_err_t set_sample_rate( int sample_rate );
+
+	// Sample rate sound is generated at
+	int sample_rate() const;
+	
+// File loading
+
+	// See Gme_Loader.h
+
+// Basic playback
+
+	// Starts a track, where 0 is the first track. Also clears warning string.
+	blargg_err_t start_track( int );
+	
+	// Generates 'count' samples info 'buf'. Output is in stereo. Any emulation
+	// errors set warning string, and major errors also end track.
+	typedef short sample_t;
+	blargg_err_t play( int count, sample_t* buf );
+	
+// Track information
+	
+	// See Gme_File.h
+	
+	// Index of current track or -1 if one hasn't been started
+	int current_track() const;
+
+	// Info for currently playing track
+	Gme_File::track_info;
+	blargg_err_t track_info( track_info_t* out ) const;
+	
+// Track status/control
+
+	// Number of milliseconds played since beginning of track (1000 per second)
+	int tell() const;
+	
+	// Seeks to new time in track. Seeking backwards or far forward can take a while.
+	blargg_err_t seek( int msec );
+	
+	// Skips n samples
+	blargg_err_t skip( int n );
+	
+	// True if a track has reached its end
+	bool track_ended() const;
+	
+	// Sets start time and length of track fade out. Once fade ends track_ended() returns
+	// true. Fade time must be set after track has been started, and can be changed
+	// at any time.
+	void set_fade( int start_msec, int length_msec = 8000 );
+	
+	// Disables automatic end-of-track detection and skipping of silence at beginning
+	void ignore_silence( bool disable = true );
+
+	int msec_to_samples( int msec ) const;
+
+// Voices
+
+	// Number of voices used by currently loaded file
+	int voice_count() const;
+	
+	// Name of voice i, from 0 to voice_count()-1
+	const char* voice_name( int i ) const;
+	
+	// Mutes/unmutes voice i, where voice 0 is first voice
+	void mute_voice( int index, bool mute = true );
+	
+	// Sets muting state of all voices at once using a bit mask, where -1 mutes them all,
+	// 0 unmutes them all, 0x01 mutes just the first voice, etc.
+	void mute_voices( int mask );
+
+// Sound customization
+	
+	// Adjusts song tempo, where 1.0 = normal, 0.5 = half speed, 2.0 = double speed.
+	// Track length as returned by track_info() assumes a tempo of 1.0.
+	void set_tempo( double );
+	
+	// Changes overall output amplitude, where 1.0 results in minimal clamping.
+	// Must be called before set_sample_rate().
+	void set_gain( double );
+	
+	// Requests use of custom multichannel buffer. Only supported by "classic" emulators;
+	// on others this has no effect. Should be called only once *before* set_sample_rate().
+	virtual void set_buffer( class Multi_Buffer* ) { }
+	
+// Sound equalization (treble/bass)
+
+	// Frequency equalizer parameters (see gme.txt)
+	// See gme.h for definition of struct gme_equalizer_t.
+	typedef gme_equalizer_t equalizer_t;
+	
+	// Current frequency equalizater parameters
+	equalizer_t const& equalizer() const;
+	
+	// Sets frequency equalizer parameters
+	void set_equalizer( equalizer_t const& );
+	
+	// Equalizer preset for a TV speaker
+	static equalizer_t const tv_eq;
+	
+// Derived interface
+protected:
+	// Cause any further generated samples to be silence, instead of calling play_()
+	void set_track_ended()                      { track_filter.set_track_ended(); }
+	
+	// If more than secs of silence are encountered, track is ended
+	void set_max_initial_silence( int secs )    { tfilter.max_initial = secs; }
+	
+	// Sets rate emulator is run at when scanning ahead for silence. 1=100%, 2=200% etc.
+	void set_silence_lookahead( int rate )      { tfilter.lookahead = rate; }
+	
+	// Sets number of voices
+	void set_voice_count( int n )               { voice_count_ = n; }
+	
+	// Sets names of voices
+	void set_voice_names( const char* const names [] );
+	
+	// Current gain
+	double gain() const                         { return gain_; }
+	
+	// Current tempo
+	double tempo() const                        { return tempo_; }
+	
+	// Re-applies muting mask using mute_voices_()
+	void remute_voices();
+	
+// Overrides should do the indicated task
+	
+	// Set sample rate as close as possible to sample_rate, then call
+	// Music_Emu::set_sample_rate_() with the actual rate used.
+	virtual blargg_err_t set_sample_rate_( int sample_rate )    BLARGG_PURE( ; )
+	
+	// Set equalizer parameters
+	virtual void set_equalizer_( equalizer_t const& )           { }
+	
+	// Mute voices based on mask
+	virtual void mute_voices_( int mask )                       BLARGG_PURE( ; )
+	
+	// Set tempo to t, which is constrained to the range 0.02 to 4.0.
+	virtual void set_tempo_( double t )                         BLARGG_PURE( ; )
+	
+	// Start track t, where 0 is the first track
+	virtual blargg_err_t start_track_( int t )                  BLARGG_PURE( ; ) // tempo is set before this
+	
+	// Generate count samples into *out. Count will always be even.
+	virtual blargg_err_t play_( int count, sample_t out [] )    BLARGG_PURE( ; )
+	
+	// Skip count samples. Count will always be even.
+	virtual blargg_err_t skip_( int count );
+
+
+// Implementation
+public:
+	gme_t();
+	~gme_t();
+	BLARGG_DEPRECATED( const char** voice_names() const { return CONST_CAST(const char**,voice_names_); } )
+
+protected:
+	virtual void unload();
+	virtual void pre_load();
+	virtual blargg_err_t post_load();
+
+private:
+	Track_Filter::setup_t tfilter;
+	Track_Filter track_filter;
+	equalizer_t equalizer_;
+	const char* const* voice_names_;
+	int voice_count_;
+	int mute_mask_;
+	double tempo_;
+	double gain_;
+	int sample_rate_;
+	int current_track_;
+	
+	void clear_track_vars();
+	
+	friend Music_Emu* gme_new_emu( gme_type_t, int );
+	friend void gme_effects( Music_Emu const*, gme_effects_t* );
+	friend void gme_set_effects( Music_Emu*, gme_effects_t const* );
+	friend void gme_set_stereo_depth( Music_Emu*, double );
+	friend const char** gme_voice_names ( Music_Emu const* );
+	
+protected:
+	Multi_Buffer* effects_buffer_;
+};
+
+// base class for info-only derivations
+struct Gme_Info_ : Music_Emu
+{
+	virtual blargg_err_t set_sample_rate_( int sample_rate );
+	virtual void set_equalizer_( equalizer_t const& );
+	virtual void mute_voices_( int mask );
+	virtual void set_tempo_( double );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t play_( int count, sample_t out [] );
+	virtual void pre_load();
+	virtual blargg_err_t post_load();
+};
+
+inline blargg_err_t Music_Emu::track_info( track_info_t* out ) const
+{
+	return track_info( out, current_track_ );
+}
+
+inline int Music_Emu::sample_rate() const           { return sample_rate_; }
+inline int Music_Emu::voice_count() const           { return voice_count_; }
+inline int Music_Emu::current_track() const         { return current_track_; }
+inline bool Music_Emu::track_ended() const          { return track_filter.track_ended(); }
+inline const Music_Emu::equalizer_t& Music_Emu::equalizer() const { return equalizer_; }
+
+inline void Music_Emu::ignore_silence( bool b )     { track_filter.ignore_silence( b ); }
+inline void Music_Emu::set_tempo_( double t )       { tempo_ = t; }
+inline void Music_Emu::remute_voices()              { mute_voices( mute_mask_ ); }
+
+inline void Music_Emu::set_voice_names( const char* const p [] ) { voice_names_ = p; }
+
+inline void Music_Emu::mute_voices_( int ) { }
+
+inline void Music_Emu::set_gain( double g )
+{
+	assert( !sample_rate() ); // you must set gain before setting sample rate
+	gain_ = g;
+}
+
+inline blargg_err_t Music_Emu::start_track_( int )  { return blargg_ok; }
+
+inline blargg_err_t Music_Emu::set_sample_rate_( int ) { return blargg_ok; }
+
+inline blargg_err_t Music_Emu::play_( int, sample_t [] ) { return blargg_ok; }
+
+#endif
diff -Nur orig/source/gme/src/Nes_Apu.cpp mod/source/gme/src/Nes_Apu.cpp
--- orig/source/gme/src/Nes_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,392 @@
+// Nes_Snd_Emu 0.2.0-pre. http://www.slack.net/~ant/
+
+#include "Nes_Apu.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const amp_range = 15;
+
+Nes_Apu::Nes_Apu() :
+	square1( &square_synth ),
+	square2( &square_synth )
+{
+	tempo_ = 1.0;
+	dmc.apu = this;
+	
+	oscs [0] = &square1;
+	oscs [1] = &square2;
+	oscs [2] = &triangle;
+	oscs [3] = &noise;
+	oscs [4] = &dmc;
+	
+	set_output( NULL );
+	dmc.nonlinear = false;
+	volume( 1.0 );
+	reset( false );
+}
+
+void Nes_Apu::treble_eq( const blip_eq_t& eq )
+{
+	square_synth  .treble_eq( eq );
+	triangle.synth.treble_eq( eq );
+	noise   .synth.treble_eq( eq );
+	dmc     .synth.treble_eq( eq );
+}
+
+void Nes_Apu::enable_nonlinear_( double sq, double tnd )
+{
+	dmc.nonlinear = true;
+	square_synth.volume( sq );
+	
+	triangle.synth.volume( tnd * 2.752 );
+	noise   .synth.volume( tnd * 1.849 );
+	dmc     .synth.volume( tnd );
+	
+	square1 .last_amp = 0;
+	square2 .last_amp = 0;
+	triangle.last_amp = 0;
+	noise   .last_amp = 0;
+	dmc     .last_amp = 0;
+}
+
+void Nes_Apu::volume( double v )
+{
+	if ( !dmc.nonlinear )
+	{
+		v *= 1.0 / 1.11; // TODO: merge into values below
+		square_synth  .volume( 0.125 / amp_range * v ); // was 0.1128   1.108
+		triangle.synth.volume( 0.150 / amp_range * v ); // was 0.12765  1.175
+		noise   .synth.volume( 0.095 / amp_range * v ); // was 0.0741   1.282
+		dmc     .synth.volume( 0.450 / 2048      * v ); // was 0.42545  1.058
+	}
+}
+
+void Nes_Apu::set_output( Blip_Buffer* buffer )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		set_output( i, buffer );
+}
+
+void Nes_Apu::set_tempo( double t )
+{
+	tempo_ = t;
+	frame_period = (dmc.pal_mode ? 8314 : 7458);
+	if ( t != 1.0 )
+		frame_period = (int) (frame_period / t) & ~1; // must be even
+}
+
+void Nes_Apu::reset( bool pal_mode, int initial_dmc_dac )
+{
+	dmc.pal_mode = pal_mode;
+	set_tempo( tempo_ );
+	
+	square1.reset();
+	square2.reset();
+	triangle.reset();
+	noise.reset();
+	dmc.reset();
+	
+	last_time = 0;
+	last_dmc_time = 0;
+	osc_enables = 0;
+	irq_flag = false;
+	earliest_irq_ = no_irq;
+	frame_delay = 1;
+	write_register( 0, 0x4017, 0x00 );
+	write_register( 0, 0x4015, 0x00 );
+	
+	for ( int addr = io_addr; addr <= 0x4013; addr++ )
+		write_register( 0, addr, (addr & 3) ? 0x00 : 0x10 );
+	
+	dmc.dac = initial_dmc_dac;
+	if ( !dmc.nonlinear )
+		triangle.last_amp = 15;
+	if ( !dmc.nonlinear ) // TODO: remove?
+		dmc.last_amp = initial_dmc_dac; // prevent output transition
+}
+
+void Nes_Apu::irq_changed()
+{
+	blip_time_t new_irq = dmc.next_irq;
+	if ( dmc.irq_flag | irq_flag ) {
+		new_irq = 0;
+	}
+	else if ( new_irq > next_irq ) {
+		new_irq = next_irq;
+	}
+	
+	if ( new_irq != earliest_irq_ ) {
+		earliest_irq_ = new_irq;
+		if ( irq_notifier.f )
+			irq_notifier.f( irq_notifier.data );
+	}
+}
+
+// frames
+
+void Nes_Apu::run_until( blip_time_t end_time )
+{
+	require( end_time >= last_dmc_time );
+	if ( end_time > next_dmc_read_time() )
+	{
+		blip_time_t start = last_dmc_time;
+		last_dmc_time = end_time;
+		dmc.run( start, end_time );
+	}
+}
+
+void Nes_Apu::run_until_( blip_time_t end_time )
+{
+	require( end_time >= last_time );
+	
+	if ( end_time == last_time )
+		return;
+	
+	if ( last_dmc_time < end_time )
+	{
+		blip_time_t start = last_dmc_time;
+		last_dmc_time = end_time;
+		dmc.run( start, end_time );
+	}
+	
+	while ( true )
+	{
+		// earlier of next frame time or end time
+		blip_time_t time = last_time + frame_delay;
+		if ( time > end_time )
+			time = end_time;
+		frame_delay -= time - last_time;
+		
+		// run oscs to present
+		square1.run( last_time, time );
+		square2.run( last_time, time );
+		triangle.run( last_time, time );
+		noise.run( last_time, time );
+		last_time = time;
+		
+		if ( time == end_time )
+			break; // no more frames to run
+		
+		// take frame-specific actions
+		frame_delay = frame_period;
+		switch ( frame++ )
+		{
+			case 0:
+				if ( !(frame_mode & 0xC0) ) {
+		 			next_irq = time + frame_period * 4 + 2;
+		 			irq_flag = true;
+		 		}
+		 		// fall through
+		 	case 2:
+		 		// clock length and sweep on frames 0 and 2
+				square1.clock_length( 0x20 );
+				square2.clock_length( 0x20 );
+				noise.clock_length( 0x20 );
+				triangle.clock_length( 0x80 ); // different bit for halt flag on triangle
+				
+				square1.clock_sweep( -1 );
+				square2.clock_sweep( 0 );
+				
+				// frame 2 is slightly shorter in mode 1
+				if ( dmc.pal_mode && frame == 3 )
+					frame_delay -= 2;
+		 		break;
+		 	
+			case 1:
+				// frame 1 is slightly shorter in mode 0
+				if ( !dmc.pal_mode )
+					frame_delay -= 2;
+				break;
+			
+		 	case 3:
+		 		frame = 0;
+		 		
+		 		// frame 3 is almost twice as long in mode 1
+		 		if ( frame_mode & 0x80 )
+					frame_delay += frame_period - (dmc.pal_mode ? 2 : 6);
+				break;
+		}
+		
+		// clock envelopes and linear counter every frame
+		triangle.clock_linear_counter();
+		square1.clock_envelope();
+		square2.clock_envelope();
+		noise.clock_envelope();
+	}
+}
+
+template<class T>
+inline void zero_apu_osc( T* osc, blip_time_t time )
+{
+	Blip_Buffer* output = osc->output;
+	int last_amp = osc->last_amp;
+	osc->last_amp = 0;
+	if ( output && last_amp )
+		osc->synth.offset( time, -last_amp, output );
+}
+
+void Nes_Apu::end_frame( blip_time_t end_time )
+{
+	if ( end_time > last_time )
+		run_until_( end_time );
+	
+	if ( dmc.nonlinear )
+	{
+		zero_apu_osc( &square1,  last_time );
+		zero_apu_osc( &square2,  last_time );
+		zero_apu_osc( &triangle, last_time );
+		zero_apu_osc( &noise,    last_time );
+		zero_apu_osc( &dmc,      last_time );
+	}
+	
+	// make times relative to new frame
+	last_time -= end_time;
+	require( last_time >= 0 );
+	
+	last_dmc_time -= end_time;
+	require( last_dmc_time >= 0 );
+	
+	if ( next_irq != no_irq ) {
+		next_irq -= end_time;
+		check( next_irq >= 0 );
+	}
+	if ( dmc.next_irq != no_irq ) {
+		dmc.next_irq -= end_time;
+		check( dmc.next_irq >= 0 );
+	}
+	if ( earliest_irq_ != no_irq ) {
+		earliest_irq_ -= end_time;
+		if ( earliest_irq_ < 0 )
+			earliest_irq_ = 0;
+	}
+}
+
+// registers
+
+static const unsigned char length_table [0x20] = {
+	0x0A, 0xFE, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06,
+	0xA0, 0x08, 0x3C, 0x0A, 0x0E, 0x0C, 0x1A, 0x0E, 
+	0x0C, 0x10, 0x18, 0x12, 0x30, 0x14, 0x60, 0x16,
+	0xC0, 0x18, 0x48, 0x1A, 0x10, 0x1C, 0x20, 0x1E
+};
+
+void Nes_Apu::write_register( blip_time_t time, int addr, int data )
+{
+	require( addr > 0x20 ); // addr must be actual address (i.e. 0x40xx)
+	require( (unsigned) data <= 0xFF );
+	
+	// Ignore addresses outside range
+	if ( unsigned (addr - io_addr) >= io_size )
+		return;
+	
+	run_until_( time );
+	
+	if ( addr < 0x4014 )
+	{
+		// Write to channel
+		int osc_index = (addr - io_addr) >> 2;
+		Nes_Osc* osc = oscs [osc_index];
+		
+		int reg = addr & 3;
+		osc->regs [reg] = data;
+		osc->reg_written [reg] = true;
+		
+		if ( osc_index == 4 )
+		{
+			// handle DMC specially
+			dmc.write_register( reg, data );
+		}
+		else if ( reg == 3 )
+		{
+			// load length counter
+			if ( (osc_enables >> osc_index) & 1 )
+				osc->length_counter = length_table [(data >> 3) & 0x1F];
+			
+			// reset square phase
+			if ( osc_index < 2 )
+				((Nes_Square*) osc)->phase = Nes_Square::phase_range - 1;
+		}
+	}
+	else if ( addr == 0x4015 )
+	{
+		// Channel enables
+		for ( int i = osc_count; i--; )
+			if ( !((data >> i) & 1) )
+				oscs [i]->length_counter = 0;
+		
+		bool recalc_irq = dmc.irq_flag;
+		dmc.irq_flag = false;
+		
+		int old_enables = osc_enables;
+		osc_enables = data;
+		if ( !(data & 0x10) ) {
+			dmc.next_irq = no_irq;
+			recalc_irq = true;
+		}
+		else if ( !(old_enables & 0x10) ) {
+			dmc.start(); // dmc just enabled
+		}
+		
+		if ( recalc_irq )
+			irq_changed();
+	}
+	else if ( addr == 0x4017 )
+	{
+		// Frame mode
+		frame_mode = data;
+		
+		bool irq_enabled = !(data & 0x40);
+		irq_flag &= irq_enabled;
+		next_irq = no_irq;
+		
+		// mode 1
+		frame_delay = (frame_delay & 1);
+		frame = 0;
+		
+		if ( !(data & 0x80) )
+		{
+			// mode 0
+			frame = 1;
+			frame_delay += frame_period;
+			if ( irq_enabled )
+				next_irq = time + frame_delay + frame_period * 3 + 1;
+		}
+		
+		irq_changed();
+	}
+}
+
+int Nes_Apu::read_status( blip_time_t time )
+{
+	run_until_( time - 1 );
+	
+	int result = (dmc.irq_flag << 7) | (irq_flag << 6);
+	
+	for ( int i = 0; i < osc_count; i++ )
+		if ( oscs [i]->length_counter )
+			result |= 1 << i;
+	
+	run_until_( time );
+	
+	if ( irq_flag )
+	{
+		result |= 0x40;
+		irq_flag = false;
+		irq_changed();
+	}
+	
+	//dprintf( "%6d/%d Read $4015->$%02X\n", frame_delay, frame, result );
+	
+	return result;
+}
diff -Nur orig/source/gme/src/Nes_Apu.h mod/source/gme/src/Nes_Apu.h
--- orig/source/gme/src/Nes_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,181 @@
+// NES 2A03 APU sound chip emulator
+
+// Nes_Snd_Emu 0.2.0-pre
+#ifndef NES_APU_H
+#define NES_APU_H
+
+#include "blargg_common.h"
+#include "Nes_Oscs.h"
+
+struct apu_state_t;
+class Nes_Buffer;
+
+class Nes_Apu {
+public:
+// Basics
+
+	typedef int nes_time_t; // NES CPU clock cycle count
+	
+	// Sets memory reader callback used by DMC oscillator to fetch samples.
+	// When callback is invoked, 'user_data' is passed unchanged as the
+	// first parameter.
+	//void dmc_reader( int (*callback)( void* user_data, int addr ), void* user_data = NULL );
+	
+	// Sets buffer to generate sound into, or 0 to mute output (reduces
+	// emulation accuracy).
+	void set_output( Blip_Buffer* );
+	
+	// All time values are the number of CPU clock cycles relative to the
+	// beginning of the current time frame. Before resetting the CPU clock
+	// count, call end_frame( last_cpu_time ).
+	
+	// Writes to register (0x4000-0x4013, and 0x4015 and 0x4017)
+	enum { io_addr = 0x4000 };
+	enum { io_size = 0x18 };
+	void write_register( nes_time_t, int addr, int data );
+	
+	// Reads from status register (0x4015)
+	enum { status_addr = 0x4015 };
+	int read_status( nes_time_t );
+	
+	// Runs all oscillators up to specified time, ends current time frame, then
+	// starts a new time frame at time 0. Time frames have no effect on emulation
+	// and each can be whatever length is convenient.
+	void end_frame( nes_time_t );
+	
+// Optional
+
+	// Resets internal frame counter, registers, and all oscillators.
+	// Uses PAL timing if pal_timing is true, otherwise use NTSC timing.
+	// Sets the DMC oscillator's initial DAC value to initial_dmc_dac without
+	// any audible click.
+	void reset( bool pal_mode = false, int initial_dmc_dac = 0 );
+	
+	// Same as set_output(), but for a particular channel
+	// 0: Square 1, 1: Square 2, 2: Triangle, 3: Noise, 4: DMC
+	enum { osc_count = 5 };
+	void set_output( int chan, Blip_Buffer* buf );
+	
+	// Adjusts frame period
+	void set_tempo( double );
+	
+	// Saves/loads exact emulation state
+	void save_state( apu_state_t* out ) const;
+	void load_state( apu_state_t const& );
+	
+	// Sets overall volume (default is 1.0)
+	void volume( double );
+	
+	// Sets treble equalization (see notes.txt)
+	void treble_eq( const blip_eq_t& );
+	
+	// Sets IRQ time callback that is invoked when the time of earliest IRQ
+	// may have changed, or NULL to disable. When callback is invoked,
+	// 'user_data' is passed unchanged as the first parameter.
+	//void irq_notifier( void (*callback)( void* user_data ), void* user_data = NULL );
+	
+	// Gets time that APU-generated IRQ will occur if no further register reads
+	// or writes occur. If IRQ is already pending, returns irq_waiting. If no
+	// IRQ will occur, returns no_irq.
+	enum { no_irq = INT_MAX/2 + 1 };
+	enum { irq_waiting = 0 };
+	nes_time_t earliest_irq( nes_time_t ) const;
+	
+	// Counts number of DMC reads that would occur if 'run_until( t )' were executed.
+	// If last_read is not NULL, set *last_read to the earliest time that
+	// 'count_dmc_reads( time )' would result in the same result.
+	int count_dmc_reads( nes_time_t t, nes_time_t* last_read = NULL ) const;
+	
+	// Time when next DMC memory read will occur
+	nes_time_t next_dmc_read_time() const;
+	
+	// Runs DMC until specified time, so that any DMC memory reads can be
+	// accounted for (i.e. inserting CPU wait states).
+	void run_until( nes_time_t );
+	
+
+// Implementation
+public:
+	Nes_Apu();
+	BLARGG_DISABLE_NOTHROW
+	// Use set_output() in place of these
+	BLARGG_DEPRECATED( void output    (        Blip_Buffer* c ); )
+	BLARGG_DEPRECATED( void osc_output( int i, Blip_Buffer* c ); )
+	
+	BLARGG_DEPRECATED_TEXT( enum { start_addr = 0x4000 }; )
+	BLARGG_DEPRECATED_TEXT( enum { end_addr   = 0x4017 }; )
+	
+	blargg_callback<int (*)( void* user_data, int addr )> dmc_reader;
+	blargg_callback<void (*)( void* user_data )> irq_notifier;
+
+	void enable_nonlinear_( double sq, double tnd );
+	static float tnd_total_() { return 196.015f; }
+	
+private:
+	friend struct Nes_Dmc;
+	
+	// noncopyable
+	Nes_Apu( const Nes_Apu& );
+	Nes_Apu& operator = ( const Nes_Apu& );
+	
+	Nes_Osc*            oscs [osc_count];
+	Nes_Square          square1;
+	Nes_Square          square2;
+	Nes_Noise           noise;
+	Nes_Triangle        triangle;
+	Nes_Dmc             dmc;
+	
+	double tempo_;
+	nes_time_t last_time; // has been run until this time in current frame
+	nes_time_t last_dmc_time;
+	nes_time_t earliest_irq_;
+	nes_time_t next_irq;
+	int frame_period;
+	int frame_delay; // cycles until frame counter runs next
+	int frame; // current frame (0-3)
+	int osc_enables;
+	int frame_mode;
+	bool irq_flag;
+	Nes_Square::Synth square_synth; // shared by squares
+	
+	void irq_changed();
+	void state_restored();
+	void run_until_( nes_time_t );
+	
+	// TODO: remove
+	friend class Nes_Core;
+};
+
+inline void Nes_Apu::set_output( int osc, Blip_Buffer* buf )
+{
+	assert( (unsigned) osc < osc_count );
+	oscs [osc]->output = buf;
+}
+
+inline Nes_Apu::nes_time_t Nes_Apu::earliest_irq( nes_time_t ) const
+{
+	return earliest_irq_;
+}
+
+inline int Nes_Apu::count_dmc_reads( nes_time_t time, nes_time_t* last_read ) const
+{
+	return dmc.count_reads( time, last_read );
+}
+	
+inline Nes_Apu::nes_time_t Nes_Dmc::next_read_time() const
+{
+	if ( length_counter == 0 )
+		return Nes_Apu::no_irq; // not reading
+	
+	return apu->last_dmc_time + delay + (bits_remain - 1) * period;
+}
+
+inline Nes_Apu::nes_time_t Nes_Apu::next_dmc_read_time() const { return dmc.next_read_time(); }
+
+BLARGG_DEPRECATED( typedef int      nes_time_t; ) // use your own typedef
+BLARGG_DEPRECATED( typedef unsigned nes_addr_t; ) // use your own typedef
+
+BLARGG_DEPRECATED_TEXT( inline void Nes_Apu::output    (        Blip_Buffer* c ) { set_output( c    ); } )
+BLARGG_DEPRECATED_TEXT( inline void Nes_Apu::osc_output( int i, Blip_Buffer* c ) { set_output( i, c ); } )
+
+#endif
diff -Nur orig/source/gme/src/Nes_Cpu.cpp mod/source/gme/src/Nes_Cpu.cpp
--- orig/source/gme/src/Nes_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,62 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nes_Cpu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+inline void Nes_Cpu::set_code_page( int i, void const* p )
+{
+	byte const* p2 = STATIC_CAST(byte const*,p) - NES_CPU_OFFSET( i * page_size );
+	cpu_state->code_map [i] = p2;
+	cpu_state_.code_map [i] = p2;
+}
+
+void Nes_Cpu::map_code( addr_t start, int size, void const* data, int mirror_size )
+{
+	// address range must begin and end on page boundaries
+	require( start % page_size == 0 );
+	require( size  % page_size == 0 );
+	require( start + size <= 0x10000 );
+	require( mirror_size % page_size == 0 );
+	
+	for ( int offset = 0; offset < size; offset += page_size )
+		set_code_page( NES_CPU_PAGE( start + offset ),
+				STATIC_CAST(char const*,data) + (offset & ((unsigned) mirror_size - 1)) );
+}
+
+void Nes_Cpu::reset( void const* unmapped_page )
+{
+	check( cpu_state == &cpu_state_ );
+	cpu_state = &cpu_state_;
+	
+	r.flags = irq_inhibit_mask;
+	r.sp = 0xFF;
+	r.pc = 0;
+	r.a  = 0;
+	r.x  = 0;
+	r.y  = 0;
+	
+	cpu_state_.time = 0;
+	cpu_state_.base = 0;
+	irq_time_ = future_time;
+	end_time_ = future_time;
+	error_count_ = 0;
+	
+	set_code_page( page_count, unmapped_page );
+	map_code( 0, 0x10000, unmapped_page, page_size );
+	
+	blargg_verify_byte_order();
+}
diff -Nur orig/source/gme/src/Nes_Cpu.h mod/source/gme/src/Nes_Cpu.h
--- orig/source/gme/src/Nes_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,131 @@
+// NES CPU emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef NES_CPU_H
+#define NES_CPU_H
+
+#include "blargg_common.h"
+
+class Nes_Cpu {
+public:
+	typedef BOOST::uint8_t byte;
+	typedef int time_t;
+	typedef int addr_t;
+	enum { future_time = INT_MAX/2 + 1 };
+	
+	// Clears registers and maps all pages to unmapped_page
+	void reset( void const* unmapped_page = NULL );
+	
+	// Maps code memory (memory accessed via the program counter). Start and size
+	// must be multiple of page_size. If mirror_size is non-zero, the first
+	// mirror_size bytes are repeated over the range. mirror_size must be a
+	// multiple of page_size.
+	enum { page_bits = 11 };
+	enum { page_size = 1 << page_bits };
+	void map_code( addr_t start, int size, void const* code, int mirror_size = 0 );
+	
+	// Accesses emulated memory as CPU does
+	byte const* get_code( addr_t ) const;
+	
+	// NES 6502 registers. NOT kept updated during emulation.
+	struct registers_t {
+		BOOST::uint16_t pc;
+		byte a;
+		byte x;
+		byte y;
+		byte flags;
+		byte sp;
+	};
+	registers_t r;
+	
+	// Time of beginning of next instruction to be executed
+	time_t time() const             { return cpu_state->time + cpu_state->base; }
+	void set_time( time_t t )       { cpu_state->time = t - cpu_state->base; }
+	void adjust_time( int delta )   { cpu_state->time += delta; }
+	
+	// Clocks past end (negative if before)
+	int time_past_end() const       { return cpu_state->time; }
+	
+	// Time of next IRQ
+	time_t irq_time() const         { return irq_time_; }
+	void set_irq_time( time_t );
+	
+	// Emulation stops once time >= end_time
+	time_t end_time() const         { return end_time_; }
+	void set_end_time( time_t );
+	
+	// Number of unimplemented instructions encountered and skipped
+	void clear_error_count()        { error_count_ = 0; }
+	unsigned error_count() const    { return error_count_; }
+	void count_error()              { error_count_++; }
+	
+	// Unmapped page should be filled with this
+	enum { halt_opcode = 0x22 };
+	
+	enum { irq_inhibit_mask = 0x04 };
+	
+	// Can read this many bytes past end of a page
+	enum { cpu_padding = 8 };
+
+private:
+	// noncopyable
+	Nes_Cpu( const Nes_Cpu& );
+	Nes_Cpu& operator = ( const Nes_Cpu& );
+
+
+// Implementation
+public:
+	Nes_Cpu() { cpu_state = &cpu_state_; }
+	enum { page_count = 0x10000 >> page_bits };
+	
+	struct cpu_state_t {
+		byte const* code_map [page_count + 1];
+		time_t base;
+		int time;
+	};
+	cpu_state_t* cpu_state; // points to cpu_state_ or a local copy
+	cpu_state_t cpu_state_;
+	time_t irq_time_;
+	time_t end_time_;
+	unsigned error_count_;
+	
+private:
+	void set_code_page( int, void const* );
+	inline void update_end_time( time_t end, time_t irq );
+};
+
+#define NES_CPU_PAGE( addr ) ((unsigned) (addr) >> Nes_Cpu::page_bits)
+
+#if BLARGG_NONPORTABLE
+	#define NES_CPU_OFFSET( addr ) (addr)
+#else
+	#define NES_CPU_OFFSET( addr ) ((addr) & (Nes_Cpu::page_size - 1))
+#endif
+
+inline BOOST::uint8_t const* Nes_Cpu::get_code( addr_t addr ) const
+{
+	return cpu_state_.code_map [NES_CPU_PAGE( addr )] + NES_CPU_OFFSET( addr );
+}
+
+inline void Nes_Cpu::update_end_time( time_t end, time_t irq )
+{
+	if ( end > irq && !(r.flags & irq_inhibit_mask) )
+		end = irq;
+	
+	cpu_state->time += cpu_state->base - end;
+	cpu_state->base = end;
+}
+
+inline void Nes_Cpu::set_irq_time( time_t t )
+{
+	irq_time_ = t;
+	update_end_time( end_time_, t );
+}
+
+inline void Nes_Cpu::set_end_time( time_t t )
+{
+	end_time_ = t;
+	update_end_time( t, irq_time_ );
+}   
+
+#endif
diff -Nur orig/source/gme/src/nes_cpu_io.h mod/source/gme/src/nes_cpu_io.h
--- orig/source/gme/src/nes_cpu_io.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/nes_cpu_io.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,83 @@
+
+#include "Nsf_Emu.h"
+
+#if !NSF_EMU_APU_ONLY
+	#include "Nes_Namco_Apu.h"
+#endif
+
+#include "blargg_source.h"
+
+int Nsf_Emu::cpu_read( nes_addr_t addr )
+{
+	int result;
+	
+	result = cpu::low_mem [addr & 0x7FF];
+	if ( !(addr & 0xE000) )
+		goto exit;
+	
+	result = *cpu::get_code( addr );
+	if ( addr > 0x7FFF )
+		goto exit;
+	
+	result = sram [addr & (sizeof sram - 1)];
+	if ( addr > 0x5FFF )
+		goto exit;
+	
+	if ( addr == Nes_Apu::status_addr )
+		return apu.read_status( cpu::time() );
+	
+	#if !NSF_EMU_APU_ONLY
+		if ( addr == Nes_Namco_Apu::data_reg_addr && namco )
+			return namco->read_data();
+	#endif
+	
+	result = addr >> 8; // simulate open bus
+	
+	if ( addr != 0x2002 )
+		debug_printf( "Read unmapped $%.4X\n", (unsigned) addr );
+	
+exit:
+	return result;
+}
+
+void Nsf_Emu::cpu_write( nes_addr_t addr, int data )
+{
+	{
+		nes_addr_t offset = addr ^ sram_addr;
+		if ( offset < sizeof sram )
+		{
+			sram [offset] = data;
+			return;
+		}
+	}
+	{
+		int temp = addr & 0x7FF;
+		if ( !(addr & 0xE000) )
+		{
+			cpu::low_mem [temp] = data;
+			return;
+		}
+	}
+	
+	if ( unsigned (addr - Nes_Apu::start_addr) <= Nes_Apu::end_addr - Nes_Apu::start_addr )
+	{
+		GME_APU_HOOK( this, addr - Nes_Apu::start_addr, data );
+		apu.write_register( cpu::time(), addr, data );
+		return;
+	}
+	
+	unsigned bank = addr - bank_select_addr;
+	if ( bank < bank_count )
+	{
+		blargg_long offset = rom.mask_addr( data * (blargg_long) bank_size );
+		if ( offset >= rom.size() )
+			set_warning( "Invalid bank" );
+		cpu::map_code( (bank + 8) * bank_size, bank_size, rom.at_addr( offset ) );
+		return;
+	}
+	
+	cpu_write_misc( addr, data );
+}
+
+#define CPU_READ( cpu, addr, time )         STATIC_CAST(Nsf_Emu&,*cpu).cpu_read( addr )
+#define CPU_WRITE( cpu, addr, data, time )  STATIC_CAST(Nsf_Emu&,*cpu).cpu_write( addr, data )
diff -Nur orig/source/gme/src/Nes_Cpu_run.h mod/source/gme/src/Nes_Cpu_run.h
--- orig/source/gme/src/Nes_Cpu_run.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Cpu_run.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1121 @@
+// NES 6502 CPU emulator run function
+
+#if 0
+/* Define these macros in the source file before #including this file.
+- Parameters might be expressions, so they are best evaluated only once,
+though they NEVER have side-effects, so multiple evaluation is OK.
+- Output parameters might be a multiple-assignment expression like "a=x",
+so they must NOT be parenthesized.
+- Except where noted, time() and related functions will NOT work
+correctly inside a macro. TIME() is always correct, and FLUSH_TIME() and
+CACHE_TIME() allow the time changing functions to work.
+- Macros "returning" void may use a {} statement block. */
+
+	// 0 <= addr <= 0xFFFF + page_size
+	// time functions can be used
+	int  READ_MEM(  addr_t );
+	void WRITE_MEM( addr_t, int data );
+	// 0 <= READ_MEM() <= 0xFF
+	
+	// 0 <= addr <= 0x1FF
+	int  READ_LOW(  addr_t );
+	void WRITE_LOW( addr_t, int data );
+	// 0 <= READ_LOW() <= 0xFF
+
+	// Often-used instructions attempt these before using a normal memory access.
+	// Optional; defaults to READ_MEM() and WRITE_MEM()
+	bool CAN_READ_FAST( addr_t ); // if true, uses result of READ_FAST
+	void READ_FAST( addr_t, int& out ); // ALWAYS called BEFORE CAN_READ_FAST
+	bool CAN_WRITE_FAST( addr_t ); // if true, uses WRITE_FAST instead of WRITE_MEM
+	void WRITE_FAST( addr_t, int data );
+
+	// Used by instructions most often used to access the NES PPU (LDA abs and BIT abs).
+	// Optional; defaults to READ_MEM.
+	void READ_PPU(  addr_t, int& out );
+	// 0 <= out <= 0xFF
+
+// The following can be used within macros:
+	
+	// Current time
+	time_t TIME();
+	
+	// Allows use of time functions
+	void FLUSH_TIME();
+	
+	// Must be used before end of macro if FLUSH_TIME() was used earlier
+	void CACHE_TIME();
+
+// Configuration (optional; commented behavior if defined)
+	
+	// Emulates dummy reads for indexed instructions
+	#define NES_CPU_DUMMY_READS 1
+	
+	// Optimizes as if map_code( 0, 0x10000 + cpu_padding, FLAT_MEM ) is always in effect
+	#define FLAT_MEM my_mem_array
+	
+	// Expanded just before beginning of code, to help debugger
+	#define CPU_BEGIN void my_run_cpu() {
+	
+#endif
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+// Allows MWCW debugger to step through code properly
+#ifdef CPU_BEGIN
+	CPU_BEGIN
+#endif
+
+// Time
+#define TIME()          (s_time + s.base)
+#define FLUSH_TIME()    {s.time = s_time - time_offset;}
+#define CACHE_TIME()    {s_time = s.time + time_offset;}
+
+// Defaults
+#ifndef CAN_WRITE_FAST
+	#define CAN_WRITE_FAST( addr )      0
+	#define WRITE_FAST( addr, data )
+#endif
+
+#ifndef CAN_READ_FAST
+	#define CAN_READ_FAST( addr )       0
+	#define READ_FAST( addr, out )
+#endif
+
+#ifndef READ_PPU
+	#define READ_PPU( addr, out )\
+	{\
+		FLUSH_TIME();\
+		out = READ_MEM( addr );\
+		CACHE_TIME();\
+	}
+#endif
+
+#define READ_STACK  READ_LOW
+#define WRITE_STACK WRITE_LOW
+
+// Dummy reads
+#if NES_CPU_DUMMY_READS
+	// TODO: optimize time handling
+	#define DUMMY_READ( addr, idx ) \
+		if ( (addr & 0xFF) < idx )\
+		{\
+			int const time_offset = 1;\
+			FLUSH_TIME();\
+			READ_MEM( (addr - 0x100) );\
+			CACHE_TIME();\
+		}
+#else
+	#define DUMMY_READ( addr, idx )
+#endif
+
+// Code
+#ifdef FLAT_MEM
+	#define CODE_PAGE(   addr ) (FLAT_MEM)
+	#define CODE_OFFSET( addr ) (addr)
+#else
+	#define CODE_PAGE( addr )   (s.code_map [NES_CPU_PAGE( addr )])
+	#define CODE_OFFSET( addr ) NES_CPU_OFFSET( addr )
+#endif
+#define READ_CODE( addr )   (CODE_PAGE( addr ) [CODE_OFFSET( addr )])
+
+// Stack
+#define SET_SP( v ) (sp = ((v) + 1) | 0x100)
+#define GET_SP()    ((sp - 1) & 0xFF)
+#define SP( o )     ((sp + (o - (o>0)*0x100)) | 0x100)
+
+// Truncation
+#define BYTE(  n ) ((BOOST::uint8_t ) (n)) /* (unsigned) n & 0xFF */
+#define SBYTE( n ) ((BOOST::int8_t  ) (n)) /* (BYTE( n ) ^ 0x80) - 0x80 */
+#define WORD(  n ) ((BOOST::uint16_t) (n)) /* (unsigned) n & 0xFFFF */
+
+// Flags with hex value for clarity when used as mask.
+// Stored in indicated variable during emulation.
+int const n80 = 0x80; // nz
+int const v40 = 0x40; // flags
+int const r20 = 0x20;
+int const b10 = 0x10;
+int const d08 = 0x08; // flags
+int const i04 = 0x04; // flags
+int const z02 = 0x02; // nz
+int const c01 = 0x01; // c
+
+#define IS_NEG (nz & 0x8080)
+
+#define GET_FLAGS( out ) \
+{\
+	out = flags & (v40 | d08 | i04);\
+	out += ((nz >> 8) | nz) & n80;\
+	out += c >> 8 & c01;\
+	if ( !BYTE( nz ) )\
+		out += z02;\
+}
+
+#define SET_FLAGS( in ) \
+{\
+	flags = in & (v40 | d08 | i04);\
+	c = nz = in << 8;\
+	nz += ~in & z02;\
+}
+
+{
+	int const time_offset = 0;
+	
+	// Local state
+	Nes_Cpu::cpu_state_t s;
+	#ifdef FLAT_MEM
+		s.base = CPU.cpu_state_.base;
+	#else
+		s = CPU.cpu_state_;
+	#endif
+	CPU.cpu_state = &s;
+	int s_time = CPU.cpu_state_.time; // helps even on x86
+	
+	// Registers
+	int pc = CPU.r.pc;
+	int a  = CPU.r.a;
+	int x  = CPU.r.x;
+	int y  = CPU.r.y;
+	int sp;
+	SET_SP( CPU.r.sp );
+	
+	// Flags
+	int flags;
+	int c;  // carry set if (c & 0x100) != 0
+	int nz; // Z set if (nz & 0xFF) == 0, N set if (nz & 0x8080) != 0
+	{
+		int temp = CPU.r.flags;
+		SET_FLAGS( temp );
+	}
+	
+loop:
+	
+	// Check all values
+	check( (unsigned) sp - 0x100 < 0x100 );
+	check( (unsigned) pc < 0x10000 );
+	check( (unsigned) a < 0x100 );
+	check( (unsigned) x < 0x100 );
+	check( (unsigned) y < 0x100 );
+	
+	// Read instruction
+	byte const* instr = CODE_PAGE( pc );
+	int opcode;
+	
+	if ( CODE_OFFSET(~0) == ~0 )
+	{
+		opcode = instr [pc];
+		pc++;
+		instr += pc;
+	}
+	else
+	{
+		instr += CODE_OFFSET( pc );
+		opcode = *instr++;
+		pc++;
+	}
+	
+	// local to function in case it helps optimizer
+	static byte const clock_table [256] =
+	{// 0 1 2 3 4 5 6 7 8 9 A B C D E F
+		0,6,2,8,3,3,5,5,3,2,2,2,4,4,6,6,// 0
+		2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,// 1
+		6,6,0,8,3,3,5,5,4,2,2,2,4,4,6,6,// 2
+		2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,// 3
+		6,6,2,8,3,3,5,5,3,2,2,2,3,4,6,6,// 4
+		2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,// 5
+		6,6,2,8,3,3,5,5,4,2,2,2,5,4,6,6,// 6
+		2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,// 7
+		2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,// 8
+		2,6,2,6,4,4,4,4,2,5,2,5,5,5,5,5,// 9
+		2,6,2,6,3,3,3,3,2,2,2,2,4,4,4,4,// A
+		2,5,2,5,4,4,4,4,2,4,2,4,4,4,4,4,// B
+		2,6,2,8,3,3,5,5,2,2,2,2,4,4,6,6,// C
+		2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7,// D
+		2,6,2,8,3,3,5,5,2,2,2,2,4,4,6,6,// E
+		2,5,2,8,4,4,6,6,2,4,2,7,4,4,7,7 // F
+	}; // 0x00 was 7 and 0x22 was 2
+	
+	// Update time
+	if ( s_time >= 0 )
+		goto out_of_time;
+	
+	#ifdef CPU_INSTR_HOOK
+	{ CPU_INSTR_HOOK( (pc-1), (&instr [-1]), a, x, y, GET_SP(), TIME() ); }
+	#endif
+	
+	s_time += clock_table [opcode];
+	
+	int data;
+	data = *instr;
+	
+	switch ( opcode )
+	{
+
+// Macros
+
+#define GET_MSB()       (instr [1])
+#define ADD_PAGE( out ) (pc++, out = data + 0x100 * GET_MSB())
+#define GET_ADDR()      GET_LE16( instr )
+
+#define PAGE_PENALTY( lsb ) s_time += (lsb) >> 8;
+
+#define INC_DEC( reg, n ) reg = BYTE( nz = reg + n ); goto loop;
+
+#define IND_Y( cross, out ) {\
+		int temp = READ_LOW( data ) + y;\
+		out = temp + 0x100 * READ_LOW( BYTE( data + 1 ) );\
+		cross( temp );\
+	}
+	
+#define IND_X( out ) {\
+		int temp = data + x;\
+		out = 0x100 * READ_LOW( BYTE( temp + 1 ) ) + READ_LOW( BYTE( temp ) );\
+	}
+	
+#define ARITH_ADDR_MODES( op )\
+case op - 0x04: /* (ind,x) */\
+	IND_X( data )\
+	goto ptr##op;\
+case op + 0x0C: /* (ind),y */\
+	IND_Y( PAGE_PENALTY, data )\
+	goto ptr##op;\
+case op + 0x10: /* zp,X */\
+	data = BYTE( data + x );\
+case op + 0x00: /* zp */\
+	data = READ_LOW( data );\
+	goto imm##op;\
+case op + 0x14: /* abs,Y */\
+	data += y;\
+	goto ind##op;\
+case op + 0x18: /* abs,X */\
+	data += x;\
+ind##op:\
+	PAGE_PENALTY( data );\
+case op + 0x08: /* abs */\
+	ADD_PAGE( data );\
+ptr##op:\
+	FLUSH_TIME();\
+	data = READ_MEM( data );\
+	CACHE_TIME();\
+case op + 0x04: /* imm */\
+imm##op:
+
+// TODO: more efficient way to handle negative branch that wraps PC around
+#define BRANCH( cond )\
+{\
+	++pc;\
+	if ( !(cond) ) goto loop;\
+	s_time++;\
+	int offset = SBYTE( data );\
+	s_time += (BYTE(pc) + offset) >> 8 & 1;\
+	pc = WORD( pc + offset );\
+	goto loop;\
+}
+
+// Often-Used
+
+	case 0xB5: // LDA zp,x
+		a = nz = READ_LOW( BYTE( data + x ) );
+		pc++;
+		goto loop;
+	
+	case 0xA5: // LDA zp
+		a = nz = READ_LOW( data );
+		pc++;
+		goto loop;
+	
+	case 0xD0: // BNE
+		BRANCH( BYTE( nz ) );
+	
+	case 0x20: { // JSR
+		int temp = pc + 1;
+		pc = GET_ADDR();
+		WRITE_STACK( SP( -1 ), temp >> 8 );
+		sp = SP( -2 );
+		WRITE_STACK( sp, temp );
+		goto loop;
+	}
+	
+	case 0x4C: // JMP abs
+		pc = GET_ADDR();
+		goto loop;
+	
+	case 0xE8: // INX
+		INC_DEC( x, 1 )
+	
+	case 0x10: // BPL
+		BRANCH( !IS_NEG )
+	
+	ARITH_ADDR_MODES( 0xC5 ) // CMP
+		nz = a - data;
+		pc++;
+		c = ~nz;
+		nz &= 0xFF;
+		goto loop;
+	
+	case 0x30: // BMI
+		BRANCH( IS_NEG )
+	
+	case 0xF0: // BEQ
+		BRANCH( !BYTE( nz ) );
+	
+	case 0x95: // STA zp,x
+		data = BYTE( data + x );
+	case 0x85: // STA zp
+		pc++;
+		WRITE_LOW( data, a );
+		goto loop;
+	
+	case 0xC8: // INY
+		INC_DEC( y, 1 )
+
+	case 0xA8: // TAY
+		y  = a;
+		nz = a;
+		goto loop;
+	
+	case 0x98: // TYA
+		a  = y;
+		nz = y;
+		goto loop;
+	
+	case 0xAD:{// LDA abs
+		int addr = GET_ADDR();
+		pc += 2;
+		READ_PPU( addr, a = nz );
+		goto loop;
+	}
+	
+	case 0x60: // RTS
+		pc = 1 + READ_STACK( sp );
+		pc += 0x100 * READ_STACK( SP( 1 ) );
+		sp = SP( 2 );
+		goto loop;
+	
+	{
+		int addr;
+		
+	case 0x8D: // STA abs
+		addr = GET_ADDR();
+		pc += 2;
+		if ( CAN_WRITE_FAST( addr ) )
+		{
+			WRITE_FAST( addr, a );
+			goto loop;
+		}
+	sta_ptr:
+		FLUSH_TIME();
+		WRITE_MEM( addr, a );
+		CACHE_TIME();
+		goto loop;
+	
+	case 0x99: // STA abs,Y
+		addr = y + GET_ADDR();
+		pc += 2;
+		if ( CAN_WRITE_FAST( addr ) )
+		{
+			WRITE_FAST( addr, a );
+			goto loop;
+		}
+		goto sta_abs_x;
+	
+	case 0x9D: // STA abs,X (slightly more common than STA abs)
+		addr = x + GET_ADDR();
+		pc += 2;
+		if ( CAN_WRITE_FAST( addr ) )
+		{
+			WRITE_FAST( addr, a );
+			goto loop;
+		}
+		DUMMY_READ( addr, x );
+	sta_abs_x:
+		FLUSH_TIME();
+		WRITE_MEM( addr, a );
+		CACHE_TIME();
+		goto loop;
+	
+	case 0x91: // STA (ind),Y
+		#define NO_PAGE_PENALTY( lsb )
+		IND_Y( NO_PAGE_PENALTY, addr )
+		pc++;
+		DUMMY_READ( addr, y );
+		goto sta_ptr;
+	
+	case 0x81: // STA (ind,X)
+		IND_X( addr )
+		pc++;
+		goto sta_ptr;
+	
+	}
+	
+	case 0xA9: // LDA #imm
+		pc++;
+		a  = data;
+		nz = data;
+		goto loop;
+
+	// common read instructions
+	{
+		int addr;
+		
+	case 0xA1: // LDA (ind,X)
+		IND_X( addr )
+		pc++;
+		goto a_nz_read_addr;
+	
+	case 0xB1:// LDA (ind),Y
+		addr = READ_LOW( data ) + y;
+		PAGE_PENALTY( addr );
+		addr += 0x100 * READ_LOW( BYTE( data + 1 ) );
+		pc++;
+		READ_FAST( addr, a = nz );
+		if ( CAN_READ_FAST( addr ) )
+			goto loop;
+		DUMMY_READ( addr, y );
+		goto a_nz_read_addr;
+	
+	case 0xB9: // LDA abs,Y
+		PAGE_PENALTY( data + y );
+		addr = GET_ADDR() + y;
+		pc += 2;
+		READ_FAST( addr, a = nz );
+		if ( CAN_READ_FAST( addr ) )
+			goto loop;
+		goto a_nz_read_addr;
+	
+	case 0xBD: // LDA abs,X
+		PAGE_PENALTY( data + x );
+		addr = GET_ADDR() + x;
+		pc += 2;
+		READ_FAST( addr, a = nz );
+		if ( CAN_READ_FAST( addr ) )
+			goto loop;
+		DUMMY_READ( addr, x );
+	a_nz_read_addr:
+		FLUSH_TIME();
+		a = nz = READ_MEM( addr );
+		CACHE_TIME();
+		goto loop;
+	
+	}
+
+// Branch
+
+	case 0x50: // BVC
+		BRANCH( !(flags & v40) )
+	
+	case 0x70: // BVS
+		BRANCH( flags & v40 )
+	
+	case 0xB0: // BCS
+		BRANCH( c & 0x100 )
+	
+	case 0x90: // BCC
+		BRANCH( !(c & 0x100) )
+	
+// Load/store
+	
+	case 0x94: // STY zp,x
+		data = BYTE( data + x );
+	case 0x84: // STY zp
+		pc++;
+		WRITE_LOW( data, y );
+		goto loop;
+	
+	case 0x96: // STX zp,y
+		data = BYTE( data + y );
+	case 0x86: // STX zp
+		pc++;
+		WRITE_LOW( data, x );
+		goto loop;
+	
+	case 0xB6: // LDX zp,y
+		data = BYTE( data + y );
+	case 0xA6: // LDX zp
+		data = READ_LOW( data );
+	case 0xA2: // LDX #imm
+		pc++;
+		x = data;
+		nz = data;
+		goto loop;
+	
+	case 0xB4: // LDY zp,x
+		data = BYTE( data + x );
+	case 0xA4: // LDY zp
+		data = READ_LOW( data );
+	case 0xA0: // LDY #imm
+		pc++;
+		y = data;
+		nz = data;
+		goto loop;
+	
+	case 0xBC: // LDY abs,X
+		data += x;
+		PAGE_PENALTY( data );
+	case 0xAC:{// LDY abs
+		int addr = data + 0x100 * GET_MSB();
+		pc += 2;
+		FLUSH_TIME();
+		y = nz = READ_MEM( addr );
+		CACHE_TIME();
+		goto loop;
+	}
+	
+	case 0xBE: // LDX abs,y
+		data += y;
+		PAGE_PENALTY( data );
+	case 0xAE:{// LDX abs
+		int addr = data + 0x100 * GET_MSB();
+		pc += 2;
+		FLUSH_TIME();
+		x = nz = READ_MEM( addr );
+		CACHE_TIME();
+		goto loop;
+	}
+	
+	{
+		int temp;
+	case 0x8C: // STY abs
+		temp = y;
+		goto store_abs;
+	
+	case 0x8E: // STX abs
+		temp = x;
+	store_abs:
+		int addr = GET_ADDR();
+		pc += 2;
+		if ( CAN_WRITE_FAST( addr ) )
+		{
+			WRITE_FAST( addr, temp );
+			goto loop;
+		}
+		FLUSH_TIME();
+		WRITE_MEM( addr, temp );
+		CACHE_TIME();
+		goto loop;
+	}
+
+// Compare
+
+	case 0xEC:{// CPX abs
+		int addr = GET_ADDR();
+		pc++;
+		FLUSH_TIME();
+		data = READ_MEM( addr );
+		CACHE_TIME();
+		goto cpx_data;
+	}
+	
+	case 0xE4: // CPX zp
+		data = READ_LOW( data );
+	case 0xE0: // CPX #imm
+	cpx_data:
+		nz = x - data;
+		pc++;
+		c = ~nz;
+		nz &= 0xFF;
+		goto loop;
+	
+	case 0xCC:{// CPY abs
+		int addr = GET_ADDR();
+		pc++;
+		FLUSH_TIME();
+		data = READ_MEM( addr );
+		CACHE_TIME();
+		goto cpy_data;
+	}
+	
+	case 0xC4: // CPY zp
+		data = READ_LOW( data );
+	case 0xC0: // CPY #imm
+	cpy_data:
+		nz = y - data;
+		pc++;
+		c = ~nz;
+		nz &= 0xFF;
+		goto loop;
+	
+// Logical
+
+	ARITH_ADDR_MODES( 0x25 ) // AND
+		nz = (a &= data);
+		pc++;
+		goto loop;
+	
+	ARITH_ADDR_MODES( 0x45 ) // EOR
+		nz = (a ^= data);
+		pc++;
+		goto loop;
+	
+	ARITH_ADDR_MODES( 0x05 ) // ORA
+		nz = (a |= data);
+		pc++;
+		goto loop;
+	
+	case 0x2C:{// BIT abs
+		int addr = GET_ADDR();
+		pc += 2;
+		READ_PPU( addr, nz );
+		flags = (flags & ~v40) + (nz & v40);
+		if ( a & nz )
+			goto loop;
+		nz <<= 8; // result must be zero, even if N bit is set
+		goto loop;
+	}
+	
+	case 0x24: // BIT zp
+		nz = READ_LOW( data );
+		pc++;
+		flags = (flags & ~v40) + (nz & v40);
+		if ( a & nz )
+			goto loop; // Z should be clear, and nz must be non-zero if nz & a is
+		nz <<= 8; // set Z flag without affecting N flag
+		goto loop;
+		
+// Add/subtract
+
+	ARITH_ADDR_MODES( 0xE5 ) // SBC
+	case 0xEB: // unofficial equivalent
+		data ^= 0xFF;
+		goto adc_imm;
+	
+	ARITH_ADDR_MODES( 0x65 ) // ADC
+	adc_imm: {
+		int carry = c >> 8 & 1;
+		int ov = (a ^ 0x80) + carry + SBYTE( data );
+		flags = (flags & ~v40) + (ov >> 2 & v40);
+		c = nz = a + data + carry;
+		pc++;
+		a = BYTE( nz );
+		goto loop;
+	}
+	
+// Shift/rotate
+
+	case 0x4A: // LSR A
+		c = 0;
+	case 0x6A: // ROR A
+		nz = c >> 1 & 0x80;
+		c = a << 8;
+		nz += a >> 1;
+		a = nz;
+		goto loop;
+
+	case 0x0A: // ASL A
+		nz = a << 1;
+		c = nz;
+		a = BYTE( nz );
+		goto loop;
+
+	case 0x2A: { // ROL A
+		nz = a << 1;
+		int temp = c >> 8 & 1;
+		c = nz;
+		nz += temp;
+		a = BYTE( nz );
+		goto loop;
+	}
+	
+	case 0x5E: // LSR abs,X
+		data += x;
+	case 0x4E: // LSR abs
+		c = 0;
+	case 0x6E: // ROR abs
+	ror_abs: {
+		ADD_PAGE( data );
+		FLUSH_TIME();
+		int temp = READ_MEM( data );
+		nz = (c >> 1 & 0x80) + (temp >> 1);
+		c = temp << 8;
+		goto rotate_common;
+	}
+	
+	case 0x3E: // ROL abs,X
+		data += x;
+		goto rol_abs;
+	
+	case 0x1E: // ASL abs,X
+		data += x;
+	case 0x0E: // ASL abs
+		c = 0;
+	case 0x2E: // ROL abs
+	rol_abs:
+		ADD_PAGE( data );
+		nz = c >> 8 & 1;
+		FLUSH_TIME();
+		nz += (c = READ_MEM( data ) << 1);
+	rotate_common:
+		pc++;
+		WRITE_MEM( data, BYTE( nz ) );
+		CACHE_TIME();
+		goto loop;
+	
+	case 0x7E: // ROR abs,X
+		data += x;
+		goto ror_abs;
+	
+	case 0x76: // ROR zp,x
+		data = BYTE( data + x );
+		goto ror_zp;
+	
+	case 0x56: // LSR zp,x
+		data = BYTE( data + x );
+	case 0x46: // LSR zp
+		c = 0;
+	case 0x66: // ROR zp
+	ror_zp: {
+		int temp = READ_LOW( data );
+		nz = (c >> 1 & 0x80) + (temp >> 1);
+		c = temp << 8;
+		goto write_nz_zp;
+	}
+	
+	case 0x36: // ROL zp,x
+		data = BYTE( data + x );
+		goto rol_zp;
+	
+	case 0x16: // ASL zp,x
+		data = BYTE( data + x );
+	case 0x06: // ASL zp
+		c = 0;
+	case 0x26: // ROL zp
+	rol_zp:
+		nz = c >> 8 & 1;
+		nz += (c = READ_LOW( data ) << 1);
+		goto write_nz_zp;
+	
+// Increment/decrement
+
+	case 0xCA: // DEX
+		INC_DEC( x, -1 )
+	
+	case 0x88: // DEY
+		INC_DEC( y, -1 )
+	
+	case 0xF6: // INC zp,x
+		data = BYTE( data + x );
+	case 0xE6: // INC zp
+		nz = 1;
+		goto add_nz_zp;
+	
+	case 0xD6: // DEC zp,x
+		data = BYTE( data + x );
+	case 0xC6: // DEC zp
+		nz = -1;
+	add_nz_zp:
+		nz += READ_LOW( data );
+	write_nz_zp:
+		pc++;
+		WRITE_LOW( data, nz );
+		goto loop;
+	
+	case 0xFE: // INC abs,x
+		data = x + GET_ADDR();
+		goto inc_ptr;
+	
+	case 0xEE: // INC abs
+		data = GET_ADDR();
+	inc_ptr:
+		nz = 1;
+		goto inc_common;
+	
+	case 0xDE: // DEC abs,x
+		data = x + GET_ADDR();
+		goto dec_ptr;
+	
+	case 0xCE: // DEC abs
+		data = GET_ADDR();
+	dec_ptr:
+		nz = -1;
+	inc_common:
+		FLUSH_TIME();
+		pc += 2;
+		nz += READ_MEM( data );
+		WRITE_MEM( data, BYTE( nz ) );
+		CACHE_TIME();
+		goto loop;
+		
+// Transfer
+
+	case 0xAA: // TAX
+		x = nz = a;
+		goto loop;
+		
+	case 0x8A: // TXA
+		a = nz = x;
+		goto loop;
+
+	case 0x9A: // TXS
+		SET_SP( x ); // verified (no flag change)
+		goto loop;
+	
+	case 0xBA: // TSX
+		x = nz = GET_SP();
+		goto loop;
+	
+// Stack
+	
+	case 0x48: // PHA
+		sp = SP( -1 );
+		WRITE_STACK( sp, a );
+		goto loop;
+		
+	case 0x68: // PLA
+		a = nz = READ_STACK( sp );
+		sp = SP( 1 );
+		goto loop;
+		
+	case 0x40:{// RTI
+		pc  = READ_STACK( SP( 1 ) );
+		pc += READ_STACK( SP( 2 ) ) * 0x100;
+		int temp = READ_STACK( sp );
+		sp = SP( 3 );
+		data = flags;
+		SET_FLAGS( temp );
+		CPU.r.flags = flags; // update externally-visible I flag
+		int delta = s.base - CPU.irq_time_;
+		if ( delta <= 0 ) goto loop; // end_time < irq_time
+		if ( flags & i04 ) goto loop;
+		s_time += delta;
+		s.base = CPU.irq_time_;
+		goto loop;
+	}
+	
+	case 0x28:{// PLP
+		int temp = READ_STACK( sp );
+		sp = SP( 1 );
+		int changed = flags ^ temp;
+		SET_FLAGS( temp );
+		if ( !(changed & i04) )
+			goto loop; // I flag didn't change
+		if ( flags & i04 )
+			goto handle_sei;
+		goto handle_cli;
+	}
+	
+	case 0x08:{// PHP
+		int temp;
+		GET_FLAGS( temp );
+		sp = SP( -1 );
+		WRITE_STACK( sp, temp | (b10 | r20) );
+		goto loop;
+	}
+	
+	case 0x6C:{// JMP (ind)
+		data = GET_ADDR();
+		byte const* page = CODE_PAGE( data );
+		pc = page [CODE_OFFSET( data )];
+		data = (data & 0xFF00) + ((data + 1) & 0xFF);
+		pc += page [CODE_OFFSET( data )] * 0x100;
+		goto loop;
+	}
+	
+	case 0x00: // BRK
+		goto handle_brk;
+	
+// Flags
+
+	case 0x38: // SEC
+		c = 0x100;
+		goto loop;
+	
+	case 0x18: // CLC
+		c = 0;
+		goto loop;
+		
+	case 0xB8: // CLV
+		flags &= ~v40;
+		goto loop;
+	
+	case 0xD8: // CLD
+		flags &= ~d08;
+		goto loop;
+	
+	case 0xF8: // SED
+		flags |= d08;
+		goto loop;
+	
+	case 0x58: // CLI
+		if ( !(flags & i04) )
+			goto loop;
+		flags &= ~i04;
+	handle_cli: {
+		//dprintf( "CLI at %d\n", TIME );
+		CPU.r.flags = flags; // update externally-visible I flag
+		int delta = s.base - CPU.irq_time_;
+		if ( delta <= 0 )
+		{
+			if ( TIME() < CPU.irq_time_ )
+				goto loop;
+			goto delayed_cli;
+		}
+		s.base = CPU.irq_time_;
+		s_time += delta;
+		if ( s_time < 0 )
+			goto loop;
+		
+		if ( delta >= s_time + 1 )
+		{
+			// delayed irq until after next instruction
+			s.base += s_time + 1;
+			s_time = -1;
+			goto loop;
+		}
+		
+		// TODO: implement
+	delayed_cli:
+		dprintf( "Delayed CLI not emulated\n" );
+		goto loop;
+	}
+	
+	case 0x78: // SEI
+		if ( flags & i04 )
+			goto loop;
+		flags |= i04;
+	handle_sei: {
+		CPU.r.flags = flags; // update externally-visible I flag
+		int delta = s.base - CPU.end_time_;
+		s.base = CPU.end_time_;
+		s_time += delta;
+		if ( s_time < 0 )
+			goto loop;
+		
+		dprintf( "Delayed SEI not emulated\n" );
+		goto loop;
+	}
+	
+// Unofficial
+	
+	// SKW - skip word
+	case 0x1C: case 0x3C: case 0x5C: case 0x7C: case 0xDC: case 0xFC:
+		PAGE_PENALTY( data + x );
+	case 0x0C:
+		pc++;
+	// SKB - skip byte
+	case 0x74: case 0x04: case 0x14: case 0x34: case 0x44: case 0x54: case 0x64:
+	case 0x80: case 0x82: case 0x89: case 0xC2: case 0xD4: case 0xE2: case 0xF4:
+		pc++;
+		goto loop;
+	
+	// NOP
+	case 0xEA: case 0x1A: case 0x3A: case 0x5A: case 0x7A: case 0xDA: case 0xFA:
+		goto loop;
+	
+	case Nes_Cpu::halt_opcode: // HLT - halt processor
+		if ( pc-- > 0x10000 )
+		{
+			// handle wrap-around (assumes caller has put page of HLT at 0x10000)
+			pc = WORD( pc );
+			goto loop;
+		}
+	case 0x02: case 0x12:            case 0x32: case 0x42: case 0x52:
+	case 0x62: case 0x72: case 0x92: case 0xB2: case 0xD2: case 0xF2:
+		goto stop;
+	
+// Unimplemented
+	
+	case 0xFF:  // force 256-entry jump table for optimization purposes
+		c |= 1; // compiler doesn't know that this won't affect anything
+	default:
+		check( (unsigned) opcode < 0x100 );
+		
+		#ifdef UNIMPL_INSTR
+			UNIMPL_INSTR();
+		#endif
+		
+		// At least skip over proper number of bytes instruction uses
+		static unsigned char const illop_lens [8] = {
+			0x40, 0x40, 0x40, 0x80, 0x40, 0x40, 0x80, 0xA0
+		};
+		opcode = instr [-1];
+		int len = illop_lens [opcode >> 2 & 7] >> (opcode << 1 & 6) & 3;
+		if ( opcode == 0x9C )
+			len = 2;
+		pc += len;
+		CPU.error_count_++;
+		
+		// Account for extra clock
+		if ( (opcode >> 4) == 0x0B )
+		{
+			if ( opcode == 0xB3 )
+				data = READ_LOW( data );
+			if ( opcode != 0xB7 )
+				PAGE_PENALTY( data + y );
+		}
+		goto loop;
+	}
+	assert( false ); // catch missing 'goto loop' or accidental 'break'
+	
+	int result_;
+handle_brk:
+	pc++;
+	result_ = b10 | 4;
+	
+#ifdef CPU_DONE
+interrupt:
+#endif
+	{
+		s_time += 7;
+		
+		// Save PC and read vector
+		WRITE_STACK( SP( -1 ), pc >> 8 );
+		WRITE_STACK( SP( -2 ), pc );
+		pc = GET_LE16( &READ_CODE( 0xFFFA ) + (result_ & 4) );
+		
+		// Save flags
+		int temp;
+		GET_FLAGS( temp );
+		temp |= r20 + (result_ & b10); // B flag set for BRK
+		sp = SP( -3 );
+		WRITE_STACK( sp, temp );
+		
+		// Update I flag in externally-visible flags
+		CPU.r.flags = (flags |= i04);
+		
+		// Update time
+		int delta = s.base - CPU.end_time_;
+		if ( delta >= 0 )
+			goto loop;
+		s_time += delta;
+		s.base = CPU.end_time_;
+		goto loop;
+	}
+	
+out_of_time:
+	pc--;
+	
+	// Optional action that triggers interrupt or changes irq/end time
+	#ifdef CPU_DONE
+	{
+		CPU_DONE( result_ );
+		if ( result_ >= 0 )
+			goto interrupt;
+		if ( s_time < 0 )
+			goto loop;
+	}
+	#endif
+stop:
+	
+	// Flush cached state
+	CPU.r.pc = pc;
+	CPU.r.sp = GET_SP();
+	CPU.r.a  = a;
+	CPU.r.x  = x;
+	CPU.r.y  = y;
+
+	int temp;
+	GET_FLAGS( temp );
+	CPU.r.flags = temp;
+	
+	CPU.cpu_state_.base = s.base;
+	CPU.cpu_state_.time = s_time;
+	CPU.cpu_state = &CPU.cpu_state_;
+}
diff -Nur orig/source/gme/src/Nes_Fds_Apu.cpp mod/source/gme/src/Nes_Fds_Apu.cpp
--- orig/source/gme/src/Nes_Fds_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Fds_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,280 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nes_Fds_Apu.h"
+
+/* Copyright (C) 2006 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const fract_range = 65536;
+
+void Nes_Fds_Apu::reset()
+{
+	memset( regs_, 0, sizeof regs_ );
+	memset( mod_wave, 0, sizeof mod_wave );
+	
+	last_time     = 0;
+	env_delay     = 0;
+	sweep_delay   = 0;
+	wave_pos      = 0;
+	last_amp      = 0;
+	wave_fract    = fract_range;
+	mod_fract     = fract_range;
+	mod_pos       = 0;
+	mod_write_pos = 0;
+	
+	static byte const initial_regs [0x0B] = {
+		0x80,       // disable envelope
+		0, 0, 0xC0, // disable wave and lfo
+		0x80,       // disable sweep
+		0, 0, 0x80, // disable modulation
+		0, 0, 0xFF  // LFO period // TODO: use 0xE8 as FDS ROM does?
+	};
+	for ( int i = 0; i < (int) sizeof initial_regs; i++ )
+	{
+		// two writes to set both gain and period for envelope registers
+		write_( io_addr + wave_size + i, 0 );
+		write_( io_addr + wave_size + i, initial_regs [i] );
+	}
+}
+
+void Nes_Fds_Apu::write_( unsigned addr, int data )
+{
+	unsigned reg = addr - io_addr;
+	if ( reg < io_size )
+	{
+		if ( reg < wave_size )
+		{
+			if ( regs (0x4089) & 0x80 )
+				regs_ [reg] = data & wave_sample_max;
+		}
+		else
+		{
+			regs_ [reg] = data;
+			switch ( addr )
+			{
+			case 0x4080:
+				if ( data & 0x80 )
+					env_gain = data & 0x3F;
+				else
+					env_speed = (data & 0x3F) + 1;
+				break;
+			
+			case 0x4084:
+				if ( data & 0x80 )
+					sweep_gain = data & 0x3F;
+				else
+					sweep_speed = (data & 0x3F) + 1;
+				break;
+			
+			case 0x4085:
+				mod_pos = mod_write_pos;
+				regs (0x4085) = data & 0x7F;
+				break;
+			
+			case 0x4088:
+				if ( regs (0x4087) & 0x80 )
+				{
+					int pos = mod_write_pos;
+					data &= 0x07;
+					mod_wave [pos    ] = data;
+					mod_wave [pos + 1] = data;
+					mod_write_pos = (pos     + 2) & (wave_size - 1);
+					mod_pos       = (mod_pos + 2) & (wave_size - 1);
+				}
+				break;
+			}
+		}
+	}
+}
+
+void Nes_Fds_Apu::set_tempo( double t )
+{
+	lfo_tempo = lfo_base_tempo;
+	if ( t != 1.0 )
+	{
+		lfo_tempo = int ((double) lfo_base_tempo / t + 0.5);
+		if ( lfo_tempo <= 0 )
+			lfo_tempo = 1;
+	}
+}
+
+void Nes_Fds_Apu::run_until( blip_time_t final_end_time )
+{
+	int const wave_freq = (regs (0x4083) & 0x0F) * 0x100 + regs (0x4082);
+	Blip_Buffer* const output_ = this->output_;
+	if ( wave_freq && output_ && !((regs (0x4089) | regs (0x4083)) & 0x80) )
+	{
+		output_->set_modified();
+		
+		// master_volume
+		#define MVOL_ENTRY( percent ) (master_vol_max * percent + 50) / 100
+		static unsigned char const master_volumes [4] = {
+			MVOL_ENTRY( 100 ), MVOL_ENTRY( 67 ), MVOL_ENTRY( 50 ), MVOL_ENTRY( 40 )
+		};
+		int const master_volume = master_volumes [regs (0x4089) & 0x03];
+		
+		// lfo_period
+		blip_time_t lfo_period = regs (0x408A) * lfo_tempo;
+		if ( regs (0x4083) & 0x40 )
+			lfo_period = 0;
+		
+		// sweep setup
+		blip_time_t sweep_time = last_time + sweep_delay;
+		blip_time_t const sweep_period = lfo_period * sweep_speed;
+		if ( !sweep_period || regs (0x4084) & 0x80 )
+			sweep_time = final_end_time;
+		
+		// envelope setup
+		blip_time_t env_time = last_time + env_delay;
+		blip_time_t const env_period = lfo_period * env_speed;
+		if ( !env_period || regs (0x4080) & 0x80 )
+			env_time = final_end_time;
+		
+		// modulation
+		int mod_freq = 0;
+		if ( !(regs (0x4087) & 0x80) )
+			mod_freq = (regs (0x4087) & 0x0F) * 0x100 + regs (0x4086);
+		
+		blip_time_t end_time = last_time;
+		do
+		{
+			// sweep
+			if ( sweep_time <= end_time )
+			{
+				sweep_time += sweep_period;
+				int mode = regs (0x4084) >> 5 & 2;
+				int new_sweep_gain = sweep_gain + mode - 1;
+				if ( (unsigned) new_sweep_gain <= (unsigned) 0x80 >> mode )
+					sweep_gain = new_sweep_gain;
+				else
+					regs (0x4084) |= 0x80; // optimization only
+			}
+			
+			// envelope
+			if ( env_time <= end_time )
+			{
+				env_time += env_period;
+				int mode = regs (0x4080) >> 5 & 2;
+				int new_env_gain = env_gain + mode - 1;
+				if ( (unsigned) new_env_gain <= (unsigned) 0x80 >> mode )
+					env_gain = new_env_gain;
+				else
+					regs (0x4080) |= 0x80; // optimization only
+			}
+			
+			// new end_time
+			blip_time_t const start_time = end_time;
+			end_time = final_end_time;
+			if ( end_time > env_time   ) end_time = env_time;
+			if ( end_time > sweep_time ) end_time = sweep_time;
+			
+			// frequency modulation
+			int freq = wave_freq;
+			if ( mod_freq )
+			{
+				// time of next modulation clock
+				blip_time_t mod_time = start_time + (mod_fract + mod_freq - 1) / mod_freq;
+				if ( end_time > mod_time )
+					end_time = mod_time;
+				
+				// run modulator up to next clock and save old sweep_bias
+				int sweep_bias = regs (0x4085);
+				mod_fract -= (end_time - start_time) * mod_freq;
+				if ( mod_fract <= 0 )
+				{
+					mod_fract += fract_range;
+					check( (unsigned) mod_fract <= fract_range );
+					
+					static short const mod_table [8] = { 0, +1, +2, +4, 0, -4, -2, -1 };
+					int mod = mod_wave [mod_pos];
+					mod_pos = (mod_pos + 1) & (wave_size - 1);
+					int new_sweep_bias = (sweep_bias + mod_table [mod]) & 0x7F;
+					if ( mod == 4 )
+						new_sweep_bias = 0;
+					regs (0x4085) = new_sweep_bias;
+				}
+				
+				// apply frequency modulation
+				sweep_bias = (sweep_bias ^ 0x40) - 0x40;
+				int factor = sweep_bias * sweep_gain;
+				int extra = factor & 0x0F;
+				factor >>= 4;
+				if ( extra )
+				{
+					factor--;
+					if ( sweep_bias >= 0 )
+						factor += 3;
+				}
+				if ( factor > 193 ) factor -= 258;
+				if ( factor < -64 ) factor += 256;
+				freq += (freq * factor) >> 6;
+				if ( freq <= 0 )
+					continue;
+			}
+			
+			// wave
+			int wave_fract = this->wave_fract;
+			blip_time_t delay = (wave_fract + freq - 1) / freq;
+			blip_time_t time = start_time + delay;
+			
+			if ( time <= end_time )
+			{
+				// at least one wave clock within start_time...end_time
+				
+				blip_time_t const min_delay = fract_range / freq;
+				int wave_pos = this->wave_pos;
+				
+				int volume = env_gain;
+				if ( volume > vol_max )
+					volume = vol_max;
+				volume *= master_volume;
+				
+				int const min_fract = min_delay * freq;
+				
+				do
+				{
+					// clock wave
+					int amp = regs_ [wave_pos] * volume;
+					wave_pos = (wave_pos + 1) & (wave_size - 1);
+					int delta = amp - last_amp;
+					if ( delta )
+					{
+						last_amp = amp;
+						synth.offset_inline( time, delta, output_ );
+					}
+					
+					wave_fract += fract_range - delay * freq;
+					check( unsigned (fract_range - wave_fract) < freq );
+					
+					// delay until next clock
+					delay = min_delay;
+					if ( wave_fract > min_fract )
+						delay++;
+					check( delay && delay == (wave_fract + freq - 1) / freq );
+					
+					time += delay;
+				}
+				while ( time <= end_time ); // TODO: using < breaks things, but <= is wrong
+				
+				this->wave_pos = wave_pos;
+			}
+			this->wave_fract = wave_fract - (end_time - (time - delay)) * freq;
+			check( this->wave_fract > 0 );
+		}
+		while ( end_time < final_end_time );
+		
+		env_delay   = env_time   - final_end_time; check( env_delay >= 0 );
+		sweep_delay = sweep_time - final_end_time; check( sweep_delay >= 0 );
+	}
+	last_time = final_end_time;
+}
diff -Nur orig/source/gme/src/Nes_Fds_Apu.h mod/source/gme/src/Nes_Fds_Apu.h
--- orig/source/gme/src/Nes_Fds_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Fds_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,139 @@
+// NES FDS sound chip emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef NES_FDS_APU_H
+#define NES_FDS_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+class Nes_Fds_Apu {
+public:
+	// setup
+	void set_tempo( double );
+	enum { osc_count = 1 };
+	void set_output( Blip_Buffer* buf );
+	void volume( double );
+	void treble_eq( blip_eq_t const& eq ) { synth.treble_eq( eq ); }
+	
+	// emulation
+	void reset();
+	enum { io_addr = 0x4040 };
+	enum { io_size = 0x53 };
+	void write( blip_time_t time, unsigned addr, int data );
+	int read( blip_time_t time, unsigned addr );
+	void end_frame( blip_time_t );
+	
+public:
+	Nes_Fds_Apu();
+	void write_( unsigned addr, int data );
+	BLARGG_DISABLE_NOTHROW
+	
+	void set_output( int index, Blip_Buffer* center,
+			Blip_Buffer* left_ignored = NULL, Blip_Buffer* right_ignored = NULL );
+	BLARGG_DEPRECATED_TEXT( enum { start_addr = 0x4040 }; )
+	BLARGG_DEPRECATED_TEXT( enum { end_addr = 0x4092 }; )
+	BLARGG_DEPRECATED_TEXT( enum { reg_count = end_addr - start_addr + 1 }; )
+	void osc_output( int, Blip_Buffer* );
+private:
+	enum { wave_size       = 0x40 };
+	enum { master_vol_max  =   10 };
+	enum { vol_max         = 0x20 };
+	enum { wave_sample_max = 0x3F };
+	
+	unsigned char regs_ [io_size];// last written value to registers
+	
+	enum { lfo_base_tempo = 8 };
+	int lfo_tempo; // normally 8; adjusted by set_tempo()   
+	
+	int env_delay;
+	int env_speed;
+	int env_gain;
+	
+	int sweep_delay;
+	int sweep_speed;
+	int sweep_gain;
+	
+	int wave_pos;
+	int last_amp;
+	blip_time_t wave_fract;
+	
+	int mod_fract;
+	int mod_pos;
+	int mod_write_pos;
+	unsigned char mod_wave [wave_size];
+	
+	// synthesis
+	blip_time_t last_time;
+	Blip_Buffer* output_;
+	Blip_Synth_Fast synth;
+	
+	// allow access to registers by absolute address (i.e. 0x4080)
+	unsigned char& regs( unsigned addr ) { return regs_ [addr - io_addr]; }
+	
+	void run_until( blip_time_t );
+};
+
+inline void Nes_Fds_Apu::volume( double v )
+{
+	synth.volume( 0.14 / master_vol_max / vol_max / wave_sample_max * v );
+}
+
+inline void Nes_Fds_Apu::set_output( Blip_Buffer* b )
+{
+	output_ = b;
+}
+
+inline void Nes_Fds_Apu::set_output( int i, Blip_Buffer* buf, Blip_Buffer*, Blip_Buffer* )
+{
+	assert( (unsigned) i < osc_count );
+	output_ = buf;
+}
+
+inline void Nes_Fds_Apu::end_frame( blip_time_t end_time )
+{
+	if ( end_time > last_time )
+		run_until( end_time );
+	last_time -= end_time;
+	assert( last_time >= 0 );
+}
+
+inline void Nes_Fds_Apu::write( blip_time_t time, unsigned addr, int data )
+{
+	run_until( time );
+	write_( addr, data );
+}
+
+inline int Nes_Fds_Apu::read( blip_time_t time, unsigned addr )
+{
+	run_until( time );
+	
+	int result = 0xFF;
+	switch ( addr )
+	{
+	case 0x4090:
+		result = env_gain;
+		break;
+	
+	case 0x4092:
+		result = sweep_gain;
+		break;
+	
+	default:
+		unsigned i = addr - io_addr;
+		if ( i < wave_size )
+			result = regs_ [i];
+	}
+	
+	return result | 0x40;
+}
+
+inline Nes_Fds_Apu::Nes_Fds_Apu()
+{
+	lfo_tempo = lfo_base_tempo;
+	set_output( NULL );
+	volume( 1.0 );
+	reset();
+}
+
+#endif
diff -Nur orig/source/gme/src/Nes_Fme7_Apu.cpp mod/source/gme/src/Nes_Fme7_Apu.cpp
--- orig/source/gme/src/Nes_Fme7_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Fme7_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,121 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nes_Fme7_Apu.h"
+
+/* Copyright (C) 2003-2006 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void Nes_Fme7_Apu::reset()
+{
+	last_time = 0;
+	
+	for ( int i = 0; i < osc_count; i++ )
+		oscs [i].last_amp = 0;
+	
+	fme7_apu_state_t* state = this;
+	memset( state, 0, sizeof *state );
+}
+
+unsigned char const Nes_Fme7_Apu::amp_table [16] =
+{
+	#define ENTRY( n ) (unsigned char) (n * amp_range + 0.5)
+	ENTRY(0.0000), ENTRY(0.0078), ENTRY(0.0110), ENTRY(0.0156),
+	ENTRY(0.0221), ENTRY(0.0312), ENTRY(0.0441), ENTRY(0.0624),
+	ENTRY(0.0883), ENTRY(0.1249), ENTRY(0.1766), ENTRY(0.2498),
+	ENTRY(0.3534), ENTRY(0.4998), ENTRY(0.7070), ENTRY(1.0000)
+	#undef ENTRY
+};
+
+void Nes_Fme7_Apu::run_until( blip_time_t end_time )
+{
+	require( end_time >= last_time );
+	
+	for ( int index = 0; index < osc_count; index++ )
+	{
+		int mode = regs [7] >> index;
+		int vol_mode = regs [010 + index];
+		int volume = amp_table [vol_mode & 0x0F];
+		
+		Blip_Buffer* const osc_output = oscs [index].output;
+		if ( !osc_output )
+			continue;
+		
+		// check for unsupported mode
+		#ifndef NDEBUG
+			if ( (mode & 011) <= 001 && vol_mode & 0x1F )
+				dprintf( "FME7 used unimplemented sound mode: %02X, vol_mode: %02X\n",
+						mode, vol_mode & 0x1F );
+		#endif
+		
+		if ( (mode & 001) | (vol_mode & 0x10) )
+			volume = 0; // noise and envelope aren't supported
+		
+		// period
+		int const period_factor = 16;
+		unsigned period = (regs [index * 2 + 1] & 0x0F) * 0x100 * period_factor +
+				regs [index * 2] * period_factor;
+		if ( period < 50 ) // around 22 kHz
+		{
+			volume = 0;
+			if ( !period ) // on my AY-3-8910A, period doesn't have extra one added
+				period = period_factor;
+		}
+		
+		// current amplitude
+		int amp = volume;
+		if ( !phases [index] )
+			amp = 0;
+		
+		{
+			int delta = amp - oscs [index].last_amp;
+			if ( delta )
+			{
+				oscs [index].last_amp = amp;
+				osc_output->set_modified();
+				synth.offset( last_time, delta, osc_output );
+			}
+		}
+		
+		blip_time_t time = last_time + delays [index];
+		if ( time < end_time )
+		{
+			int delta = amp * 2 - volume;
+			osc_output->set_modified();
+			if ( volume )
+			{
+				do
+				{
+					delta = -delta;
+					synth.offset_inline( time, delta, osc_output );
+					time += period;
+				}
+				while ( time < end_time );
+				
+				oscs [index].last_amp = (delta + volume) >> 1;
+				phases [index] = (delta > 0);
+			}
+			else
+			{
+				// maintain phase when silent
+				int count = (end_time - time + period - 1) / period;
+				phases [index] ^= count & 1;
+				time += count * period;
+			}
+		}
+		
+		delays [index] = time - end_time;
+	}
+	
+	last_time = end_time;
+}
+
diff -Nur orig/source/gme/src/Nes_Fme7_Apu.h mod/source/gme/src/Nes_Fme7_Apu.h
--- orig/source/gme/src/Nes_Fme7_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Fme7_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,131 @@
+// Sunsoft FME-7 sound emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef NES_FME7_APU_H
+#define NES_FME7_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+struct fme7_apu_state_t
+{
+	enum { reg_count = 14 };
+	BOOST::uint8_t regs [reg_count];
+	BOOST::uint8_t phases [3]; // 0 or 1
+	BOOST::uint8_t latch;
+	BOOST::uint16_t delays [3]; // a, b, c
+};
+
+class Nes_Fme7_Apu : private fme7_apu_state_t {
+public:
+	// See Nes_Apu.h for reference
+	void reset();
+	void volume( double );
+	void treble_eq( blip_eq_t const& );
+	void set_output( Blip_Buffer* );
+	enum { osc_count = 3 };
+	void set_output( int index, Blip_Buffer* );
+	void end_frame( blip_time_t );
+	void save_state( fme7_apu_state_t* ) const;
+	void load_state( fme7_apu_state_t const& );
+	
+	// Mask and addresses of registers
+	enum { addr_mask = 0xE000 };
+	enum { data_addr = 0xE000 };
+	enum { latch_addr = 0xC000 };
+	
+	// (addr & addr_mask) == latch_addr
+	void write_latch( int );
+	
+	// (addr & addr_mask) == data_addr
+	void write_data( blip_time_t, int data );
+	
+public:
+	Nes_Fme7_Apu();
+	BLARGG_DISABLE_NOTHROW
+private:
+	// noncopyable
+	Nes_Fme7_Apu( const Nes_Fme7_Apu& );
+	Nes_Fme7_Apu& operator = ( const Nes_Fme7_Apu& );
+	
+	static unsigned char const amp_table [16];
+	
+	struct {
+		Blip_Buffer* output;
+		int last_amp;
+	} oscs [osc_count];
+	blip_time_t last_time;
+	
+	enum { amp_range = 192 }; // can be any value; this gives best error/quality tradeoff
+	Blip_Synth_Norm synth;
+	
+	void run_until( blip_time_t );
+};
+
+inline void Nes_Fme7_Apu::volume( double v )
+{
+	synth.volume( 0.38 / amp_range * v ); // to do: fine-tune
+}
+
+inline void Nes_Fme7_Apu::treble_eq( blip_eq_t const& eq )
+{
+	synth.treble_eq( eq );
+}
+
+inline void Nes_Fme7_Apu::set_output( int i, Blip_Buffer* buf )
+{
+	assert( (unsigned) i < osc_count );
+	oscs [i].output = buf;
+}
+
+inline void Nes_Fme7_Apu::set_output( Blip_Buffer* buf )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		set_output( i, buf );
+}
+
+inline Nes_Fme7_Apu::Nes_Fme7_Apu()
+{
+	set_output( NULL );
+	volume( 1.0 );
+	reset();
+}
+
+inline void Nes_Fme7_Apu::write_latch( int data ) { latch = data; }
+
+inline void Nes_Fme7_Apu::write_data( blip_time_t time, int data )
+{
+	if ( (unsigned) latch >= reg_count )
+	{
+		#ifdef dprintf
+			dprintf( "FME7 write to %02X (past end of sound registers)\n", (int) latch );
+		#endif
+		return;
+	}
+	
+	run_until( time );
+	regs [latch] = data;
+}
+
+inline void Nes_Fme7_Apu::end_frame( blip_time_t time )
+{
+	if ( time > last_time )
+		run_until( time );
+	
+	assert( last_time >= time );
+	last_time -= time;
+}
+
+inline void Nes_Fme7_Apu::save_state( fme7_apu_state_t* out ) const
+{
+	*out = *this;
+}
+
+inline void Nes_Fme7_Apu::load_state( fme7_apu_state_t const& in )
+{
+	reset();
+	fme7_apu_state_t* state = this;
+	*state = in;
+}
+
+#endif
diff -Nur orig/source/gme/src/Nes_Mmc5_Apu.h mod/source/gme/src/Nes_Mmc5_Apu.h
--- orig/source/gme/src/Nes_Mmc5_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Mmc5_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,70 @@
+// NES MMC5 sound chip emulator
+
+// Nes_Snd_Emu 0.2.0-pre
+#ifndef NES_MMC5_APU_H
+#define NES_MMC5_APU_H
+
+#include "blargg_common.h"
+#include "Nes_Apu.h"
+
+class Nes_Mmc5_Apu : public Nes_Apu {
+public:
+	enum { regs_addr = 0x5000 };
+	enum { regs_size = 0x16 };
+	
+	enum { osc_count  = 3 };
+	void write_register( blip_time_t, unsigned addr, int data );
+	void set_output( Blip_Buffer* );
+	void set_output( int index, Blip_Buffer* );
+	
+	enum { exram_size = 1024 };
+	unsigned char exram [exram_size];
+	
+	BLARGG_DEPRECATED_TEXT( enum { start_addr = 0x5000 }; )
+	BLARGG_DEPRECATED_TEXT( enum { end_addr   = 0x5015 }; )
+};
+
+inline void Nes_Mmc5_Apu::set_output( int i, Blip_Buffer* b )
+{
+	// in: square 1, square 2, PCM
+	// out: square 1, square 2, skipped, skipped, PCM
+	if ( i > 1 )
+		i += 2;
+	Nes_Apu::set_output( i, b );
+}
+
+inline void Nes_Mmc5_Apu::set_output( Blip_Buffer* b )
+{
+	set_output( 0, b );
+	set_output( 1, b );
+	set_output( 2, b );
+}
+
+inline void Nes_Mmc5_Apu::write_register( blip_time_t time, unsigned addr, int data )
+{
+	switch ( addr )
+	{
+	case 0x5015: // channel enables
+		data &= 0x03; // enable the square waves only
+		// fall through
+	case 0x5000: // Square 1
+	case 0x5002:
+	case 0x5003:
+	case 0x5004: // Square 2
+	case 0x5006:
+	case 0x5007:
+	case 0x5011: // DAC
+		Nes_Apu::write_register( time, addr - 0x1000, data );
+		break;
+	
+	case 0x5010: // some things write to this for some reason
+		break;
+	
+#ifdef BLARGG_DEBUG_H
+	default:
+			dprintf( "Unmapped MMC5 APU write: $%04X <- $%02X\n", addr, data );
+#endif
+	}
+}
+
+#endif
diff -Nur orig/source/gme/src/Nes_Namco_Apu.cpp mod/source/gme/src/Nes_Namco_Apu.cpp
--- orig/source/gme/src/Nes_Namco_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Namco_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,152 @@
+// Nes_Snd_Emu 0.2.0-pre. http://www.slack.net/~ant/
+
+#include "Nes_Namco_Apu.h"
+
+/* Copyright (C) 2003-2006 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Nes_Namco_Apu::Nes_Namco_Apu()
+{
+	set_output( NULL );
+	volume( 1.0 );
+	reset();
+}
+
+void Nes_Namco_Apu::reset()
+{
+	last_time = 0;
+	addr_reg = 0;
+	
+	int i;
+	for ( i = 0; i < reg_count; i++ )
+		reg [i] = 0;
+	
+	for ( i = 0; i < osc_count; i++ )
+	{
+		Namco_Osc& osc = oscs [i];
+		osc.delay = 0;
+		osc.last_amp = 0;
+		osc.wave_pos = 0;
+	}
+}
+
+void Nes_Namco_Apu::set_output( Blip_Buffer* buf )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		set_output( i, buf );
+}
+
+/*
+void Nes_Namco_Apu::reflect_state( Tagged_Data& data )
+{
+	reflect_int16( data, BLARGG_4CHAR('A','D','D','R'), &addr_reg );
+	
+	static const char hex [17] = "0123456789ABCDEF";
+	int i;
+	for ( i = 0; i < reg_count; i++ )
+		reflect_int16( data, 'RG\0\0' + hex [i >> 4] * 0x100 + hex [i & 15], &reg [i] );
+	
+	for ( i = 0; i < osc_count; i++ )
+	{
+		reflect_int32( data, BLARGG_4CHAR('D','L','Y','0') + i, &oscs [i].delay );
+		reflect_int16( data, BLARGG_4CHAR('P','O','S','0') + i, &oscs [i].wave_pos );
+	}
+}
+*/
+
+void Nes_Namco_Apu::end_frame( blip_time_t time )
+{
+	if ( time > last_time )
+		run_until( time );
+	
+	assert( last_time >= time );
+	last_time -= time;
+}
+
+void Nes_Namco_Apu::run_until( blip_time_t nes_end_time )
+{
+	int active_oscs = (reg [0x7F] >> 4 & 7) + 1;
+	for ( int i = osc_count - active_oscs; i < osc_count; i++ )
+	{
+		Namco_Osc& osc = oscs [i];
+		Blip_Buffer* output = osc.output;
+		if ( !output )
+			continue;
+		
+		blip_resampled_time_t time =
+				output->resampled_time( last_time ) + osc.delay;
+		blip_resampled_time_t end_time = output->resampled_time( nes_end_time );
+		osc.delay = 0;
+		if ( time < end_time )
+		{
+			const BOOST::uint8_t* osc_reg = &reg [i * 8 + 0x40];
+			if ( !(osc_reg [4] & 0xE0) )
+				continue;
+			
+			int volume = osc_reg [7] & 15;
+			if ( !volume )
+				continue;
+			
+			int freq = (osc_reg [4] & 3) * 0x10000 + osc_reg [2] * 0x100 + osc_reg [0];
+			if ( freq < 64 * active_oscs )
+				continue; // prevent low frequencies from excessively delaying freq changes
+			
+			int const master_clock_divider = 12; // NES time derived via divider of master clock
+			int const n106_divider = 45; // N106 then divides master clock by this
+			int const max_freq = 0x3FFFF;
+			int const lowest_freq_period = (max_freq + 1) * n106_divider / master_clock_divider;
+			// divide by 8 to avoid overflow
+			blip_resampled_time_t period =
+					output->resampled_duration( lowest_freq_period / 8 ) / freq * 8 * active_oscs;
+			
+			int wave_size = 32 - (osc_reg [4] >> 2 & 7) * 4;
+			if ( !wave_size )
+				continue;
+			
+			int last_amp = osc.last_amp;
+			int wave_pos = osc.wave_pos;
+			
+			output->set_modified();
+			
+			do
+			{
+				// read wave sample
+				int addr = wave_pos + osc_reg [6];
+				int sample = reg [addr >> 1] >> (addr << 2 & 4);
+				wave_pos++;
+				sample = (sample & 15) * volume;
+				
+				// output impulse if amplitude changed
+				int delta = sample - last_amp;
+				if ( delta )
+				{
+					last_amp = sample;
+					synth.offset_resampled( time, delta, output );
+				}
+				
+				// next sample
+				time += period;
+				if ( wave_pos >= wave_size )
+					wave_pos = 0;
+			}
+			while ( time < end_time );
+			
+			osc.wave_pos = wave_pos;
+			osc.last_amp = last_amp;
+		}
+		osc.delay = time - end_time;
+	}
+	
+	last_time = nes_end_time;
+}
+
diff -Nur orig/source/gme/src/Nes_Namco_Apu.h mod/source/gme/src/Nes_Namco_Apu.h
--- orig/source/gme/src/Nes_Namco_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Namco_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,102 @@
+// Namco 106 sound chip emulator
+
+// Nes_Snd_Emu 0.2.0-pre
+#ifndef NES_NAMCO_APU_H
+#define NES_NAMCO_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+struct namco_state_t;
+
+class Nes_Namco_Apu {
+public:
+	// See Nes_Apu.h for reference.
+	void volume( double );
+	void treble_eq( const blip_eq_t& );
+	void set_output( Blip_Buffer* );
+	enum { osc_count = 8 };
+	void set_output( int index, Blip_Buffer* );
+	void reset();
+	void end_frame( blip_time_t );
+	
+	// Read/write data register is at 0x4800
+	enum { data_reg_addr = 0x4800 };
+	void write_data( blip_time_t, int );
+	int read_data();
+	
+	// Write-only address register is at 0xF800
+	enum { addr_reg_addr = 0xF800 };
+	void write_addr( int );
+	
+	// to do: implement save/restore
+	void save_state( namco_state_t* out ) const;
+	void load_state( namco_state_t const& );
+	
+public:
+	Nes_Namco_Apu();
+	BLARGG_DISABLE_NOTHROW
+private:
+	// noncopyable
+	Nes_Namco_Apu( const Nes_Namco_Apu& );
+	Nes_Namco_Apu& operator = ( const Nes_Namco_Apu& );
+	
+	struct Namco_Osc {
+		int delay;
+		Blip_Buffer* output;
+		short last_amp;
+		short wave_pos;
+	};
+	
+	Namco_Osc oscs [osc_count];
+	
+	blip_time_t last_time;
+	int addr_reg;
+	
+	enum { reg_count = 0x80 };
+	BOOST::uint8_t reg [reg_count];
+	Blip_Synth_Norm synth;
+	
+	BOOST::uint8_t& access();
+	void run_until( blip_time_t );
+};
+/*
+struct namco_state_t
+{
+	BOOST::uint8_t regs [0x80];
+	BOOST::uint8_t addr;
+	BOOST::uint8_t unused;
+	BOOST::uint8_t positions [8];
+	BOOST::uint32_t delays [8];
+};
+*/
+
+inline BOOST::uint8_t& Nes_Namco_Apu::access()
+{
+	int addr = addr_reg & 0x7F;
+	if ( addr_reg & 0x80 )
+		addr_reg = (addr + 1) | 0x80;
+	return reg [addr];
+}
+
+inline void Nes_Namco_Apu::volume( double v ) { synth.volume( 0.10 / osc_count / 15 * v ); }
+
+inline void Nes_Namco_Apu::treble_eq( const blip_eq_t& eq ) { synth.treble_eq( eq ); }
+
+inline void Nes_Namco_Apu::write_addr( int v ) { addr_reg = v; }
+
+inline int Nes_Namco_Apu::read_data() { return access(); }
+
+inline void Nes_Namco_Apu::set_output( int i, Blip_Buffer* buf )
+{
+	assert( (unsigned) i < osc_count );
+	oscs [i].output = buf;
+}
+
+inline void Nes_Namco_Apu::write_data( blip_time_t time, int data )
+{
+	run_until( time );
+	access() = data;
+}
+
+#endif
diff -Nur orig/source/gme/src/Nes_Oscs.cpp mod/source/gme/src/Nes_Oscs.cpp
--- orig/source/gme/src/Nes_Oscs.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Oscs.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,578 @@
+// Nes_Snd_Emu 0.2.0-pre. http://www.slack.net/~ant/
+
+#include "Nes_Apu.h"
+
+/* Copyright (C) 2003-2006 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// Nes_Osc
+
+void Nes_Osc::clock_length( int halt_mask )
+{
+	if ( length_counter && !(regs [0] & halt_mask) )
+		length_counter--;
+}
+
+void Nes_Envelope::clock_envelope()
+{
+	int period = regs [0] & 15;
+	if ( reg_written [3] )
+	{
+		reg_written [3] = false;
+		env_delay = period;
+		envelope = 15;
+	}
+	else if ( --env_delay < 0 )
+	{
+		env_delay = period;
+		if ( envelope | (regs [0] & 0x20) )
+			envelope = (envelope - 1) & 15;
+	}
+}
+
+int Nes_Envelope::volume() const
+{
+	return length_counter == 0 ? 0 : (regs [0] & 0x10) ? (regs [0] & 15) : envelope;
+}
+
+// Nes_Square
+
+void Nes_Square::clock_sweep( int negative_adjust )
+{
+	int sweep = regs [1];
+	
+	if ( --sweep_delay < 0 )
+	{
+		reg_written [1] = true;
+		
+		int period = this->period();
+		int shift = sweep & shift_mask;
+		if ( shift && (sweep & 0x80) && period >= 8 )
+		{
+			int offset = period >> shift;
+			
+			if ( sweep & negate_flag )
+				offset = negative_adjust - offset;
+			
+			if ( period + offset < 0x800 )
+			{
+				period += offset;
+				// rewrite period
+				regs [2] = period & 0xFF;
+				regs [3] = (regs [3] & ~7) | ((period >> 8) & 7);
+			}
+		}
+	}
+	
+	if ( reg_written [1] )
+	{
+		reg_written [1] = false;
+		sweep_delay = (sweep >> 4) & 7;
+	}
+}
+
+// TODO: clean up
+inline Nes_Square::nes_time_t Nes_Square::maintain_phase( nes_time_t time, nes_time_t end_time,
+		nes_time_t timer_period )
+{
+	nes_time_t remain = end_time - time;
+	if ( remain > 0 )
+	{
+		int count = (remain + timer_period - 1) / timer_period;
+		phase = (phase + count) & (phase_range - 1);
+		time += count * timer_period;
+	}
+	return time;
+}
+
+void Nes_Square::run( nes_time_t time, nes_time_t end_time )
+{
+	const int period = this->period();
+	const int timer_period = (period + 1) * 2;
+	
+	if ( !output )
+	{
+		delay = maintain_phase( time + delay, end_time, timer_period ) - end_time;
+		return;
+	}
+	
+	int offset = period >> (regs [1] & shift_mask);
+	if ( regs [1] & negate_flag )
+		offset = 0;
+	
+	const int volume = this->volume();
+	if ( volume == 0 || period < 8 || (period + offset) >= 0x800 )
+	{
+		if ( last_amp )
+		{
+			output->set_modified();
+			synth.offset( time, -last_amp, output );
+			last_amp = 0;
+		}
+		
+		time += delay;
+		time = maintain_phase( time, end_time, timer_period );
+	}
+	else
+	{
+		// handle duty select
+		int duty_select = (regs [0] >> 6) & 3;
+		int duty = 1 << duty_select; // 1, 2, 4, 2
+		int amp = 0;
+		if ( duty_select == 3 )
+		{
+			duty = 2; // negated 25%
+			amp = volume;
+		}
+		if ( phase < duty )
+			amp ^= volume;
+		
+		output->set_modified();
+		{
+			int delta = update_amp( amp );
+			if ( delta )
+				synth.offset( time, delta, output );
+		}
+		
+		time += delay;
+		if ( time < end_time )
+		{
+			Blip_Buffer* const output = this->output;
+			const Synth& synth = this->synth;
+			int delta = amp * 2 - volume;
+			int phase = this->phase;
+			
+			do
+			{
+				phase = (phase + 1) & (phase_range - 1);
+				if ( phase == 0 || phase == duty )
+				{
+					delta = -delta;
+					synth.offset_inline( time, delta, output );
+				}
+				time += timer_period;
+			}
+			while ( time < end_time );
+			
+			last_amp = (delta + volume) >> 1;
+			this->phase = phase;
+		}
+	}
+	
+	delay = time - end_time;
+}
+
+// Nes_Triangle
+
+void Nes_Triangle::clock_linear_counter()
+{
+	if ( reg_written [3] )
+		linear_counter = regs [0] & 0x7F;
+	else if ( linear_counter )
+		linear_counter--;
+	
+	if ( !(regs [0] & 0x80) )
+		reg_written [3] = false;
+}
+
+inline int Nes_Triangle::calc_amp() const
+{
+	int amp = phase_range - phase;
+	if ( amp < 0 )
+		amp = phase - (phase_range + 1);
+	return amp;
+}
+
+// TODO: clean up
+inline Nes_Square::nes_time_t Nes_Triangle::maintain_phase( nes_time_t time, nes_time_t end_time,
+		nes_time_t timer_period )
+{
+	nes_time_t remain = end_time - time;
+	if ( remain > 0 )
+	{
+		int count = (remain + timer_period - 1) / timer_period;
+		phase = ((unsigned) phase + 1 - count) & (phase_range * 2 - 1);
+		phase++;
+		time += count * timer_period;
+	}
+	return time;
+}
+
+void Nes_Triangle::run( nes_time_t time, nes_time_t end_time )
+{
+	const int timer_period = period() + 1;
+	if ( !output )
+	{
+		time += delay;
+		delay = 0;
+		if ( length_counter && linear_counter && timer_period >= 3 )
+			delay = maintain_phase( time, end_time, timer_period ) - end_time;
+		return;
+	}
+	
+	// to do: track phase when period < 3
+	// to do: Output 7.5 on dac when period < 2? More accurate, but results in more clicks.
+	
+	int delta = update_amp( calc_amp() );
+	if ( delta )
+	{
+		output->set_modified();
+		synth.offset( time, delta, output );
+	}
+	
+	time += delay;
+	if ( length_counter == 0 || linear_counter == 0 || timer_period < 3 )
+	{
+		time = end_time;
+	}
+	else if ( time < end_time )
+	{
+		Blip_Buffer* const output = this->output;
+		
+		int phase = this->phase;
+		int volume = 1;
+		if ( phase > phase_range )
+		{
+			phase -= phase_range;
+			volume = -volume;
+		}
+		output->set_modified();
+		
+		do
+		{
+			if ( --phase == 0 )
+			{
+				phase = phase_range;
+				volume = -volume;
+			}
+			else
+			{
+				synth.offset_inline( time, volume, output );
+			}
+			
+			time += timer_period;
+		}
+		while ( time < end_time );
+		
+		if ( volume < 0 )
+			phase += phase_range;
+		this->phase = phase;
+		last_amp = calc_amp();
+ 	}
+	delay = time - end_time;
+}
+
+// Nes_Dmc
+
+void Nes_Dmc::reset()
+{
+	address = 0;
+	dac = 0;
+	buf = 0;
+	bits_remain = 1;
+	bits = 0;
+	buf_full = false;
+	silence = true;
+	next_irq = Nes_Apu::no_irq;
+	irq_flag = false;
+	irq_enabled = false;
+	
+	Nes_Osc::reset();
+	period = 0x1AC;
+}
+
+void Nes_Dmc::recalc_irq()
+{
+	nes_time_t irq = Nes_Apu::no_irq;
+	if ( irq_enabled && length_counter )
+		irq = apu->last_dmc_time + delay +
+				((length_counter - 1) * 8 + bits_remain - 1) * nes_time_t (period) + 1;
+	if ( irq != next_irq )
+	{
+		next_irq = irq;
+		apu->irq_changed();
+	}
+}
+
+int Nes_Dmc::count_reads( nes_time_t time, nes_time_t* last_read ) const
+{
+	if ( last_read )
+		*last_read = time;
+	
+	if ( length_counter == 0 )
+		return 0; // not reading
+	
+	nes_time_t first_read = next_read_time();
+	nes_time_t avail = time - first_read;
+	if ( avail <= 0 )
+		return 0;
+	
+	int count = (avail - 1) / (period * 8) + 1;
+	if ( !(regs [0] & loop_flag) && count > length_counter )
+		count = length_counter;
+	
+	if ( last_read )
+	{
+		*last_read = first_read + (count - 1) * (period * 8) + 1;
+		check( *last_read <= time );
+		check( count == count_reads( *last_read, NULL ) );
+		check( count - 1 == count_reads( *last_read - 1, NULL ) );
+	}
+	
+	return count;
+}
+
+static short const dmc_period_table [2] [16] = {
+	{428, 380, 340, 320, 286, 254, 226, 214, // NTSC
+	190, 160, 142, 128, 106,  84,  72,  54},
+
+	{398, 354, 316, 298, 276, 236, 210, 198, // PAL
+	176, 148, 132, 118,  98,  78,  66,  50}
+};
+
+inline void Nes_Dmc::reload_sample()
+{
+	address = 0x4000 + regs [2] * 0x40;
+	length_counter = regs [3] * 0x10 + 1;
+}
+
+static int const dmc_table [128] =
+{
+   0,  24,  48,  71,  94, 118, 141, 163, 186, 209, 231, 253, 275, 297, 319, 340,
+ 361, 383, 404, 425, 445, 466, 486, 507, 527, 547, 567, 587, 606, 626, 645, 664,
+ 683, 702, 721, 740, 758, 777, 795, 813, 832, 850, 867, 885, 903, 920, 938, 955,
+ 972, 989,1006,1023,1040,1056,1073,1089,1105,1122,1138,1154,1170,1185,1201,1217,
+1232,1248,1263,1278,1293,1308,1323,1338,1353,1368,1382,1397,1411,1425,1440,1454,
+1468,1482,1496,1510,1523,1537,1551,1564,1578,1591,1604,1618,1631,1644,1657,1670,
+1683,1695,1708,1721,1733,1746,1758,1771,1783,1795,1807,1819,1831,1843,1855,1867,
+1879,1890,1902,1914,1925,1937,1948,1959,1971,1982,1993,2004,2015,2026,2037,2048,
+};
+
+inline int Nes_Dmc::update_amp_nonlinear( int in )
+{
+	if ( !nonlinear )
+		in = dmc_table [in];
+	int delta = in - last_amp;
+	last_amp = in;
+	return delta;
+}
+
+void Nes_Dmc::write_register( int addr, int data )
+{
+	if ( addr == 0 )
+	{
+		period = dmc_period_table [pal_mode] [data & 15];
+		irq_enabled = (data & 0xC0) == 0x80; // enabled only if loop disabled
+		irq_flag &= irq_enabled;
+		recalc_irq();
+	}
+	else if ( addr == 1 )
+	{
+		dac = data & 0x7F;
+	}
+}
+
+void Nes_Dmc::start()
+{
+	reload_sample();
+	fill_buffer();
+	recalc_irq();
+}
+
+void Nes_Dmc::fill_buffer()
+{
+	if ( !buf_full && length_counter )
+	{
+		require( apu->dmc_reader.f ); // dmc_reader must be set
+		buf = apu->dmc_reader.f( apu->dmc_reader.data, 0x8000u + address );
+		address = (address + 1) & 0x7FFF;
+		buf_full = true;
+		if ( --length_counter == 0 )
+		{
+			if ( regs [0] & loop_flag )
+			{
+				reload_sample();
+			}
+			else
+			{
+				apu->osc_enables &= ~0x10;
+				irq_flag = irq_enabled;
+				next_irq = Nes_Apu::no_irq;
+				apu->irq_changed();
+			}
+		}
+	}
+}
+
+void Nes_Dmc::run( nes_time_t time, nes_time_t end_time )
+{
+	int delta = update_amp_nonlinear( dac );
+	if ( !output )
+	{
+		silence = true;
+	}
+	else if ( delta )
+	{
+		output->set_modified();
+		synth.offset( time, delta, output );
+	}
+	
+	time += delay;
+	if ( time < end_time )
+	{
+		int bits_remain = this->bits_remain;
+		if ( silence && !buf_full )
+		{
+			int count = (end_time - time + period - 1) / period;
+			bits_remain = (bits_remain - 1 + 8 - (count % 8)) % 8 + 1;
+			time += count * period;
+		}
+		else
+		{
+			Blip_Buffer* const output = this->output;
+			const int period = this->period;
+			int bits = this->bits;
+			int dac = this->dac;
+			if ( output )
+				output->set_modified();
+			
+			do
+			{
+				if ( !silence )
+				{
+					int step = (bits & 1) * 4 - 2;
+					bits >>= 1;
+					if ( unsigned (dac + step) <= 0x7F )
+					{
+						dac += step;
+						synth.offset_inline( time, update_amp_nonlinear( dac ), output );
+					}
+				}
+				
+				time += period;
+				
+				if ( --bits_remain == 0 )
+				{
+					bits_remain = 8;
+					if ( !buf_full )
+					{
+						silence = true;
+					}
+					else
+					{
+						silence = false;
+						bits = buf;
+						buf_full = false;
+						if ( !output )
+							silence = true;
+						fill_buffer();
+					}
+				}
+			}
+			while ( time < end_time );
+			
+			this->dac = dac;
+			this->bits = bits;
+		}
+		this->bits_remain = bits_remain;
+	}
+	delay = time - end_time;
+}
+
+// Nes_Noise
+
+static short const noise_period_table [16] = {
+	0x004, 0x008, 0x010, 0x020, 0x040, 0x060, 0x080, 0x0A0,
+	0x0CA, 0x0FE, 0x17C, 0x1FC, 0x2FA, 0x3F8, 0x7F2, 0xFE4
+};
+
+void Nes_Noise::run( nes_time_t time, nes_time_t end_time )
+{
+	int period = noise_period_table [regs [2] & 15];
+	
+	if ( !output )
+	{
+		// TODO: clean up
+		time += delay;
+		delay = time + (end_time - time + period - 1) / period * period - end_time;
+		return;
+	}
+	
+	
+	const int volume = this->volume();
+	int amp = (noise & 1) ? volume : 0;
+	{
+		int delta = update_amp( amp );
+		if ( delta )
+		{
+			output->set_modified();
+			synth.offset( time, delta, output );
+		}
+	}
+	
+	time += delay;
+	if ( time < end_time )
+	{
+		const int mode_flag = 0x80;
+		
+		if ( !volume )
+		{
+			// round to next multiple of period
+			time += (end_time - time + period - 1) / period * period;
+			
+			// approximate noise cycling while muted, by shuffling up noise register
+			// to do: precise muted noise cycling?
+			if ( !(regs [2] & mode_flag) )
+			{
+				int feedback = (noise << 13) ^ (noise << 14);
+				noise = (feedback & 0x4000) | (noise >> 1);
+			}
+		}
+		else
+		{
+			Blip_Buffer* const output = this->output;
+			
+			// using resampled time avoids conversion in synth.offset()
+			blip_resampled_time_t rperiod = output->resampled_duration( period );
+			blip_resampled_time_t rtime = output->resampled_time( time );
+			
+			int noise = this->noise;
+			int delta = amp * 2 - volume;
+			const int tap = (regs [2] & mode_flag ? 8 : 13);
+			output->set_modified();
+			
+			do
+			{
+				int feedback = (noise << tap) ^ (noise << 14);
+				time += period;
+				
+				if ( (noise + 1) & 2 )
+				{
+					// bits 0 and 1 of noise differ
+					delta = -delta;
+					synth.offset_resampled( rtime, delta, output );
+				}
+				
+				rtime += rperiod;
+				noise = (feedback & 0x4000) | (noise >> 1);
+			}
+			while ( time < end_time );
+			
+			last_amp = (delta + volume) >> 1;
+			this->noise = noise;
+		}
+	}
+	
+	delay = time - end_time;
+}
+
diff -Nur orig/source/gme/src/Nes_Oscs.h mod/source/gme/src/Nes_Oscs.h
--- orig/source/gme/src/Nes_Oscs.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Oscs.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,147 @@
+// Private oscillators used by Nes_Apu
+
+// Nes_Snd_Emu 0.2.0-pre
+#ifndef NES_OSCS_H
+#define NES_OSCS_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+class Nes_Apu;
+
+struct Nes_Osc
+{
+	typedef int nes_time_t;
+	
+	unsigned char regs [4];
+	bool reg_written [4];
+	Blip_Buffer* output;
+	int length_counter;// length counter (0 if unused by oscillator)
+	int delay;      // delay until next (potential) transition
+	int last_amp;   // last amplitude oscillator was outputting
+	
+	void clock_length( int halt_mask );
+	int period() const {
+		return (regs [3] & 7) * 0x100 + (regs [2] & 0xFF);
+	}
+	void reset() {
+		delay = 0;
+		last_amp = 0;
+	}
+	int update_amp( int amp ) {
+		int delta = amp - last_amp;
+		last_amp = amp;
+		return delta;
+	}
+};
+
+struct Nes_Envelope : Nes_Osc
+{
+	int envelope;
+	int env_delay;
+	
+	void clock_envelope();
+	int volume() const;
+	void reset() {
+		envelope = 0;
+		env_delay = 0;
+		Nes_Osc::reset();
+	}
+};
+
+// Nes_Square
+struct Nes_Square : Nes_Envelope
+{
+	enum { negate_flag = 0x08 };
+	enum { shift_mask = 0x07 };
+	enum { phase_range = 8 };
+	int phase;
+	int sweep_delay;
+	
+	typedef Blip_Synth_Norm Synth;
+	Synth const& synth; // shared between squares
+	
+	Nes_Square( Synth const* s ) : synth( *s ) { }
+	
+	void clock_sweep( int adjust );
+	void run( nes_time_t, nes_time_t );
+	void reset() {
+		sweep_delay = 0;
+		Nes_Envelope::reset();
+	}
+	nes_time_t maintain_phase( nes_time_t time, nes_time_t end_time,
+			nes_time_t timer_period );
+};
+
+// Nes_Triangle
+struct Nes_Triangle : Nes_Osc
+{
+	enum { phase_range = 16 };
+	int phase;
+	int linear_counter;
+	Blip_Synth_Fast synth;
+	
+	int calc_amp() const;
+	void run( nes_time_t, nes_time_t );
+	void clock_linear_counter();
+	void reset() {
+		linear_counter = 0;
+		phase = 1;
+		Nes_Osc::reset();
+	}
+	nes_time_t maintain_phase( nes_time_t time, nes_time_t end_time,
+			nes_time_t timer_period );
+};
+
+// Nes_Noise
+struct Nes_Noise : Nes_Envelope
+{
+	int noise;
+	Blip_Synth_Fast synth;
+	
+	void run( nes_time_t, nes_time_t );
+	void reset() {
+		noise = 1 << 14;
+		Nes_Envelope::reset();
+	}
+};
+
+// Nes_Dmc
+struct Nes_Dmc : Nes_Osc
+{
+	int address;    // address of next byte to read
+	int period;
+	//int length_counter; // bytes remaining to play (already defined in Nes_Osc)
+	int buf;
+	int bits_remain;
+	int bits;
+	bool buf_full;
+	bool silence;
+	
+	enum { loop_flag = 0x40 };
+	
+	int dac;
+	
+	nes_time_t next_irq;
+	bool irq_enabled;
+	bool irq_flag;
+	bool pal_mode;
+	bool nonlinear;
+	
+	Nes_Apu* apu;
+	
+	Blip_Synth_Fast synth;
+	
+	int  update_amp_nonlinear( int dac_in );
+	void start();
+	void write_register( int, int );
+	void run( nes_time_t, nes_time_t );
+	void recalc_irq();
+	void fill_buffer();
+	void reload_sample();
+	void reset();
+	int count_reads( nes_time_t, nes_time_t* ) const;
+	nes_time_t next_read_time() const;
+};
+
+#endif
diff -Nur orig/source/gme/src/nestypes.h mod/source/gme/src/nestypes.h
--- orig/source/gme/src/nestypes.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/nestypes.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,40 @@
+#ifndef NESTYPES_H__
+#define NESTYPES_H__
+
+#if defined(_MSC_VER)
+#define NEVER_REACH __assume(0);
+#define inline __inline
+#elif defined(__BORLANDC__)
+#define __fastcall __msfastcall
+#elif defined(__GNUC__)
+#define __inline        __inline__
+#define __fastcall
+#else
+#define __inline
+#define __fastcall
+#endif
+#ifndef NEVER_REACH
+#define NEVER_REACH
+#endif
+
+typedef int             Int;
+typedef unsigned int    Uint;
+typedef signed int      Int32;
+typedef unsigned int    Uint32;
+typedef signed short    Int16;
+typedef unsigned short  Uint16;
+typedef signed char     Int8;
+typedef unsigned char   Uint8;
+typedef char            Char;
+
+#include <stdlib.h>
+
+#define XSLEEP(n)       ((void)0)
+#define XMALLOC(s)      malloc(s)
+#define XREALLOC(p,s)   realloc(p,s)
+#define XFREE(p)        free(p);\
+						p = NULL;
+#define XMEMCPY(d,s,n)  memcpy(d,s,n)
+#define XMEMSET(d,c,n)  memset(d,c,n)
+
+#endif /* NESTYPES_H__ */
diff -Nur orig/source/gme/src/Nes_Vrc6_Apu.cpp mod/source/gme/src/Nes_Vrc6_Apu.cpp
--- orig/source/gme/src/Nes_Vrc6_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Vrc6_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,216 @@
+// Nes_Snd_Emu 0.2.0-pre. http://www.slack.net/~ant/
+
+#include "Nes_Vrc6_Apu.h"
+
+/* Copyright (C) 2003-2006 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void Nes_Vrc6_Apu::set_output( Blip_Buffer* buf )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		set_output( i, buf );
+}
+
+void Nes_Vrc6_Apu::reset()
+{
+	last_time = 0;
+	for ( int i = 0; i < osc_count; i++ )
+	{
+		Vrc6_Osc& osc = oscs [i];
+		for ( int j = 0; j < reg_count; j++ )
+			osc.regs [j] = 0;
+		osc.delay = 0;
+		osc.last_amp = 0;
+		osc.phase = 1;
+		osc.amp = 0;
+	}
+}
+
+Nes_Vrc6_Apu::Nes_Vrc6_Apu()
+{
+	set_output( NULL );
+	volume( 1.0 );
+	reset();
+}
+
+void Nes_Vrc6_Apu::run_until( blip_time_t time )
+{
+	require( time >= last_time );
+	run_square( oscs [0], time );
+	run_square( oscs [1], time );
+	run_saw( time );
+	last_time = time;
+}
+
+void Nes_Vrc6_Apu::write_osc( blip_time_t time, int osc_index, int reg, int data )
+{
+	require( (unsigned) osc_index < osc_count );
+	require( (unsigned) reg < reg_count );
+	
+	run_until( time );
+	oscs [osc_index].regs [reg] = data;
+}
+
+void Nes_Vrc6_Apu::end_frame( blip_time_t time )
+{
+	if ( time > last_time )
+		run_until( time );
+	
+	assert( last_time >= time );
+	last_time -= time;
+}
+
+void Nes_Vrc6_Apu::save_state( vrc6_apu_state_t* out ) const
+{
+	assert( sizeof (vrc6_apu_state_t) == 20 );
+	out->saw_amp = oscs [2].amp;
+	for ( int i = 0; i < osc_count; i++ )
+	{
+		Vrc6_Osc const& osc = oscs [i];
+		for ( int r = 0; r < reg_count; r++ )
+			out->regs [i] [r] = osc.regs [r];
+		
+		out->delays [i] = osc.delay;
+		out->phases [i] = osc.phase;
+	}
+}
+
+void Nes_Vrc6_Apu::load_state( vrc6_apu_state_t const& in )
+{
+	reset();
+	oscs [2].amp = in.saw_amp;
+	for ( int i = 0; i < osc_count; i++ )
+	{
+		Vrc6_Osc& osc = oscs [i];
+		for ( int r = 0; r < reg_count; r++ )
+			osc.regs [r] = in.regs [i] [r];
+		
+		osc.delay = in.delays [i];
+		osc.phase = in.phases [i];
+	}
+	if ( !oscs [2].phase )
+		oscs [2].phase = 1;
+}
+
+void Nes_Vrc6_Apu::run_square( Vrc6_Osc& osc, blip_time_t end_time )
+{
+	Blip_Buffer* output = osc.output;
+	if ( !output )
+		return;
+	
+	int volume = osc.regs [0] & 15;
+	if ( !(osc.regs [2] & 0x80) )
+		volume = 0;
+	
+	int gate = osc.regs [0] & 0x80;
+	int duty = ((osc.regs [0] >> 4) & 7) + 1;
+	int delta = ((gate || osc.phase < duty) ? volume : 0) - osc.last_amp;
+	blip_time_t time = last_time;
+	if ( delta )
+	{
+		osc.last_amp += delta;
+		output->set_modified();
+		square_synth.offset( time, delta, output );
+	}
+	
+	time += osc.delay;
+	osc.delay = 0;
+	int period = osc.period();
+	if ( volume && !gate && period > 4 )
+	{
+		if ( time < end_time )
+		{
+			int phase = osc.phase;
+			output->set_modified();
+			
+			do
+			{
+				phase++;
+				if ( phase == 16 )
+				{
+					phase = 0;
+					osc.last_amp = volume;
+					square_synth.offset( time, volume, output );
+				}
+				if ( phase == duty )
+				{
+					osc.last_amp = 0;
+					square_synth.offset( time, -volume, output );
+				}
+				time += period;
+			}
+			while ( time < end_time );
+			
+			osc.phase = phase;
+		}
+		osc.delay = time - end_time;
+	}
+}
+
+void Nes_Vrc6_Apu::run_saw( blip_time_t end_time )
+{
+	Vrc6_Osc& osc = oscs [2];
+	Blip_Buffer* output = osc.output;
+	if ( !output )
+		return;
+	output->set_modified();
+	
+	int amp = osc.amp;
+	int amp_step = osc.regs [0] & 0x3F;
+	blip_time_t time = last_time;
+	int last_amp = osc.last_amp;
+	if ( !(osc.regs [2] & 0x80) || !(amp_step | amp) )
+	{
+		osc.delay = 0;
+		int delta = (amp >> 3) - last_amp;
+		last_amp = amp >> 3;
+		saw_synth.offset( time, delta, output );
+	}
+	else
+	{
+		time += osc.delay;
+		if ( time < end_time )
+		{
+			int period = osc.period() * 2;
+			int phase = osc.phase;
+			
+			do
+			{
+				if ( --phase == 0 )
+				{
+					phase = 7;
+					amp = 0;
+				}
+				
+				int delta = (amp >> 3) - last_amp;
+				if ( delta )
+				{
+					last_amp = amp >> 3;
+					saw_synth.offset( time, delta, output );
+				}
+				
+				time += period;
+				amp = (amp + amp_step) & 0xFF;
+			}
+			while ( time < end_time );
+			
+			osc.phase = phase;
+			osc.amp = amp;
+		}
+		
+		osc.delay = time - end_time;
+	}
+	
+	osc.last_amp = last_amp;
+}
+
diff -Nur orig/source/gme/src/Nes_Vrc6_Apu.h mod/source/gme/src/Nes_Vrc6_Apu.h
--- orig/source/gme/src/Nes_Vrc6_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Vrc6_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,95 @@
+// Konami VRC6 sound chip emulator
+
+// Nes_Snd_Emu 0.2.0-pre
+#ifndef NES_VRC6_APU_H
+#define NES_VRC6_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+struct vrc6_apu_state_t;
+
+class Nes_Vrc6_Apu {
+public:
+	// See Nes_Apu.h for reference
+	void reset();
+	void volume( double );
+	void treble_eq( blip_eq_t const& );
+	void set_output( Blip_Buffer* );
+	enum { osc_count = 3 };
+	void set_output( int index, Blip_Buffer* );
+	void end_frame( blip_time_t );
+	void save_state( vrc6_apu_state_t* ) const;
+	void load_state( vrc6_apu_state_t const& );
+	
+	// Oscillator 0 write-only registers are at $9000-$9002
+	// Oscillator 1 write-only registers are at $A000-$A002
+	// Oscillator 2 write-only registers are at $B000-$B002
+	enum { reg_count = 3 };
+	enum { base_addr = 0x9000 };
+	enum { addr_step = 0x1000 };
+	void write_osc( blip_time_t, int osc, int reg, int data );
+	
+public:
+	Nes_Vrc6_Apu();
+	BLARGG_DISABLE_NOTHROW
+private:
+	// noncopyable
+	Nes_Vrc6_Apu( const Nes_Vrc6_Apu& );
+	Nes_Vrc6_Apu& operator = ( const Nes_Vrc6_Apu& );
+	
+	struct Vrc6_Osc
+	{
+		BOOST::uint8_t regs [3];
+		Blip_Buffer* output;
+		int delay;
+		int last_amp;
+		int phase;
+		int amp; // only used by saw
+		
+		int period() const
+		{
+			return (regs [2] & 0x0F) * 0x100 + regs [1] + 1;
+		}
+	};
+	
+	Vrc6_Osc oscs [osc_count];
+	blip_time_t last_time;
+	
+	Blip_Synth_Fast saw_synth;
+	Blip_Synth_Norm square_synth;
+	
+	void run_until( blip_time_t );
+	void run_square( Vrc6_Osc& osc, blip_time_t );
+	void run_saw( blip_time_t );
+};
+
+struct vrc6_apu_state_t
+{
+	BOOST::uint8_t regs [3] [3];
+	BOOST::uint8_t saw_amp;
+	BOOST::uint16_t delays [3];
+	BOOST::uint8_t phases [3];
+	BOOST::uint8_t unused;
+};
+
+inline void Nes_Vrc6_Apu::set_output( int i, Blip_Buffer* buf )
+{
+	assert( (unsigned) i < osc_count );
+	oscs [i].output = buf;
+}
+
+inline void Nes_Vrc6_Apu::volume( double v )
+{
+	double const factor = 0.0967 * 2;
+	saw_synth.volume( factor / 31 * v );
+	square_synth.volume( factor * 0.5 / 15 * v );
+}
+
+inline void Nes_Vrc6_Apu::treble_eq( blip_eq_t const& eq )
+{
+	saw_synth.treble_eq( eq );
+	square_synth.treble_eq( eq );
+}
+
+#endif
diff -Nur orig/source/gme/src/Nes_Vrc7_Apu.cpp mod/source/gme/src/Nes_Vrc7_Apu.cpp
--- orig/source/gme/src/Nes_Vrc7_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Vrc7_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,206 @@
+#include "Nes_Vrc7_Apu.h"
+
+#include "ym2413.h"
+#include <string.h>
+
+#include "blargg_source.h"
+
+int const period = 36; // NES CPU clocks per FM clock
+
+Nes_Vrc7_Apu::Nes_Vrc7_Apu()
+{
+	opll = 0;
+}
+
+blargg_err_t Nes_Vrc7_Apu::init()
+{
+	CHECK_ALLOC( opll = ym2413_init( 3579545, 3579545 / 72, 1 ) );
+	
+	set_output( 0 );
+	volume( 1.0 );
+	reset();
+	return 0;
+}
+
+Nes_Vrc7_Apu::~Nes_Vrc7_Apu()
+{
+	if ( opll )
+		ym2413_shutdown( opll );
+}
+
+void Nes_Vrc7_Apu::set_output( Blip_Buffer* buf )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		oscs [i].output = buf;
+	output_changed();
+}
+
+void Nes_Vrc7_Apu::output_changed()
+{
+	mono.output = oscs [0].output;
+	for ( int i = osc_count; --i; )
+	{
+		if ( mono.output != oscs [i].output )
+		{
+			mono.output = 0;
+			break;
+		}
+	}
+	
+	if ( mono.output )
+	{
+		for ( int i = osc_count; --i; )
+		{
+			mono.last_amp += oscs [i].last_amp;
+			oscs [i].last_amp = 0;
+		}
+	}
+}
+
+void Nes_Vrc7_Apu::reset()
+{
+	addr      = 0;
+	next_time = 0;
+	mono.last_amp = 0;
+	
+	for ( int i = osc_count; --i >= 0; )
+	{
+		Vrc7_Osc& osc = oscs [i];
+		osc.last_amp = 0;
+		for ( int j = 0; j < 3; ++j )
+			osc.regs [j] = 0;
+	}
+
+	ym2413_reset_chip( opll );
+}
+
+void Nes_Vrc7_Apu::write_reg( int data )
+{
+	addr = data;
+}
+
+void Nes_Vrc7_Apu::write_data( blip_time_t time, int data )
+{
+	int type = (addr >> 4) - 1;
+	int chan = addr & 15;
+	if ( (unsigned) type < 3 && chan < osc_count )
+		oscs [chan].regs [type] = data;
+	
+	if ( time > next_time )
+		run_until( time );
+	ym2413_write( opll, 0, addr );
+	ym2413_write( opll, 1, data );
+}
+
+void Nes_Vrc7_Apu::end_frame( blip_time_t time )
+{
+	if ( time > next_time )
+		run_until( time );
+	
+	next_time -= time;
+	assert( next_time >= 0 );
+	
+	for ( int i = osc_count; --i >= 0; )
+	{
+		Blip_Buffer* output = oscs [i].output;
+		if ( output )
+			output->set_modified();
+	}
+}
+
+void Nes_Vrc7_Apu::save_snapshot( vrc7_snapshot_t* out ) const
+{
+	out->latch = addr;
+	out->delay = next_time;
+	for ( int i = osc_count; --i >= 0; )
+	{
+		for ( int j = 0; j < 3; ++j )
+			out->regs [i] [j] = oscs [i].regs [j];
+	}
+	memcpy( out->inst, ym2413_get_inst0( opll ), 8 );
+}
+
+void Nes_Vrc7_Apu::load_snapshot( vrc7_snapshot_t const& in )
+{
+	assert( offsetof (vrc7_snapshot_t,delay) == 28 - 1 );
+	
+	reset();
+	next_time = in.delay;
+	write_reg( in.latch );
+	int i;
+	for ( i = 0; i < osc_count; ++i )
+	{
+		for ( int j = 0; j < 3; ++j )
+			oscs [i].regs [j] = in.regs [i] [j];
+	}
+
+	for ( i = 0; i < 8; ++i )
+	{
+		ym2413_write( opll, 0, i );
+		ym2413_write( opll, 1, in.inst [i] );
+	}
+
+	for ( i = 0; i < 3; ++i )
+	{
+		for ( int j = 0; j < 6; ++j )
+		{
+			ym2413_write( opll, 0, 0x10 + i * 0x10 + j );
+			ym2413_write( opll, 1, oscs [j].regs [i] );
+		}
+	}
+}
+
+void Nes_Vrc7_Apu::run_until( blip_time_t end_time )
+{
+	require( end_time > next_time );
+
+	blip_time_t time = next_time;
+	void* opll = this->opll; // cache
+	Blip_Buffer* const mono_output = mono.output;
+	if ( mono_output )
+	{
+		// optimal case
+		do
+		{
+			ym2413_advance_lfo( opll );
+			int amp = 0;
+			for ( int i = 0; i < osc_count; i++ )
+				amp += ym2413_calcch( opll, i );
+			ym2413_advance( opll );
+			int delta = amp - mono.last_amp;
+			if ( delta )
+			{
+				mono.last_amp = amp;
+				synth.offset_inline( time, delta, mono_output );
+			}
+			time += period;
+		}
+		while ( time < end_time );
+	}
+	else
+	{
+		mono.last_amp = 0;
+		do
+		{
+			ym2413_advance_lfo( opll );
+			for ( int i = 0; i < osc_count; ++i )
+			{
+				Vrc7_Osc& osc = oscs [i];
+				if ( osc.output )
+				{
+					int amp = ym2413_calcch( opll, i );
+					int delta = amp - osc.last_amp;
+					if ( delta )
+					{
+						osc.last_amp = amp;
+						synth.offset( time, delta, osc.output );
+					}
+				}
+			}
+			ym2413_advance( opll );
+			time += period;
+		}
+		while ( time < end_time );
+	}
+	next_time = time;
+}
diff -Nur orig/source/gme/src/Nes_Vrc7_Apu.h mod/source/gme/src/Nes_Vrc7_Apu.h
--- orig/source/gme/src/Nes_Vrc7_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nes_Vrc7_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,80 @@
+// Konami VRC7 sound chip emulator
+
+#ifndef NES_VRC7_APU_H
+#define NES_VRC7_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+struct vrc7_snapshot_t;
+
+class Nes_Vrc7_Apu {
+public:
+	blargg_err_t init();
+	
+	// See Nes_Apu.h for reference
+	void reset();
+	void volume( double );
+	void treble_eq( blip_eq_t const& );
+	void set_output( Blip_Buffer* );
+	enum { osc_count = 6 };
+	void set_output( int index, Blip_Buffer* );
+	void end_frame( blip_time_t );
+	void save_snapshot( vrc7_snapshot_t* ) const;
+	void load_snapshot( vrc7_snapshot_t const& );
+	
+	void write_reg( int reg );
+	void write_data( blip_time_t, int data );
+	
+public:
+	Nes_Vrc7_Apu();
+	~Nes_Vrc7_Apu();
+	BLARGG_DISABLE_NOTHROW
+private:
+	// noncopyable
+	Nes_Vrc7_Apu( const Nes_Vrc7_Apu& );
+	Nes_Vrc7_Apu& operator = ( const Nes_Vrc7_Apu& );
+
+	struct Vrc7_Osc
+	{
+		BOOST::uint8_t regs [3];
+		Blip_Buffer* output;
+		int last_amp;
+	};
+
+	Vrc7_Osc oscs [osc_count];
+	void* opll;
+	int addr;
+	blip_time_t next_time;
+	struct {
+		Blip_Buffer* output;
+		int last_amp;
+	} mono;
+	
+	Blip_Synth_Fast synth;
+	
+	void run_until( blip_time_t );
+	void output_changed();
+};
+
+struct vrc7_snapshot_t
+{
+	BOOST::uint8_t latch;
+	BOOST::uint8_t inst [8];
+	BOOST::uint8_t regs [6] [3];
+	BOOST::uint8_t delay;
+};
+
+inline void Nes_Vrc7_Apu::set_output( int i, Blip_Buffer* buf )
+{
+	assert( (unsigned) i < osc_count );
+	oscs [i].output = buf;
+	output_changed();
+}
+
+// DB2LIN_AMP_BITS == 11, * 2
+inline void Nes_Vrc7_Apu::volume( double v ) { synth.volume( 1.0 / 3 / 4096 * v ); }
+
+inline void Nes_Vrc7_Apu::treble_eq( blip_eq_t const& eq ) { synth.treble_eq( eq ); }
+
+#endif
diff -Nur orig/source/gme/src/Nsf_Core.cpp mod/source/gme/src/Nsf_Core.cpp
--- orig/source/gme/src/Nsf_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsf_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,302 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nsf_Core.h"
+
+#include "blargg_endian.h"
+
+#if !NSF_EMU_APU_ONLY
+	#include "Nes_Namco_Apu.h"
+	#include "Nes_Vrc6_Apu.h"
+	#include "Nes_Fme7_Apu.h"
+	#include "Nes_Fds_Apu.h"
+	#include "Nes_Mmc5_Apu.h"
+	#include "Nes_Vrc7_Apu.h"
+#endif
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Nsf_Core::Nsf_Core()
+{
+	fds   = NULL;
+	fme7  = NULL;
+	mmc5  = NULL;
+	namco = NULL;
+	vrc6  = NULL;
+	vrc7  = NULL;
+}
+
+Nsf_Core::~Nsf_Core()
+{
+	unload();
+}
+
+void Nsf_Core::unload()
+{
+#if !NSF_EMU_APU_ONLY
+	delete fds;
+	fds = NULL;
+	
+	delete fme7;
+	fme7 = NULL;
+	
+	delete namco;
+	namco = NULL;
+	
+	delete mmc5;
+	mmc5 = NULL;
+	
+	delete vrc6;
+	vrc6 = NULL;
+	
+	delete vrc7;
+	vrc7 = NULL;
+#endif
+
+	Nsf_Impl::unload();
+}
+
+void Nsf_Core::set_tempo( double t )
+{
+	set_play_period( (int) (header().play_period() / t) );
+	nes_apu()->set_tempo( t );
+#if !NSF_EMU_APU_ONLY
+	if ( fds )
+		fds->set_tempo( t );
+#endif
+}
+
+blargg_err_t Nsf_Core::post_load()
+{
+	int chip_flags = header().chip_flags;
+	
+	#if !NSF_EMU_APU_ONLY
+		if ( chip_flags & header_t::fds_mask )
+			CHECK_ALLOC( fds = BLARGG_NEW Nes_Fds_Apu );
+		
+		if ( chip_flags & header_t::fme7_mask )
+			CHECK_ALLOC( fme7 = BLARGG_NEW Nes_Fme7_Apu );
+		
+		if ( chip_flags & header_t::mmc5_mask )
+			CHECK_ALLOC( mmc5 = BLARGG_NEW Nes_Mmc5_Apu );
+		
+		if ( chip_flags & header_t::namco_mask )
+			CHECK_ALLOC( namco = BLARGG_NEW Nes_Namco_Apu );
+		
+		if ( chip_flags & header_t::vrc6_mask )
+			CHECK_ALLOC( vrc6 = BLARGG_NEW Nes_Vrc6_Apu );
+		
+		if ( chip_flags & header_t::vrc7_mask )
+		{
+			#if NSF_EMU_NO_VRC7
+				chip_flags = ~chips_mask; // give warning rather than error
+			#else
+					CHECK_ALLOC( vrc7 = BLARGG_NEW Nes_Vrc7_Apu );
+					RETURN_ERR( vrc7->init() );
+			#endif
+		}
+	#endif
+
+	set_tempo( 1.0 );
+	
+	if ( chip_flags & ~chips_mask )
+		set_warning( "Uses unsupported audio expansion hardware" );
+
+	return Nsf_Impl::post_load();
+}
+
+int Nsf_Core::cpu_read( addr_t addr )
+{
+	#if !NSF_EMU_APU_ONLY
+	{
+		if ( addr == Nes_Namco_Apu::data_reg_addr && namco )
+			return namco->read_data();
+		
+		if ( (unsigned) (addr - Nes_Fds_Apu::io_addr) < Nes_Fds_Apu::io_size && fds )
+			return fds->read( time(), addr );
+		
+		int i = addr - 0x5C00;
+		if ( (unsigned) i < mmc5->exram_size && mmc5 )
+			return mmc5->exram [i];
+		
+		int m = addr - 0x5205;
+		if ( (unsigned) m < 2 && mmc5 )
+			return (mmc5_mul [0] * mmc5_mul [1]) >> (m * 8) & 0xFF;
+	}
+	#endif
+	
+	return Nsf_Impl::cpu_read( addr );
+}
+
+int Nsf_Core::unmapped_read( addr_t addr )
+{
+	switch ( addr )
+	{
+	case 0x2002:
+	case 0x4016:
+	case 0x4017:
+		return addr >> 8;
+	}
+
+	return Nsf_Impl::unmapped_read( addr );
+}
+
+void Nsf_Core::cpu_write( addr_t addr, int data )
+{
+	#if !NSF_EMU_APU_ONLY
+	{
+		if ( (unsigned) (addr - fds->io_addr) < fds->io_size && fds )
+		{
+			fds->write( time(), addr, data );
+			return;
+		}
+		
+		if ( namco )
+		{
+			if ( addr == namco->addr_reg_addr )
+			{
+				namco->write_addr( data );
+				return;
+			}
+			
+			if ( addr == namco->data_reg_addr )
+			{
+				namco->write_data( time(), data );
+				return;
+			}
+		}
+		
+		if ( vrc6 )
+		{
+			int reg = addr & (vrc6->addr_step - 1);
+			int osc = (unsigned) (addr - vrc6->base_addr) / vrc6->addr_step;
+			if ( (unsigned) osc < vrc6->osc_count && (unsigned) reg < vrc6->reg_count )
+			{
+				vrc6->write_osc( time(), osc, reg, data );
+				return;
+			}
+		}
+		
+		if ( addr >= fme7->latch_addr && fme7 )
+		{
+			switch ( addr & fme7->addr_mask )
+			{
+			case Nes_Fme7_Apu::latch_addr:
+				fme7->write_latch( data );
+				return;
+			
+			case Nes_Fme7_Apu::data_addr:
+				fme7->write_data( time(), data );
+				return;
+			}
+		}
+		
+		if ( mmc5 )
+		{
+			if ( (unsigned) (addr - mmc5->regs_addr) < mmc5->regs_size )
+			{
+				mmc5->write_register( time(), addr, data );
+				return;
+			}
+			
+			int m = addr - 0x5205;
+			if ( (unsigned) m < 2 )
+			{
+				mmc5_mul [m] = data;
+				return;
+			}
+			
+			int i = addr - 0x5C00;
+			if ( (unsigned) i < mmc5->exram_size )
+			{
+				mmc5->exram [i] = data;
+				return;
+			}
+		}
+		
+		if ( vrc7 )
+		{
+			if ( addr == 0x9010 )
+			{
+				vrc7->write_reg( data );
+				return;
+			}
+			
+			if ( (unsigned) (addr - 0x9028) <= 0x08 )
+			{
+				vrc7->write_data( time(), data );
+				return;
+			}
+		}
+	}
+	#endif
+	
+	return Nsf_Impl::cpu_write( addr, data );
+}
+
+void Nsf_Core::unmapped_write( addr_t addr, int data )
+{
+	switch ( addr )
+	{
+	case 0x8000: // some write to $8000 and $8001 repeatedly
+	case 0x8001:
+	case 0x4800: // probably namco sound mistakenly turned on in MCK
+	case 0xF800:
+	case 0xFFF8: // memory mapper?
+		return;
+	}
+	
+	if ( mmc5 && addr == 0x5115 ) return;
+	
+	// FDS memory
+	if ( fds && (unsigned) (addr - 0x8000) < 0x6000 ) return;
+
+	Nsf_Impl::unmapped_write( addr, data );
+}
+
+blargg_err_t Nsf_Core::start_track( int track )
+{
+	#if !NSF_EMU_APU_ONLY
+		if ( mmc5 )
+		{
+			mmc5_mul [0] = 0;
+			mmc5_mul [1] = 0;
+			memset( mmc5->exram, 0, mmc5->exram_size );
+		}
+	#endif
+	
+	#if !NSF_EMU_APU_ONLY
+		if ( fds   ) fds  ->reset();
+		if ( fme7  ) fme7 ->reset();
+		if ( mmc5  ) mmc5 ->reset();
+		if ( namco ) namco->reset();
+		if ( vrc6  ) vrc6 ->reset();
+		if ( vrc7  ) vrc7 ->reset();
+	#endif
+	
+	return Nsf_Impl::start_track( track );
+}
+
+void Nsf_Core::end_frame( time_t end )
+{
+	Nsf_Impl::end_frame( end );
+	
+	#if !NSF_EMU_APU_ONLY
+		if ( fds   ) fds  ->end_frame( end );
+		if ( fme7  ) fme7 ->end_frame( end );
+		if ( mmc5  ) mmc5 ->end_frame( end );
+		if ( namco ) namco->end_frame( end );
+		if ( vrc6  ) vrc6 ->end_frame( end );
+		if ( vrc7  ) vrc7 ->end_frame( end );
+	#endif
+}
diff -Nur orig/source/gme/src/Nsf_Core.h mod/source/gme/src/Nsf_Core.h
--- orig/source/gme/src/Nsf_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsf_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,68 @@
+// Loads NSF file and emulates CPU and sound chips
+
+// Game_Music_Emu 0.6-pre
+#ifndef NSF_CORE_H
+#define NSF_CORE_H
+
+#include "Nsf_Impl.h"
+
+class Nes_Namco_Apu;
+class Nes_Vrc6_Apu;
+class Nes_Fme7_Apu;
+class Nes_Mmc5_Apu;
+class Nes_Vrc7_Apu;
+class Nes_Fds_Apu;
+
+class Nsf_Core : public Nsf_Impl {
+public:
+	
+	// Adjusts music tempo, where 1.0 is normal. Can be changed while playing.
+	// Loading a file resets tempo to 1.0.
+	void set_tempo( double );
+	
+	// Pointer to sound chip, or NULL if not used by current file.
+	// Must be assigned to a Blip_Buffer to get any sound.
+	Nes_Fds_Apu  * fds_apu  () { return fds;   }
+	Nes_Fme7_Apu * fme7_apu () { return fme7;  }
+	Nes_Mmc5_Apu * mmc5_apu () { return mmc5;  }
+	Nes_Namco_Apu* namco_apu() { return namco; }
+	Nes_Vrc6_Apu * vrc6_apu () { return vrc6;  }
+	Nes_Vrc7_Apu * vrc7_apu () { return vrc7;  }
+	
+	// Mask for which chips are supported
+	#if NSF_EMU_APU_ONLY
+		enum { chips_mask = 0 };
+	#else
+		enum { chips_mask = header_t::all_mask };
+	#endif
+
+protected:
+	virtual int  unmapped_read(  addr_t );
+	virtual void unmapped_write( addr_t, int data );
+
+
+// Implementation
+public:
+	Nsf_Core();
+	~Nsf_Core();
+	virtual void unload();
+	virtual blargg_err_t start_track( int );
+	virtual void end_frame( time_t );
+
+protected:
+	virtual blargg_err_t post_load();
+	virtual int  cpu_read(  addr_t );
+	virtual void cpu_write( addr_t, int );
+
+private:
+	byte mmc5_mul [2];
+	
+	Nes_Fds_Apu*   fds;
+	Nes_Fme7_Apu*  fme7;
+	Nes_Mmc5_Apu*  mmc5;
+	Nes_Namco_Apu* namco;
+	Nes_Vrc6_Apu*  vrc6;
+	Nes_Vrc7_Apu*  vrc7;
+};
+
+#endif
diff -Nur orig/source/gme/src/Nsf_Cpu.cpp mod/source/gme/src/Nsf_Cpu.cpp
--- orig/source/gme/src/Nsf_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsf_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,116 @@
+// Normal CPU for NSF emulator
+
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nsf_Impl.h"
+
+#include "blargg_endian.h"
+
+#ifdef BLARGG_DEBUG_H
+	//#define CPU_LOG_START 1000000
+	//#include "nes_cpu_log.h"
+	#undef LOG_MEM
+#endif
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#ifndef LOG_MEM
+	#define LOG_MEM( addr, str, data ) data
+#endif
+
+int Nsf_Impl::read_mem( addr_t addr )
+{
+	int result = low_ram [addr & (low_ram_size-1)]; // also handles wrap-around
+	if ( addr & 0xE000 )
+	{
+		result = *cpu.get_code( addr );
+		if ( addr < sram_addr )
+		{
+			if ( addr == apu.status_addr )
+				result = apu.read_status( time() );
+			else
+				result = cpu_read( addr );
+		}
+	}
+	return LOG_MEM( addr, ">", result );
+}
+
+void Nsf_Impl::write_mem( addr_t addr, int data )
+{
+	(void) LOG_MEM( addr, "<", data );
+	
+	int offset = addr - sram_addr;
+	if ( (unsigned) offset < sram_size )
+	{
+		sram() [offset] = data;
+	}
+	else
+	{
+		// after sram because CPU handles most low_ram accesses internally already
+		int temp = addr & (low_ram_size-1); // also handles wrap-around
+		if ( !(addr & 0xE000) )
+		{
+			low_ram [temp] = data;
+		}
+		else
+		{
+			int bank = addr - banks_addr;
+			if ( (unsigned) bank < bank_count )
+			{
+				write_bank( bank, data );
+			}
+			else if ( (unsigned) (addr - apu.io_addr) < apu.io_size )
+			{
+				apu.write_register( time(), addr, data );
+			}
+			else
+			{
+			#if !NSF_EMU_APU_ONLY
+				// 0x8000-0xDFFF is writable
+				int i = addr - 0x8000;
+				if ( (unsigned) i < fdsram_size && fds_enabled() )
+					fdsram() [i] = data;
+				else
+			#endif
+				cpu_write( addr, data );
+			}
+		}
+	}
+}
+
+#define READ_LOW(  addr       ) (LOG_MEM( addr, ">", low_ram [addr] ))
+#define WRITE_LOW( addr, data ) (LOG_MEM( addr, "<", low_ram [addr] = data ))
+
+#define CAN_WRITE_FAST( addr )  (addr < low_ram_size)
+#define WRITE_FAST              WRITE_LOW
+
+// addr < 0x2000 || addr >= 0x8000
+#define CAN_READ_FAST( addr )   ((addr ^ 0x8000) < 0xA000)
+#define READ_FAST( addr, out  ) (LOG_MEM( addr, ">", out = READ_CODE( addr ) ))
+
+#define READ_MEM(  addr       ) read_mem(  addr )
+#define WRITE_MEM( addr, data ) write_mem( addr, data )
+
+#define CPU cpu
+
+#define CPU_BEGIN \
+bool Nsf_Impl::run_cpu_until( time_t end )\
+{\
+	cpu.set_end_time( end );\
+	if ( *cpu.get_code( cpu.r.pc ) != cpu.halt_opcode )\
+	{
+		#include "Nes_Cpu_run.h"
+	}
+	return cpu.time_past_end() < 0;
+}
diff -Nur orig/source/gme/src/Nsfe_Emu.cpp mod/source/gme/src/Nsfe_Emu.cpp
--- orig/source/gme/src/Nsfe_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsfe_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,321 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nsfe_Emu.h"
+
+#include "blargg_endian.h"
+#include <ctype.h>
+
+/* Copyright (C) 2005-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Nsfe_Info::Nsfe_Info() { playlist_disabled = false; }
+
+Nsfe_Info::~Nsfe_Info() { }
+
+inline void Nsfe_Info::unload()
+{
+	track_name_data.clear();
+	track_names.clear();
+	playlist.clear();
+	track_times.clear();
+}
+
+// TODO: if no playlist, treat as if there is a playlist that is just 1,2,3,4,5... ?
+void Nsfe_Info::disable_playlist( bool b )
+{
+	playlist_disabled = b;
+	info.track_count = playlist.size();
+	if ( !info.track_count || playlist_disabled )
+		info.track_count = actual_track_count_;
+}
+
+int Nsfe_Info::remap_track( int track ) const
+{
+	if ( !playlist_disabled && (unsigned) track < playlist.size() )
+		track = playlist [track];
+	return track;
+}
+
+// Read multiple strings and separate into individual strings
+static blargg_err_t read_strs( Data_Reader& in, int size, blargg_vector<char>& chars,
+		blargg_vector<const char*>& strs )
+{
+	RETURN_ERR( chars.resize( size + 1 ) );
+	chars [size] = 0; // in case last string doesn't have terminator
+	RETURN_ERR( in.read( &chars [0], size ) );
+	
+	RETURN_ERR( strs.resize( 128 ) );
+	int count = 0;
+	for ( int i = 0; i < size; i++ )
+	{
+		if ( (int) strs.size() <= count )
+			RETURN_ERR( strs.resize( count * 2 ) );
+		strs [count++] = &chars [i];
+		while ( i < size && chars [i] )
+			i++;
+	}
+	
+	return strs.resize( count );
+}
+
+// Copy in to out, where out has out_max characters allocated. Truncate to
+// out_max - 1 characters.
+static void copy_str( const char in [], char out [], int out_max )
+{
+	out [out_max - 1] = 0;
+	strncpy( out, in, out_max - 1 );
+}
+
+struct nsfe_info_t
+{
+	byte load_addr [2];
+	byte init_addr [2];
+	byte play_addr [2];
+	byte speed_flags;
+	byte chip_flags;
+	byte track_count;
+	byte first_track;
+	byte unused [6];
+};
+
+blargg_err_t Nsfe_Info::load( Data_Reader& in, Nsfe_Emu* nsf_emu )
+{
+	int const nsfe_info_size = 16;
+	assert( offsetof (nsfe_info_t,unused [6]) == nsfe_info_size );
+	
+	// check header
+	byte signature [4];
+	blargg_err_t err = in.read( signature, sizeof signature );
+	if ( err )
+		return (blargg_is_err_type( err, blargg_err_file_eof ) ? blargg_err_file_type : err);
+	if ( memcmp( signature, "NSFE", 4 ) )
+		return blargg_err_file_type;
+	
+	// free previous info
+	track_name_data.clear();
+	track_names.clear();
+	playlist.clear();
+	track_times.clear();
+	
+	// default nsf header
+	static const Nsf_Emu::header_t base_header =
+	{
+		{'N','E','S','M','\x1A'},// tag
+		1,                  // version
+		1, 1,               // track count, first track
+		{0,0},{0,0},{0,0},  // addresses
+		"","","",           // strings
+		{0x1A, 0x41},       // NTSC rate
+		{0,0,0,0,0,0,0,0},  // banks
+		{0x20, 0x4E},       // PAL rate
+		0, 0,               // flags
+		{0,0,0,0}           // unused
+	};
+	Nsf_Emu::header_t& header = info;
+	header = base_header;
+	
+	// parse tags
+	int phase = 0;
+	while ( phase != 3 )
+	{
+		// read size and tag
+		byte block_header [2] [4];
+		RETURN_ERR( in.read( block_header, sizeof block_header ) );
+		int size = get_le32( block_header [0] );
+		int tag  = get_le32( block_header [1] );
+		
+		//dprintf( "tag: %c%c%c%c\n", char(tag), char(tag>>8), char(tag>>16), char(tag>>24) );
+		
+		switch ( tag )
+		{
+			case BLARGG_4CHAR('O','F','N','I'): {
+				check( phase == 0 );
+				if ( size < 8 )
+					return blargg_err_file_corrupt;
+				
+				nsfe_info_t finfo;
+				finfo.track_count = 1;
+				finfo.first_track = 0;
+				
+				RETURN_ERR( in.read( &finfo, min( size, (int) nsfe_info_size ) ) );
+				if ( size > nsfe_info_size )
+					RETURN_ERR( in.skip( size - nsfe_info_size ) );
+				phase = 1;
+				info.speed_flags = finfo.speed_flags;
+				info.chip_flags  = finfo.chip_flags;
+				info.track_count = finfo.track_count;
+				this->actual_track_count_ = finfo.track_count;
+				info.first_track = finfo.first_track;
+				memcpy( info.load_addr, finfo.load_addr, 2 * 3 );
+				break;
+			}
+			
+			case BLARGG_4CHAR('K','N','A','B'):
+				if ( size > (int) sizeof info.banks )
+					return blargg_err_file_corrupt;
+				RETURN_ERR( in.read( info.banks, size ) );
+				break;
+			
+			case BLARGG_4CHAR('h','t','u','a'): {
+				blargg_vector<char> chars;
+				blargg_vector<const char*> strs;
+				RETURN_ERR( read_strs( in, size, chars, strs ) );
+				int n = strs.size();
+				
+				if ( n > 3 )
+					copy_str( strs [3], info.dumper, sizeof info.dumper );
+				
+				if ( n > 2 )
+					copy_str( strs [2], info.copyright, sizeof info.copyright );
+				
+				if ( n > 1 )
+					copy_str( strs [1], info.author, sizeof info.author );
+				
+				if ( n > 0 )
+					copy_str( strs [0], info.game, sizeof info.game );
+				
+				break;
+			}
+			
+			case BLARGG_4CHAR('e','m','i','t'):
+				RETURN_ERR( track_times.resize( size / 4 ) );
+				RETURN_ERR( in.read( track_times.begin(), track_times.size() * 4 ) );
+				break;
+			
+			case BLARGG_4CHAR('l','b','l','t'):
+				RETURN_ERR( read_strs( in, size, track_name_data, track_names ) );
+				break;
+			
+			case BLARGG_4CHAR('t','s','l','p'):
+				RETURN_ERR( playlist.resize( size ) );
+				RETURN_ERR( in.read( &playlist [0], size ) );
+				break;
+			
+			case BLARGG_4CHAR('A','T','A','D'): {
+				check( phase == 1 );
+				phase = 2;
+				if ( !nsf_emu )
+				{
+					RETURN_ERR( in.skip( size ) );
+				}
+				else
+				{
+					Subset_Reader sub( &in, size ); // limit emu to nsf data
+					Remaining_Reader rem( &header, header.size, &sub );
+					RETURN_ERR( nsf_emu->Nsf_Emu::load_( rem ) );
+					check( rem.remain() == 0 );
+				}
+				break;
+			}
+			
+			case BLARGG_4CHAR('D','N','E','N'):
+				check( phase == 2 );
+				phase = 3;
+				break;
+			
+			default:
+				// tags that can be skipped start with a lowercase character
+				check( islower( (tag >> 24) & 0xFF ) );
+				RETURN_ERR( in.skip( size ) );
+				break;
+		}
+	}
+	
+	return blargg_ok;
+}
+
+blargg_err_t Nsfe_Info::track_info_( track_info_t* out, int track ) const
+{
+	int remapped = remap_track( track );
+	if ( (unsigned) remapped < track_times.size() )
+	{
+		int length = (BOOST::int32_t) get_le32( track_times [remapped] );
+		if ( length > 0 )
+			out->length = length;
+	}
+	if ( (unsigned) remapped < track_names.size() )
+		Gme_File::copy_field_( out->song, track_names [remapped] );
+	
+	GME_COPY_FIELD( info, out, game );
+	GME_COPY_FIELD( info, out, author );
+	GME_COPY_FIELD( info, out, copyright );
+	GME_COPY_FIELD( info, out, dumper );
+	return blargg_ok;
+}
+
+Nsfe_Emu::Nsfe_Emu()
+{
+	set_type( gme_nsfe_type );
+}
+
+Nsfe_Emu::~Nsfe_Emu() { }
+
+void Nsfe_Emu::unload()
+{
+	info.unload();
+	Nsf_Emu::unload();
+}
+
+blargg_err_t Nsfe_Emu::track_info_( track_info_t* out, int track ) const
+{
+	return info.track_info_( out, track );
+}
+
+struct Nsfe_File : Gme_Info_
+{
+	Nsfe_Info info;
+	
+	Nsfe_File() { set_type( gme_nsfe_type ); }
+	
+	blargg_err_t load_( Data_Reader& in )
+	{
+		RETURN_ERR( info.load( in, 0 ) );
+		info.disable_playlist( false );
+		set_track_count( info.info.track_count );
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int track ) const
+	{
+		return info.track_info_( out, track );
+	}
+};
+
+static Music_Emu* new_nsfe_emu () { return BLARGG_NEW Nsfe_Emu ; }
+static Music_Emu* new_nsfe_file() { return BLARGG_NEW Nsfe_File; }
+
+gme_type_t_ const gme_nsfe_type [1] = {{ "Nintendo NES", 0, &new_nsfe_emu, &new_nsfe_file, "NSFE", 1 }};
+
+blargg_err_t Nsfe_Emu::load_( Data_Reader& in )
+{
+	RETURN_ERR( info.load( in, this ) );
+	disable_playlist_( false );
+	return blargg_ok;
+}
+
+void Nsfe_Emu::disable_playlist_( bool b )
+{
+	info.disable_playlist( b );
+	set_track_count( info.info.track_count );
+}
+
+void Nsfe_Emu::clear_playlist_()
+{
+	disable_playlist_( true );
+	Nsf_Emu::clear_playlist_();
+}
+
+blargg_err_t Nsfe_Emu::start_track_( int track )
+{
+	return Nsf_Emu::start_track_( info.remap_track( track ) );
+}
diff -Nur orig/source/gme/src/Nsfe_Emu.h mod/source/gme/src/Nsfe_Emu.h
--- orig/source/gme/src/Nsfe_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsfe_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,72 @@
+// Nintendo NES/Famicom NSFE music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef NSFE_EMU_H
+#define NSFE_EMU_H
+
+#include "blargg_common.h"
+#include "Nsf_Emu.h"
+class Nsfe_Emu;
+
+// Allows reading info from NSFE file without creating emulator
+class Nsfe_Info {
+public:
+	blargg_err_t load( Data_Reader&, Nsfe_Emu* );
+	
+	struct info_t : Nsf_Emu::header_t
+	{
+		char game      [256];
+		char author    [256];
+		char copyright [256];
+		char dumper    [256];
+	} info;
+	
+	void disable_playlist( bool = true );
+	
+	blargg_err_t track_info_( track_info_t* out, int track ) const;
+	
+	int remap_track( int i ) const;
+	
+	void unload();
+	
+// Implementation
+public:
+	Nsfe_Info();
+	~Nsfe_Info();
+	BLARGG_DISABLE_NOTHROW
+private:
+	blargg_vector<char> track_name_data;
+	blargg_vector<const char*> track_names;
+	blargg_vector<unsigned char> playlist;
+	blargg_vector<char [4]> track_times;
+	int actual_track_count_;
+	bool playlist_disabled;
+};
+
+class Nsfe_Emu : public Nsf_Emu {
+public:
+	static gme_type_t static_type() { return gme_nsfe_type; }
+	
+	struct header_t { char tag [4]; };
+
+
+// Implementation
+public:
+	Nsfe_Emu();
+	~Nsfe_Emu();
+	virtual void unload();
+
+protected:
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t start_track_( int );
+	virtual void clear_playlist_();
+
+private:
+	Nsfe_Info info;
+	
+	void disable_playlist_( bool b );
+	friend class Nsfe_Info;
+};
+
+#endif
diff -Nur orig/source/gme/src/Nsf_Emu.cpp mod/source/gme/src/Nsf_Emu.cpp
--- orig/source/gme/src/Nsf_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsf_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,314 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nsf_Emu.h"
+
+#if !NSF_EMU_APU_ONLY
+	#include "Nes_Namco_Apu.h"
+	#include "Nes_Vrc6_Apu.h"
+	#include "Nes_Fme7_Apu.h"
+	#include "Nes_Fds_Apu.h"
+	#include "Nes_Mmc5_Apu.h"
+	#include "Nes_Vrc7_Apu.h"
+#endif
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Nsf_Emu::equalizer_t const Nsf_Emu::nes_eq     = {  -1.0, 80 };
+Nsf_Emu::equalizer_t const Nsf_Emu::famicom_eq = { -15.0, 80 };
+
+Nsf_Emu::Nsf_Emu()
+{
+	set_type( gme_nsf_type );
+	set_silence_lookahead( 6 );
+	set_gain( 1.4 );
+	set_equalizer( nes_eq );
+}
+
+Nsf_Emu::~Nsf_Emu()
+{
+	unload();
+}
+
+void Nsf_Emu::unload()
+{
+	core_.unload();
+	Music_Emu::unload();
+}
+
+// Track info
+
+static void copy_nsf_fields( Nsf_Emu::header_t const& h, track_info_t* out )
+{
+	GME_COPY_FIELD( h, out, game );
+	GME_COPY_FIELD( h, out, author );
+	GME_COPY_FIELD( h, out, copyright );
+	if ( h.chip_flags )
+		Music_Emu::copy_field_( out->system, "Famicom" );
+}
+
+blargg_err_t Nsf_Emu::track_info_( track_info_t* out, int ) const
+{
+	copy_nsf_fields( header(), out );
+	return blargg_ok;
+}
+
+static blargg_err_t check_nsf_header( Nsf_Emu::header_t const& h )
+{
+	if ( !h.valid_tag() )
+		return blargg_err_file_type;
+	return blargg_ok;
+}
+
+struct Nsf_File : Gme_Info_
+{
+	Nsf_Emu::header_t h;
+	
+	Nsf_File() { set_type( gme_nsf_type ); }
+	
+	blargg_err_t load_( Data_Reader& in )
+	{
+		blargg_err_t err = in.read( &h, h.size );
+		if ( err )
+			return (blargg_is_err_type( err, blargg_err_file_eof ) ? blargg_err_file_type : err);
+		
+		if ( h.vers != 1 )
+			set_warning( "Unknown file version" );
+		
+		int unsupported_chips = ~Nsf_Core::chips_mask;
+		#if NSF_EMU_NO_VRC7
+			unsupported_chips |= Nsf_Emu::header_t::vrc7_mask;
+		#endif
+		if ( h.chip_flags & unsupported_chips )
+			set_warning( "Uses unsupported audio expansion hardware" );
+		
+		set_track_count( h.track_count );
+		return check_nsf_header( h );
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		copy_nsf_fields( h, out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_nsf_emu () { return BLARGG_NEW Nsf_Emu ; }
+static Music_Emu* new_nsf_file() { return BLARGG_NEW Nsf_File; }
+
+gme_type_t_ const gme_nsf_type [1] = {{ "Nintendo NES", 0, &new_nsf_emu, &new_nsf_file, "NSF", 1 }};
+
+// Setup
+
+void Nsf_Emu::set_tempo_( double t )
+{
+	core_.set_tempo( t );
+}
+
+void Nsf_Emu::append_voices( const char* const names [], int const types [], int count )
+{
+	assert( voice_count_ + count < max_voices );
+	for ( int i = 0; i < count; i++ )
+	{
+		voice_names_ [voice_count_ + i] = names [i];
+		voice_types_ [voice_count_ + i] = types [i];
+	}
+	voice_count_ += count;
+	set_voice_count( voice_count_ );
+	set_voice_types( voice_types_ );
+}
+
+blargg_err_t Nsf_Emu::init_sound()
+{
+	voice_count_ = 0;
+	set_voice_names( voice_names_ );
+	
+	{
+		int const count = Nes_Apu::osc_count;
+		static const char* const names [Nes_Apu::osc_count] = {
+			"Square 1", "Square 2", "Triangle", "Noise", "DMC"
+		};
+		static int const types [count] = {
+			wave_type+1, wave_type+2, mixed_type+1, noise_type+0, mixed_type+1
+		};
+		append_voices( names, types, count );
+	}
+	
+	// Make adjusted_gain * 0.75 = 1.0 so usual APU and one sound chip uses 1.0
+	double adjusted_gain = 1.0 / 0.75 * gain();
+	
+#if !NSF_EMU_APU_ONLY
+	// TODO: order of chips here must match that in set_voice()
+	
+	if ( core_.vrc6_apu() )
+	{
+		int const count = Nes_Vrc6_Apu::osc_count;
+		static const char* const names [count] = {
+			"Square 3", "Square 4", "Saw Wave"
+		};
+		static int const types [count] = {
+			wave_type+3, wave_type+4, wave_type+5,
+		};
+		append_voices( names, types, count );
+		adjusted_gain *= 0.75;
+	}
+	
+	if ( core_.fme7_apu() )
+	{
+		int const count = Nes_Fme7_Apu::osc_count;
+		static const char* const names [count] = {
+			"Square 3", "Square 4", "Square 5"
+		};
+		static int const types [count] = {
+			wave_type+3, wave_type+4, wave_type+5,
+		};
+		append_voices( names, types, count );
+		adjusted_gain *= 0.75;
+	}
+	
+	if ( core_.mmc5_apu() )
+	{
+		int const count = Nes_Mmc5_Apu::osc_count;
+		static const char* const names [count] = {
+			"Square 3", "Square 4", "PCM"
+		};
+		static int const types [count] = {
+			wave_type+3, wave_type+4, mixed_type+2
+		};
+		append_voices( names, types, count );
+		adjusted_gain *= 0.75;
+	}
+	
+	if ( core_.fds_apu() )
+	{
+		int const count = Nes_Fds_Apu::osc_count;
+		static const char* const names [count] = {
+			"FM"
+		};
+		static int const types [count] = {
+			wave_type+0
+		};
+		append_voices( names, types, count );
+		adjusted_gain *= 0.75;
+	}
+	
+	if ( core_.namco_apu() )
+	{
+		int const count = Nes_Namco_Apu::osc_count;
+		static const char* const names [count] = {
+			"Wave 1", "Wave 2", "Wave 3", "Wave 4",
+			"Wave 5", "Wave 6", "Wave 7", "Wave 8"
+		};
+		static int const types [count] = {
+			wave_type+3, wave_type+4, wave_type+5, wave_type+ 6,
+			wave_type+7, wave_type+8, wave_type+9, wave_type+10,
+		};
+		append_voices( names, types, count );
+		adjusted_gain *= 0.75;
+	}
+	
+	if ( core_.vrc7_apu() )
+	{
+		int const count = Nes_Vrc7_Apu::osc_count;
+		static const char* const names [count] = {
+			"FM 1", "FM 2", "FM 3", "FM 4", "FM 5", "FM 6"
+		};
+		static int const types [count] = {
+			wave_type+3, wave_type+4, wave_type+5, wave_type+6,
+			wave_type+7, wave_type+8
+		};
+		append_voices( names, types, count );
+		adjusted_gain *= 0.75;
+	}
+	
+	if ( core_.vrc7_apu()  ) core_.vrc7_apu() ->volume( adjusted_gain );
+	if ( core_.namco_apu() ) core_.namco_apu()->volume( adjusted_gain );
+	if ( core_.vrc6_apu()  ) core_.vrc6_apu() ->volume( adjusted_gain );
+	if ( core_.fme7_apu()  ) core_.fme7_apu() ->volume( adjusted_gain );
+	if ( core_.mmc5_apu()  ) core_.mmc5_apu() ->volume( adjusted_gain );
+	if ( core_.fds_apu()   ) core_.fds_apu()  ->volume( adjusted_gain );
+#endif
+	
+	if ( adjusted_gain > gain() )
+		adjusted_gain = gain(); // only occurs if no other sound chips
+	
+	core_.nes_apu()->volume( adjusted_gain );
+	
+	return blargg_ok;
+}
+
+blargg_err_t Nsf_Emu::load_( Data_Reader& in )
+{
+	RETURN_ERR( core_.load( in ) );
+	set_track_count( header().track_count );
+	RETURN_ERR( check_nsf_header( header() ) );
+	set_warning( core_.warning() );
+	RETURN_ERR( init_sound() );
+	set_tempo( tempo() );
+	return setup_buffer( (int) (header().clock_rate() + 0.5) );
+}
+
+void Nsf_Emu::update_eq( blip_eq_t const& eq )
+{
+	core_.nes_apu()->treble_eq( eq );
+	
+	#if !NSF_EMU_APU_ONLY
+	{
+		if ( core_.namco_apu() ) core_.namco_apu()->treble_eq( eq );
+		if ( core_.vrc6_apu()  ) core_.vrc6_apu() ->treble_eq( eq );
+		if ( core_.fme7_apu()  ) core_.fme7_apu() ->treble_eq( eq );
+		if ( core_.mmc5_apu()  ) core_.mmc5_apu() ->treble_eq( eq );
+		if ( core_.fds_apu()   ) core_.fds_apu()  ->treble_eq( eq );
+		if ( core_.vrc7_apu()  ) core_.vrc7_apu() ->treble_eq( eq );
+	}
+	#endif
+}
+
+void Nsf_Emu::set_voice( int i, Blip_Buffer* buf, Blip_Buffer*, Blip_Buffer* )
+{
+	#define HANDLE_CHIP( chip ) \
+		if ( chip && (i -= chip->osc_count) < 0 )\
+		{\
+			chip->set_output( i + chip->osc_count, buf );\
+			return;\
+		}\
+	
+	HANDLE_CHIP( core_.nes_apu() );
+	
+	#if !NSF_EMU_APU_ONLY
+	{
+		// TODO: order of chips here must match that in init_sound()
+		HANDLE_CHIP( core_.vrc6_apu()  );
+		HANDLE_CHIP( core_.fme7_apu()  );
+		HANDLE_CHIP( core_.mmc5_apu()  );
+		HANDLE_CHIP( core_.fds_apu()   );
+		HANDLE_CHIP( core_.namco_apu() );
+		HANDLE_CHIP( core_.vrc7_apu()  );
+	}
+	#endif
+}
+
+blargg_err_t Nsf_Emu::start_track_( int track )
+{
+	RETURN_ERR( Classic_Emu::start_track_( track ) );
+	return core_.start_track( track );
+}
+
+blargg_err_t Nsf_Emu::run_clocks( blip_time_t& duration, int )
+{
+	core_.end_frame( duration );
+	const char* w = core_.warning();
+	if ( w )
+		set_warning( w );
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Nsf_Emu.h mod/source/gme/src/Nsf_Emu.h
--- orig/source/gme/src/Nsf_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsf_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,51 @@
+// Nintendo NES/Famicom NSF music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef NSF_EMU_H
+#define NSF_EMU_H
+
+#include "Classic_Emu.h"
+#include "Nsf_Core.h"
+
+class Nsf_Emu : public Classic_Emu {
+public:
+	// Equalizer profiles for US NES and Japanese Famicom
+	static equalizer_t const nes_eq;
+	static equalizer_t const famicom_eq;
+	
+	// NSF file header (see Nsf_Impl.h)
+	typedef Nsf_Core::header_t header_t;
+	
+	// Header for currently loaded file
+	header_t const& header() const { return core_.header(); }
+	
+	static gme_type_t static_type() { return gme_nsf_type; }
+	
+	Nsf_Core& core() { return core_; }
+	
+public:
+	Nsf_Emu();
+	~Nsf_Emu();
+	virtual void unload();
+
+protected:
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+	
+private:
+	enum { max_voices = 32 };
+	const char* voice_names_ [32];
+	int voice_types_ [32];
+	int voice_count_;
+	Nsf_Core core_;
+	
+	blargg_err_t init_sound();
+	void append_voices( const char* const names [], int const types [], int count );
+};
+
+#endif
diff -Nur orig/source/gme/src/Nsf_Impl.cpp mod/source/gme/src/Nsf_Impl.cpp
--- orig/source/gme/src/Nsf_Impl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsf_Impl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,327 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Nsf_Impl.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// number of frames until play interrupts init
+int const initial_play_delay = 7; // KikiKaikai needed this to work
+int const bank_size = 0x1000;
+int const rom_addr  = 0x8000;
+
+int Nsf_Impl::read_code( addr_t addr ) const
+{
+	return *cpu.get_code( addr );
+}
+
+int Nsf_Impl::pcm_read( void* self, int addr )
+{
+	return STATIC_CAST(Nsf_Impl*,self)->read_code( addr );
+}
+
+Nsf_Impl::Nsf_Impl() : rom( bank_size )
+{
+	apu.dmc_reader( pcm_read, this );
+	assert( offsetof (header_t,unused [4]) == header_t::size );
+}
+
+void Nsf_Impl::unload()
+{
+	rom.clear();
+	high_ram.clear();
+	Gme_Loader::unload();
+}
+
+Nsf_Impl::~Nsf_Impl() { unload(); }
+
+bool nsf_header_t::valid_tag() const
+{
+	return 0 == memcmp( tag, "NESM\x1A", 5 );
+}
+
+double nsf_header_t::clock_rate() const
+{
+	return pal_only() ? 1662607.125 : 1789772.727272727;
+}
+
+int nsf_header_t::play_period() const
+{
+	// NTSC
+	int         clocks   = 29780;
+	int         value    = 0x411A;
+	byte const* rate_ptr = ntsc_speed;
+	
+	// PAL
+	if ( pal_only() )
+	{
+		clocks   = 33247;
+		value    = 0x4E20;
+		rate_ptr = pal_speed;
+	}
+	
+	// Default rate
+	int rate = get_le16( rate_ptr );
+	if ( rate == 0 )
+		rate = value;
+	
+	// Custom rate
+	if ( rate != value )
+		clocks = (int) (rate * clock_rate() * (1.0/1000000.0));
+	
+	return clocks;
+}
+
+// Gets address, given pointer to it in file header. If zero, returns rom_addr.
+Nsf_Impl::addr_t Nsf_Impl::get_addr( byte const in [] )
+{
+	addr_t addr = get_le16( in );
+	if ( addr == 0 )
+		addr = rom_addr;
+	return addr;
+}
+
+blargg_err_t Nsf_Impl::load_( Data_Reader& in )
+{
+	// pad ROM data with 0
+	RETURN_ERR( rom.load( in, header_.size, &header_, 0 ) );
+	
+	if ( !header_.valid_tag() )
+		return blargg_err_file_type;
+	
+	RETURN_ERR( high_ram.resize( (fds_enabled() ? fdsram_offset + fdsram_size : fdsram_offset) ) );
+
+	addr_t load_addr = get_addr( header_.load_addr );
+	if ( load_addr < (fds_enabled() ? sram_addr : rom_addr) )
+		set_warning( "Load address is too low" );
+	
+	rom.set_addr( load_addr % bank_size );
+	
+	if ( header_.vers != 1 )
+		set_warning( "Unknown file version" );
+	
+	set_play_period( header_.play_period() );
+	
+	return blargg_ok;
+}
+
+void Nsf_Impl::write_bank( int bank, int data )
+{
+	// Find bank in ROM
+	int offset = rom.mask_addr( data * bank_size );
+	if ( offset >= rom.size() )
+		special_event( "invalid bank" );
+	void const* rom_data = rom.at_addr( offset );
+	
+	#if !NSF_EMU_APU_ONLY
+		if ( bank < bank_count - fds_banks && fds_enabled() )
+		{
+			// TODO: FDS bank switching is kind of hacky, might need to
+			// treat ROM as RAM so changes won't get lost when switching.
+			byte* out = sram();
+			if ( bank >= fds_banks )
+			{
+				out = fdsram();
+				bank -= fds_banks;
+			}
+			memcpy( &out [bank * bank_size], rom_data, bank_size );
+			return;
+		}
+	#endif
+	
+	if ( bank >= fds_banks )
+		cpu.map_code( (bank + 6) * bank_size, bank_size, rom_data );
+}
+
+void Nsf_Impl::map_memory()
+{
+	// Map standard things
+	cpu.reset( unmapped_code() );
+	cpu.map_code( 0, 0x2000, low_ram, low_ram_size ); // mirrored four times
+	cpu.map_code( sram_addr, sram_size, sram() );
+	
+	// Determine initial banks
+	byte banks [bank_count];
+	static byte const zero_banks [sizeof header_.banks] = { 0 };
+	if ( memcmp( header_.banks, zero_banks, sizeof zero_banks ) )
+	{
+		banks [0] = header_.banks [6];
+		banks [1] = header_.banks [7];
+		memcpy( banks + fds_banks, header_.banks, sizeof header_.banks );
+	}
+	else
+	{
+		// No initial banks, so assign them based on load_addr
+		int first_bank = (get_addr( header_.load_addr ) - sram_addr) / bank_size;
+		unsigned total_banks = rom.size() / bank_size;
+		for ( int i = bank_count; --i >= 0; )
+		{
+			int bank = i - first_bank;
+			if ( (unsigned) bank >= total_banks )
+				bank = 0;
+			banks [i] = bank;
+		}
+	}
+	
+	// Map banks
+	for ( int i = (fds_enabled() ? 0 : fds_banks); i < bank_count; ++i )
+		write_bank( i, banks [i] );
+	
+	// Map FDS RAM
+	if ( fds_enabled() )
+		cpu.map_code( rom_addr, fdsram_size, fdsram() );
+}
+
+inline void Nsf_Impl::push_byte( int b )
+{
+	low_ram [0x100 + cpu.r.sp--] = b;
+}
+
+// Jumps to routine, given pointer to address in file header. Pushes idle_addr
+// as return address, NOT old PC.
+void Nsf_Impl::jsr_then_stop( byte const addr [] )
+{
+	cpu.r.pc = get_addr( addr );
+	push_byte( (idle_addr - 1) >> 8 );
+	push_byte( (idle_addr - 1) );
+}
+
+blargg_err_t Nsf_Impl::start_track( int track )
+{
+	int speed_flags = 0;
+	#if NSF_EMU_EXTRA_FLAGS
+		speed_flags = header().speed_flags;
+	#endif
+	
+	apu.reset( header().pal_only(), (speed_flags & 0x20) ? 0x3F : 0 );
+	apu.write_register( 0, 0x4015, 0x0F );
+	apu.write_register( 0, 0x4017, (speed_flags & 0x10) ? 0x80 : 0 );
+	
+	// Clear memory
+	memset( unmapped_code(), Nes_Cpu::halt_opcode, unmapped_size );
+	memset( low_ram, 0, low_ram_size );
+	memset( sram(), 0, sram_size );
+	
+	map_memory();
+	
+	// Arrange time of first call to play routine
+	play_extra = 0;
+	next_play  = play_period;
+	
+	play_delay = initial_play_delay;
+	saved_state.pc = idle_addr;
+	
+	// Setup for call to init routine
+	cpu.r.a  = track;
+	cpu.r.x  = header_.pal_only();
+	cpu.r.sp = 0xFF;
+	jsr_then_stop( header_.init_addr );
+	if ( cpu.r.pc < get_addr( header_.load_addr ) )
+		set_warning( "Init address < load address" );
+	
+	return blargg_ok;
+}
+
+void Nsf_Impl::unmapped_write( addr_t addr, int data )
+{
+	dprintf( "Unmapped write $%04X <- %02X\n", (int) addr, data );
+}
+
+int Nsf_Impl::unmapped_read( addr_t addr )
+{
+	dprintf( "Unmapped read $%04X\n", (int) addr );
+	return addr >> 8;
+}
+
+void Nsf_Impl::special_event( const char str [] )
+{
+	dprintf( "%s\n", str );
+}
+
+void Nsf_Impl::run_once( time_t end )
+{
+	// Emulate until next play call if possible
+	if ( run_cpu_until( min( next_play, end ) ) )
+	{
+		// Halt instruction encountered
+		
+		if ( cpu.r.pc != idle_addr )
+		{
+			special_event( "illegal instruction" );
+			cpu.count_error();
+			cpu.set_time( cpu.end_time() );
+			return;
+		}
+
+		// Init/play routine returned
+		play_delay = 1; // play can now be called regularly
+		
+		if ( saved_state.pc == idle_addr )
+		{
+			// nothing to run
+			time_t t = cpu.end_time();
+			if ( cpu.time() < t )
+				cpu.set_time( t );
+		}
+		else
+		{
+			// continue init routine that was interrupted by play routine
+			cpu.r = saved_state;
+			saved_state.pc = idle_addr;
+		}
+	}
+	
+	if ( time() >= next_play )
+	{
+		// Calculate time of next call to play routine
+		play_extra ^= 1; // extra clock every other call
+		next_play += play_period + play_extra;
+		
+		// Call routine if ready
+		if ( play_delay && !--play_delay )
+		{
+			// Save state if init routine is still running
+			if ( cpu.r.pc != idle_addr )
+			{
+				check( saved_state.pc == idle_addr );
+				saved_state = cpu.r;
+				special_event( "play called during init" );
+			}
+			
+			jsr_then_stop( header_.play_addr );
+		}
+	}
+}
+
+void Nsf_Impl::run_until( time_t end )
+{
+	while ( time() < end )
+		run_once( end );
+}
+
+void Nsf_Impl::end_frame( time_t end )
+{
+	if ( time() < end )
+		run_until( end );
+	cpu.adjust_time( -end );
+	
+	// Localize to new time frame
+	next_play -= end;
+	check( next_play >= 0 );
+	if ( next_play < 0 )
+		next_play = 0;
+	
+	apu.end_frame( end );
+}
diff -Nur orig/source/gme/src/Nsf_Impl.h mod/source/gme/src/Nsf_Impl.h
--- orig/source/gme/src/Nsf_Impl.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Nsf_Impl.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,189 @@
+// Loads NSF file and emulates CPU and RAM, no sound chips
+
+// Game_Music_Emu 0.6-pre
+#ifndef NSF_IMPL_H
+#define NSF_IMPL_H
+
+#include "Gme_Loader.h"
+#include "Nes_Cpu.h"
+#include "Rom_Data.h"
+#include "Nes_Apu.h"
+
+// NSF file header
+struct nsf_header_t
+{
+	typedef unsigned char byte;
+	enum { size = 0x80 };
+	
+	char tag        [ 5];
+	byte vers;
+	byte track_count;
+	byte first_track;
+	byte load_addr  [ 2];
+	byte init_addr  [ 2];
+	byte play_addr  [ 2];
+	char game       [32]; // NOT null-terminated if 32 chars in length
+	char author     [32];
+	char copyright  [32];
+	byte ntsc_speed [ 2];
+	byte banks      [ 8];
+	byte pal_speed  [ 2];
+	byte speed_flags;
+	byte chip_flags;
+	byte unused     [ 4];
+	
+	// Sound chip masks
+	enum {
+		vrc6_mask  = 1 << 0,
+		vrc7_mask  = 1 << 1,
+		fds_mask   = 1 << 2,
+		mmc5_mask  = 1 << 3,
+		namco_mask = 1 << 4,
+		fme7_mask  = 1 << 5,
+		all_mask   = (1 << 6) - 1
+	};
+	
+	// True if header has proper NSF file signature
+	bool valid_tag() const;
+	
+	// True if file supports only PAL speed
+	bool pal_only() const           { return (speed_flags & 3) == 1; }
+	
+	// Clocks per second
+	double clock_rate() const;
+	
+	// Clocks between calls to play routine
+	int play_period() const;
+};
+
+/* Loads NSF file into memory, then emulates CPU, RAM, and ROM.
+Non-memory accesses are routed through cpu_read() and cpu_write(). */
+class Nsf_Impl : public Gme_Loader {
+public:
+
+	// Sound chip
+	Nes_Apu* nes_apu()                  { return &apu; }
+	
+	// Starts track, where 0 is the first
+	virtual blargg_err_t start_track( int );
+	
+	// Emulates to at least time t, then begins new time frame at
+	// time t. Might emulate a few clocks extra, so after returning,
+	// time() may not be zero.
+	typedef int time_t; // clock count
+	virtual void end_frame( time_t n );
+	
+// Finer control
+
+	// Header for currently loaded file
+	typedef nsf_header_t header_t;
+	header_t const& header() const      { return header_; }
+	
+	// Sets clocks between calls to play routine to p + 1/2 clock
+	void set_play_period( int p )       { play_period = p; }
+	
+	// Time play routine will next be called
+	time_t play_time() const        { return next_play; }
+	
+	// Emulates to at least time t. Might emulate a few clocks extra.
+	virtual void run_until( time_t t );
+	
+	// Time emulated to
+	time_t time() const             { return cpu.time(); }
+	
+protected:
+// Nsf_Core use
+
+	typedef int addr_t;
+	
+	// Called for unmapped accesses. Default just prints info if debugging.
+	virtual void unmapped_write( addr_t, int data );
+	virtual int  unmapped_read(  addr_t );
+	
+	// Override in derived class
+	// Bank writes and RAM at 0-$7FF and $6000-$7FFF are handled internally
+	virtual int  cpu_read(  addr_t a )          { return unmapped_read( a ); }
+	virtual void cpu_write( addr_t a, int data ){ unmapped_write( a, data ); }
+	
+	// Reads byte as CPU would when executing code. Only works for RAM/ROM,
+	// NOT I/O like sound chips.
+	int  read_code( addr_t addr ) const;
+
+// Debugger services
+
+	enum { mem_size  = 0x10000 };
+	
+	// CPU sits here when waiting for next call to play routine
+	enum { idle_addr = 0x5FF6 };
+	
+	Nes_Cpu cpu;
+	
+	// Runs CPU to at least time t and returns false, or returns true
+	// if it encounters illegal instruction (halt).
+	virtual bool run_cpu_until( time_t t );
+	
+	// CPU calls through to these to access memory (except instructions)
+	int  read_mem(  addr_t );
+	void write_mem( addr_t, int );
+	
+	// Address of play routine
+	addr_t play_addr() const        { return get_addr( header_.play_addr ); }
+	
+	// Same as run_until, except emulation stops for any event (routine returned,
+	// play routine called, illegal instruction).
+	void run_once( time_t );
+	
+	// Make a note of event
+	virtual void special_event( const char str [] );
+	
+
+// Implementation
+public:
+	Nsf_Impl();
+	~Nsf_Impl();
+
+protected:
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual void unload();
+
+private:
+	enum { low_ram_size = 0x800 };
+	enum { fdsram_size  = 0x6000 };
+	enum { sram_size    = 0x2000 };
+	enum { unmapped_size= Nes_Cpu::page_size + 8 };
+	enum { fds_banks    = 2 };
+	enum { bank_count   = fds_banks + 8 };
+	enum { banks_addr   = idle_addr };
+	enum { sram_addr    = 0x6000 };
+	
+	blargg_vector<byte> high_ram;
+	Rom_Data rom;
+	
+	// Play routine timing
+	time_t next_play;
+	time_t play_period;
+	int play_extra;
+	int play_delay;
+	Nes_Cpu::registers_t saved_state; // of interrupted init routine
+	
+	// Large objects after others
+	header_t header_;
+	Nes_Apu apu;
+	byte low_ram [low_ram_size];
+	
+	// Larger RAM areas allocated separately
+	enum { fdsram_offset = sram_size + unmapped_size };
+	byte* sram()            { return high_ram.begin(); }
+	byte* unmapped_code()   { return &high_ram [sram_size]; }
+	byte* fdsram()          { return &high_ram [fdsram_offset]; }
+	int fds_enabled() const { return header_.chip_flags & header_t::fds_mask; }
+	
+	void map_memory();
+	void write_bank( int index, int data );
+	void jsr_then_stop( byte const addr [] );
+	void push_byte( int );
+	static addr_t get_addr( byte const [] );
+	static int pcm_read( void*, int );
+};
+
+#endif
diff -Nur orig/source/gme/src/Opl_Apu.cpp mod/source/gme/src/Opl_Apu.cpp
--- orig/source/gme/src/Opl_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Opl_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,271 @@
+#include "Opl_Apu.h"
+
+#include "blargg_source.h"
+
+#include "ym2413.h"
+#include "fmopl.h"
+
+Opl_Apu::Opl_Apu() { opl = 0; opl_memory = 0; }
+
+blargg_err_t Opl_Apu::init( long clock, long rate, blip_time_t period, type_t type )
+{
+	type_ = type;
+	clock_ = clock;
+	rate_ = rate;
+	period_ = period;
+	set_output( 0, 0 );
+	volume( 1.0 );
+	switch (type)
+	{
+	case type_opll:
+	case type_msxmusic:
+	case type_smsfmunit:
+		opl = ym2413_init( clock, rate, 0 );
+		break;
+
+	case type_vrc7:
+		opl = ym2413_init( clock, rate, 1 );
+		break;
+
+	case type_opl:
+		opl = ym3526_init( clock, rate );
+		break;
+
+	case type_msxaudio:
+		//logfile = fopen("c:\\temp\\msxaudio.log", "wb");
+		opl = y8950_init( clock, rate );
+		opl_memory = malloc( 32768 );
+		y8950_set_delta_t_memory( opl, opl_memory, 32768 );
+		break;
+
+	case type_opl2:
+		opl = ym3812_init( clock, rate );
+		break;
+	}
+	reset();
+	return 0;
+}
+
+Opl_Apu::~Opl_Apu()
+{
+	if (opl)
+	{
+		switch (type_)
+		{
+		case type_opll:
+		case type_msxmusic:
+		case type_smsfmunit:
+		case type_vrc7:
+			ym2413_shutdown( opl );
+			break;
+
+		case type_opl:
+			ym3526_shutdown( opl );
+			break;
+
+		case type_msxaudio:
+			y8950_shutdown( opl );
+			free( opl_memory );
+			opl_memory = NULL;
+			//fclose( logfile );
+			break;
+
+		case type_opl2:
+			ym3812_shutdown( opl );
+			break;
+		}
+	}
+}
+
+void Opl_Apu::reset()
+{
+	addr = 0;
+	next_time = 0;
+	last_amp = 0;
+
+	switch (type_)
+	{
+	case type_opll:
+	case type_msxmusic:
+	case type_smsfmunit:
+	case type_vrc7:
+		ym2413_reset_chip( opl );
+		break;
+
+	case type_opl:
+		ym3526_reset_chip( opl );
+		break;
+
+	case type_msxaudio:
+		y8950_reset_chip( opl );
+		break;
+
+	case type_opl2:
+		ym3812_reset_chip( opl );
+		break;
+	}
+}
+
+void Opl_Apu::write_data( blip_time_t time, int data )
+{
+	run_until( time );
+	switch (type_)
+	{
+	case type_opll:
+	case type_msxmusic:
+	case type_smsfmunit:
+	case type_vrc7:
+		ym2413_write( opl, 0, addr );
+		ym2413_write( opl, 1, data );
+		break;
+
+	case type_opl:
+		ym3526_write( opl, 0, addr );
+		ym3526_write( opl, 1, data );
+		break;
+
+	case type_msxaudio:
+		/*if ( addr >= 7 && addr <= 7 + 11 )
+		{
+			unsigned char temp [2] = { addr - 7, data };
+			fwrite( &temp, 1, 2, logfile );
+		}*/
+		y8950_write( opl, 0, addr );
+		y8950_write( opl, 1, data );
+		break;
+
+	case type_opl2:
+		ym3812_write( opl, 0, addr );
+		ym3812_write( opl, 1, data );
+		break;
+	}
+}
+
+int Opl_Apu::read( blip_time_t time, int port )
+{
+	run_until( time );
+	switch (type_)
+	{
+	case type_opll:
+	case type_msxmusic:
+	case type_smsfmunit:
+	case type_vrc7:
+		return ym2413_read( opl, port );
+
+	case type_opl:
+		return ym3526_read( opl, port );
+
+	case type_msxaudio:
+		{
+			int ret = y8950_read( opl, port );
+			/*unsigned char temp [2] = { port + 0x80, ret };
+			fwrite( &temp, 1, 2, logfile );*/
+			return ret;
+		}
+
+	case type_opl2:
+		return ym3812_read( opl, port );
+	}
+
+	return 0;
+}
+
+void Opl_Apu::end_frame( blip_time_t time )
+{
+	run_until( time );
+	next_time -= time;
+
+	if ( output_ )
+		output_->set_modified();
+}
+
+void Opl_Apu::run_until( blip_time_t end_time )
+{
+	if ( end_time > next_time )
+	{
+		blip_time_t time_delta = end_time - next_time;
+		blip_time_t time = next_time;
+		unsigned count = time_delta / period_ + 1;
+		switch (type_)
+		{
+		case type_opll:
+		case type_msxmusic:
+		case type_smsfmunit:
+		case type_vrc7:
+			{
+				SAMP bufMO[ 1024 ];
+				SAMP bufRO[ 1024 ];
+				SAMP * buffers[2] = { bufMO, bufRO };
+
+				while ( count > 0 )
+				{
+					unsigned todo = count;
+					if ( todo > 1024 ) todo = 1024;
+					ym2413_update_one( opl, buffers, todo );
+
+					if ( output_ )
+					{
+						int last_amp = this->last_amp;
+						for ( unsigned i = 0; i < todo; i++ )
+						{
+							int amp = bufMO [i] + bufRO [i];
+							int delta = amp - last_amp;
+							if ( delta )
+							{
+								last_amp = amp;
+								synth.offset_inline( time, delta, output_ );
+							}
+							time += period_;
+						}
+						this->last_amp = last_amp;
+					}
+					else time += period_ * todo;
+
+					count -= todo;
+				}
+			}
+			break;
+
+		case type_opl:
+		case type_msxaudio:
+		case type_opl2:
+			{
+				OPLSAMPLE buffer[ 1024 ];
+
+				while ( count > 0 )
+				{
+					unsigned todo = count;
+					if ( todo > 1024 ) todo = 1024;
+					switch (type_)
+					{
+					case type_opl:      ym3526_update_one( opl, buffer, todo ); break;
+					case type_msxaudio: y8950_update_one( opl, buffer, todo ); break;
+					case type_opl2:     ym3812_update_one( opl, buffer, todo ); break;
+					}
+
+					if ( output_ )
+					{
+						int last_amp = this->last_amp;
+						for ( unsigned i = 0; i < todo; i++ )
+						{
+							int amp = buffer [i];
+							int delta = amp - last_amp;
+							if ( delta )
+							{
+								last_amp = amp;
+								synth.offset_inline( time, delta, output_ );
+							}
+							time += period_;
+						}
+						this->last_amp = last_amp;
+					}
+					else time += period_ * todo;
+
+					count -= todo;
+				}
+			}
+			break;
+		}
+		next_time = time;
+	}
+}
\ Nincs új sor a fájl végén
diff -Nur orig/source/gme/src/Opl_Apu.h mod/source/gme/src/Opl_Apu.h
--- orig/source/gme/src/Opl_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Opl_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,63 @@
+#ifndef OPL_APU_H
+#define OPL_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+#include <stdio.h>
+
+class Opl_Apu {
+public:
+	Opl_Apu();
+	~Opl_Apu();
+	
+	enum type_t { type_opll = 0x10, type_msxmusic = 0x11, type_smsfmunit = 0x12,
+			type_vrc7 = 0x13, type_opl = 0x20, type_msxaudio = 0x21, type_opl2 = 0x22 };
+	blargg_err_t init( long clock, long rate, blip_time_t period, type_t );
+	
+	void reset();
+	void volume( double v ) { synth.volume( 1.0 / (4096 * 6) * v ); }
+	void treble_eq( blip_eq_t const& eq ) { synth.treble_eq( eq ); }
+	enum { osc_count = 1 };
+	void osc_output( int index, Blip_Buffer* );
+	void set_output( int i, Blip_Buffer* buf, Blip_Buffer* = NULL, Blip_Buffer* = NULL ) { osc_output( 0, buf ); }
+	void end_frame( blip_time_t );
+	
+	void write_addr( int data ) { addr = data; }
+	void write_data( blip_time_t, int data );
+
+	int read( blip_time_t, int port );
+	
+	static bool supported() { return true; }
+
+private:
+	// noncopyable
+	Opl_Apu( const Opl_Apu& );
+	Opl_Apu& operator = ( const Opl_Apu& );
+
+	Blip_Buffer* output_;
+	type_t type_;
+	void* opl;
+	void* opl_memory;
+	//FILE* logfile;
+	unsigned char regs[ 0x100 ];
+	blip_time_t next_time;
+	int last_amp;
+	int addr;
+	
+	long clock_;
+	long rate_;
+	blip_time_t period_;
+	
+	Blip_Synth_Fast synth;
+	
+	void run_until( blip_time_t );
+};
+
+inline void Opl_Apu::osc_output( int i, Blip_Buffer* buf )
+{
+	assert( (unsigned) i < osc_count );
+	output_ = buf;
+}
+
+#endif
diff -Nur orig/source/gme/src/Resampler.cpp mod/source/gme/src/Resampler.cpp
--- orig/source/gme/src/Resampler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Resampler.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,79 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Resampler.h"
+
+/* Copyright (C) 2004-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Resampler::Resampler()
+{
+	write_pos = 0;
+	rate_     = 0;
+}
+
+Resampler::~Resampler() { }
+
+void Resampler::clear()
+{
+	write_pos = 0;
+	clear_();
+}
+
+inline int Resampler::resample_wrapper( sample_t out [], int* out_size,
+		sample_t const in [], int in_size )
+{
+	assert( rate() );
+	
+	sample_t* out_ = out;
+	int result = resample_( &out_, out + *out_size, in, in_size ) - in;
+	assert( out_ <= out + *out_size );
+	assert( result <= in_size );
+	
+	*out_size = out_ - out;
+	return result;
+}
+
+int Resampler::resample( sample_t out [], int out_size, sample_t const in [], int* in_size )
+{
+	*in_size = resample_wrapper( out, &out_size, in, *in_size );
+	return out_size;
+}
+
+
+//// Buffering
+
+blargg_err_t Resampler::resize_buffer( int new_size )
+{
+	RETURN_ERR( buf.resize( new_size ) );
+	clear();
+	return blargg_ok;
+}
+
+int Resampler::skip_input( int count )
+{
+	write_pos -= count;
+	if ( write_pos < 0 ) // occurs when downsampling
+	{
+		count += write_pos;
+		write_pos = 0;
+	}
+	memmove( buf.begin(), &buf [count], write_pos * sizeof buf [0] );
+	return count;
+}
+
+int Resampler::read( sample_t out [], int out_size )
+{
+	if ( out_size )
+		skip_input( resample_wrapper( out, &out_size, buf.begin(), write_pos ) );
+	return out_size;
+}
diff -Nur orig/source/gme/src/Resampler.h mod/source/gme/src/Resampler.h
--- orig/source/gme/src/Resampler.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Resampler.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,110 @@
+// Common interface for resamplers
+
+// Game_Music_Emu 0.6-pre
+#ifndef RESAMPLER_H
+#define RESAMPLER_H
+
+#include "blargg_common.h"
+
+class Resampler {
+public:
+	
+	virtual ~Resampler();
+	
+	// Sets input/output resampling ratio
+	blargg_err_t set_rate( double );
+	
+	// Current input/output ratio
+	double rate() const             { return rate_; }
+	
+	// Samples are 16-bit signed
+	typedef short sample_t;
+
+// One of two different buffering schemes can be used, as decided by the caller:
+
+// External buffering (caller provides input buffer)
+	
+	// Resamples in to at most n out samples and returns number of samples actually
+	// written. Sets *in_size to number of input samples that aren't needed anymore
+	// and should be removed from input.
+	int resample( sample_t out [], int n, sample_t const in [], int* in_size );
+
+// Internal buffering (resampler manages buffer)
+	
+	// Resizes input buffer to n samples, then clears it
+	blargg_err_t resize_buffer( int n );
+	
+	// Clears input buffer
+	void clear();
+	
+	// Writes at most n samples to input buffer and returns number actually written.
+	// Result will be less than n if there isn't enough free space in buffer.
+	int write( sample_t const in [], int n );
+	
+	// Number of input samples in buffer
+	int written() const             { return write_pos; }
+	
+	// Removes first n input samples from buffer, fewer if there aren't that many.
+	// Returns number of samples actually removed.
+	int skip_input( int n );
+	
+	// Resamples input to at most n output samples. Returns number of samples
+	// actually written to out. Result will be less than n if there aren't
+	// enough input samples in buffer.
+	int read( sample_t out [], int n );
+
+// Direct writing to input buffer, instead of using write( in, n ) above
+
+	// Pointer to place to write input samples
+	sample_t* buffer()              { return &buf [write_pos]; }
+	
+	// Number of samples that can be written to buffer()
+	int buffer_free() const         { return buf.size() - write_pos; }
+	
+	// Notifies resampler that n input samples have been written to buffer().
+	// N must not be greater than buffer_free().
+	void write( int n );
+
+// Derived interface
+protected:
+	virtual blargg_err_t set_rate_( double rate ) BLARGG_PURE( ; )
+	
+	virtual void clear_() { }
+	
+	// Resample as many available in samples as will fit within out_size and
+	// return pointer past last input sample read and set *out just past
+	// the last output sample.
+	virtual sample_t const* resample_( sample_t** out, sample_t const* out_end,
+			sample_t const in [], int in_size ) BLARGG_PURE( { return in; } )
+
+// Implementation
+public:
+	Resampler();
+
+private:
+	blargg_vector<sample_t> buf;
+	int write_pos;
+	double rate_;
+	
+	int resample_wrapper( sample_t out [], int* out_size,
+			sample_t const in [], int in_size );
+};
+
+inline void Resampler::write( int count )
+{
+	write_pos += count;
+	assert( (unsigned) write_pos <= buf.size() );
+}
+
+inline blargg_err_t Resampler::set_rate_( double r )
+{
+	rate_ = r;
+	return blargg_ok;
+}
+
+inline blargg_err_t Resampler::set_rate( double r )
+{
+	return set_rate_( r );
+}
+
+#endif
diff -Nur orig/source/gme/src/Rom_Data.cpp mod/source/gme/src/Rom_Data.cpp
--- orig/source/gme/src/Rom_Data.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Rom_Data.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,99 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Rom_Data.h"
+
+/* Copyright (C) 2003-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void Rom_Data::clear()
+{
+	file_size_ = 0;
+	rom_addr   = 0;
+	mask       = 0;
+	rom.clear();
+}
+
+Rom_Data::Rom_Data( int page_size ) :
+	pad_size( page_size + pad_extra )
+{
+	// page_size should be power of 2
+	check( (page_size & (page_size - 1)) == 0 );
+	
+	clear();
+}
+
+Rom_Data::~Rom_Data()
+{ }
+
+// Reads file into array, placing file_offset bytes of padding before the beginning, and pad_size after the end
+blargg_err_t Rom_Data::load_( Data_Reader& in, int header_size, int file_offset )
+{
+	clear();
+	file_size_ = in.remain();
+	if ( file_size_ <= header_size ) // <= because there must be data after header
+		return blargg_err_file_type;
+	
+	RETURN_ERR( rom.resize( file_offset + file_size_ + pad_size ) );
+	
+	return in.read( rom.begin() + file_offset, file_size_ );
+}
+
+blargg_err_t Rom_Data::load( Data_Reader& in, int header_size,
+		void* header_out, int fill )
+{
+	int file_offset = pad_size - header_size;
+	blargg_err_t err = load_( in, header_size, file_offset );
+	if ( err )
+	{
+		clear();
+		return err;
+	}
+	
+	file_size_ -= header_size;
+	memcpy( header_out, &rom [file_offset], header_size );
+	
+	memset( rom.begin()         , fill, pad_size );
+	memset( rom.end() - pad_size, fill, pad_size );
+	
+	return blargg_ok;
+}
+
+void Rom_Data::set_addr( int addr )
+{
+	int const page_size = pad_size - pad_extra;
+	
+	// Minimum size that contains all bytes and is a multiple of page_size
+	int const size = (addr + file_size_ + page_size - 1) / page_size * page_size;
+	
+	// Find lowest power of 2 that is >= size
+	int power2 = 1;
+	while ( power2 < size )
+		power2 *= 2;
+	
+	mask = power2 - 1;
+	
+	// Address of first byte of ROM (possibly negative)
+	rom_addr = addr - page_size - pad_extra;
+
+	if ( rom.resize( size - rom_addr + pad_extra ) ) { } // OK if shrink fails
+}
+
+byte* Rom_Data::at_addr( int addr )
+{
+	int offset = mask_addr( addr ) - rom_addr;
+	
+	if ( (unsigned) offset > (unsigned) (rom.size() - pad_size) )
+		offset = 0; // unmapped
+	
+	return &rom [offset];
+}
diff -Nur orig/source/gme/src/Rom_Data.h mod/source/gme/src/Rom_Data.h
--- orig/source/gme/src/Rom_Data.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Rom_Data.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,94 @@
+// Manages ROM data loaded from file in an efficient manner
+
+// Game_Music_Emu 0.6-pre
+#ifndef ROM_DATA_H
+#define ROM_DATA_H
+
+#include "blargg_common.h"
+#include "Data_Reader.h"
+
+/* Loads a ROM file into memory and allows access to it in page-sized chunks.
+
+* ROM file consists of header followed by ROM data. Instead of storing the entire
+ROM contents, the file only stores the occupied portion, with the bytes before and
+after that cleared to some value. The size and format of the header is up to the
+caller, as is the starting address of the ROM data following it. File loading is
+performed with a single read, rather than two or more that might otherwise be
+required.
+
+* Once ROM data is loaded and its address specified, a pointer to any "page" can
+be obtained. ROM data is mirrored using smallest power of 2 that contains it.
+Addresses not aligned to pages can also be used, but this might cause unexpected
+results.
+
+Example with file data of size 0x0C put at address 0x0F, with page size of 8:
+
+---------------0123456789AB--------------------0123456789AB---------...
+^       ^       ^       ^       ^       ^       ^       ^       ^   
+0     0x08     0x10    0x18    0x20    0x28    0x30    0x38    0x40
+
+at_addr(0x00) = pointer to 8 bytes of fill.
+at_addr(0x08) = pointer to 7 bytes of fill, followed by first byte of file.
+at_addr(0x10) = pointer to next 8 bytes of file.
+at_addr(0x18) = pointer to last 3 bytes of file, followed by 5 bytes of fill.
+at_addr(0x20) = pointer to 8 bytes of fill.
+at_addr(0x28) = pointer to 7 bytes of fill, followed by first byte of file.
+etc. */
+
+class Rom_Data {
+	enum { pad_extra = 8 };
+public:
+	typedef unsigned char byte;
+	
+	// Page_size should be a power of 2
+	Rom_Data( int page_size );
+	
+	// Loads file into memory, then copies header to *header_out and fills
+	// unmapped bank and file data padding with fill. Returns blargg_err_file_type
+	// if in.remain() <= header_size.
+	blargg_err_t load( Data_Reader& in, int header_size, void* header_out, int fill );
+	
+	// Below, "file data" refers to data AFTER the header
+	
+	// Size of file data
+	int file_size() const               { return file_size_; }
+	
+	// Pointer to beginning of file data
+	byte      * begin()                 { return rom.begin() + pad_size; }
+	byte const* begin() const           { return rom.begin() + pad_size; }
+	
+	// Pointer to unmapped page cleared with fill value
+	byte* unmapped()                    { return rom.begin(); }
+	
+	// Sets address that file data will start at. Must be set before using following
+	// functions, and cannot be set more than once.
+	void set_addr( int addr );
+	
+	// Address of first empty page (file size + addr rounded up to multiple of page_size)
+	int size() const                    { return rom.size() - pad_extra + rom_addr; }
+	
+	// Masks address to nearest power of two greater than size()
+	int mask_addr( int addr ) const     { return addr & mask; }
+	
+	// Pointer to page beginning at addr, or unmapped() if outside data.
+	// Mirrored using mask_addr().
+	byte* at_addr( int addr );
+	
+	// Frees memory
+	void clear();
+
+// Implementation
+public:
+	~Rom_Data();
+
+protected:
+	blargg_vector<byte> rom;
+	int mask;
+	int rom_addr;
+	int const pad_size;
+	int file_size_;
+	
+	blargg_err_t load_( Data_Reader& in, int header_size, int file_offset );
+};
+
+#endif
diff -Nur orig/source/gme/src/Sap_Apu.cpp mod/source/gme/src/Sap_Apu.cpp
--- orig/source/gme/src/Sap_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,339 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sap_Apu.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const max_frequency = 12000; // pure waves above this frequency are silenced
+
+static void gen_poly( unsigned mask, int count, byte out [] )
+{
+	unsigned n = 1;
+	do
+	{
+		int bits = 0;
+		int b = 0;
+		do
+		{
+			// implemented using "Galios configuration"
+			bits |= (n & 1) << b;
+			n = (n >> 1) ^ (mask * (n & 1));
+		}
+		while ( b++ < 7 );
+		*out++ = bits;
+	}
+	while ( --count );
+}
+
+// poly5
+int const poly5_len = (1 <<  5) - 1;
+unsigned const poly5_mask = (1U << poly5_len) - 1;
+unsigned const poly5 = 0x167C6EA1;
+
+inline unsigned run_poly5( unsigned in, int shift )
+{
+	return (in << shift & poly5_mask) | (in >> (poly5_len - shift));
+}
+
+#define POLY_MASK( width, tap1, tap2 ) \
+	((1U << (width - 1 - tap1)) | (1U << (width - 1 - tap2)))
+
+Sap_Apu_Impl::Sap_Apu_Impl()
+{
+	gen_poly( POLY_MASK(  4, 1, 0 ), sizeof poly4,  poly4  );
+	gen_poly( POLY_MASK(  9, 5, 0 ), sizeof poly9,  poly9  );
+	gen_poly( POLY_MASK( 17, 5, 0 ), sizeof poly17, poly17 );
+
+// comment out to recauculate poly5 constant
+#if	0
+		byte poly5 [4];
+		gen_poly( POLY_MASK(  5, 2, 0 ), sizeof poly5,  poly5  );
+		unsigned n = poly5 [3] * 0x1000000 + poly5 [2] * 0x10000 + 
+				poly5 [1] * 0x100 + poly5 [0];
+		unsigned rev = n & 1;
+		for ( int i = 1; i < poly5_len; i++ )
+			rev |= (n >> i & 1) << (poly5_len - i);
+		dprintf( "poly5: 0x%08lX\n", rev );
+#endif
+}
+
+void Sap_Apu::set_output( Blip_Buffer* b )
+{
+	for ( int i = 0; i < osc_count; ++i )
+		set_output( i, b );
+}
+
+Sap_Apu::Sap_Apu()
+{
+	impl = NULL;
+	set_output( NULL );
+}
+
+void Sap_Apu::reset( Sap_Apu_Impl* new_impl )
+{
+	impl      = new_impl;
+	last_time = 0;
+	poly5_pos = 0;
+	poly4_pos = 0;
+	polym_pos = 0;
+	control   = 0;
+	
+	for ( int i = 0; i < osc_count; i++ )
+		memset( &oscs [i], 0, offsetof (osc_t,output) );
+}
+
+inline void Sap_Apu::calc_periods()
+{
+	 // 15/64 kHz clock
+	int divider = 28;
+	if ( this->control & 1 )
+		divider = 114;
+	
+	for ( int i = 0; i < osc_count; i++ )
+	{
+		osc_t* const osc = &oscs [i];
+		
+		int const osc_reload = osc->regs [0]; // cache
+		int period = (osc_reload + 1) * divider;
+		static byte const fast_bits [osc_count] = { 1 << 6, 1 << 4, 1 << 5, 1 << 3 };
+		if ( this->control & fast_bits [i] )
+		{
+			period = osc_reload + 4;
+			if ( i & 1 )
+			{
+				period = osc_reload * 0x100 + osc [-1].regs [0] + 7;
+				if ( !(this->control & fast_bits [i - 1]) )
+					period = (period - 6) * divider;
+				
+				if ( (osc [-1].regs [1] & 0x1F) > 0x10 )
+					dprintf( "Use of slave channel in 16-bit mode not supported\n" );
+			}
+		}
+		osc->period = period;
+	}
+}
+
+void Sap_Apu::run_until( blip_time_t end_time )
+{
+	calc_periods();
+	Sap_Apu_Impl* const impl = this->impl; // cache
+	
+	// 17/9-bit poly selection
+	byte const* polym = impl->poly17;
+	int polym_len = poly17_len;
+	if ( this->control & 0x80 )
+	{
+		polym_len = poly9_len;
+		polym = impl->poly9;
+	}
+	polym_pos %= polym_len;
+	
+	for ( int i = 0; i < osc_count; i++ )
+	{
+		osc_t* const osc = &oscs [i];
+		blip_time_t time = last_time + osc->delay;
+		blip_time_t const period = osc->period;
+		
+		// output
+		Blip_Buffer* output = osc->output;
+		if ( output )
+		{
+			int const osc_control = osc->regs [1]; // cache
+			int volume = (osc_control & 0x0F) * 2;
+			if ( !volume || osc_control & 0x10 || // silent, DAC mode, or inaudible frequency
+					((osc_control & 0xA0) == 0xA0 && period < 1789773 / 2 / max_frequency) )
+			{
+				if ( !(osc_control & 0x10) )
+					volume >>= 1; // inaudible frequency = half volume
+				
+				int delta = volume - osc->last_amp;
+				if ( delta )
+				{
+					osc->last_amp = volume;
+					output->set_modified();
+					impl->synth.offset( last_time, delta, output );
+				}
+				
+				// TODO: doesn't maintain high pass flip-flop (very minor issue)
+			}
+			else
+			{
+				// high pass
+				static byte const hipass_bits [osc_count] = { 1 << 2, 1 << 1, 0, 0 };
+				blip_time_t period2 = 0; // unused if no high pass
+				blip_time_t time2 = end_time;
+				if ( this->control & hipass_bits [i] )
+				{
+					period2 = osc [2].period;
+					time2 = last_time + osc [2].delay;
+					if ( osc->invert )
+					{
+						// trick inner wave loop into inverting output
+						osc->last_amp -= volume;
+						volume = -volume;
+					}
+				}
+				
+				if ( time < end_time || time2 < end_time )
+				{
+					// poly source
+					static byte const poly1 [] = { 0x55, 0x55 }; // square wave
+					byte const* poly = poly1;
+					int poly_len = 8 * sizeof poly1; // can be just 2 bits, but this is faster
+					int poly_pos = osc->phase & 1;
+					int poly_inc = 1;
+					if ( !(osc_control & 0x20) )
+					{
+						poly     = polym;
+						poly_len = polym_len;
+						poly_pos = polym_pos;
+						if ( osc_control & 0x40 )
+						{
+							poly     = impl->poly4;
+							poly_len = poly4_len;
+							poly_pos = poly4_pos;
+						}
+						poly_inc = period % poly_len;
+						poly_pos = (poly_pos + osc->delay) % poly_len;
+					}
+					poly_inc -= poly_len; // allows more optimized inner loop below
+					
+					// square/poly5 wave
+					unsigned wave = poly5;
+					check( poly5 & 1 ); // low bit is set for pure wave
+					int poly5_inc = 0;
+					if ( !(osc_control & 0x80) )
+					{
+						wave = run_poly5( wave, (osc->delay + poly5_pos) % poly5_len );
+						poly5_inc = period % poly5_len;
+					}
+					
+					output->set_modified();
+					
+					// Run wave and high pass interleved with each catching up to the other.
+					// Disabled high pass has no performance effect since inner wave loop
+					// makes no compromise for high pass, and only runs once in that case.
+					int osc_last_amp = osc->last_amp;
+					do
+					{
+						// run high pass
+						if ( time2 < time )
+						{
+							int delta = -osc_last_amp;
+							if ( volume < 0 )
+								delta += volume;
+							if ( delta )
+							{
+								osc_last_amp += delta - volume;
+								volume = -volume;
+								impl->synth.offset( time2, delta, output );
+							}
+						}
+						while ( time2 <= time ) // must advance *past* time to avoid hang
+							time2 += period2;
+						
+						// run wave
+						blip_time_t end = end_time;
+						if ( end > time2 )
+							end = time2;
+						while ( time < end )
+						{
+							if ( wave & 1 )
+							{
+								int amp = volume * (poly [poly_pos >> 3] >> (poly_pos & 7) & 1);
+								if ( (poly_pos += poly_inc) < 0 )
+									poly_pos += poly_len;
+								int delta = amp - osc_last_amp;
+								if ( delta )
+								{
+									osc_last_amp = amp;
+									impl->synth.offset( time, delta, output );
+								}
+							}
+							wave = run_poly5( wave, poly5_inc );
+							time += period;
+						}
+					}
+					while ( time < end_time || time2 < end_time );
+					
+					osc->phase = poly_pos;
+					osc->last_amp = osc_last_amp;
+				}
+				
+				osc->invert = 0;
+				if ( volume < 0 )
+				{
+					// undo inversion trickery
+					osc->last_amp -= volume;
+					osc->invert = 1;
+				}
+			}
+		}
+		
+		// maintain divider
+		blip_time_t remain = end_time - time;
+		if ( remain > 0 )
+		{
+			int count = (remain + period - 1) / period;
+			osc->phase ^= count;
+			time += count * period;
+		}
+		osc->delay = time - end_time;
+	}
+	
+	// advance polies
+	blip_time_t duration = end_time - last_time;
+	last_time = end_time;
+	poly4_pos = (poly4_pos + duration) % poly4_len;
+	poly5_pos = (poly5_pos + duration) % poly5_len;
+	polym_pos += duration; // will get %'d on next call
+}
+
+void Sap_Apu::write_data( blip_time_t time, int addr, int data )
+{
+	run_until( time );
+	int i = (addr - 0xD200) >> 1;
+	if ( (unsigned) i < osc_count )
+	{
+		oscs [i].regs [addr & 1] = data;
+	}
+	else if ( addr == 0xD208 )
+	{
+		control = data;
+	}
+	else if ( addr == 0xD209 )
+	{
+		oscs [0].delay = 0;
+		oscs [1].delay = 0;
+		oscs [2].delay = 0;
+		oscs [3].delay = 0;
+	}
+	/*
+	// TODO: are polynomials reset in this case?
+	else if ( addr == 0xD20F )
+	{
+		if ( (data & 3) == 0 )
+			polym_pos = 0;
+	}
+	*/
+}
+
+void Sap_Apu::end_frame( blip_time_t end_time )
+{
+	if ( end_time > last_time )
+		run_until( end_time );
+	
+	last_time -= end_time;
+	assert( last_time >= 0 );
+}
diff -Nur orig/source/gme/src/Sap_Apu.h mod/source/gme/src/Sap_Apu.h
--- orig/source/gme/src/Sap_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,103 @@
+// Atari POKEY sound chip emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef SAP_APU_H
+#define SAP_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+class Sap_Apu_Impl;
+
+class Sap_Apu {
+public:
+// Basics
+
+	// Sets buffer to generate sound into, or 0 to mute
+	void set_output( Blip_Buffer* );
+	
+	// Emulates to time t, then writes data to addr
+	void write_data( blip_time_t t, int addr, int data );
+
+	// Emulates to time t, then subtracts t from the current time.
+	// OK if previous write call had time slightly after t.
+	void end_frame( blip_time_t t );
+	
+// More features
+
+	// Same as set_output(), but for a particular channel
+	enum { osc_count = 4 };
+	void set_output( int index, Blip_Buffer* );
+	
+	// Resets sound chip and sets Sap_Apu_Impl
+	void reset( Sap_Apu_Impl* impl );
+	
+	// Registers are at io_addr to io_addr+io_size-1
+	enum { io_addr = 0xD200 };
+	enum { io_size = 0x0A };
+	
+private:
+	// noncopyable
+	Sap_Apu( const Sap_Apu& );
+	Sap_Apu& operator = ( const Sap_Apu& );
+	
+// Implementation
+public:
+	Sap_Apu();
+	
+private:
+	struct osc_t
+	{
+		unsigned char regs [2];
+		unsigned char phase;
+		unsigned char invert;
+		int last_amp;
+		blip_time_t delay;
+		blip_time_t period; // always recalculated before use; here for convenience
+		Blip_Buffer* output;
+	};
+	osc_t oscs [osc_count];
+	Sap_Apu_Impl* impl;
+	blip_time_t last_time;
+	int poly5_pos;
+	int poly4_pos;
+	int polym_pos;
+	int control;
+	
+	void calc_periods();
+	void run_until( blip_time_t );
+	
+	enum { poly4_len  = (1 <<  4) - 1 };
+	enum { poly9_len  = (1 <<  9) - 1 };
+	enum { poly17_len = (1 << 17) - 1 };
+	friend class Sap_Apu_Impl;
+};
+
+// Common tables and Blip_Synth that can be shared among multiple Sap_Apu objects
+class Sap_Apu_Impl {
+public:
+	// Set treble with synth.treble_eq()
+	Blip_Synth_Norm synth;
+	
+	// Sets overall volume, where 1.0is normal
+	void volume( double d ) { synth.volume( 1.0 / Sap_Apu::osc_count / 30 * d ); }
+	
+	
+// Implementation
+public:
+	Sap_Apu_Impl();
+
+private:
+	BOOST::uint8_t poly4  [Sap_Apu::poly4_len /8 + 1];
+	BOOST::uint8_t poly9  [Sap_Apu::poly9_len /8 + 1];
+	BOOST::uint8_t poly17 [Sap_Apu::poly17_len/8 + 1];
+	friend class Sap_Apu;
+};
+
+inline void Sap_Apu::set_output( int i, Blip_Buffer* b )
+{
+	assert( (unsigned) i < osc_count );
+	oscs [i].output = b;
+}
+
+#endif
diff -Nur orig/source/gme/src/Sap_Core.cpp mod/source/gme/src/Sap_Core.cpp
--- orig/source/gme/src/Sap_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,192 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sap_Core.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const idle_addr = 0xD2D2;
+
+Sap_Core::Sap_Core()
+{
+	set_tempo( 1 );
+}
+
+void Sap_Core::push( int b )
+{
+	mem.ram [0x100 + cpu.r.sp--] = (byte) b;
+}
+
+void Sap_Core::jsr_then_stop( addr_t addr )
+{
+	cpu.r.pc = addr;
+	
+	// Some rips pop three bytes off stack before RTS.
+	push( (idle_addr - 1) >> 8 );
+	push(  idle_addr - 1       );
+	
+	// 3 bytes so that RTI or RTS will jump to idle_addr.
+	// RTI will use the first two bytes as the address, 0xD2D2.
+	// RTS will use the last two bytes, 0xD2D1, which it internally increments.
+	push( (idle_addr - 1) >> 8 );
+	push( (idle_addr - 1) >> 8 );
+	push(  idle_addr - 1       );
+}
+
+// Runs routine and allows it up to one second to return
+void Sap_Core::run_routine( addr_t addr )
+{
+	jsr_then_stop( addr );
+	run_cpu( lines_per_frame * base_scanline_period * 60 );
+	check( cpu.r.pc == idle_addr );
+	check( cpu.r.sp >= 0xFF - 6 );
+}
+
+inline void Sap_Core::call_init( int track )
+{
+	cpu.r.a = track;
+	
+	switch ( info.type )
+	{
+	case 'B':
+		run_routine( info.init_addr );
+		break;
+	
+	case 'C':
+		cpu.r.a = 0x70;
+		cpu.r.x = info.music_addr&0xFF;
+		cpu.r.y = info.music_addr >> 8;
+		run_routine( info.play_addr + 3 );
+		cpu.r.a = 0;
+		cpu.r.x = track;
+		run_routine( info.play_addr + 3 );
+		break;
+	
+	case 'D':
+		check( info.fastplay == lines_per_frame );
+		jsr_then_stop( info.init_addr );
+		break;
+	}
+}
+
+void Sap_Core::setup_ram()
+{
+	memset( &mem, 0, sizeof mem );
+	
+	ram() [idle_addr] = cpu.halt_opcode;
+	
+	addr_t const irq_addr = idle_addr - 1;
+	ram() [irq_addr] = cpu.halt_opcode;
+	ram() [0xFFFE] = (byte) irq_addr;
+	ram() [0xFFFF] = irq_addr >> 8;
+}
+
+blargg_err_t Sap_Core::start_track( int track, info_t const& new_info )
+{
+	info = new_info;
+	
+	check( ram() [idle_addr] == cpu.halt_opcode );
+	
+	apu_ .reset( &apu_impl_ );
+	apu2_.reset( &apu_impl_ );
+	
+	cpu.reset( ram() );
+	
+	frame_start = 0;
+	next_play = play_period() * 4;
+	saved_state.pc = idle_addr;
+	
+	time_mask = 0; // disables sound during init
+	call_init( track );
+	time_mask = ~0;
+	
+	return blargg_ok;
+}
+
+blargg_err_t Sap_Core::run_until( time_t end )
+{
+	while ( cpu.time() < end )
+	{
+		time_t next = min( next_play, end );
+		if ( (run_cpu( next ) && cpu.r.pc != idle_addr) || cpu.error_count() )
+			// TODO: better error
+			return BLARGG_ERR( BLARGG_ERR_GENERIC, "Emulation error (illegal instruction)" );
+		
+		if ( cpu.r.pc == idle_addr )
+		{
+			if ( saved_state.pc == idle_addr )
+			{
+				// no code to run until next play call
+				cpu.set_time( next );
+			}
+			else
+			{
+				// play had interrupted non-returning init, so restore registers
+				// init routine was running
+				check( cpu.r.sp == saved_state.sp - 3 );
+				cpu.r = saved_state;
+				saved_state.pc = idle_addr;
+			}
+		}
+		
+		if ( cpu.time() >= next_play )
+		{
+			next_play += play_period();
+			
+			if ( cpu.r.pc == idle_addr || info.type == 'D' )
+			{
+				// Save state if init routine is still running
+				if ( cpu.r.pc != idle_addr )
+				{
+					check( info.type == 'D' );
+					check( saved_state.pc == idle_addr );
+					saved_state = cpu.r;
+				}
+				
+				addr_t addr = info.play_addr;
+				if ( info.type == 'C' )
+					addr += 6;
+				jsr_then_stop( addr );
+			}
+			else
+			{
+				dprintf( "init/play hadn't returned before next play call\n" );
+			}
+		}
+	}
+	return blargg_ok;
+}
+
+blargg_err_t Sap_Core::end_frame( time_t end )
+{
+	RETURN_ERR( run_until( end ) );
+	
+	cpu.adjust_time( -end );
+	
+	time_t frame_time = lines_per_frame * scanline_period;
+	while ( frame_start < end )
+		frame_start += frame_time;
+	frame_start -= end + frame_time;
+	
+	if ( (next_play -= end) < 0 )
+	{
+		next_play = 0;
+		check( false );
+	}
+	
+	apu_.end_frame( end );
+	if ( info.stereo )
+		apu2_.end_frame( end );
+	
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Sap_Core.h mod/source/gme/src/Sap_Core.h
--- orig/source/gme/src/Sap_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,91 @@
+// Atari XL/XE SAP core CPU and RAM emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef SAP_CORE_H
+#define SAP_CORE_H
+
+#include "Sap_Apu.h"
+#include "Nes_Cpu.h"
+
+class Sap_Core {
+public:
+	
+	// Sound chips and common state
+	Sap_Apu& apu()                              { return apu_; }
+	Sap_Apu& apu2()                             { return apu2_; }
+	Sap_Apu_Impl& apu_impl()                    { return apu_impl_; }
+	
+	// Adjusts music tempo, where 1.0 is normal. Can be changed while playing.
+	void set_tempo( double );
+	
+	// Clears RAM and sets up default vectors, etc.
+	void setup_ram();
+	
+	// 64K RAM to load file data blocks into
+	BOOST::uint8_t* ram()                       { return mem.ram; }
+	
+	// Calls init routine and configures playback. RAM must have been
+	// set up already.
+	struct info_t {
+		int init_addr;
+		int play_addr;
+		int music_addr;
+		int type;
+		int fastplay;
+		int stereo;
+	};
+	blargg_err_t start_track( int track, info_t const& );
+	
+	// Ends time frame at time t, then begins new at time 0
+	typedef Nes_Cpu::time_t time_t; // Clock count
+	blargg_err_t end_frame( time_t t );
+	
+
+// Implementation
+public:
+	Sap_Core();
+
+private:
+	enum { base_scanline_period = 114 };
+	enum { lines_per_frame = 312 };
+	typedef Nes_Cpu::addr_t addr_t;
+	
+	time_t scanline_period;
+	time_t next_play;
+	time_t time_mask;
+	time_t frame_start;
+	Nes_Cpu cpu;
+	Nes_Cpu::registers_t saved_state;
+	info_t info;
+	Sap_Apu apu_;
+	Sap_Apu apu2_;
+	
+	// large items
+	struct {
+		BOOST::uint8_t padding1 [  0x100];
+		BOOST::uint8_t ram      [0x10000];
+		BOOST::uint8_t padding2 [  0x100];
+	} mem; // TODO: put on freestore
+	Sap_Apu_Impl apu_impl_;
+
+	void push( int b );
+	void jsr_then_stop( addr_t );
+	void run_routine( addr_t );
+	void call_init( int track );
+	bool run_cpu( time_t end );
+	int  play_addr();
+	int  read_d40b();
+	int  read_mem( addr_t );
+	void write_D2xx( int d2xx, int data );
+	
+	time_t time() const                     { return cpu.time() & time_mask; }
+	blargg_err_t run_until( time_t t );
+	time_t play_period() const { return info.fastplay * scanline_period; }
+};
+
+inline void Sap_Core::set_tempo( double t )
+{
+	scanline_period = (int) (base_scanline_period / t + 0.5);
+}
+
+#endif
diff -Nur orig/source/gme/src/Sap_Cpu.cpp mod/source/gme/src/Sap_Cpu.cpp
--- orig/source/gme/src/Sap_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,96 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sap_Core.h"
+
+#include "blargg_endian.h"
+
+//#define CPU_LOG_MAX 100000
+//#include "nes_cpu_log.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// functions defined in same file as CPU emulator to help compiler's optimizer
+
+int Sap_Core::read_d40b()
+{
+	//dprintf( "D40B read\n" );
+	check( cpu.time() >= frame_start );
+	return ((unsigned) (cpu.time() - frame_start) / scanline_period % lines_per_frame) / 2;
+}
+
+void Sap_Core::write_D2xx( int d2xx, int data )
+{
+	addr_t const base = 0xD200;
+	
+	if ( d2xx < apu_.io_size )
+	{
+		apu_.write_data( time(), d2xx + base, data );
+		return;
+	}
+	
+	if ( (unsigned) (d2xx - 0x10) < apu2_.io_size && info.stereo )
+	{
+		apu2_.write_data( time(), d2xx + (base - 0x10), data );
+		return;
+	}
+	
+	if ( d2xx == 0xD40A - base )
+	{
+		dprintf( "D40A write\n" );
+		time_t t = cpu.time();
+		time_t into_line = (t - frame_start) % scanline_period;
+		cpu.set_end_time( t - into_line + scanline_period );
+		return;
+	}
+	
+	if ( (d2xx & ~0x0010) != 0x0F || data != 0x03 )
+		dprintf( "Unmapped write $%04X <- $%02X\n", d2xx + base, data );
+}
+
+inline int Sap_Core::read_mem( addr_t addr )
+{
+	int result = mem.ram [addr];
+	if ( addr == 0xD40B )
+		result = read_d40b(); 
+	else if ( (addr & 0xF900) == 0xD000 )
+		dprintf( "Unmapped read $%04X\n", addr );
+	return result;
+}
+
+
+#define READ_LOW(  addr       ) (ram [addr])
+#define WRITE_LOW( addr, data ) (ram [addr] = data)
+
+#define READ_MEM(  addr       ) read_mem( addr )
+#define WRITE_MEM( addr, data ) \
+{\
+	ram [addr] = data;\
+	int d2xx = addr - 0xD200;\
+	if ( (unsigned) d2xx < 0x100 )\
+		write_D2xx( d2xx, data );\
+}
+
+#define CPU         cpu
+#define FLAT_MEM    ram
+
+#define CPU_BEGIN \
+bool Sap_Core::run_cpu( time_t end )\
+{\
+	CPU.set_end_time( end );\
+	byte* const ram = this->mem.ram; /* cache */
+	
+	#include "Nes_Cpu_run.h"
+	
+	return cpu.time_past_end() < 0;
+}
diff -Nur orig/source/gme/src/Sap_Cpu.h mod/source/gme/src/Sap_Cpu.h
--- orig/source/gme/src/Sap_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,83 @@
+// Atari 6502 CPU emulator
+
+// Game_Music_Emu 0.5.5
+#ifndef SAP_CPU_H
+#define SAP_CPU_H
+
+#include "blargg_common.h"
+
+typedef blargg_long sap_time_t; // clock cycle count
+typedef unsigned sap_addr_t; // 16-bit address
+enum { future_sap_time = INT_MAX / 2 + 1 };
+
+class Sap_Cpu {
+public:
+	typedef BOOST::uint8_t uint8_t;
+	
+	// Clear all registers and keep pointer to 64K memory passed in
+	void reset( void* mem_64k );
+	
+	// Run until specified time is reached. Returns true if suspicious/unsupported
+	// instruction was encountered at any point during run.
+	bool run( sap_time_t end_time );
+	
+	// Registers are not updated until run() returns (except I flag in status)
+	struct registers_t {
+		BOOST::uint16_t pc;
+		BOOST::uint8_t a;
+		BOOST::uint8_t x;
+		BOOST::uint8_t y;
+		BOOST::uint8_t status;
+		BOOST::uint8_t sp;
+	};
+	registers_t r;
+	
+	enum { idle_addr = 0xFEFF };
+	
+	// Time of beginning of next instruction to be executed
+	sap_time_t time() const             { return state->time + state->base; }
+	void set_time( sap_time_t t )       { state->time = t - state->base; }
+	void adjust_time( int delta )       { state->time += delta; }
+	
+	sap_time_t irq_time() const         { return irq_time_; }
+	void set_irq_time( sap_time_t );
+	
+	sap_time_t end_time() const         { return end_time_; }
+	void set_end_time( sap_time_t );
+	
+public:
+	Sap_Cpu() { state = &state_; }
+	enum { irq_inhibit = 0x04 };
+private:
+	struct state_t {
+		sap_time_t base;
+		sap_time_t time;
+	};
+	state_t* state; // points to state_ or a local copy within run()
+	state_t state_;
+	sap_time_t irq_time_;
+	sap_time_t end_time_;
+	uint8_t* mem;
+	
+	inline sap_time_t update_end_time( sap_time_t end, sap_time_t irq );
+};
+
+inline sap_time_t Sap_Cpu::update_end_time( sap_time_t t, sap_time_t irq )
+{
+	if ( irq < t && !(r.status & irq_inhibit) ) t = irq;
+	sap_time_t delta = state->base - t;
+	state->base = t;
+	return delta;
+}
+
+inline void Sap_Cpu::set_irq_time( sap_time_t t )
+{
+	state->time += update_end_time( end_time_, (irq_time_ = t) );
+}
+
+inline void Sap_Cpu::set_end_time( sap_time_t t )
+{
+	state->time += update_end_time( (end_time_ = t), irq_time_ );
+}
+
+#endif
diff -Nur orig/source/gme/src/sap_cpu_io.h mod/source/gme/src/sap_cpu_io.h
--- orig/source/gme/src/sap_cpu_io.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/sap_cpu_io.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,26 @@
+
+#include "Sap_Emu.h"
+
+#include "blargg_source.h"
+
+#define CPU_WRITE( cpu, addr, data, time )  STATIC_CAST(Sap_Emu&,*cpu).cpu_write( addr, data )
+
+void Sap_Emu::cpu_write( sap_addr_t addr, int data )
+{
+	mem.ram [addr] = data;
+	if ( (addr >> 8) == 0xD2 )
+		cpu_write_( addr, data );
+}
+
+#ifdef NDEBUG
+	#define CPU_READ( cpu, addr, time )     READ_LOW( addr )
+#else
+	#define CPU_READ( cpu, addr, time )     STATIC_CAST(Sap_Emu&,*cpu).cpu_read( addr )
+	
+	int Sap_Emu::cpu_read( sap_addr_t addr )
+	{
+		if ( (addr & 0xF900) == 0xD000 )
+			debug_printf( "Unmapped read $%04X\n", addr );
+		return mem.ram [addr];
+	}
+#endif
diff -Nur orig/source/gme/src/Sap_Emu.cpp mod/source/gme/src/Sap_Emu.cpp
--- orig/source/gme/src/Sap_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,385 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sap_Emu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+Sap_Emu::Sap_Emu()
+{
+	set_type( gme_sap_type );
+	set_silence_lookahead( 6 );
+}
+
+Sap_Emu::~Sap_Emu() { }
+
+// Track info
+
+// Returns 16 or greater if not hex. Handles uppercase and lowercase.
+// Thoroughly tested and rejects ALL non-hex characters.
+inline int from_hex_char( int h )
+{
+	h -= 0x30;
+	if ( (unsigned) h > 9 )
+		h = ((h - 0x11) & 0xDF) + 10;
+	return h;
+}
+
+static int from_hex( byte const in [] )
+{
+	int result = 0;
+	for ( int n = 4; n--; )
+	{
+		int h = from_hex_char( *in++ );
+		if ( h > 15 )
+			return -1;
+		result = result * 0x10 + h;
+	}
+	return result;
+}
+
+static int parse_int( byte const* io [], byte const* end )
+{
+	byte const* in = *io;
+	int n = 0;
+	while ( in < end )
+	{
+		int dig = *in - '0';
+		if ( (unsigned) dig > 9 )
+			break;
+		++in;
+		n = n * 10 + dig;
+	}
+	if ( in == *io )
+		n = -1; // no numeric characters
+	*io = in;
+	return n;
+}
+
+static int from_dec( byte const in [], byte const* end )
+{
+	int n = parse_int( &in, end );
+	if ( in < end )
+		n = -1;
+	return n;
+}
+
+static void parse_string( byte const in [], byte const* end, int len, char out [] )
+{
+	byte const* start = in;
+	if ( *in++ == '\"' )
+	{
+		start++;
+		while ( in < end && *in != '\"' )
+			in++;
+	}
+	else
+	{
+		in = end;
+	}
+	len = min( len - 1, int (in - start) );
+	out [len] = 0;
+	memcpy( out, start, len );
+}
+
+static int parse_time( byte const in [], byte const* end )
+{
+	int minutes = parse_int( &in, end );
+	if ( minutes < 0 || *in != ':' )
+		return 0;
+	
+	++in;
+	int seconds = parse_int( &in, end );
+	if ( seconds < 0 )
+		return 0;
+	
+	int time = minutes * 60000 + seconds * 1000;
+	if ( *in == '.' )
+	{
+		byte const* start = ++in;
+		int msec = parse_int( &in, end );
+		if ( msec >= 0 )
+		{
+			// allow 1-3 digits
+			for ( int n = in - start; n < 3; n++ )
+				msec *= 10;
+			time += msec;
+		}
+	}
+	
+	while ( in < end && *in <= ' ' )
+		++in;
+	
+	if ( end - in >= 4 && !memcmp( in, "LOOP", 4 ) )
+		time = -time;
+	
+	return time;
+}
+
+static blargg_err_t parse_info( byte const in [], int size, Sap_Emu::info_t* out )
+{
+	out->track_count   = 1;
+	out->author    [0] = 0;
+	out->name      [0] = 0;
+	out->copyright [0] = 0;
+	
+	for ( int i = 0; i < Sap_Emu::max_tracks; i++ )
+		out->track_times [i] = 0;
+	
+	if ( size < 16 || memcmp( in, "SAP\x0D\x0A", 5 ) )
+		return blargg_err_file_type;
+	
+	int time_count = 0;
+	byte const* file_end = in + size - 5;
+	in += 5;
+	while ( in < file_end && (in [0] != 0xFF || in [1] != 0xFF) )
+	{
+		byte const* line_end = in;
+		while ( line_end < file_end && *line_end != 0x0D )
+			line_end++;
+		
+		char const* tag = (char const*) in;
+		while ( in < line_end && *in > ' ' )
+			in++;
+		int tag_len = (char const*) in - tag;
+		
+		while ( in < line_end && *in <= ' ' ) in++;
+		
+		if ( tag_len <= 0 )
+		{
+			// skip line
+		}
+		else if ( !strncmp( "TIME", tag, tag_len ) && time_count < Sap_Emu::max_tracks )
+		{
+			out->track_times [time_count++] = parse_time( in, line_end );
+		}
+		else if ( !strncmp( "INIT", tag, tag_len ) )
+		{
+			out->init_addr = from_hex( in );
+			if ( (unsigned) out->init_addr >= 0x10000 )
+				return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "init address" );
+		}
+		else if ( !strncmp( "PLAYER", tag, tag_len ) )
+		{
+			out->play_addr = from_hex( in );
+			if ( (unsigned) out->play_addr >= 0x10000 )
+				return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "play address" );
+		}
+		else if ( !strncmp( "MUSIC", tag, tag_len ) )
+		{
+			out->music_addr = from_hex( in );
+			if ( (unsigned) out->music_addr >= 0x10000 )
+				return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "music address" );
+		}
+		else if ( !strncmp( "SONGS", tag, tag_len ) )
+		{
+			out->track_count = from_dec( in, line_end );
+			if ( out->track_count <= 0 )
+				return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "track count" );
+		}
+		else if ( !strncmp( "TYPE", tag, tag_len ) )
+		{
+			switch ( out->type = *in )
+			{
+			case 'S':
+				out->type = 'C';
+			case 'B':
+			case 'C':
+			case 'D':
+				break;
+			
+			default:
+				return BLARGG_ERR( BLARGG_ERR_FILE_FEATURE, "player type" );
+			}
+		}
+		else if ( !strncmp( "STEREO", tag, tag_len ) )
+		{
+			out->stereo = true;
+		}
+		else if ( !strncmp( "FASTPLAY", tag, tag_len ) )
+		{
+			out->fastplay = from_dec( in, line_end );
+			if ( out->fastplay <= 0 )
+				return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "fastplay value" );
+		}
+		else if ( !strncmp( "AUTHOR", tag, tag_len ) )
+		{
+			parse_string( in, line_end, sizeof out->author, out->author );
+		}
+		else if ( !strncmp( "NAME", tag, tag_len ) )
+		{
+			parse_string( in, line_end, sizeof out->name, out->name );
+		}
+		else if ( !strncmp( "DATE", tag, tag_len ) )
+		{
+			parse_string( in, line_end, sizeof out->copyright, out->copyright );
+		}
+		
+		in = line_end + 2;
+	}
+	
+	if ( in [0] != 0xFF || in [1] != 0xFF )
+		return BLARGG_ERR( BLARGG_ERR_FILE_CORRUPT, "ROM data missing" );
+	out->rom_data = in + 2;
+	
+	return blargg_ok;
+}
+
+static void copy_sap_fields( Sap_Emu::info_t const& in, track_info_t* out )
+{
+	Gme_File::copy_field_( out->game,      in.name );
+	Gme_File::copy_field_( out->author,    in.author );
+	Gme_File::copy_field_( out->copyright, in.copyright );
+}
+
+blargg_err_t Sap_Emu::track_info_( track_info_t* out, int track ) const
+{
+	copy_sap_fields( info_, out );
+	
+	if ( track < max_tracks )
+	{
+		int time = info_.track_times [track];
+		if ( time )
+		{
+			if ( time > 0 )
+			{
+				out->loop_length = 0;
+			}
+			else
+			{
+				time = -time;
+				out->loop_length = time;
+			}
+			out->length = time;
+		}
+	}
+	return blargg_ok;
+}
+
+struct Sap_File : Gme_Info_
+{
+	Sap_Emu::info_t info;
+	
+	Sap_File() { set_type( gme_sap_type ); }
+	
+	blargg_err_t load_mem_( byte const begin [], int size )
+	{
+		RETURN_ERR( parse_info( begin, size, &info ) );
+		set_track_count( info.track_count );
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		copy_sap_fields( info, out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_sap_emu () { return BLARGG_NEW Sap_Emu ; }
+static Music_Emu* new_sap_file() { return BLARGG_NEW Sap_File; }
+
+gme_type_t_ const gme_sap_type [1] = {{ "Atari XL", 0, &new_sap_emu, &new_sap_file, "SAP", 1 }};
+
+// Setup
+
+blargg_err_t Sap_Emu::load_mem_( byte const in [], int size )
+{
+	file_end = in + size;
+	
+	info_.warning    = NULL;
+	info_.type       = 'B';
+	info_.stereo     = false;
+	info_.init_addr  = -1;
+	info_.play_addr  = -1;
+	info_.music_addr = -1;
+	info_.fastplay   = 312;
+	RETURN_ERR( parse_info( in, size, &info_ ) );
+	
+	set_warning( info_.warning );
+	set_track_count( info_.track_count );
+	set_voice_count( Sap_Apu::osc_count << info_.stereo );
+	core.apu_impl().volume( gain() );
+	
+	static const char* const names [Sap_Apu::osc_count * 2] = {
+		"Wave 1", "Wave 2", "Wave 3", "Wave 4",
+		"Wave 5", "Wave 6", "Wave 7", "Wave 8",
+	};
+	set_voice_names( names );
+	
+	static int const types [Sap_Apu::osc_count * 2] = {
+		wave_type+1, wave_type+2, wave_type+3, wave_type+0,
+		wave_type+5, wave_type+6, wave_type+7, wave_type+4,
+	};
+	set_voice_types( types );
+	
+	return setup_buffer( 1773447 );
+}
+
+void Sap_Emu::update_eq( blip_eq_t const& eq )
+{
+	core.apu_impl().synth.treble_eq( eq );
+}
+
+void Sap_Emu::set_voice( int i, Blip_Buffer* center, Blip_Buffer* left, Blip_Buffer* right )
+{
+	int i2 = i - Sap_Apu::osc_count;
+	if ( i2 >= 0 )
+		core.apu2().set_output( i2, right );
+	else
+		core.apu().set_output( i, (info_.stereo ? left : center) );
+}
+
+// Emulation
+
+void Sap_Emu::set_tempo_( double t )
+{
+	core.set_tempo( t );
+}
+
+blargg_err_t Sap_Emu::start_track_( int track )
+{
+	RETURN_ERR( Classic_Emu::start_track_( track ) );
+	
+	core.setup_ram();
+	
+	// Copy file data to RAM
+	byte const* in = info_.rom_data;
+	while ( file_end - in >= 5 )
+	{
+		int start = get_le16( in );
+		int end   = get_le16( in + 2 );
+		//dprintf( "Block $%04X-$%04X\n", start, end );
+		in += 4;
+		int len = end - start + 1;
+		if ( (unsigned) len > (unsigned) (file_end - in) )
+		{
+			set_warning( "Invalid file data block" );
+			break;
+		}
+		
+		memcpy( core.ram() + start, in, len );
+		in += len;
+		if ( file_end - in >= 2 && in [0] == 0xFF && in [1] == 0xFF )
+			in += 2;
+	}
+	
+	return core.start_track( track, info_ );
+}
+
+blargg_err_t Sap_Emu::run_clocks( blip_time_t& duration, int )
+{
+	return core.end_frame( duration );
+}
diff -Nur orig/source/gme/src/Sap_Emu.h mod/source/gme/src/Sap_Emu.h
--- orig/source/gme/src/Sap_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sap_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,51 @@
+// Atari XL/XE SAP music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef SAP_EMU_H
+#define SAP_EMU_H
+
+#include "Classic_Emu.h"
+#include "Sap_Apu.h"
+#include "Sap_Core.h"
+
+class Sap_Emu : public Classic_Emu {
+public:
+	enum { max_tracks = 32 }; // TODO: no fixed limit
+	
+	// SAP file info (see Sap_Core.h for more)
+	struct info_t : Sap_Core::info_t {
+		byte const* rom_data;
+		const char* warning;
+		int  track_count;
+		int  track_times [max_tracks];
+		char author    [256];
+		char name      [256];
+		char copyright [ 32];
+	};
+	
+	// Info for currently loaded file
+	info_t const& info() const { return info_; }
+
+	static gme_type_t static_type() { return gme_sap_type; }
+
+// Implementation
+public:
+	Sap_Emu();
+	~Sap_Emu();
+
+protected:
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t load_mem_( byte const [], int );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+
+private:
+	info_t info_;
+	byte const* file_end;
+	Sap_Core core;
+};
+
+#endif
diff -Nur orig/source/gme/src/s_deltat.c mod/source/gme/src/s_deltat.c
--- orig/source/gme/src/s_deltat.c	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_deltat.c	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,281 @@
+#include "kmsnddev.h"
+#include "divfix.h"
+#include "s_logtbl.h"
+#include "s_deltat.h"
+#include <string.h>
+
+#define CPS_SHIFT 16
+#define PHASE_SHIFT 16 /* 16(fix) */
+
+typedef struct {
+	KMIF_SOUND_DEVICE kmif;
+	KMIF_LOGTABLE *logtbl;
+	struct YMDELTATPCMSOUND_COMMON_TAG {
+		Int32 mastervolume;
+		Int32 step;
+		Int32 output;
+		Uint32 cnt;
+		Uint32 cps;
+		Uint32 phase;
+		Uint32 deltan;
+		Uint32 scale;
+		Uint32 mem;
+		Uint32 play;
+		Uint32 start;
+		Uint32 stop;
+		Int32 level32;
+		Uint8 key;
+		Uint8 level;
+		Uint8 granuality;
+		Uint8 pad4_3;
+		Uint8 regs[0x10];
+	} common;
+	Uint8 *romrambuf;
+	Uint32 romrammask;
+	Uint8 *rambuf;
+	Uint32 rammask;
+	Uint8 *rombuf;
+	Uint32 rommask;
+	Uint8 ymdeltatpcm_type;
+	Uint8 memshift;
+} YMDELTATPCMSOUND;
+
+const static Uint8 table_step[8] =
+{
+	  1,   3,   5,   7,   9,  11,  13,  15,
+};
+const static Uint8 table_scale[16] =
+{
+	 57,  57,  57,  57,  77, 102, 128, 153,
+	 57,  57,  57,  57,  77, 102, 128, 153,
+};
+
+__inline static void writeram(YMDELTATPCMSOUND *sndp, Uint32 v)
+{
+	sndp->rambuf[(sndp->common.mem >> 1) & sndp->rammask] = v;
+	sndp->common.mem += 1 << 1;
+}
+
+__inline static Uint32 readram(YMDELTATPCMSOUND *sndp)
+{
+	Uint32 v;
+	v = sndp->romrambuf[(sndp->common.play >> 1) & sndp->romrammask];
+	if (sndp->common.play & 1)
+		v &= 0x0F;
+	else
+		v >>= 4;
+	sndp->common.play += 1;
+	if (sndp->common.play >= sndp->common.stop)
+	{
+		if (sndp->common.regs[0] & 0x10)
+		{
+			sndp->common.play = sndp->common.start;
+			sndp->common.step = 0;
+			sndp->common.scale = 127;
+		}
+		else
+		{
+			sndp->common.key = 0;
+		}
+	}
+	return v;
+}
+
+__inline static void DelrtatStep(YMDELTATPCMSOUND *sndp, Uint32 data)
+{
+	if (data & 8)
+		sndp->common.step -= (table_step[data & 7] * sndp->common.scale) >> 3;
+	else
+		sndp->common.step += (table_step[data & 7] * sndp->common.scale) >> 3;
+	if (sndp->common.step > ((1 << 15) - 1)) sndp->common.step = ((1 << 15) - 1);
+	if (sndp->common.step < -(1 << 15)) sndp->common.step = -(1 << 15);
+	sndp->common.scale = (sndp->common.scale * table_scale[data]) >> 6;
+	if (sndp->common.scale > 24576) sndp->common.scale = 24576;
+	if (sndp->common.scale < 127) sndp->common.scale = 127;
+}
+
+#if (((-1) >> 1) == -1)
+#define SSR(x, y) (((Int32)x) >> (y))
+#else
+#define SSR(x, y) (((x) >= 0) ? ((x) >> (y)) : (-((-(x) - 1) >> (y)) - 1))
+#endif
+
+static int sndsynth(YMDELTATPCMSOUND *sndp )
+{
+	if (!sndp->common.key)
+		return 0;
+	{
+		Uint32 step;
+		sndp->common.cnt += sndp->common.cps;
+		step = sndp->common.cnt >> CPS_SHIFT;
+		sndp->common.cnt &= (1 << CPS_SHIFT) - 1;
+		sndp->common.phase += step * sndp->common.deltan;
+		step = sndp->common.phase >> PHASE_SHIFT;
+		sndp->common.phase &= (1 << PHASE_SHIFT) - 1;
+		if (step)
+		{
+			do
+			{
+				DelrtatStep(sndp, readram(sndp));
+			} while (--step);
+			sndp->common.output = sndp->common.step * sndp->common.level32;
+			sndp->common.output = SSR(sndp->common.output, 8 + 2);
+		}
+	}
+	return sndp->common.output;
+}
+
+
+
+static void sndwrite(YMDELTATPCMSOUND *sndp, Uint32 a, Uint32 v)
+{
+	sndp->common.regs[a] = v;
+	switch (a)
+	{
+		/* START,REC,MEMDATA,REPEAT,SPOFF,--,--,RESET */
+		case 0x00:  /* Control Register 1 */
+			if ((v & 0x80) && !sndp->common.key)
+			{
+				sndp->common.key = 1;
+				sndp->common.play = sndp->common.start;
+				sndp->common.step = 0;
+				sndp->common.scale = 127;
+			}
+			if (v & 1) sndp->common.key = 0;
+			break;
+		/* L,R,-,-,SAMPLE,DA/AD,RAMTYPE,ROM */
+		case 0x01:  /* Control Register 2 */
+			sndp->romrambuf  = (sndp->common.regs[1] & 1) ? sndp->rombuf  : sndp->rambuf;
+			sndp->romrammask = (sndp->common.regs[1] & 1) ? sndp->rommask : sndp->rammask;
+			break;
+		case 0x02:  /* Start Address L */
+		case 0x03:  /* Start Address H */
+			sndp->common.granuality = (v & 2) ? 1 : 4;
+			sndp->common.start = ((sndp->common.regs[3] << 8) + sndp->common.regs[2]) << (sndp->memshift + 1);
+			sndp->common.mem = sndp->common.start;
+			break;
+		case 0x04:  /* Stop Address L */
+		case 0x05:  /* Stop Address H */
+			sndp->common.stop = ((sndp->common.regs[5] << 8) + sndp->common.regs[4]) << (sndp->memshift + 1);
+			break;
+		case 0x06:  /* Prescale L */
+		case 0x07:  /* Prescale H */
+			break;
+		case 0x08:  /* Data */
+			if ((sndp->common.regs[0] & 0x60) == 0x60) writeram(sndp, v);
+			break;
+		case 0x09:  /* Delta-N L */
+		case 0x0A:  /* Delta-N H */
+			sndp->common.deltan = (sndp->common.regs[0xA] << 8) + sndp->common.regs[0x9];
+			if (sndp->common.deltan < 0x100) sndp->common.deltan = 0x100;
+			break;
+		case 0x0B:  /* Level Control */
+			sndp->common.level = v;
+			sndp->common.level32 = ((Int32)(sndp->common.level * LogToLin(sndp->logtbl, sndp->common.mastervolume, LOG_LIN_BITS - 15))) >> 7;
+			sndp->common.output = sndp->common.step * sndp->common.level32;
+			sndp->common.output = SSR(sndp->common.output, 8 + 2);
+			break;
+	}
+}
+
+static Uint32 sndread(YMDELTATPCMSOUND *sndp, Uint32 a)
+{
+	return 0;
+}
+
+static void sndreset(YMDELTATPCMSOUND *sndp, Uint32 clock, Uint32 freq)
+{
+	XMEMSET(&sndp->common, 0, sizeof(sndp->common));
+	sndp->common.cps = DivFix(clock, 72 * freq, CPS_SHIFT);
+	sndp->romrambuf  = (sndp->common.regs[1] & 1) ? sndp->rombuf  : sndp->rambuf;
+	sndp->romrammask = (sndp->common.regs[1] & 1) ? sndp->rommask : sndp->rammask;
+	sndp->common.granuality = 4;
+}
+
+static void sndvolume(YMDELTATPCMSOUND *sndp, Int32 volume)
+{
+	volume = (volume << (LOG_BITS - 8)) << 1;
+	sndp->common.mastervolume = volume;
+	sndp->common.level32 = ((Int32)(sndp->common.level * LogToLin(sndp->logtbl, sndp->common.mastervolume, LOG_LIN_BITS - 15))) >> 7;
+	sndp->common.output = sndp->common.step * sndp->common.level32;
+	sndp->common.output = SSR(sndp->common.output, 8 + 2);
+}
+
+static void sndrelease(YMDELTATPCMSOUND *sndp)
+{
+	if (sndp->logtbl) sndp->logtbl->release(sndp->logtbl->ctx);
+	XFREE(sndp);
+}
+
+static void setinst(YMDELTATPCMSOUND *sndp, Uint32 n, void *p, Uint32 l)
+{
+	if (n) return;
+	if (p)
+	{
+		sndp->rombuf  = (Uint8*) p;
+		sndp->rommask = l - 1;
+		sndp->romrambuf  = (sndp->common.regs[1] & 1) ? sndp->rombuf  : sndp->rambuf;
+		sndp->romrammask = (sndp->common.regs[1] & 1) ? sndp->rommask : sndp->rammask;
+	}
+	else
+	{
+		sndp->rombuf  = 0;
+		sndp->rommask = 0;
+	}
+
+}
+
+KMIF_SOUND_DEVICE *YMDELTATPCMSoundAlloc(Uint32 ymdeltatpcm_type)
+{
+	Uint32 ram_size;
+	YMDELTATPCMSOUND *sndp;
+	switch (ymdeltatpcm_type)
+	{
+		case YMDELTATPCM_TYPE_Y8950:
+			ram_size = 32 * 1024;
+			break;
+		case YMDELTATPCM_TYPE_YM2608:
+			ram_size = 256 * 1024;
+			break;
+		default:
+			ram_size = 0;
+			break;
+	}
+	sndp = (YMDELTATPCMSOUND*) XMALLOC(sizeof(YMDELTATPCMSOUND) + ram_size);
+	if (!sndp) return 0;
+	sndp->ymdeltatpcm_type = ymdeltatpcm_type;
+	switch (ymdeltatpcm_type)
+	{
+		case YMDELTATPCM_TYPE_Y8950:
+			sndp->memshift = 2;
+			break;
+		case YMDELTATPCM_TYPE_YM2608:
+			/* OPNA */
+			sndp->memshift = 6;
+			break;
+		case YMDELTATPCM_TYPE_YM2610:
+			sndp->memshift = 9;
+			break;
+	}
+	sndp->kmif.ctx = sndp;
+	sndp->kmif.release = (void (*)( void* )) sndrelease;
+	sndp->kmif.synth = (int (*)( void* )) sndsynth;
+	sndp->kmif.volume = (void (*)( void*, int )) sndvolume;
+	sndp->kmif.reset = (void (*)( void*, Uint32, Uint32 )) sndreset;
+	sndp->kmif.write = (void (*)( void*, Uint32, Uint32 )) sndwrite;
+	sndp->kmif.read = (Uint32 (*)( void*, Uint32 )) sndread;
+	sndp->kmif.setinst = (void (*)( void*, Uint32, void*, Uint32 )) setinst;
+	/* RAM */
+	sndp->rambuf = ram_size ? (Uint8 *)(sndp + 1) : 0;
+	sndp->rammask = ram_size ? (ram_size - 1) : 0;
+	/* ROM */
+	sndp->rombuf = 0;
+	sndp->rommask = 0;
+	sndp->logtbl = LogTableAddRef();
+	if (!sndp->logtbl)
+	{
+		sndrelease(sndp);
+		return 0;
+	}
+	return &sndp->kmif;
+}
diff -Nur orig/source/gme/src/s_deltat.h mod/source/gme/src/s_deltat.h
--- orig/source/gme/src/s_deltat.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_deltat.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef S_DELTAT_H__
+#define S_DELTAT_H__
+
+#include "kmsnddev.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum {
+	/* MSX-AUDIO   */ YMDELTATPCM_TYPE_Y8950,
+	/* OPNA ADPCM  */ YMDELTATPCM_TYPE_YM2608,
+	/* OPNB ADPCMB */ YMDELTATPCM_TYPE_YM2610
+};
+
+KMIF_SOUND_DEVICE *YMDELTATPCMSoundAlloc(Uint32 ymdeltatpcm_type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_DELTAT_H__ */
+
diff -Nur orig/source/gme/src/Sgc_Core.cpp mod/source/gme/src/Sgc_Core.cpp
--- orig/source/gme/src/Sgc_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sgc_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,108 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sgc_Core.h"
+
+/* Copyright (C) 2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void Sgc_Core::set_tempo( double t )
+{
+	set_play_period( clock_rate() / (header().rate ? 50 : 60) / int(t) );
+}
+
+blargg_err_t Sgc_Core::load_( Data_Reader& dr )
+{
+	RETURN_ERR( Sgc_Impl::load_( dr ) );
+	
+	if ( sega_mapping() && fm_apu_.supported() )
+		RETURN_ERR( fm_apu_.init( clock_rate(), clock_rate() / 72 ) );
+	
+	set_tempo( 1.0 );
+	return blargg_ok;
+}
+
+blargg_err_t Sgc_Core::start_track( int t )
+{
+	if ( sega_mapping() )
+	{
+		apu_.reset();
+		fm_apu_.reset();
+		fm_accessed = false;
+	}
+	else
+	{
+		apu_.reset( 0x0003, 15 );
+	}
+	
+	return Sgc_Impl::start_track( t );
+}
+
+blargg_err_t Sgc_Core::end_frame( time_t t )
+{
+	RETURN_ERR( Sgc_Impl::end_frame( t ) );
+	apu_.end_frame( t );
+	if ( sega_mapping() && fm_accessed )
+	{
+		if ( fm_apu_.supported() )
+			fm_apu_.end_frame( t );
+		else
+			set_warning( "FM sound not supported" );
+	}
+
+	return blargg_ok;
+}
+	
+Sgc_Core::Sgc_Core()
+{ }
+
+Sgc_Core::~Sgc_Core()
+{ }
+
+void Sgc_Core::cpu_out( time_t time, addr_t addr, int data )
+{
+	int port = addr & 0xFF;
+	
+	if ( sega_mapping() )
+	{
+		switch ( port )
+		{
+		case 0x06:
+			apu_.write_ggstereo( time, data );
+			return;
+		
+		case 0x7E:
+		case 0x7F:
+			apu_.write_data( time, data ); dprintf( "$7E<-%02X\n", data );
+			return;
+		
+		case 0xF0:
+			fm_accessed = true;
+			if ( fm_apu_.supported() )
+				fm_apu_.write_addr( data );//, dprintf( "$F0<-%02X\n", data );
+			return;
+		
+		case 0xF1:
+			fm_accessed = true;
+			if ( fm_apu_.supported() )
+				fm_apu_.write_data( time, data );//, dprintf( "$F1<-%02X\n", data );
+			return;
+		}
+	}
+	else if ( port >= 0xE0 )
+	{
+		apu_.write_data( time, data );
+		return;
+	}
+	
+	Sgc_Impl::cpu_out( time, addr, data );
+}
diff -Nur orig/source/gme/src/Sgc_Core.h mod/source/gme/src/Sgc_Core.h
--- orig/source/gme/src/Sgc_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sgc_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,44 @@
+// Sega/Game Gear/Coleco SGC music file emulator core
+
+// Game_Music_Emu 0.6-pre
+#ifndef SGC_CORE_H
+#define SGC_CORE_H
+
+#include "Sgc_Impl.h"
+#include "Sms_Fm_Apu.h"
+#include "Sms_Apu.h"
+
+class Sgc_Core : public Sgc_Impl {
+public:
+	
+	// Adjusts music tempo, where 1.0 is normal. Can be changed while playing.
+	// Resets to 1.0 when loading file.
+	void set_tempo( double );
+	
+	// Starts track, where 0 is the first.
+	blargg_err_t start_track( int );
+	
+	// Ends time frame at time t
+	blargg_err_t end_frame( time_t t );
+	
+	// SN76489 sound chip
+	Sms_Apu& apu()                  { return apu_; }
+	Sms_Fm_Apu& fm_apu()            { return fm_apu_; }
+	
+protected:
+	// Overrides
+	virtual void cpu_out( time_t, addr_t, int data );
+	virtual blargg_err_t load_( Data_Reader& );
+
+// Implementation
+public:
+	Sgc_Core();
+	~Sgc_Core();
+
+private:
+	bool fm_accessed;
+	Sms_Apu apu_;
+	Sms_Fm_Apu fm_apu_;
+};
+
+#endif
diff -Nur orig/source/gme/src/Sgc_Cpu.cpp mod/source/gme/src/Sgc_Cpu.cpp
--- orig/source/gme/src/Sgc_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sgc_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,36 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sgc_Impl.h"
+
+#include "blargg_endian.h"
+//#include "z80_cpu_log.h"
+
+/* Copyright (C) 2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#define OUT_PORT(  addr, data ) cpu_out( TIME(), addr, data )
+#define IN_PORT(   addr       ) cpu_in( addr )
+#define WRITE_MEM( addr, data ) cpu_write( addr, data )
+#define IDLE_ADDR               idle_addr
+#define CPU                     cpu
+#define RST_BASE                vectors_addr
+
+#define CPU_BEGIN \
+bool Sgc_Impl::run_cpu( time_t end_time )\
+{\
+	cpu.set_end_time( end_time );
+
+	#include "Z80_Cpu_run.h"
+	
+	return warning;
+}
diff -Nur orig/source/gme/src/Sgc_Emu.cpp mod/source/gme/src/Sgc_Emu.cpp
--- orig/source/gme/src/Sgc_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sgc_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,136 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sgc_Emu.h"
+
+/* Copyright (C) 2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const osc_count = Sms_Apu::osc_count + Sms_Fm_Apu::osc_count;
+
+Sgc_Emu::Sgc_Emu()
+{
+	set_type( gme_sgc_type );
+	set_silence_lookahead( 6 );
+	set_gain( 1.2 );
+}
+
+Sgc_Emu::~Sgc_Emu() { }
+
+void Sgc_Emu::unload()
+{
+	core_.unload();
+	Music_Emu::unload();
+}
+
+// Track info
+
+static void copy_sgc_fields( Sgc_Emu::header_t const& h, track_info_t* out )
+{
+	GME_COPY_FIELD( h, out, game );
+	GME_COPY_FIELD( h, out, author );
+	GME_COPY_FIELD( h, out, copyright );
+}
+
+blargg_err_t Sgc_Emu::track_info_( track_info_t* out, int ) const
+{
+	copy_sgc_fields( header(), out );
+	return blargg_ok;
+}
+
+struct Sgc_File : Gme_Info_
+{
+	Sgc_Emu::header_t h;
+	
+	Sgc_File() { set_type( gme_sgc_type ); }
+	
+	blargg_err_t load_( Data_Reader& in )
+	{
+		blargg_err_t err = in.read( &h, h.size );
+		if ( err )
+			return (blargg_is_err_type( err, blargg_err_file_eof ) ? blargg_err_file_type : err);
+		
+		set_track_count( h.song_count );
+		if ( !h.valid_tag() )
+			return blargg_err_file_type;
+		
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		copy_sgc_fields( h, out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_sgc_emu () { return BLARGG_NEW Sgc_Emu ; }
+static Music_Emu* new_sgc_file() { return BLARGG_NEW Sgc_File; }
+
+gme_type_t_ const gme_sgc_type [1] = {{ "Z80 PSG", 0, &new_sgc_emu, &new_sgc_file, "SGC", 1 }};
+
+// Setup
+
+blargg_err_t Sgc_Emu::load_( Data_Reader& in )
+{
+	RETURN_ERR( core_.load( in ) );
+	set_warning( core_.warning() );
+	set_track_count( header().song_count );
+	set_voice_count( core_.sega_mapping() ? osc_count : core_.apu().osc_count );
+	
+	core_.apu   ().volume( gain() );
+	core_.fm_apu().volume( gain() );
+	
+	static const char* const names [osc_count + 1] = {
+		"Square 1", "Square 2", "Square 3", "Noise", "FM"
+	};
+	set_voice_names( names );
+	
+	static int const types [osc_count + 1] = {
+		wave_type+1, wave_type+2, wave_type+3, mixed_type+1, mixed_type+2
+	};
+	set_voice_types( types );
+	
+	return setup_buffer( core_.clock_rate() );
+}
+
+void Sgc_Emu::update_eq( blip_eq_t const& eq )
+{
+	core_.apu   ().treble_eq( eq );
+	core_.fm_apu().treble_eq( eq );
+}
+
+void Sgc_Emu::set_voice( int i, Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	if ( i < core_.apu().osc_count )
+		core_.apu().set_output( i, c, l, r );
+	else
+		core_.fm_apu().set_output( c, l, r );
+}
+
+void Sgc_Emu::set_tempo_( double t )
+{
+	core_.set_tempo( t );
+}
+
+blargg_err_t Sgc_Emu::start_track_( int track )
+{
+	RETURN_ERR( core_.start_track( track ) );
+	return Classic_Emu::start_track_( track );
+}
+
+blargg_err_t Sgc_Emu::run_clocks( blip_time_t& duration, int )
+{
+	RETURN_ERR( core_.end_frame( duration ) );
+	set_warning( core_.warning() );
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Sgc_Emu.h mod/source/gme/src/Sgc_Emu.h
--- orig/source/gme/src/Sgc_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sgc_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,43 @@
+// Sega/Game Gear/Coleco SGC music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef SGC_EMU_H
+#define SGC_EMU_H
+
+#include "Classic_Emu.h"
+#include "Sgc_Core.h"
+
+class Sgc_Emu : public Classic_Emu {
+public:
+	// SGC file header (see Sgc_Impl.h)
+	typedef Sgc_Core::header_t header_t;
+	
+	// Header for currently loaded file
+	header_t const& header() const              { return core_.header(); }
+	
+	// Sets 0x2000-byte Coleco BIOS. Necessary to play Coleco tracks.
+	static void set_coleco_bios( void const* p ){ Sgc_Core::set_coleco_bios( p ); }
+	
+	static gme_type_t static_type()             { return gme_sgc_type; }
+	
+// Internal
+public:
+	Sgc_Emu();
+	~Sgc_Emu();
+
+protected:
+	// Classic_Emu overrides
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t load_( Data_Reader& );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+	virtual void unload();
+	
+private:
+	Sgc_Core core_;
+};
+
+#endif
diff -Nur orig/source/gme/src/Sgc_Impl.cpp mod/source/gme/src/Sgc_Impl.cpp
--- orig/source/gme/src/Sgc_Impl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sgc_Impl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,225 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Sgc_Impl.h"
+
+/* Copyright (C) 2006-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void const* Sgc_Impl::coleco_bios;
+
+Sgc_Impl::Sgc_Impl() :
+	rom( bank_size )
+{
+	assert( offsetof (header_t,copyright [32]) == header_t::size );
+}
+
+Sgc_Impl::~Sgc_Impl()
+{ }
+
+bool Sgc_Impl::header_t::valid_tag() const
+{
+	return 0 == memcmp( tag, "SGC\x1A", 4 );
+}
+
+blargg_err_t Sgc_Impl::load_( Data_Reader& in )
+{
+	RETURN_ERR( rom.load( in, header_.size, &header_, 0 ) );
+	
+	if ( !header_.valid_tag() )
+		return blargg_err_file_type;
+	
+	if ( header_.vers != 1 )
+		set_warning( "Unknown file version" );
+	
+	if ( header_.system > 2 )
+		set_warning( "Unknown system" );
+	
+	addr_t load_addr = get_le16( header_.load_addr );
+	if ( load_addr < 0x400 )
+		set_warning( "Invalid load address" );
+	
+	rom.set_addr( load_addr );
+	play_period = clock_rate() / 60;
+	
+	if ( sega_mapping() )
+	{
+		RETURN_ERR( ram.resize( 0x2000 + Sgc_Cpu::page_padding ) );
+		RETURN_ERR( ram2.resize( bank_size + Sgc_Cpu::page_padding ) );
+	}
+	else
+	{
+		RETURN_ERR( ram.resize( 0x400 + Sgc_Cpu::page_padding ) );
+	}
+	
+	RETURN_ERR( vectors.resize( Sgc_Cpu::page_size + Sgc_Cpu::page_padding ) );
+	
+	// TODO: doesn't need to be larger than page size, if we do mapping calls right
+	RETURN_ERR( unmapped_write.resize( bank_size ) );
+	
+	return blargg_ok;
+}
+
+void Sgc_Impl::unload()
+{
+	rom.clear();
+	vectors.clear();
+	ram.clear();
+	ram2.clear();
+	unmapped_write.clear();
+	Gme_Loader::unload();
+}
+
+blargg_err_t Sgc_Impl::start_track( int track )
+{
+	memset( ram .begin(), 0, ram .size() );
+	memset( ram2.begin(), 0, ram2.size() );
+	memset( vectors.begin(), 0xFF, vectors.size() );
+	cpu.reset( unmapped_write.begin(), rom.unmapped() );
+	
+	if ( sega_mapping() )
+	{
+		vectors_addr = 0x10000 - Sgc_Cpu::page_size;
+		idle_addr = vectors_addr;
+		for ( int i = 1; i < 8; ++i )
+		{
+			vectors [i*8 + 0] = 0xC3; // JP addr
+			vectors [i*8 + 1] = header_.rst_addrs [i*2 + 0];
+			vectors [i*8 + 2] = header_.rst_addrs [i*2 + 1];
+		}
+		
+		cpu.map_mem( 0xC000, 0x2000, ram.begin() );
+		cpu.map_mem( vectors_addr, cpu.page_size, unmapped_write.begin(), vectors.begin() );
+		
+		bank2 = NULL;
+		for ( int i = 0; i < 4; ++i )
+			cpu_write( 0xFFFC + i, header_.mapping [i] );
+	}
+	else
+	{
+		if ( !coleco_bios )
+			return BLARGG_ERR( BLARGG_ERR_CALLER, "Coleco BIOS not set" );
+		
+		vectors_addr = 0;
+		cpu.map_mem( 0, 0x2000, unmapped_write.begin(), coleco_bios );
+		for ( int i = 0; i < 8; ++i )
+			cpu.map_mem( 0x6000 + i*0x400, 0x400, ram.begin() );
+		
+		idle_addr = 0x2000;
+		cpu.map_mem( 0x2000, cpu.page_size, unmapped_write.begin(), vectors.begin() );
+		
+		for ( int i = 0; i < 0x8000 / bank_size; ++i )
+		{
+			int addr = 0x8000 + i*bank_size;
+			cpu.map_mem( addr, bank_size, unmapped_write.begin(), rom.at_addr( addr ) );
+		}
+	}
+	
+	cpu.r.sp  = get_le16( header_.stack_ptr );
+	cpu.r.b.a = track;
+	next_play = play_period;
+	
+	jsr( header_.init_addr );
+	
+	return blargg_ok;
+}
+
+// Emulation
+
+void Sgc_Impl::jsr( byte const (&addr) [2] )
+{
+	*cpu.write( --cpu.r.sp ) = idle_addr >> 8;
+	*cpu.write( --cpu.r.sp ) = idle_addr & 0xFF;
+	cpu.r.pc = get_le16( addr );
+}
+
+void Sgc_Impl::set_bank( int bank, void const* data )
+{
+	//dprintf( "map bank %d to %p\n", bank, (byte*) data - rom.at_addr( 0 ) );
+	cpu.map_mem( bank * bank_size, bank_size, unmapped_write.begin(), data );
+}
+
+void Sgc_Impl::cpu_write( addr_t addr, int data )
+{
+	if ( (addr ^ 0xFFFC) > 3 || !sega_mapping() )
+	{
+		*cpu.write( addr ) = data;
+		return;
+	}
+	
+	switch ( addr )
+	{
+	case 0xFFFC:
+		cpu.map_mem( 2 * bank_size, bank_size, ram2.begin() );
+		if ( data & 0x08 )
+			break;
+		
+		bank2 = ram2.begin();
+		// FALL THROUGH
+	
+	case 0xFFFF: {
+		bool rom_mapped = (cpu.read( 2 * bank_size ) == bank2);
+		bank2 = rom.at_addr( data * bank_size );
+		if ( rom_mapped )
+			set_bank( 2, bank2 );
+		break;
+	}
+		
+	case 0xFFFD:
+		set_bank( 0, rom.at_addr( data * bank_size ) );
+		break;
+	
+	case 0xFFFE:
+		set_bank( 1, rom.at_addr( data * bank_size ) );
+		break;
+	}
+}
+
+int Sgc_Impl::cpu_in( addr_t addr )
+{
+	dprintf( "in %02X\n", addr );
+	return 0;
+}
+	
+void Sgc_Impl::cpu_out( time_t, addr_t addr, int )
+{
+	dprintf( "out %02X\n", addr & 0xFF );
+}
+
+blargg_err_t Sgc_Impl::end_frame( time_t end )
+{
+	while ( cpu.time() < end )
+	{
+		time_t next = min( end, next_play );
+		if ( run_cpu( next ) )
+		{
+			set_warning( "Unsupported CPU instruction" );
+			cpu.set_time( next );
+		}
+		
+		if ( cpu.r.pc == idle_addr )
+			cpu.set_time( next );
+		
+		if ( cpu.time() >= next_play )
+		{
+			next_play += play_period;
+			if ( cpu.r.pc == idle_addr )
+				jsr( header_.play_addr );
+		}
+	}
+	
+	next_play -= end;
+	check( next_play >= 0 );
+	cpu.adjust_time( -end );
+	
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Sgc_Impl.h mod/source/gme/src/Sgc_Impl.h
--- orig/source/gme/src/Sgc_Impl.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sgc_Impl.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,114 @@
+// Sega/Game Gear/Coleco SGC music file emulator implementation internals
+
+// Game_Music_Emu 0.6-pre
+#ifndef SGC_IMPL_H
+#define SGC_IMPL_H
+
+#include "Gme_Loader.h"
+#include "Rom_Data.h"
+#include "Z80_Cpu.h"
+
+class Sgc_Impl : public Gme_Loader {
+public:
+	
+	// SGC file header
+	struct header_t
+	{
+		enum { size = 0xA0 };
+		
+		char tag       [4]; // "SGC\x1A"
+		byte vers;          // 0x01
+		byte rate;          // 0=NTSC 1=PAL
+		byte reserved1 [2];
+		byte load_addr [2];
+		byte init_addr [2];
+		byte play_addr [2];
+		byte stack_ptr [2];
+		byte reserved2 [2];
+		byte rst_addrs [7*2];
+		byte mapping   [4]; // Used by Sega only
+		byte first_song;    // Song to start playing first
+		byte song_count;
+		byte first_effect;
+		byte last_effect;
+		byte system;        // 0=Master System 1=Game Gear 2=Colecovision
+		byte reserved3 [23];
+		char game      [32]; // strings can be 32 chars, NOT terminated
+		char author    [32];
+		char copyright [32];
+		
+		// True if header has valid file signature
+		bool valid_tag() const;
+		
+		int effect_count() const        { return last_effect ? last_effect - first_effect + 1 : 0; }
+	};
+	
+	// Header for currently loaded file
+	header_t const& header() const                  { return header_; }
+	
+	int clock_rate() const                          { return header_.rate ? 3546893 : 3579545; }
+	
+	// 0x2000 bytes
+	static void set_coleco_bios( void const* p )    { coleco_bios = p; }
+	
+	// Clocks between calls to play routine
+	typedef int time_t;
+	void set_play_period( time_t p )                { play_period = p; }
+	
+	// 0 = first track
+	blargg_err_t start_track( int );
+	
+	// Runs for t clocks
+	blargg_err_t end_frame( time_t t );
+	
+	// True if Master System or Game Gear
+	bool sega_mapping() const;
+	
+protected:
+	typedef Z80_Cpu Sgc_Cpu;
+	Sgc_Cpu cpu;
+	
+	typedef int addr_t;
+	virtual void cpu_out( time_t, addr_t, int data ) BLARGG_PURE( ; )
+
+// Implementation
+public:
+	Sgc_Impl();
+	~Sgc_Impl();
+	virtual void unload();
+
+protected:
+	virtual blargg_err_t load_( Data_Reader& );
+
+private:
+	enum { bank_size = 0x4000 };
+	
+	Rom_Data rom;
+	time_t play_period;
+	time_t next_play;
+	void const* bank2;      // ROM selected for bank 2, in case RAM is currently hiding it
+	addr_t vectors_addr;    // RST vectors start here
+	addr_t idle_addr;       // return address for init/play routines
+	static void const* coleco_bios;
+	
+	// large items
+	header_t header_;
+	blargg_vector<byte> vectors;
+	blargg_vector<byte> ram;
+	blargg_vector<byte> ram2;
+	blargg_vector<byte> unmapped_write;
+	
+	bool run_cpu( time_t end );
+	void jsr( byte const (&addr) [2] );
+	void cpu_write( addr_t, int data );
+	int  cpu_in(  addr_t );
+	
+	void set_bank( int bank, void const* data );
+};
+
+inline bool Sgc_Impl::sega_mapping() const
+{
+	return header_.system <= 1;
+}
+
+#endif
diff -Nur orig/source/gme/src/s_logtbl.c mod/source/gme/src/s_logtbl.c
--- orig/source/gme/src/s_logtbl.c	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_logtbl.c	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,88 @@
+#include "nestypes.h"
+#include "s_logtbl.h"
+
+#if STATIC_TABLES
+
+static void LogTableRelease(void *ctx)
+{
+}
+
+static KMIF_LOGTABLE log_static_tables = {
+	&log_static_tables;
+	LogTableRelease,
+#include "s_logt.h"
+};
+
+
+KMIF_LOGTABLE *LogTableAddRef(void)
+{
+	log_static_tables.release = LogTableRelease;
+	return &log_static_tables;
+}
+
+#else
+
+#include <math.h>
+
+static volatile Uint32 log_tables_mutex = 0;
+static Uint32 log_tables_refcount = 0;
+static KMIF_LOGTABLE *log_tables = 0;
+
+static void LogTableRelease(void *ctx)
+{
+	++log_tables_mutex;
+	while (log_tables_mutex != 1)
+	{
+		XSLEEP(0);
+	}
+	log_tables_refcount--;
+	if (!log_tables_refcount)
+	{
+		XFREE(ctx);
+		log_tables = 0;
+	}
+	--log_tables_mutex;
+}
+
+static void LogTableCalc(KMIF_LOGTABLE *kmif_lt)
+{
+	Uint32 i;
+	double a;
+	for (i = 0; i < (1 << LOG_BITS); i++)
+	{
+		a = (1 << LOG_LIN_BITS) / pow(2, i / (double)(1 << LOG_BITS));
+		kmif_lt->logtbl[i] = (Uint32)a;
+	}
+	kmif_lt->lineartbl[0] = LOG_LIN_BITS << LOG_BITS;
+	for (i = 1; i < (1 << LIN_BITS) + 1; i++)
+	{
+		Uint32 ua;
+		a = i << (LOG_LIN_BITS - LIN_BITS);
+		ua = (Uint32)((LOG_LIN_BITS - (log(a) / log(2))) * (1 << LOG_BITS));
+		kmif_lt->lineartbl[i] = ua << 1;
+	}
+}
+
+KMIF_LOGTABLE *LogTableAddRef(void)
+{
+	++log_tables_mutex;
+	while (log_tables_mutex != 1)
+	{
+		XSLEEP(0);
+	}
+	if (!log_tables_refcount)
+	{
+		log_tables = (KMIF_LOGTABLE*) XMALLOC(sizeof(KMIF_LOGTABLE));
+		if (log_tables)
+		{
+			log_tables->ctx = log_tables;
+			log_tables->release = LogTableRelease;
+			LogTableCalc(log_tables);
+		}
+	}
+	if (log_tables) log_tables_refcount++;
+	--log_tables_mutex;
+	return log_tables;
+}
+
+#endif
diff -Nur orig/source/gme/src/s_logtbl.h mod/source/gme/src/s_logtbl.h
--- orig/source/gme/src/s_logtbl.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_logtbl.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,43 @@
+#ifndef S_LOGTBL_H__
+#define S_LOGTBL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LOG_BITS 12
+#define LIN_BITS 7
+#define LOG_LIN_BITS 30
+
+typedef struct
+{
+	void *ctx;
+	void (*release)(void *ctx);
+	Uint32 lineartbl[(1 << LIN_BITS) + 1];
+	Uint32 logtbl[1 << LOG_BITS];
+} KMIF_LOGTABLE;
+
+KMIF_LOGTABLE *LogTableAddRef(void);
+
+__inline static Uint32 LinToLog(KMIF_LOGTABLE *kmif_lt, Int32 l)
+{
+	return (l < 0) ? (kmif_lt->lineartbl[-l] + 1) : kmif_lt->lineartbl[l];
+}
+
+__inline static Int32 LogToLin(KMIF_LOGTABLE *kmif_lt, Int32 l, Uint32 sft)
+{
+	Int32 ret;
+	Uint32 ofs;
+	ofs = l + (sft << (LOG_BITS + 1));
+	sft = ofs >> (LOG_BITS + 1);
+	if (sft >= LOG_LIN_BITS) return 0;
+	ofs = (ofs >> 1) & ((1 << LOG_BITS) - 1);
+	ret = kmif_lt->logtbl[ofs] >> sft;
+	return (l & 1) ? -ret : ret;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_LOGTBL_H__ */
diff -Nur orig/source/gme/src/Sms_Apu.cpp mod/source/gme/src/Sms_Apu.cpp
--- orig/source/gme/src/Sms_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sms_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,371 @@
+// Sms_Snd_Emu 0.1.1. http://www.slack.net/~ant/
+
+#include "Sms_Apu.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const noise_osc = 3;
+
+void Sms_Apu::volume( double vol )
+{
+	vol *= 0.85 / osc_count / 64;
+	norm_synth.volume( vol );
+	fast_synth.volume( vol );
+}
+
+void Sms_Apu::treble_eq( blip_eq_t const& eq )
+{
+	norm_synth.treble_eq( eq );
+	fast_synth.treble_eq( eq );
+}
+
+inline int Sms_Apu::calc_output( int i ) const
+{
+	int flags = ggstereo >> i;
+	return (flags >> 3 & 2) | (flags & 1);
+}
+
+void Sms_Apu::set_output( int i, Blip_Buffer* center, Blip_Buffer* left, Blip_Buffer* right )
+{
+	// Must be silent (all NULL), mono (left and right NULL), or stereo (none NULL)
+	require( !center || (center && !left && !right) || (center && left && right) );
+	require( (unsigned) i < osc_count ); // fails if you pass invalid osc index
+	
+	if ( center )
+	{
+		unsigned const divisor = 16384 * 16 * 2;
+		min_tone_period = ((unsigned) center->clock_rate() + divisor/2) / divisor;
+	}
+	
+	if ( !center || !left || !right )
+	{
+		left  = center;
+		right = center;
+	}
+	
+	Osc& o = oscs [i];
+	o.outputs [0] = NULL;
+	o.outputs [1] = right;
+	o.outputs [2] = left;
+	o.outputs [3] = center;
+	o.output = o.outputs [calc_output( i )];
+}
+
+void Sms_Apu::set_output( Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	for ( int i = osc_count; --i >= 0; )
+		set_output( i, c, l, r );
+}
+
+static inline unsigned fibonacci_to_galois_lfsr( unsigned fibonacci, int width )
+{
+	unsigned galois = 0;
+	while ( --width >= 0 )
+	{
+		galois = (galois << 1) | (fibonacci & 1);
+		fibonacci >>= 1;
+	}
+	return galois;
+}
+
+void Sms_Apu::reset( unsigned feedback, int noise_width )
+{
+	last_time = 0;
+	latch     = 0;
+	ggstereo  = 0;
+	
+	// Calculate noise feedback values
+	if ( !feedback || !noise_width )
+	{
+		feedback    = 0x0009;
+		noise_width = 16;
+	}
+	looped_feedback = 1 << (noise_width - 1);
+	noise_feedback  = fibonacci_to_galois_lfsr( feedback, noise_width );
+	
+	// Reset oscs
+	for ( int i = osc_count; --i >= 0; )
+	{
+		Osc& o = oscs [i];
+		o.output   =  NULL;
+		o.last_amp =  0;
+		o.delay    =  0;
+		o.phase    =  0;
+		o.period   =  0;
+		o.volume   = 15; // silent
+	}
+	
+	oscs [noise_osc].phase = 0x8000;
+	write_ggstereo( 0, 0xFF );
+}
+
+Sms_Apu::Sms_Apu()
+{
+	min_tone_period = 7;
+	
+	// Clear outputs to NULL FIRST
+	ggstereo = 0;
+	set_output( NULL );
+	
+	volume( 1.0 );
+	reset();
+}
+
+void Sms_Apu::run_until( blip_time_t end_time )
+{
+	require( end_time >= last_time );
+	if ( end_time <= last_time )
+		return;
+	
+	// Synthesize each oscillator
+	for ( int idx = osc_count; --idx >= 0; )
+	{
+		Osc& osc = oscs [idx];
+		int vol  = 0;
+		int amp  = 0;
+		
+		// Determine what will be generated
+		Blip_Buffer* const out = osc.output;
+		if ( out )
+		{
+			// volumes [i] ~= 64 * pow( 1.26, 15 - i ) / pow( 1.26, 15 )
+			static unsigned char const volumes [16] = {
+				64, 50, 40, 32, 25, 20, 16, 13, 10, 8, 6, 5, 4, 3, 2, 0
+			};
+			
+			vol = volumes [osc.volume];
+			amp = (osc.phase & 1) * vol;
+			
+			// Square freq above 16 kHz yields constant amplitude at half volume
+			if ( idx != noise_osc && osc.period < min_tone_period )
+			{
+				amp = vol >> 1;
+				vol = 0;
+			}
+			
+			// Update amplitude
+			int delta = amp - osc.last_amp;
+			if ( delta )
+			{
+				osc.last_amp = amp;
+				norm_synth.offset( last_time, delta, out );
+				out->set_modified();
+			}
+		}
+		
+		// Generate wave
+		blip_time_t time = last_time + osc.delay;
+		if ( time < end_time )
+		{
+			// Calculate actual period
+			int period = osc.period;
+			if ( idx == noise_osc )
+			{
+				period = 0x20 << (period & 3);
+				if ( period == 0x100 )
+					period = oscs [2].period * 2;
+			}
+			period *= 0x10;
+			if ( !period )
+				period = 0x10;
+			
+			// Maintain phase when silent
+			int phase = osc.phase;
+			if ( !vol )
+			{
+				int count = (end_time - time + period - 1) / period;
+				time += count * period;
+				if ( idx != noise_osc ) // TODO: maintain noise LFSR phase?
+					phase ^= count & 1;
+			}
+			else
+			{
+				int delta = amp * 2 - vol;
+				
+				if ( idx != noise_osc )
+				{
+					// Square
+					do
+					{
+						delta = -delta;
+						norm_synth.offset( time, delta, out );
+						time += period;
+					}
+					while ( time < end_time );
+					phase = (delta >= 0);
+				}
+				else
+				{
+					// Noise
+					unsigned const feedback = (osc.period & 4 ? noise_feedback : looped_feedback);
+					do
+					{
+						unsigned changed = phase + 1;
+						phase = ((phase & 1) * feedback) ^ (phase >> 1);
+						if ( changed & 2 ) // true if bits 0 and 1 differ
+						{
+							delta = -delta;
+							fast_synth.offset_inline( time, delta, out );
+						}
+						time += period;
+					}
+					while ( time < end_time );
+					check( phase );
+				}
+				osc.last_amp = (phase & 1) * vol;
+				out->set_modified();
+			}
+			osc.phase = phase;
+		}
+		osc.delay = time - end_time;
+	}
+	last_time = end_time;
+}
+
+void Sms_Apu::write_ggstereo( blip_time_t time, int data )
+{
+	require( (unsigned) data <= 0xFF );
+	
+	run_until( time );
+	ggstereo = data;
+	
+	for ( int i = osc_count; --i >= 0; )
+	{
+		Osc& osc = oscs [i];
+		
+		Blip_Buffer* old = osc.output;
+		osc.output = osc.outputs [calc_output( i )];
+		if ( osc.output != old )
+		{
+			int delta = -osc.last_amp;
+			if ( delta )
+			{
+				osc.last_amp = 0;
+				if ( old )
+				{
+					old->set_modified();
+					fast_synth.offset( last_time, delta, old );
+				}
+			}
+		}
+	}
+}
+
+void Sms_Apu::write_data( blip_time_t time, int data )
+{
+	require( (unsigned) data <= 0xFF );
+	
+	run_until( time );
+	
+	if ( data & 0x80 )
+		latch = data;
+	
+	// We want the raw values written so our save state format can be
+	// as close to hardware as possible and unspecific to any emulator.
+	int idx = latch >> 5 & 3;
+	Osc& osc = oscs [idx];
+	if ( latch & 0x10 )
+	{
+		osc.volume = data & 0x0F;
+	}
+	else
+	{
+		if ( idx == noise_osc )
+			osc.phase = 0x8000; // reset noise LFSR
+		
+		// Replace high 6 bits/low 4 bits of register with data
+		int lo = osc.period;
+		int hi = data << 4;
+		if ( idx == noise_osc || (data & 0x80) )
+		{
+			hi = lo;
+			lo = data;
+		}
+		osc.period = (hi & 0x3F0) | (lo & 0x00F);
+	}
+}
+
+void Sms_Apu::end_frame( blip_time_t end_time )
+{
+	if ( end_time > last_time )
+		run_until( end_time );
+	
+	last_time -= end_time;
+	assert( last_time >= 0 );
+}
+
+#if SMS_APU_CUSTOM_STATE
+	#define REFLECT( x, y ) (save ?       (io->y) = (x) :         (x) = (io->y)          )
+#else
+	#define REFLECT( x, y ) (save ? set_val( io->y, x ) : (void) ((x) = get_val( io->y )))
+	
+	static unsigned get_val( byte const p [] )
+	{
+		return  p [3] * 0x1000000 + p [2] * 0x10000 + p [1] * 0x100 + p [0];
+	}
+
+	static void set_val( byte p [], unsigned n )
+	{
+		p [0] = (byte) (n      );
+		p [1] = (byte) (n >>  8);
+		p [2] = (byte) (n >> 16);
+		p [3] = (byte) (n >> 24);
+	}
+#endif
+
+inline const char* Sms_Apu::save_load( sms_apu_state_t* io, bool save )
+{
+	#if !SMS_APU_CUSTOM_STATE
+		assert( sizeof (sms_apu_state_t) == 128 );
+	#endif
+	
+	// Format of data, where later format is incompatible with earlier
+	int format = io->format0;
+	REFLECT( format, format );
+	if ( format != io->format0 )
+		return "Unsupported sound save state format";
+	
+	// Version of data, where later versions just add fields to the end
+	int version = 0;
+	REFLECT( version, version );
+	
+	REFLECT( latch,    latch    );
+	REFLECT( ggstereo, ggstereo );
+	
+	for ( int i = osc_count; --i >= 0; )
+	{
+		Osc& osc = oscs [i];
+		REFLECT( osc.period, periods [i] );
+		REFLECT( osc.volume, volumes [i] );
+		REFLECT( osc.delay,  delays  [i] );
+		REFLECT( osc.phase,  phases  [i] );
+	}
+	
+	return 0;
+}
+
+void Sms_Apu::save_state( sms_apu_state_t* out )
+{
+	save_load( out, true );
+	#if !SMS_APU_CUSTOM_STATE
+		memset( out->unused, 0, sizeof out->unused );
+	#endif
+}
+
+blargg_err_t Sms_Apu::load_state( sms_apu_state_t const& in )
+{
+	RETURN_ERR( save_load( CONST_CAST(sms_apu_state_t*,&in), false ) );
+	write_ggstereo( 0, ggstereo );
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Sms_Apu.h mod/source/gme/src/Sms_Apu.h
--- orig/source/gme/src/Sms_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sms_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,128 @@
+// Sega Master System SN76489 PSG sound chip emulator
+
+// Sms_Snd_Emu 0.1.2
+#ifndef SMS_APU_H
+#define SMS_APU_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+struct sms_apu_state_t;
+
+class Sms_Apu {
+public:
+// Basics
+
+	// Sets buffer(s) to generate sound into, or 0 to mute. If only center is not 0,
+	// output is mono.
+	void set_output( Blip_Buffer* center, Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+
+	// Emulates to time t, then writes data to Game Gear left/right assignment byte
+	void write_ggstereo( blip_time_t t, int data );
+	
+	// Emulates to time t, then writes data
+	void write_data( blip_time_t t, int data );
+	
+	// Emulates to time t, then subtracts t from the current time.
+	// OK if previous write call had time slightly after t.
+	void end_frame( blip_time_t t );
+
+// More features
+
+	// Resets sound chip and sets noise feedback bits and width
+	void reset( unsigned noise_feedback = 0, int noise_width = 0 );
+	
+	// Same as set_output(), but for a particular channel
+	// 0: Square 1, 1: Square 2, 2: Square 3, 3: Noise
+	enum { osc_count = 4 }; // 0 <= chan < osc_count
+	void set_output( int chan, Blip_Buffer* center, Blip_Buffer* left = NULL, Blip_Buffer* right = NULL );
+	
+	// Sets overall volume, where 1.0 is normal
+	void volume( double );
+	
+	// Sets treble equalization
+	void treble_eq( blip_eq_t const& );
+	
+	// Saves full emulation state to state_out. Data format is portable and
+	// includes some extra space to avoid expansion in case more state needs
+	// to be stored in the future.
+	void save_state( sms_apu_state_t* state_out );
+	
+	// Loads state. You should call reset() BEFORE this.
+	blargg_err_t load_state( sms_apu_state_t const& in );
+
+private:
+	// noncopyable
+	Sms_Apu( const Sms_Apu& );
+	Sms_Apu& operator = ( const Sms_Apu& );
+
+// Implementation
+public:
+	Sms_Apu();
+	~Sms_Apu() { }
+	BLARGG_DISABLE_NOTHROW
+	
+	// Use set_output() instead
+	BLARGG_DEPRECATED( void output    (        Blip_Buffer* c                                 ) { set_output( c, c, c    ); } )
+	BLARGG_DEPRECATED( void output    (        Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r ) { set_output( c, l, r    ); } )
+	BLARGG_DEPRECATED( void osc_output( int i, Blip_Buffer* c                                 ) { set_output( i, c, c, c ); } )
+	BLARGG_DEPRECATED( void osc_output( int i, Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r ) { set_output( i, c, l, r ); } )
+
+private:
+	struct Osc
+	{
+		Blip_Buffer* outputs [4]; // NULL, right, left, center
+		Blip_Buffer* output;
+		int          last_amp;
+		
+		int         volume;
+		int         period;
+		int         delay;
+		unsigned    phase;
+	};
+	
+	Osc     oscs [osc_count];
+	int     ggstereo;
+	int     latch;
+	
+	blip_time_t last_time;
+	int         min_tone_period;
+	unsigned    noise_feedback;
+	unsigned    looped_feedback;
+	Blip_Synth_Fast fast_synth;
+	Blip_Synth_Norm norm_synth;
+	
+	int calc_output( int i ) const;
+	void run_until( blip_time_t );
+	const char* save_load( sms_apu_state_t*, bool save );
+	friend class Sms_Apu_Tester;
+};
+
+struct sms_apu_state_t
+{
+	// If SMS_APU_CUSTOM_STATE is 1, values are stored as normal integers,
+	// so your code can then save and load them however it likes. Otherwise,
+	// they are 4-byte arrays in little-endian format, making entire
+	// structure suitable for direct storage on disk.
+	
+#if SMS_APU_CUSTOM_STATE
+	typedef int val_t;
+#else
+	typedef unsigned char val_t [4];
+#endif
+	
+	enum { format0 = 0x50414D53 };
+	
+	val_t format;
+	val_t version;
+	val_t latch;
+	val_t ggstereo;
+	val_t periods [4];
+	val_t volumes [4];
+	val_t delays  [4];
+	val_t phases  [4];
+	
+	val_t unused  [12]; // for future expansion
+};
+
+#endif
diff -Nur orig/source/gme/src/Sms_Fm_Apu.cpp mod/source/gme/src/Sms_Fm_Apu.cpp
--- orig/source/gme/src/Sms_Fm_Apu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sms_Fm_Apu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,80 @@
+#include "Sms_Fm_Apu.h"
+
+#include "blargg_source.h"
+
+Sms_Fm_Apu::Sms_Fm_Apu()
+{ }
+
+Sms_Fm_Apu::~Sms_Fm_Apu()
+{ }
+
+blargg_err_t Sms_Fm_Apu::init( double clock_rate, double sample_rate )
+{
+	period_ = int(clock_rate / sample_rate + 0.5);
+	CHECK_ALLOC( !apu.set_rate( sample_rate, clock_rate ) );
+	
+	set_output( 0 );
+	volume( 1.0 );
+	reset();
+	return blargg_ok;
+}
+
+void Sms_Fm_Apu::reset()
+{
+	addr      = 0;
+	next_time = 0;
+	last_amp  = 0;
+	
+	apu.reset();
+}
+
+void Sms_Fm_Apu::write_data( blip_time_t time, int data )
+{
+	if ( time > next_time )
+		run_until( time );
+	
+	apu.write( addr, data );
+}
+
+void Sms_Fm_Apu::run_until( blip_time_t end_time )
+{
+	assert( end_time > next_time );
+	
+	Blip_Buffer* const output = this->output_;
+	if ( !output )
+	{
+		next_time = end_time;
+		return;
+	}
+	
+	blip_time_t time = next_time;
+	do
+	{
+		Ym2413_Emu::sample_t samples [2];
+		apu.run( 1, samples );
+		int amp = (samples [0] + samples [1]) >> 1;
+		
+		int delta = amp - last_amp;
+		if ( delta )
+		{
+			last_amp = amp;
+			synth.offset_inline( time, delta, output );
+		}
+		time += period_;
+	}
+	while ( time < end_time );
+	
+	next_time = time;
+}
+
+void Sms_Fm_Apu::end_frame( blip_time_t time )
+{
+	if ( time > next_time )
+		run_until( time );
+	
+	next_time -= time;
+	assert( next_time >= 0 );
+	
+	if ( output_ )
+		output_->set_modified();
+}
diff -Nur orig/source/gme/src/Sms_Fm_Apu.h mod/source/gme/src/Sms_Fm_Apu.h
--- orig/source/gme/src/Sms_Fm_Apu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sms_Fm_Apu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,47 @@
+#ifndef SMS_FM_APU_H
+#define SMS_FM_APU_H
+
+#include "Blip_Buffer.h"
+#include "Ym2413_Emu.h"
+
+class Sms_Fm_Apu {
+public:
+	static bool supported()                     { return Ym2413_Emu::supported(); }
+	blargg_err_t init( double clock_rate, double sample_rate );
+	
+	void set_output( Blip_Buffer* b, Blip_Buffer* = NULL, Blip_Buffer* = NULL ) { output_ = b; }
+	void volume( double v )                     { synth.volume( 0.4 / 4096 * v ); }
+	void treble_eq( blip_eq_t const& eq )       { synth.treble_eq( eq ); }
+	
+	void reset();
+	
+	void write_addr( int data )                 { addr = data; }
+	void write_data( blip_time_t, int data );
+	
+	void end_frame( blip_time_t t );
+
+// Implementation
+public:
+	Sms_Fm_Apu();
+	~Sms_Fm_Apu();
+	BLARGG_DISABLE_NOTHROW
+	enum { osc_count = 1 };
+	void set_output( int i, Blip_Buffer* b, Blip_Buffer* = NULL, Blip_Buffer* = NULL ) { output_ = b; }
+
+private:
+	Blip_Buffer* output_;
+	blip_time_t next_time;
+	int last_amp;
+	int addr;
+	
+	int clock_;
+	int rate_;
+	blip_time_t period_;
+	
+	Blip_Synth_Norm synth;
+	Ym2413_Emu apu;
+	
+	void run_until( blip_time_t );
+};
+
+#endif
diff -Nur orig/source/gme/src/Sms_Oscs.h mod/source/gme/src/Sms_Oscs.h
--- orig/source/gme/src/Sms_Oscs.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Sms_Oscs.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,49 @@
+// Private oscillators used by Sms_Apu
+
+// Sms_Snd_Emu 0.1.4
+#ifndef SMS_OSCS_H
+#define SMS_OSCS_H
+
+#include "blargg_common.h"
+#include "Blip_Buffer.h"
+
+struct Sms_Osc
+{
+	Blip_Buffer* outputs [4]; // NULL, right, left, center
+	Blip_Buffer* output;
+	int output_select;
+	
+	int delay;
+	int last_amp;
+	int volume;
+	
+	Sms_Osc();
+	void reset();
+};
+
+struct Sms_Square : Sms_Osc
+{
+	int period;
+	int phase;
+	
+	typedef Blip_Synth<blip_good_quality,1> Synth;
+	const Synth* synth;
+	
+	void reset();
+	void run( blip_time_t, blip_time_t );
+};
+
+struct Sms_Noise : Sms_Osc
+{
+	const int* period;
+	unsigned shifter;
+	unsigned feedback;
+	
+	typedef Blip_Synth<blip_med_quality,1> Synth;
+	Synth synth;
+	
+	void reset();
+	void run( blip_time_t, blip_time_t );
+};
+
+#endif
diff -Nur orig/source/gme/src/Snes_Spc.cpp mod/source/gme/src/Snes_Spc.cpp
--- orig/source/gme/src/Snes_Spc.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Snes_Spc.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,378 @@
+// SPC emulation support: init, sample buffering, reset, SPC loading
+
+// snes_spc 0.9.0. http://www.slack.net/~ant/
+
+#include "Snes_Spc.h"
+
+/* Copyright (C) 2004-2007 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#define RAM         (m.ram.ram)
+#define REGS        (m.smp_regs [0])
+#define REGS_IN     (m.smp_regs [1])
+
+// (n ? n : 256)
+#define IF_0_THEN_256( n ) ((uint8_t) ((n) - 1) + 1)
+
+
+//// Init
+
+blargg_err_t Snes_Spc::init()
+{
+	memset( &m, 0, sizeof m );
+	dsp.init( RAM );
+	
+	m.tempo = tempo_unit;
+	
+	// Most SPC music doesn't need ROM, and almost all the rest only rely
+	// on these two bytes
+	m.rom [0x3E] = 0xFF;
+	m.rom [0x3F] = 0xC0;
+	
+	static unsigned char const cycle_table [128] =
+	{//   01   23   45   67   89   AB   CD   EF
+	    0x28,0x47,0x34,0x36,0x26,0x54,0x54,0x68, // 0
+	    0x48,0x47,0x45,0x56,0x55,0x65,0x22,0x46, // 1
+	    0x28,0x47,0x34,0x36,0x26,0x54,0x54,0x74, // 2
+	    0x48,0x47,0x45,0x56,0x55,0x65,0x22,0x38, // 3
+	    0x28,0x47,0x34,0x36,0x26,0x44,0x54,0x66, // 4
+	    0x48,0x47,0x45,0x56,0x55,0x45,0x22,0x43, // 5
+	    0x28,0x47,0x34,0x36,0x26,0x44,0x54,0x75, // 6
+	    0x48,0x47,0x45,0x56,0x55,0x55,0x22,0x36, // 7
+	    0x28,0x47,0x34,0x36,0x26,0x54,0x52,0x45, // 8
+	    0x48,0x47,0x45,0x56,0x55,0x55,0x22,0xC5, // 9
+	    0x38,0x47,0x34,0x36,0x26,0x44,0x52,0x44, // A
+	    0x48,0x47,0x45,0x56,0x55,0x55,0x22,0x34, // B
+	    0x38,0x47,0x45,0x47,0x25,0x64,0x52,0x49, // C
+	    0x48,0x47,0x56,0x67,0x45,0x55,0x22,0x83, // D
+	    0x28,0x47,0x34,0x36,0x24,0x53,0x43,0x40, // E
+	    0x48,0x47,0x45,0x56,0x34,0x54,0x22,0x60, // F
+	};
+	
+	// unpack cycle table
+	for ( int i = 0; i < 128; i++ )
+	{
+		int n = cycle_table [i];
+		m.cycle_table [i * 2 + 0] = n >> 4;
+		m.cycle_table [i * 2 + 1] = n & 0x0F;
+	}
+	
+	#if SPC_LESS_ACCURATE
+		memcpy( reg_times, reg_times_, sizeof reg_times );
+	#endif
+	
+	reset();
+	return blargg_ok;
+}
+
+void Snes_Spc::init_rom( uint8_t const in [rom_size] )
+{
+	memcpy( m.rom, in, sizeof m.rom );
+}
+
+void Snes_Spc::set_tempo( int t )
+{
+	m.tempo = t;
+	int const timer2_shift = 4; // 64 kHz
+	int const other_shift  = 3; //  8 kHz
+	
+	#if SPC_DISABLE_TEMPO
+		m.timers [2].prescaler = timer2_shift;
+		m.timers [1].prescaler = timer2_shift + other_shift;
+		m.timers [0].prescaler = timer2_shift + other_shift;
+	#else
+		if ( !t )
+			t = 1;
+		int const timer2_rate  = 1 << timer2_shift;
+		int rate = (timer2_rate * tempo_unit + (t >> 1)) / t;
+		if ( rate < timer2_rate / 4 )
+			rate = timer2_rate / 4; // max 4x tempo
+		m.timers [2].prescaler = rate;
+		m.timers [1].prescaler = rate << other_shift;
+		m.timers [0].prescaler = rate << other_shift;
+	#endif
+}
+
+// Timer registers have been loaded. Applies these to the timers. Does not
+// reset timer prescalers or dividers.
+void Snes_Spc::timers_loaded()
+{
+	int i;
+	for ( i = 0; i < timer_count; i++ )
+	{
+		Timer* t = &m.timers [i];
+		t->period  = IF_0_THEN_256( REGS [r_t0target + i] );
+		t->enabled = REGS [r_control] >> i & 1;
+		t->counter = REGS_IN [r_t0out + i] & 0x0F;
+	}
+	
+	set_tempo( m.tempo );
+}
+
+// Loads registers from unified 16-byte format
+void Snes_Spc::load_regs( uint8_t const in [reg_count] )
+{
+	memcpy( REGS, in, reg_count );
+	memcpy( REGS_IN, REGS, reg_count );
+	
+	// These always read back as 0
+	REGS_IN [r_test    ] = 0;
+	REGS_IN [r_control ] = 0;
+	REGS_IN [r_t0target] = 0;
+	REGS_IN [r_t1target] = 0;
+	REGS_IN [r_t2target] = 0;
+}
+
+// RAM was just loaded from SPC, with $F0-$FF containing SMP registers
+// and timer counts. Copies these to proper registers.
+void Snes_Spc::ram_loaded()
+{
+	m.rom_enabled = 0;
+	load_regs( &RAM [0xF0] );
+	
+	// Put STOP instruction around memory to catch PC underflow/overflow
+	memset( m.ram.padding1, cpu_pad_fill, sizeof m.ram.padding1 );
+	memset( m.ram.padding2, cpu_pad_fill, sizeof m.ram.padding2 );
+}
+
+// Registers were just loaded. Applies these new values.
+void Snes_Spc::regs_loaded()
+{
+	enable_rom( REGS [r_control] & 0x80 );
+	timers_loaded();
+}
+
+void Snes_Spc::reset_time_regs()
+{
+	m.cpu_error     = NULL;
+	m.echo_accessed = 0;
+	m.spc_time      = 0;
+	m.dsp_time      = 0;
+	#if SPC_LESS_ACCURATE
+		m.dsp_time = clocks_per_sample + 1;
+	#endif
+	
+	for ( int i = 0; i < timer_count; i++ )
+	{
+		Timer* t = &m.timers [i];
+		t->next_time = 1;
+		t->divider   = 0;
+	}
+	
+	regs_loaded();
+	
+	m.extra_clocks = 0;
+	reset_buf();
+}
+
+void Snes_Spc::reset_common( int timer_counter_init )
+{
+	int i;
+	for ( i = 0; i < timer_count; i++ )
+		REGS_IN [r_t0out + i] = timer_counter_init;
+	
+	// Run IPL ROM
+	memset( &m.cpu_regs, 0, sizeof m.cpu_regs );
+	m.cpu_regs.pc = rom_addr;
+	
+	REGS [r_test   ] = 0x0A;
+	REGS [r_control] = 0xB0; // ROM enabled, clear ports
+	for ( i = 0; i < port_count; i++ )
+		REGS_IN [r_cpuio0 + i] = 0;
+	
+	reset_time_regs();
+}
+
+void Snes_Spc::soft_reset()
+{
+	reset_common( 0 );
+	dsp.soft_reset();
+}
+
+void Snes_Spc::reset()
+{
+	memset( RAM, 0xFF, 0x10000 );
+	ram_loaded();
+	reset_common( 0x0F );
+	dsp.reset();
+}
+
+char const Snes_Spc::signature [signature_size + 1] =
+		"SNES-SPC700 Sound File Data v0.30\x1A\x1A";
+
+blargg_err_t Snes_Spc::load_spc( void const* data, long size )
+{
+	spc_file_t const* const spc = (spc_file_t const*) data;
+	
+	// be sure compiler didn't insert any padding into fle_t
+	assert( sizeof (spc_file_t) == spc_min_file_size + 0x80 );
+	
+	// Check signature and file size
+	if ( size < signature_size || memcmp( spc, signature, 27 ) )
+		return "Not an SPC file";
+	
+	if ( size < spc_min_file_size )
+		return "Corrupt SPC file";
+	
+	// CPU registers
+	m.cpu_regs.pc  = spc->pch * 0x100 + spc->pcl;
+	m.cpu_regs.a   = spc->a;
+	m.cpu_regs.x   = spc->x;
+	m.cpu_regs.y   = spc->y;
+	m.cpu_regs.psw = spc->psw;
+	m.cpu_regs.sp  = spc->sp;
+	
+	// RAM and registers
+	memcpy( RAM, spc->ram, 0x10000 );
+	ram_loaded();
+	
+	// DSP registers
+	dsp.load( spc->dsp );
+	
+	reset_time_regs();
+	
+	return blargg_ok;
+}
+
+void Snes_Spc::clear_echo()
+{
+	if ( !(dsp.read( Spc_Dsp::r_flg ) & 0x20) )
+	{
+		int addr = 0x100 * dsp.read( Spc_Dsp::r_esa );
+		int end  = addr + 0x800 * (dsp.read( Spc_Dsp::r_edl ) & 0x0F);
+		if ( end > 0x10000 )
+			end = 0x10000;
+		memset( &RAM [addr], 0xFF, end - addr );
+	}
+}
+
+
+//// Sample output
+
+void Snes_Spc::reset_buf()
+{
+	// Start with half extra buffer of silence
+	sample_t* out = m.extra_buf;
+	while ( out < &m.extra_buf [extra_size / 2] )
+		*out++ = 0;
+	
+	m.extra_pos = out;
+	m.buf_begin = NULL;
+	
+	dsp.set_output( NULL, 0 );
+}
+
+void Snes_Spc::set_output( sample_t out [], int size )
+{
+	require( (size & 1) == 0 ); // size must be even
+	
+	m.extra_clocks &= clocks_per_sample - 1;
+	if ( out )
+	{
+		sample_t const* out_end = out + size;
+		m.buf_begin = out;
+		m.buf_end   = out_end;
+		
+		// Copy extra to output
+		sample_t const* in = m.extra_buf;
+		while ( in < m.extra_pos && out < out_end )
+			*out++ = *in++;
+		
+		// Handle output being full already
+		if ( out >= out_end )
+		{
+			// Have DSP write to remaining extra space
+			out     = dsp.extra();
+			out_end = &dsp.extra() [extra_size];
+			
+			// Copy any remaining extra samples as if DSP wrote them
+			while ( in < m.extra_pos )
+				*out++ = *in++;
+			assert( out <= out_end );
+		}
+		
+		dsp.set_output( out, out_end - out );
+	}
+	else
+	{
+		reset_buf();
+	}
+}
+
+void Snes_Spc::save_extra()
+{
+	// Get end pointers
+	sample_t const* main_end = m.buf_end;     // end of data written to buf
+	sample_t const* dsp_end  = dsp.out_pos(); // end of data written to dsp.extra()
+	if ( m.buf_begin <= dsp_end && dsp_end <= main_end )
+	{
+		main_end = dsp_end;
+		dsp_end  = dsp.extra(); // nothing in DSP's extra
+	}
+	
+	// Copy any extra samples at these ends into extra_buf
+	sample_t* out = m.extra_buf;
+	sample_t const* in;
+	for ( in = m.buf_begin + sample_count(); in < main_end; in++ )
+		*out++ = *in;
+	for ( in = dsp.extra(); in < dsp_end ; in++ )
+		*out++ = *in;
+	
+	m.extra_pos = out;
+	assert( out <= &m.extra_buf [extra_size] );
+}
+
+blargg_err_t Snes_Spc::play( int count, sample_t out [] )
+{
+	require( (count & 1) == 0 ); // must be even
+	if ( count )
+	{
+		set_output( out, count );
+		end_frame( count * (clocks_per_sample / 2) );
+	}
+	
+	const char* err = m.cpu_error;
+	m.cpu_error = NULL;
+	return err;
+}
+
+blargg_err_t Snes_Spc::skip( int count )
+{
+	#if SPC_LESS_ACCURATE
+	if ( count > 2 * sample_rate * 2 )
+	{
+		set_output( NULL, 0 );
+		
+		// Skip a multiple of 4 samples
+		time_t end = count;
+		count = (count & 3) + 1 * sample_rate * 2;
+		end = (end - count) * (clocks_per_sample / 2);
+		
+		m.skipped_kon  = 0;
+		m.skipped_koff = 0;
+		
+		// Preserve DSP and timer synchronization
+		// TODO: verify that this really preserves it
+		int old_dsp_time = m.dsp_time + m.spc_time;
+		m.dsp_time = end - m.spc_time + skipping_time;
+		end_frame( end );
+		m.dsp_time = m.dsp_time - skipping_time + old_dsp_time;
+		
+		dsp.write( Spc_Dsp::r_koff, m.skipped_koff & ~m.skipped_kon );
+		dsp.write( Spc_Dsp::r_kon , m.skipped_kon );
+		clear_echo();
+	}
+	#endif
+	
+	return play( count, NULL );
+}
diff -Nur orig/source/gme/src/Snes_Spc.h mod/source/gme/src/Snes_Spc.h
--- orig/source/gme/src/Snes_Spc.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Snes_Spc.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,291 @@
+// SNES SPC-700 APU emulator
+
+// snes_spc 0.9.0
+#ifndef SNES_SPC_H
+#define SNES_SPC_H
+
+#include "Spc_Dsp.h"
+#include "blargg_endian.h"
+
+struct Snes_Spc {
+public:
+	typedef BOOST::uint8_t uint8_t;
+	
+	// Must be called once before using
+	blargg_err_t init();
+	
+	// Sample pairs generated per second
+	enum { sample_rate = 32000 };
+	
+// Emulator use
+	
+	// Sets IPL ROM data. Library does not include ROM data. Most SPC music files
+	// don't need ROM, but a full emulator must provide this.
+	enum { rom_size = 0x40 };
+	void init_rom( uint8_t const rom [rom_size] );
+
+	// Sets destination for output samples
+	typedef short sample_t;
+	void set_output( sample_t* out, int out_size );
+
+	// Number of samples written to output since last set
+	int sample_count() const;
+
+	// Resets SPC to power-on state. This resets your output buffer, so you must
+	// call set_output() after this.
+	void reset();
+
+	// Emulates pressing reset switch on SNES. This resets your output buffer, so
+	// you must call set_output() after this.
+	void soft_reset();
+
+	// 1024000 SPC clocks per second, sample pair every 32 clocks
+	typedef int time_t;
+	enum { clock_rate = 1024000 };
+	enum { clocks_per_sample = 32 };
+	
+	// Emulated port read/write at specified time
+	enum { port_count = 4 };
+	int  read_port ( time_t, int port );
+	void write_port( time_t, int port, int data );
+
+	// Runs SPC to end_time and starts a new time frame at 0
+	void end_frame( time_t end_time );
+	
+// Sound control
+	
+	// Mutes voices corresponding to non-zero bits in mask (issues repeated KOFF events).
+	// Reduces emulation accuracy.
+	enum { voice_count = 8 };
+	void mute_voices( int mask );
+	
+	// If true, prevents channels and global volumes from being phase-negated.
+	void disable_surround( bool disable = true );
+
+	// If true, enables cubic interpolation
+	void interpolation_level( int level = 0 );
+	
+	// Sets tempo, where tempo_unit = normal, tempo_unit / 2 = half speed, etc.
+	enum { tempo_unit = 0x100 };
+	void set_tempo( int );
+
+// SPC music files
+
+	// Loads SPC data into emulator
+	enum { spc_min_file_size = 0x10180 };
+	enum { spc_file_size     = 0x10200 };
+	blargg_err_t load_spc( void const* in, long size );
+	
+	// Clears echo region. Useful after loading an SPC as many have garbage in echo.
+	void clear_echo();
+
+	// Plays for count samples and write samples to out. Discards samples if out
+	// is NULL. Count must be a multiple of 2 since output is stereo.
+	blargg_err_t play( int count, sample_t out [] );
+	
+	// Skips count samples. Several times faster than play() when using fast DSP.
+	blargg_err_t skip( int count );
+
+// State save/load (only available with accurate DSP)
+
+#if !SPC_NO_COPY_STATE_FUNCS
+	// Saves/loads state
+	enum { state_size = 67 * 1024 }; // maximum space needed when saving
+	typedef Spc_Dsp::copy_func_t copy_func_t;
+	void copy_state( unsigned char** io, copy_func_t );
+	
+	// Writes minimal header to spc_out
+	static void init_header( void* spc_out );
+
+	// Saves emulator state as SPC file data. Writes spc_file_size bytes to spc_out.
+	// Does not set up SPC header; use init_header() for that.
+	void save_spc( void* spc_out );
+
+	// Returns true if new key-on events occurred since last check. Useful for
+	// trimming silence while saving an SPC.
+	bool check_kon();
+#endif
+
+public:
+	// TODO: document
+	struct regs_t
+	{
+		int pc;
+		int a;
+		int x;
+		int y;
+		int psw;
+		int sp;
+	};
+	regs_t& smp_regs() { return m.cpu_regs; }
+	
+	uint8_t* smp_ram() { return m.ram.ram; }
+	
+	void run_until( time_t t ) { run_until_( t ); }
+public:
+	BLARGG_DISABLE_NOTHROW
+	
+	typedef BOOST::uint16_t uint16_t;
+	
+	// Time relative to m_spc_time. Speeds up code a bit by eliminating need to
+	// constantly add m_spc_time to time from CPU. CPU uses time that ends at
+	// 0 to eliminate reloading end time every instruction. It pays off.
+	typedef int rel_time_t;
+	
+	struct Timer
+	{
+		rel_time_t next_time; // time of next event
+		int prescaler;
+		int period;
+		int divider;
+		int enabled;
+		int counter;
+	};
+	enum { reg_count = 0x10 };
+	enum { timer_count = 3 };
+	enum { extra_size = Spc_Dsp::extra_size };
+	
+	enum { signature_size = 35 };
+	
+private:
+	Spc_Dsp dsp;
+	
+	#if SPC_LESS_ACCURATE
+		static signed char const reg_times_ [256];
+		signed char reg_times [256];
+	#endif
+	
+	struct state_t
+	{
+		Timer timers [timer_count];
+		
+		uint8_t smp_regs [2] [reg_count];
+		
+		regs_t cpu_regs;
+		
+		rel_time_t  dsp_time;
+		time_t      spc_time;
+		bool        echo_accessed;
+		
+		int         tempo;
+		int         skipped_kon;
+		int         skipped_koff;
+		const char* cpu_error;
+		
+		int         extra_clocks;
+		sample_t*   buf_begin;
+		sample_t const* buf_end;
+		sample_t*   extra_pos;
+		sample_t    extra_buf [extra_size];
+		
+		int         rom_enabled;
+		uint8_t     rom    [rom_size];
+		uint8_t     hi_ram [rom_size];
+		
+		unsigned char cycle_table [256];
+		
+		struct
+		{
+			// padding to neutralize address overflow
+			union {
+				uint8_t padding1 [0x100];
+				uint16_t align; // makes compiler align data for 16-bit access
+			} padding1 [1];
+			uint8_t ram      [0x10000];
+			uint8_t padding2 [0x100];
+		} ram;
+	};
+	state_t m;
+	
+	enum { rom_addr = 0xFFC0 };
+	
+	enum { skipping_time = 127 };
+	
+	// Value that padding should be filled with
+	enum { cpu_pad_fill = 0xFF };
+	
+	enum {
+        r_test     = 0x0, r_control  = 0x1,
+        r_dspaddr  = 0x2, r_dspdata  = 0x3,
+        r_cpuio0   = 0x4, r_cpuio1   = 0x5,
+        r_cpuio2   = 0x6, r_cpuio3   = 0x7,
+        r_f8       = 0x8, r_f9       = 0x9,
+        r_t0target = 0xA, r_t1target = 0xB, r_t2target = 0xC,
+        r_t0out    = 0xD, r_t1out    = 0xE, r_t2out    = 0xF
+	};
+	
+	void timers_loaded();
+	void enable_rom( int enable );
+	void reset_buf();
+	void save_extra();
+	void load_regs( uint8_t const in [reg_count] );
+	void ram_loaded();
+	void regs_loaded();
+	void reset_time_regs();
+	void reset_common( int timer_counter_init );
+	
+	Timer* run_timer_      ( Timer* t, rel_time_t );
+	Timer* run_timer       ( Timer* t, rel_time_t );
+	int dsp_read           ( rel_time_t );
+	void dsp_write         ( int data, rel_time_t );
+	void cpu_write_smp_reg_( int data, rel_time_t, int addr );
+	void cpu_write_smp_reg ( int data, rel_time_t, int addr );
+	void cpu_write_high    ( int data, int i, rel_time_t );
+	void cpu_write         ( int data, int addr, rel_time_t );
+	int cpu_read_smp_reg   ( int i, rel_time_t );
+	int cpu_read           ( int addr, rel_time_t );
+	unsigned CPU_mem_bit   ( uint8_t const* pc, rel_time_t );
+	
+	bool check_echo_access ( int addr );
+	uint8_t* run_until_( time_t end_time );
+	
+	struct spc_file_t
+	{
+		char    signature [signature_size];
+		uint8_t has_id666;
+		uint8_t version;
+		uint8_t pcl, pch;
+		uint8_t a;
+		uint8_t x;
+		uint8_t y;
+		uint8_t psw;
+		uint8_t sp;
+		char    text [212];
+		uint8_t ram [0x10000];
+		uint8_t dsp [128];
+		uint8_t unused [0x40];
+		uint8_t ipl_rom [0x40];
+	};
+
+	static char const signature [signature_size + 1];
+	
+	void save_regs( uint8_t out [reg_count] );
+};
+
+#include <assert.h>
+
+inline int Snes_Spc::sample_count() const { return (m.extra_clocks >> 5) * 2; }
+
+inline int Snes_Spc::read_port( time_t t, int port )
+{
+	assert( (unsigned) port < port_count );
+	return run_until_( t ) [port];
+}
+
+inline void Snes_Spc::write_port( time_t t, int port, int data )
+{
+	assert( (unsigned) port < port_count );
+	run_until_( t ) [0x10 + port] = data;
+}
+
+inline void Snes_Spc::mute_voices( int mask ) { dsp.mute_voices( mask ); }
+	
+inline void Snes_Spc::disable_surround( bool disable ) { dsp.disable_surround( disable ); }
+
+inline void Snes_Spc::interpolation_level( int level ) { dsp.interpolation_level( level ); }
+
+#if !SPC_NO_COPY_STATE_FUNCS
+inline bool Snes_Spc::check_kon() { return dsp.check_kon(); }
+#endif
+
+#endif
diff -Nur orig/source/gme/src/s_opl.c mod/source/gme/src/s_opl.c
--- orig/source/gme/src/s_opl.c	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_opl.c	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1244 @@
+/*
+  s_opl.c -- YM2413/Y8950/YM3526/YM3812 emulator by Mamiya, 2001.
+
+  References: 
+    fmopl.c        -- 1999,2000 written by Tatsuyuki Satoh (MAME development).
+    fmopl.c(fixed) -- 2000 modified by mamiya (NEZplug development).
+    fmgen.cpp      -- 1999-2001 written by cisc.
+    emu2413.c      -- a YM2413 emulator : written by Mitsutaka Okazaki 2001
+    fmpac.ill      -- 2000 created by sama. 
+    fmpac.ill      -- 2000 created by NARUTO. 
+    fmpac.ill      -- 2001 created by Okazaki. 
+    YM2413 application manual
+*/
+
+#include "kmsnddev.h"
+#include "divfix.h"
+#include "s_logtbl.h"
+#include "s_opltbl.h"
+#include "s_opl.h"
+#include "s_deltat.h"
+#include <string.h>
+
+#define PG_SHIFT 10 /* fix */
+#define CPS_SHIFTE 20
+#define CPS_SHIFTP 14
+#define LFO_SHIFT 16
+
+#define OPLL_INST_WORK  0x40
+#define OPLL_INST_WORK2 (OPLL_INST_WORK + 8 * 0x13)
+
+#define AR_BITS   6 /* fix */
+#define AR_SHIFT 14 /* fix */
+#define EG_SHIFT 15 /* fix */
+
+#define AR_PHASEMAX (((1 << AR_BITS) - 1) << AR_SHIFT)
+#define EG_PHASEMAX (127 << EG_SHIFT)
+#define EG_KEYOFF   (128 << EG_SHIFT)
+#define LOG_KEYOFF   (31 << (LOG_BITS + 1))
+
+#if 0
+  0-48dB
+  AR_BITS=6
+  AR_SHIFT=14
+  x = FC000h(20.7618(sec) * 3579545 / 72)cycles 63 * 4000h
+  x / 3 * 4 1730.15(ms)
+  x / 3 * 256 27.03(ms)
+
+  EG_BITS=7
+  EG_SHIFT=15
+  x = 3F8000h(83.7064(sec) * 3579545 / 72)cycles 127 * 8000h
+  x / 4 = 20926.6(ms)
+#endif
+
+
+#define TESTING_OPTIMIZE_AME 1
+#define USE_FBBUF 1
+
+typedef struct
+{
+	Uint32 phase;
+	Uint32 spd;
+	Uint32 rng;
+} OPL_PG;
+
+enum {
+	EG_MODE_ATTACK,
+	EG_MODE_DECAY,
+	EG_MODE_SUSTINE,
+	EG_MODE_RELEASE,
+	EG_MODE_NUM,
+	EG_MODE_SUSHOLD,
+	EG_MODE_OFF = EG_MODE_NUM
+};
+
+typedef struct
+{
+	Uint32 phasear;
+	Uint32 phase;
+	Uint32 spd [EG_MODE_NUM];
+	Uint32 dr_phasemax;
+	Uint8 mode;
+	Uint8 pad4_1;
+	Uint8 pad4_2;
+	Uint8 pad4_3;
+} OPL_EG;
+
+enum
+{
+	FLAG_AME        = (1 << 0),
+	FLAG_PME        = (1 << 1),
+	FLAG_EGT        = (1 << 2),
+	FLAG_KSR        = (1 << 3)
+};
+
+typedef struct
+{
+	OPL_PG pg;
+	OPL_EG eg;
+	Int32 input;
+#if USE_FBBUF
+	Int32 fbbuf;
+#endif
+#if TESTING_OPTIMIZE_AME
+	Uint32* amin;
+#endif
+	Uint32 tl_ofs;
+	Uint32* sintable;
+
+	Uint8 modcar;   /* 1:m 0:c */
+	Uint8 fb;
+	Uint8 lvl;
+	Uint8 nst;
+
+	Uint8 tll;
+	Uint8 key;
+	Uint8 rkey;
+	Uint8 prevkey;
+
+	Uint8 enable;
+	Uint8 __enablehold__;
+	Uint8 flag;
+	Uint8 ksr;
+
+	Uint8 mul;
+	Uint8 ksl;
+	Uint8 ar;
+	Uint8 dr;
+	Uint8 sl;
+	Uint8 rr;
+	Uint8 tl;
+	Uint8 wf;
+} OPL_OP;
+
+typedef struct
+{
+	OPL_OP op [2];
+	Uint8 con;
+	Uint8 freql;
+	Uint8 freqh;
+	Uint8 blk;
+	Uint8 kcode;
+	Uint8 sus;
+	Uint8 ksb;
+	Uint8 pad4_3;
+} OPL_CH;
+
+enum
+{
+	LFO_UNIT_AM,
+	LFO_UNIT_PM,
+	LFO_UNIT_NUM
+};
+
+typedef struct
+{
+	Uint32 output;
+	Uint32 cnt;
+	Uint32 sps; /* step per sample */
+	Uint32 adr;
+	Uint32 adrmask;
+	Uint32* table;
+} OPL_LFO;
+
+typedef struct
+{
+	KMIF_SOUND_DEVICE kmif;
+	KMIF_SOUND_DEVICE* deltatpcm;
+	KMIF_LOGTABLE* logtbl;
+	KMIF_OPLTABLE* opltbl;
+	OPL_CH ch [9];
+	OPL_LFO lfo [LFO_UNIT_NUM];
+	struct OPLSOUND_COMMON_TAG
+	{
+		Uint32 cpsp;
+		Uint32 cnt;
+		Uint32* ar_table;
+		Uint32* tll2logtbl;
+#if TESTING_OPTIMIZE_AME
+		Uint32 amzero;
+#endif
+		Int32 mastervolume;
+		Uint32 sintablemask;
+		Uint32 ratetbla [4];
+		Uint32 ratetbl [4];
+		Uint8 adr;
+		Uint8 wfe;
+		Uint8 rc;
+		Uint8 rmode;
+		Uint8 enable;
+	} common;
+	Uint8 regs [0x100];
+	Uint8 opl_type;
+} OPLSOUND;
+
+static Uint8 romtone [3] [16 * 19] =
+{
+	{
+#include "i_fmpac.h"
+	},
+	{
+#include "i_fmunit.h"
+	},
+	{
+#include "i_vrc7.h"
+	},
+};
+
+static void SetOpOff(OPL_OP* opp )
+{
+	opp->eg.mode = EG_MODE_OFF;
+	opp->eg.phase = EG_KEYOFF;
+	opp->enable = 0;
+}
+
+inline static void EgStep( OPLSOUND* sndp, OPL_OP* opp )
+{
+	switch ( opp->eg.mode )
+	{
+	default:
+		NEVER_REACH
+	
+	case EG_MODE_ATTACK:
+		opp->eg.phase = sndp->common.ar_table [opp->eg.phasear >> (AR_SHIFT + AR_BITS - ARTBL_BITS)] >> (ARTBL_SHIFT -  EG_SHIFT);
+		opp->eg.phasear += opp->eg.spd [EG_MODE_ATTACK];
+		if ( opp->eg.phasear >= AR_PHASEMAX )
+		{
+			opp->eg.mode = EG_MODE_DECAY;
+			opp->eg.phase = 0;
+		}
+		break;
+	
+	case EG_MODE_DECAY:
+		opp->eg.phase += opp->eg.spd [EG_MODE_DECAY];
+		if ( opp->eg.phase >= opp->eg.dr_phasemax )
+		{
+			opp->eg.phase = opp->eg.dr_phasemax;
+			opp->eg.mode = (opp->flag & FLAG_EGT) ? EG_MODE_SUSHOLD : EG_MODE_SUSTINE;
+		}
+		break;
+	
+	case EG_MODE_SUSTINE:
+	case EG_MODE_RELEASE:
+		opp->eg.phase += opp->eg.spd [opp->eg.mode];
+		if ( opp->eg.phase >= EG_PHASEMAX )
+			SetOpOff(opp);
+		break;
+	
+	case EG_MODE_SUSHOLD:
+	case EG_MODE_OFF:
+		break;
+	}
+}
+
+static void OpStep( OPLSOUND* sndp, OPL_OP* opp )
+{
+	int step;
+	EgStep(sndp, opp);
+	step = opp->pg.spd;
+	if ( opp->flag & FLAG_PME )
+		step = (step * sndp->lfo [LFO_UNIT_PM].output) >> PM_SHIFT;
+	opp->pg.phase += step;
+}
+
+__inline static void OpStepNG( OPLSOUND* sndp, OPL_OP* opp )
+{
+	Uint32 step;
+	EgStep(sndp, opp);
+	opp->pg.phase += opp->pg.spd;
+	step = opp->pg.phase >> opp->nst/*(PG_SHIFT + 5)*/;
+	opp->pg.phase &=  (1 << opp->nst/*(PG_SHIFT + 5)*/) - 1;
+	while ( step-- )
+	{
+		opp->pg.rng ^= ((opp->pg.rng & 1) << 16) + ((opp->pg.rng & 1) << 13);
+		opp->pg.rng >>= 1;
+	}
+}
+
+#if -1 >> 1 == -1
+/* RIGHT SHIFT IS SIGNED */
+#define SSR(x, y) ((Int32)(x) >> (y))
+#else
+/* RIGHT SHIFT IS UNSIGNED */
+#define SSR(x, y) (((x) >= 0) ? ((x) >> (y)) : (-((-(x) - 1) >> (y)) - 1))
+#endif
+
+
+inline static void OpSynthMod( OPLSOUND* sndp, OPL_OP* opp )
+{
+	if ( opp->enable )
+	{
+		Uint32 tll;
+		Int32 output;
+		OpStep(sndp, opp);
+		tll = opp->tll + (opp->eg.phase >> EG_SHIFT);
+		tll = (tll >= (1 << TLLTBL_BITS)) ? LOG_KEYOFF : sndp->common.tll2logtbl [tll];
+		tll += opp->tl_ofs;
+#if TESTING_OPTIMIZE_AME
+		tll += *opp->amin;
+#else
+		if ( opp->flag & FLAG_AME )
+			tll += sndp->lfo [LFO_UNIT_AM].output;
+#endif
+		tll += opp->sintable [sndp->common.sintablemask & (opp->input + (opp->pg.phase >> PG_SHIFT))];
+		output = LogToLin(sndp->logtbl, tll, -8 + ((LOG_LIN_BITS + 1) - (SINTBL_BITS + 2)));
+		if ( opp->fb )
+		{
+#if USE_FBBUF
+			Int32 fbtmp;
+			fbtmp = opp->fbbuf + output;
+			opp->fbbuf = output;
+			opp->input = SSR(fbtmp, (9 - opp->fb));
+#else
+			opp->input = SSR(output, (8 - opp->fb));
+#endif
+		}
+		opp [1].input = output;
+	}
+}
+
+inline static Int32 OpSynthCarFb( OPLSOUND* sndp, OPL_OP* opp )
+{
+	if ( opp->enable )
+	{
+		Uint32 tll;
+		OpStep(sndp, opp);
+		tll = opp->tll + (opp->eg.phase >> EG_SHIFT);
+		tll = (tll >= (1 << TLLTBL_BITS)) ? LOG_KEYOFF : sndp->common.tll2logtbl [tll];
+		tll += opp->tl_ofs;
+#if TESTING_OPTIMIZE_AME
+		tll +=* opp->amin;
+#else
+		if ( opp->flag & FLAG_AME) tll += sndp->lfo [LFO_UNIT_AM].output;
+#endif
+		tll += opp->sintable [sndp->common.sintablemask & (opp->input + (opp->pg.phase >> PG_SHIFT))];
+		if ( opp->fb )
+		{
+#if USE_FBBUF
+			Int32 output, fbtmp;
+			output = LogToLin(sndp->logtbl, tll, -8 + ((LOG_LIN_BITS + 1) - (SINTBL_BITS + 2)));
+			fbtmp = opp->fbbuf + output;
+			opp->fbbuf = output;
+			opp->input = SSR(fbtmp, (9 - opp->fb));
+#else
+			Int32 output;
+			output = LogToLin(sndp->logtbl, tll, -8 + ((LOG_LIN_BITS + 1) - (SINTBL_BITS + 2)));
+			opp->input = SSR(output, (8 - opp->fb));
+#endif
+		}
+		return LogToLin(sndp->logtbl, tll + sndp->common.mastervolume, -8 + LOG_LIN_BITS - 19 - opp->lvl);
+	}
+	return 0;
+}
+
+inline static Int32 OpSynthCar( OPLSOUND* sndp, OPL_OP* opp )
+{
+	if ( opp->enable )
+	{
+		Uint32 tll;
+		OpStep(sndp, opp);
+		tll = opp->tll + (opp->eg.phase >> EG_SHIFT);
+		tll = (tll >= (1 << TLLTBL_BITS)) ? LOG_KEYOFF : sndp->common.tll2logtbl [tll];
+		tll += opp->tl_ofs;
+#if TESTING_OPTIMIZE_AME
+		tll += *opp->amin;
+#else
+		if ( opp->flag & FLAG_AME )
+			tll += sndp->lfo [LFO_UNIT_AM].output;
+#endif
+		tll += opp->sintable [sndp->common.sintablemask & (opp->input + (opp->pg.phase >> PG_SHIFT))];
+		return LogToLin(sndp->logtbl, tll + sndp->common.mastervolume, -8 + LOG_LIN_BITS - 19 - opp->lvl);
+	}
+	return 0;
+}
+
+inline static Int32 OpSynthTom( OPLSOUND* sndp, OPL_OP* opp )
+{
+	if ( opp->enable )
+	{
+		Uint32 tll;
+		OpStep(sndp, opp);
+		tll = opp->tll + (opp->eg.phase >> EG_SHIFT);
+		tll = (tll >= 128 - 16) ? LOG_KEYOFF : sndp->common.tll2logtbl [tll];
+		tll += opp->tl_ofs;
+		tll += opp->sintable [sndp->common.sintablemask & (opp->pg.phase >> PG_SHIFT)];
+		return LogToLin(sndp->logtbl, tll + sndp->common.mastervolume, -8 + LOG_LIN_BITS - 19 - opp->lvl);
+	}
+	return 0;
+}
+
+
+static Int32 OpSynthRym( OPLSOUND* sndp, OPL_OP* opp )
+{
+	if ( opp->enable )
+	{
+		Uint32 tll;
+		OpStepNG(sndp, opp);
+		tll = opp->tll + (opp->eg.phase >> EG_SHIFT) + 0x10/* +6dB */;
+		tll = (tll >= (1 << TLLTBL_BITS)) ? LOG_KEYOFF : sndp->common.tll2logtbl [tll];
+		tll += opp->tl_ofs;
+		tll += (opp->pg.rng & 1);
+		return LogToLin(sndp->logtbl, tll + sndp->common.mastervolume, -8 + LOG_LIN_BITS - 19 - opp->lvl);
+	}
+	return 0;
+}
+
+inline static void LfoStep(OPL_LFO* lfop )
+{
+	lfop->cnt += lfop->sps;
+	lfop->adr += lfop->cnt >> LFO_SHIFT;
+	lfop->cnt &= (1 << LFO_SHIFT) - 1;
+	lfop->output = lfop->table [lfop->adr & lfop->adrmask];
+}
+
+static int sndsynth( OPLSOUND* sndp )
+{
+	Int32 accum = 0;
+	if ( sndp->common.enable )
+	{
+		Uint32 i, rch;
+		for ( i = 0; i < LFO_UNIT_NUM; i++ )
+			LfoStep(&sndp->lfo [i]);
+		
+		rch = sndp->common.rmode ? 7 : 9;
+		for ( i = 0; i < rch; i++ )
+		{
+			if ( sndp->ch [i].op [0].modcar )
+				OpSynthMod(sndp, &sndp->ch [i].op [0]);
+			else
+				accum += OpSynthCarFb(sndp, &sndp->ch [i].op [0]);
+			accum += OpSynthCar(sndp, &sndp->ch [i].op [1]);
+		}
+		if ( sndp->common.rmode )
+		{
+			accum += OpSynthRym(sndp, &sndp->ch [7].op [0]);
+			accum += OpSynthRym(sndp, &sndp->ch [7].op [1]);
+			accum += OpSynthTom(sndp, &sndp->ch [8].op [0]);
+			accum += OpSynthRym(sndp, &sndp->ch [8].op [1]);
+		}
+	}
+	if ( sndp->deltatpcm )
+	{
+		accum += sndp->deltatpcm->synth(sndp->deltatpcm->ctx);
+	}
+#if 0
+	/* NISE DAC */
+	if ( accum >= 0 )
+		accum =  (Int32)(((Uint32) accum) & (((1 << 8) - 1) << (23 - 8)));
+	else
+		accum = -(Int32)(((Uint32)-accum) & (((1 << 8) - 1) << (23 - 8)));
+#endif
+	return accum;
+}
+
+static void sndvolume( OPLSOUND* sndp, Int32 volume )
+{
+	if ( sndp->deltatpcm) sndp->deltatpcm->volume(sndp->deltatpcm->ctx, volume);
+	volume = (volume << (LOG_BITS - 8)) << 1;
+	sndp->common.mastervolume = volume;
+}
+
+const static Uint8 op_table [0x20]=
+{
+	   0,   2,   4,   1,   3,   5,0xFF,0xFF,
+	   6,   8,  10,   7,   9,  11,0xFF,0xFF,
+	  12,  14,  16,  13,  15,  17,0xFF,0xFF,
+	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+};
+
+const static Uint8 mul_table [0x10]=
+{
+	 1+0, 2+0, 4+0, 2+4, 8+0, 8+2, 8+4,16-2,
+	16+0,16+2,16+4,16+4,16+8,16+8,32-2,32-2,
+};
+
+#define DB2TLL(x) (x * 2 / 375 )
+const static Uint8 ksl_table [8] [16]=
+{
+	{
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL(    0),
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL(    0),
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL(    0),
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL(    0),
+	},{
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL(    0),
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL(    0),
+		DB2TLL(    0), DB2TLL(  750), DB2TLL( 1125), DB2TLL( 1500),
+		DB2TLL( 1875), DB2TLL( 2250), DB2TLL( 2625), DB2TLL( 3000),
+	},{
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL(    0),
+		DB2TLL(    0), DB2TLL( 1125), DB2TLL( 1875), DB2TLL( 2625),
+		DB2TLL( 3000), DB2TLL( 3750), DB2TLL( 4125), DB2TLL( 4500),
+		DB2TLL( 4875), DB2TLL( 5250), DB2TLL( 5625), DB2TLL( 6000),
+	},{
+		DB2TLL(    0), DB2TLL(    0), DB2TLL(    0), DB2TLL( 1875),
+		DB2TLL( 3000), DB2TLL( 4125), DB2TLL( 4875), DB2TLL( 5625),
+		DB2TLL( 6000), DB2TLL( 6750), DB2TLL( 7125), DB2TLL( 7500),
+		DB2TLL( 7875), DB2TLL( 8250), DB2TLL( 8625), DB2TLL( 9000),
+	},{
+		DB2TLL(    0), DB2TLL(    0), DB2TLL( 3000), DB2TLL( 4875),
+		DB2TLL( 6000), DB2TLL( 7125), DB2TLL( 7875), DB2TLL( 8625),
+		DB2TLL( 9000), DB2TLL( 9750), DB2TLL(10125), DB2TLL(10500),
+		DB2TLL(10875), DB2TLL(11250), DB2TLL(11625), DB2TLL(12000),
+	},{
+		DB2TLL(    0), DB2TLL( 3000), DB2TLL( 6000), DB2TLL( 7875),
+		DB2TLL( 9000), DB2TLL(10125), DB2TLL(10875), DB2TLL(11625),
+		DB2TLL(12000), DB2TLL(12750), DB2TLL(13125), DB2TLL(13500),
+		DB2TLL(13875), DB2TLL(14250), DB2TLL(14625), DB2TLL(15000),
+	},{
+		DB2TLL(    0), DB2TLL( 6000), DB2TLL( 9000), DB2TLL(10875),
+		DB2TLL(12000), DB2TLL(13125), DB2TLL(13875), DB2TLL(14625),
+		DB2TLL(15000), DB2TLL(15750), DB2TLL(16125), DB2TLL(16500),
+		DB2TLL(16875), DB2TLL(17250), DB2TLL(17625), DB2TLL(18000),
+	},{
+		DB2TLL(    0), DB2TLL( 9000), DB2TLL(12000), DB2TLL(13875),
+		DB2TLL(15000), DB2TLL(16125), DB2TLL(16875), DB2TLL(17625),
+		DB2TLL(18000), DB2TLL(18750), DB2TLL(19125), DB2TLL(19500),
+		DB2TLL(19875), DB2TLL(20250), DB2TLL(20625), DB2TLL(21000),
+	}
+};
+#undef DB2TLL
+
+static Uint32 rateconvAR( OPLSOUND* sndp, Uint32 rrr, Uint32 ksr )
+{
+	if ( !rrr )
+		return 0;
+	rrr = rrr + (ksr >> 2);
+	if ( rrr >= 15)
+		return AR_PHASEMAX;
+	return sndp->common.ratetbla [ksr & 3] >> (CPS_SHIFTE + 1 - rrr);
+}
+
+static Uint32 rateconv( OPLSOUND* sndp, Uint32 rrr, Uint32 ksr )
+{
+	if ( !rrr )
+		return 0;
+	rrr = rrr + (ksr >> 2);
+	if ( rrr > 15 )
+		rrr = 15;
+	return sndp->common.ratetbl [ksr & 3] >> (CPS_SHIFTE + 1 - rrr);
+}
+
+static void OpUpdateWF( OPLSOUND* sndp, OPL_OP* opp )
+{
+	opp->sintable = sndp->opltbl->sin_table [opp->wf & sndp->common.wfe];
+}
+
+static void OpUpdatePG( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp )
+{
+	opp->pg.spd = (((chp->freqh << 8) + chp->freql) * opp->mul * sndp->common.cpsp) >> (CPS_SHIFTP - chp->blk);
+}
+
+static void OpUpdateEG( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp )
+{
+	Uint32 sr, rr;
+	opp->ksr = chp->kcode >> ((opp->flag & FLAG_KSR) ? 0 : 2);
+	opp->eg.dr_phasemax = opp->sl << (1 + 2 + EG_SHIFT);    /* 3dB->eg */
+	opp->eg.spd [EG_MODE_ATTACK] = rateconvAR(sndp, opp->ar, opp->ksr);
+	opp->eg.spd [EG_MODE_DECAY] = rateconv(sndp, opp->dr, opp->ksr);
+	if ( opp->flag & FLAG_EGT )
+	{
+		if ( opp->eg.mode == EG_MODE_SUSTINE )
+			opp->eg.mode = EG_MODE_SUSHOLD;
+		sr = 0;
+		rr = opp->rr;
+	}
+	else
+	{
+		if ( opp->eg.mode == EG_MODE_SUSHOLD )
+			opp->eg.mode = EG_MODE_SUSTINE;
+		sr = opp->rr;
+		rr = 7;
+	}
+	if ( chp->sus )
+	{
+		rr = 5;
+	}
+	opp->eg.spd [EG_MODE_SUSTINE] = rateconv(sndp, sr, opp->ksr);
+	opp->eg.spd [EG_MODE_RELEASE] = rateconv(sndp, rr, opp->ksr);
+}
+
+static void OpUpdateTLL( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp )
+{
+	opp->tll = (opp->tl + (chp->ksb >> opp->ksl)) << 1;
+}
+
+
+
+static void oplsetopmul( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp, Uint32 v )
+{
+	opp->flag &= ~(FLAG_AME | FLAG_PME | FLAG_EGT | FLAG_KSR);
+#if TESTING_OPTIMIZE_AME
+	if ( v & 0x80 )
+		opp->amin = &sndp->lfo [LFO_UNIT_AM].output; else opp->amin = &sndp->common.amzero;
+#else
+	if ( v & 0x80 )
+		opp->flag |= FLAG_AME;
+#endif
+	if ( v & 0x40 ) opp->flag |= FLAG_PME;
+	if ( v & 0x20 ) opp->flag |= FLAG_EGT;
+	if ( v & 0x10 ) opp->flag |= FLAG_KSR;
+	opp->mul = mul_table [v & 0x0F];
+	OpUpdateEG(sndp, chp, opp);
+	OpUpdatePG(sndp, chp, opp);
+}
+
+static void oplsetopkstl( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp, Uint32 v )
+{
+	opp->ksl = (v >> 6) ? (3 - (v >> 6)) : 15;  /* 0 / 1.5 / 3 / 6 db/OCT */
+	opp->tl = v & 0x3F; /* 0.75 db */
+	OpUpdateTLL(sndp, chp, opp);
+}
+
+static void oplsetopardr( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp, Uint32 v )
+{
+	opp->ar = v >> 4;
+	opp->dr = v & 0xF;
+	OpUpdateEG(sndp, chp, opp);
+}
+
+static void oplsetopslrr( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp, Uint32 v )
+{
+	opp->sl = v >> 4;
+	opp->rr = v & 0xF;
+	OpUpdateEG(sndp, chp, opp);
+}
+
+static void oplsetopwf( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp, Uint32 v )
+{
+	opp->wf = v & 0x3;
+	OpUpdateWF(sndp, opp);
+}
+
+static void oplsetopkey( OPLSOUND* sndp, OPL_OP* opp )
+{
+	Uint8 nextkey = ((sndp->common.rmode) && opp->rkey) || opp->key;
+	if ( opp->prevkey ^ nextkey )
+	{
+		opp->prevkey = nextkey;
+		if ( nextkey )
+		{
+			sndp->common.enable = 1;
+			opp->eg.mode = EG_MODE_ATTACK;
+			opp->eg.phase = EG_KEYOFF;
+			opp->enable = 1;
+			opp->eg.phasear = 0;
+		}
+		else if ( !opp->modcar && opp->eg.mode != EG_MODE_OFF )
+			opp->eg.mode = EG_MODE_RELEASE;
+	}
+}
+
+static void oplsetchfreql( OPLSOUND* sndp, OPL_CH* chp, Uint32 v )
+{
+	chp->freql = v & 0xFF;
+	chp->ksb = ksl_table [chp->blk] [(chp->freqh << 2) + (chp->freql >> 6)];
+	OpUpdatePG(sndp, chp, &chp->op [0]);
+	OpUpdatePG(sndp, chp, &chp->op [1]);
+	OpUpdateTLL(sndp, chp, &chp->op [0]);
+	OpUpdateTLL(sndp, chp, &chp->op [1]);
+}
+
+static void oplsetchfreqh( OPLSOUND* sndp, OPL_CH* chp, Uint32 v )
+{
+	Uint32 key = v & 0x20;
+	chp->kcode = (v >> 1) & 15;
+	chp->freqh = v & 3;
+	chp->blk = (v >> 2) & 7;
+	chp->op [0].key = chp->op [1].key = key;
+	oplsetopkey(sndp, &chp->op [0]);
+	oplsetopkey(sndp, &chp->op [1]);
+	chp->sus = 0;
+	chp->ksb = ksl_table [chp->blk] [(chp->freqh << 2) + (chp->freql >> 6)];
+	OpUpdateEG(sndp, chp, &chp->op [0]);
+	OpUpdateEG(sndp, chp, &chp->op [1]);
+	OpUpdatePG(sndp, chp, &chp->op [0]);
+	OpUpdatePG(sndp, chp, &chp->op [1]);
+	OpUpdateTLL(sndp, chp, &chp->op [0]);
+	OpUpdateTLL(sndp, chp, &chp->op [1]);
+}
+
+static void oplsetchfbcon( OPLSOUND* sndp, OPL_CH* chp, Uint32 v )
+{
+	chp->op [0].fb = (v >> 1) & 7;
+#if USE_FBBUF
+	chp->op [0].fbbuf = 0;
+#endif
+	chp->con = v & 1;
+	chp->op [0].modcar = (chp->con) ? 0 : 1;
+	OpUpdateEG(sndp, chp, &chp->op [0]);
+	chp->op [1].input = 0;
+}
+
+static void opllsetopvolume( OPLSOUND* sndp, OPL_CH* chp, OPL_OP* opp, Uint32 v )
+{
+	opp->tl = v;
+	OpUpdateTLL(sndp, chp, opp);
+}
+
+static void opllsetchfreql( OPLSOUND* sndp, OPL_CH* chp, Uint32 v )
+{
+	chp->freql = v & 0xFF;
+	chp->ksb = ksl_table [chp->blk] [(chp->freqh << 3) + (chp->freql >> 5)];
+	OpUpdatePG(sndp, chp, &chp->op [0]);
+	OpUpdatePG(sndp, chp, &chp->op [1]);
+	OpUpdateTLL(sndp, chp, &chp->op [0]);
+	OpUpdateTLL(sndp, chp, &chp->op [1]);
+}
+
+static void opllsetchfreqh( OPLSOUND* sndp, OPL_CH* chp, Uint32 v )
+{
+	Uint32 key = v & 0x10;
+	chp->kcode = v & 15;
+	chp->freqh = v & 1;
+	chp->blk = (v >> 1) & 7;
+	chp->op [0].key = chp->op [1].key = key;
+	oplsetopkey(sndp, &chp->op [0]);
+	oplsetopkey(sndp, &chp->op [1]);
+	chp->sus = v & 0x20;
+	chp->ksb = ksl_table [chp->blk] [(chp->freqh << 3) + (chp->freql >> 5)];
+	OpUpdateEG(sndp, chp, &chp->op [0]);
+	OpUpdateEG(sndp, chp, &chp->op [1]);
+	OpUpdatePG(sndp, chp, &chp->op [0]);
+	OpUpdatePG(sndp, chp, &chp->op [1]);
+	OpUpdateTLL(sndp, chp, &chp->op [0]);
+	OpUpdateTLL(sndp, chp, &chp->op [1]);
+}
+
+static void SetOpTone( OPLSOUND* sndp, OPL_OP* opp, Uint8* tonep )
+{
+	opp->flag &= ~(FLAG_AME | FLAG_PME | FLAG_EGT | FLAG_KSR);
+#if TESTING_OPTIMIZE_AME
+	if ( tonep [0] & 0x80 ) opp->amin = &sndp->lfo [LFO_UNIT_AM].output; else opp->amin = &sndp->common.amzero;
+#else
+	if ( tonep [0] & 0x80 ) opp->flag |= FLAG_AME;
+#endif
+	if ( tonep [0] & 0x40 ) opp->flag |= FLAG_PME;
+	if ( tonep [0] & 0x20 ) opp->flag |= FLAG_EGT;
+	if ( tonep [0] & 0x10 ) opp->flag |= FLAG_KSR;
+	opp->mul = mul_table [tonep [0] & 0x0F] << 1;
+	opp->ksl = (tonep [2] >> 6) ? (3 - (tonep [2] >> 6)) : 15;
+	opp->ar = tonep [4] >> 4;
+	opp->dr = tonep [4] & 0xF;
+	opp->sl = tonep [6] >> 4;
+	opp->rr = tonep [6] & 0xF;
+}
+static void SetChTone( OPLSOUND* sndp, OPL_CH* chp, Uint8* tonep, Uint8* tlofsp )
+{
+	Uint32 op;
+	for ( op = 0; op < 2; op++ )
+		SetOpTone(sndp, &chp->op [op], &tonep [op]);
+	chp->op [0].tl_ofs = (tlofsp [0] ^ 0x80) << (LOG_BITS - 4 + 1);
+	chp->op [1].tl_ofs = (tlofsp [1] ^ 0x80) << (LOG_BITS - 4 + 1);
+	chp->op [0].tl = tonep [2] & 0x3F;
+	chp->op [0].fb = tonep [3] & 0x7;
+	chp->op [0].wf = (tonep [3] >> 3) & 1;
+	chp->op [1].wf = (tonep [3] >> 4) & 1;
+#if USE_FBBUF
+	chp->op [0].fbbuf = 0;
+#endif
+	chp->op [1].input = 0;
+	OpUpdateWF(sndp, &chp->op [0]);
+	OpUpdateWF(sndp, &chp->op [1]);
+	OpUpdateEG(sndp, chp, &chp->op [0]);
+	OpUpdateEG(sndp, chp, &chp->op [1]);
+	OpUpdatePG(sndp, chp, &chp->op [0]);
+	OpUpdatePG(sndp, chp, &chp->op [1]);
+	OpUpdateTLL(sndp, chp, &chp->op [0]);
+	OpUpdateTLL(sndp, chp, &chp->op [1]);
+}
+
+static void opllsetchtone( OPLSOUND* sndp, OPL_CH* chp, Uint32 tone )
+{
+	SetChTone(sndp, chp, &sndp->regs [OPLL_INST_WORK + (tone << 3)], &sndp->regs [OPLL_INST_WORK2 + (tone << 1) + 0]);
+}
+
+static void recovercon( OPLSOUND* sndp, OPL_CH* chp )
+{
+	chp->op [0].modcar = (chp->con) ? 0 : 1;
+	chp->op [0].lvl = chp->con ? 1 : 0;
+	chp->op [1].lvl = 1;
+	OpUpdateEG(sndp, chp, &chp->op [0]);
+	chp->op [1].input = 0;
+}
+
+static void initrc_common( OPLSOUND* sndp, Uint32 rmode )
+{
+	if ( rmode )
+	{
+		/* BD */
+		sndp->ch [6].op [0].modcar = 1;
+		sndp->ch [6].op [0].lvl = 0;
+		OpUpdateEG(sndp, &sndp->ch [6], &sndp->ch [6].op [0]);
+		sndp->ch [6].op [1].input = 0;
+		sndp->ch [6].op [1].lvl = 2;
+		/* CYM */
+		sndp->ch [7].op [0].modcar = 0;
+		sndp->ch [7].op [0].lvl = 1;
+		OpUpdateEG(sndp, &sndp->ch [7], &sndp->ch [7].op [0]);
+		/* SD */
+		sndp->ch [7].op [1].input = 0;
+		sndp->ch [7].op [1].lvl = 2;
+		/* TOM */
+		sndp->ch [8].op [0].modcar = 0;
+		sndp->ch [8].op [0].lvl = 2;
+		OpUpdateEG(sndp, &sndp->ch [8], &sndp->ch [8].op [0]);
+		/* HH */
+		sndp->ch [8].op [1].input = 0;
+		sndp->ch [8].op [1].lvl = 1;
+	}
+	else
+	{
+		recovercon(sndp, &sndp->ch [6]);
+		if ( !sndp->ch [6].op [0].key ) SetOpOff(&sndp->ch [6].op [0]);
+		if ( !sndp->ch [6].op [1].key ) SetOpOff(&sndp->ch [6].op [1]);
+		recovercon(sndp, &sndp->ch [7]);
+		if ( !sndp->ch [7].op [0].key ) SetOpOff(&sndp->ch [7].op [0]);
+		if ( !sndp->ch [7].op [1].key ) SetOpOff(&sndp->ch [7].op [1]);
+		recovercon(sndp, &sndp->ch [8]);
+		if ( !sndp->ch [8].op [0].key ) SetOpOff(&sndp->ch [8].op [0]);
+		if ( !sndp->ch [8].op [1].key ) SetOpOff(&sndp->ch [8].op [1]);
+	}
+}
+
+static void oplsetrc( OPLSOUND* sndp, Uint32 rc )
+{
+	sndp->lfo [LFO_UNIT_AM].table = (rc & 0x80) ? sndp->opltbl->am_table1 : sndp->opltbl->am_table2;
+	sndp->lfo [LFO_UNIT_PM].table = (rc & 0x40) ? sndp->opltbl->pm_table1 : sndp->opltbl->pm_table2;
+	if ( (sndp->common.rmode ^ rc) & 0x20 )
+	{
+		if ( rc & 0x20 )
+		{
+#if 0
+			static Uint8 volini [2] = { 0, 0 };
+			static Uint8 bdtone [8] = { 0x04, 0x20, 0x28, 0x00, 0xDF, 0xF8, 0xFF, 0xF8 };
+			SetChTone(sndp, &sndp->ch [6], bdtone, volini);
+			SetChTone(sndp, &sndp->ch [7], &romtone [0] [0x11 << 4], volini);
+			SetChTone(sndp, &sndp->ch [8], &romtone [0] [0x12 << 4], volini);
+#endif
+			sndp->ch [7].op [0].nst = PG_SHIFT + 4;
+			sndp->ch [7].op [1].nst = PG_SHIFT + 6;
+			sndp->ch [8].op [1].nst = PG_SHIFT + 5;
+		}
+		initrc_common(sndp, rc & 0x20);
+	}
+	sndp->common.rmode = rc & 0x20;
+	sndp->common.rc = rc & 0x1F;
+	/* BD */
+	sndp->ch [6].op [0].rkey = sndp->ch [6].op [1].rkey = rc & 0x10;
+	oplsetopkey(sndp, &sndp->ch [6].op [0]);
+	oplsetopkey(sndp, &sndp->ch [6].op [1]);
+	/* CYM */
+	sndp->ch [7].op [0].rkey = rc & 0x01;
+	oplsetopkey(sndp, &sndp->ch [7].op [0]);
+	/* SD */
+	sndp->ch [7].op [1].rkey = rc & 0x08;
+	oplsetopkey(sndp, &sndp->ch [7].op [1]);
+	/* TOM */
+	sndp->ch [8].op [0].rkey = rc & 0x04;
+	oplsetopkey(sndp, &sndp->ch [8].op [0]);
+	/* HH */
+	sndp->ch [8].op [1].rkey = rc & 0x02;
+	oplsetopkey(sndp, &sndp->ch [8].op [1]);
+}
+
+static void opllsetrc( OPLSOUND* sndp, Uint32 rc )
+{
+	if ( (sndp->common.rmode ^ rc) & 0x20 )
+	{
+		if ( rc & 0x20 )
+		{
+			opllsetchtone(sndp, &sndp->ch [6], 0x10);
+			opllsetchtone(sndp, &sndp->ch [7], 0x11);
+			opllsetchtone(sndp, &sndp->ch [8], 0x12);
+			opllsetopvolume(sndp, &sndp->ch [7], &sndp->ch [7].op [0], (sndp->regs [0x37] & 0xF0) >> 2);
+			opllsetopvolume(sndp, &sndp->ch [8], &sndp->ch [8].op [0], (sndp->regs [0x38] & 0xF0) >> 2);
+			sndp->ch [7].op [0].nst = PG_SHIFT + 5;
+			sndp->ch [7].op [1].nst = PG_SHIFT + 5;
+			sndp->ch [8].op [1].nst = PG_SHIFT + 5;
+		}
+		else
+		{
+			opllsetchtone(sndp, &sndp->ch [6], sndp->regs [0x36]>>4);
+			opllsetchtone(sndp, &sndp->ch [7], sndp->regs [0x37]>>4);
+			opllsetchtone(sndp, &sndp->ch [8], sndp->regs [0x38]>>4);
+		}
+		initrc_common(sndp, rc & 0x20);
+	}
+	sndp->common.rmode = rc & 0x20;
+	sndp->common.rc = rc & 0x1F;
+	/* BD */
+	sndp->ch [6].op [0].rkey = sndp->ch [6].op [1].rkey = rc & 0x10;
+	oplsetopkey(sndp, &sndp->ch [6].op [0]);
+	oplsetopkey(sndp, &sndp->ch [6].op [1]);
+	/* CYM */
+	sndp->ch [7].op [0].rkey = rc & 0x01;
+	oplsetopkey(sndp, &sndp->ch [7].op [0]);
+	/* SD */
+	sndp->ch [7].op [1].rkey = rc & 0x08;
+	oplsetopkey(sndp, &sndp->ch [7].op [1]);
+	/* TOM */
+	sndp->ch [8].op [0].rkey = rc & 0x04;
+	oplsetopkey(sndp, &sndp->ch [8].op [0]);
+	/* HH */
+	sndp->ch [8].op [1].rkey = rc & 0x02;
+	oplsetopkey(sndp, &sndp->ch [8].op [1]);
+}
+
+#define OPLSETOP(func) { \
+	Uint32 op = op_table [a & 0x1F]; \
+	if ( op != 0xFF) func(sndp, &sndp->ch [op >> 1], &sndp->ch [op >> 1].op [op & 1], v); \
+}
+
+__inline static void oplwritereg( OPLSOUND* sndp, Uint32 a, Uint32 v )
+{
+	switch ( a >> 5 )
+	{
+	default:
+		NEVER_REACH
+	
+	case 0:
+		switch ( a & 0x1F )
+		{
+		case 0x01:
+			if ( sndp->opl_type == OPL_TYPE_OPL2 )
+			{
+				Uint32 i;
+				sndp->common.wfe = (v & 0x20) ? 3 : 0;
+				for ( i = 0; i < 9; i++ )
+				{
+					OpUpdateWF(sndp, &sndp->ch [i].op [0]);
+					OpUpdateWF(sndp, &sndp->ch [i].op [1]);
+				}
+			}
+			break;
+		
+		case 0x08:
+			/* CSM mode */
+		case 0x07:  case 0x09:  case 0x0A:  case 0x0B:  case 0x0C:
+		case 0x0D:  case 0x0E:  case 0x0F:  case 0x10:  case 0x11:  case 0x12:
+			if ( sndp->deltatpcm )
+				sndp->deltatpcm->write(sndp->deltatpcm->ctx, a - 0x07, v);
+			break;
+		}
+		break;
+	
+	case 1: OPLSETOP(oplsetopmul); break;
+	case 2: OPLSETOP(oplsetopkstl); break;
+	case 3: OPLSETOP(oplsetopardr); break;
+	case 4: OPLSETOP(oplsetopslrr); break;
+	case 7: OPLSETOP(oplsetopwf); break;
+	case 5:
+		if ( (a & 0x1F) == (0xBD & 0x1F) )
+			oplsetrc(sndp, v);
+		else if ( (a & 0x1F) < 9 )
+			oplsetchfreql(sndp, &sndp->ch [a & 0xF], v);
+		else if ( (a & 0xF) < 9 )
+			oplsetchfreqh(sndp, &sndp->ch [a & 0xF], v);
+		break;
+	
+	case 6:
+		if ( (a & 0x1F) < 9) oplsetchfbcon(sndp, &sndp->ch [a & 0xF], v);
+		break;
+	}
+}
+
+static void oplwrite( OPLSOUND* sndp, Uint32 a, Uint32 v )
+{
+	if ( a & 1 )
+	{
+		sndp->regs [sndp->common.adr] = v;
+		oplwritereg(sndp, sndp->common.adr, v);
+	}
+	else
+		sndp->common.adr = v;
+}
+
+static Uint32 oplread( OPLSOUND* sndp, Uint32 a )
+{
+	if ( a & 1 )
+		return sndp->regs [sndp->common.adr];
+	else
+		return 0x80;
+}
+
+__inline static void opllwritereg( OPLSOUND* sndp, Uint32 a, Uint32 v )
+{
+	switch ( a >> 3 )
+	{
+	default:
+		NEVER_REACH
+	case 0:
+		sndp->regs [OPLL_INST_WORK + (a & 7)] = v;
+		break;
+	
+	case 1:
+		if ( a == 0xE) opllsetrc(sndp, v & 0x3F);
+		break;
+	
+	case 2:
+	case 3:
+		a &= 0xF;
+		if ( a < 9) opllsetchfreql(sndp, &sndp->ch [a], v);
+		break;
+	
+	case 4:
+	case 5:
+		a &= 0xF;
+		if ( a < 9) opllsetchfreqh(sndp, &sndp->ch [a], v);
+		break;
+	
+	case 6:
+	case 7:
+		a &= 0xF;
+		if ( a < 9 )
+		{
+			if ( (sndp->common.rmode) && (a >= 6) )
+			{
+				if ( a != 6) opllsetopvolume(sndp, &sndp->ch [a], &sndp->ch [a].op [0], (v & 0xF0) >> 2);
+			}
+			else
+			{
+				opllsetchtone(sndp, &sndp->ch [a], (v & 0xF0) >> 4);
+			}
+			opllsetopvolume(sndp, &sndp->ch [a], &sndp->ch [a].op [1], (v & 0xF) << 2);
+		}
+		break;
+	}
+}
+
+static void opllwrite( OPLSOUND* sndp, Uint32 a, Uint32 v )
+{
+	if ( a & 1 )
+	{
+		if ( sndp->common.adr < 0x40 )
+		{
+			sndp->regs [sndp->common.adr] = v;
+			opllwritereg(sndp, sndp->common.adr, v);
+		}
+	}
+	else
+		sndp->common.adr = v;
+}
+
+static Uint32 opllread( OPLSOUND* sndp, Uint32 a )
+{
+	return 0xFF;
+}
+
+static void opreset( OPLSOUND* sndp, OPL_OP* opp )
+{
+	/* XMEMSET(opp, 0, sizeof(OPL_OP)); */
+	SetOpOff(opp);
+	opp->tl_ofs = 0x80 << (LOG_BITS - 4 + 1);
+#if TESTING_OPTIMIZE_AME
+	opp->amin = &sndp->common.amzero;
+#endif
+	opp->pg.rng = 0xFFFF;
+}
+
+static void chreset( OPLSOUND* sndp, OPL_CH* chp, Uint32 clock, Uint32 freq )
+{
+	Uint32 op;
+	XMEMSET(chp, 0, sizeof(OPL_CH));
+	for ( op = 0; op < 2; op++ )
+	{
+		opreset(sndp, &chp->op [op]);
+	}
+	recovercon(sndp, chp);
+}
+
+static void sndreset( OPLSOUND* sndp, Uint32 clock, Uint32 freq )
+{
+	Uint32 i, cpse;
+	XMEMSET(&sndp->common, 0, sizeof(sndp->common));
+	XMEMSET(&sndp->lfo [LFO_UNIT_AM], 0, sizeof(OPL_LFO));
+	sndp->lfo [LFO_UNIT_AM].sps = DivFix(37 * (1 << AMTBL_BITS), freq * 10, LFO_SHIFT);
+	sndp->lfo [LFO_UNIT_AM].adrmask = (1 << AMTBL_BITS) - 1;
+	sndp->lfo [LFO_UNIT_AM].table = sndp->opltbl->am_table1;
+	XMEMSET(&sndp->lfo [LFO_UNIT_PM], 0, sizeof(OPL_LFO));
+	sndp->lfo [LFO_UNIT_PM].sps = DivFix(64 * (1 << PMTBL_BITS), freq * 10, LFO_SHIFT);
+	sndp->lfo [LFO_UNIT_PM].adrmask = (1 << PMTBL_BITS) - 1;
+	sndp->lfo [LFO_UNIT_PM].table = sndp->opltbl->pm_table1;
+	sndp->common.cpsp = DivFix(clock, 72 * freq, CPS_SHIFTP);
+	cpse = DivFix(clock, 72 * freq, CPS_SHIFTE);
+	for ( i = 0; i < 4; i++ )
+	{
+		sndp->common.ratetbl [i] = (i + 4) * cpse;
+		sndp->common.ratetbla [i] = 3 * sndp->common.ratetbl [i];
+	}
+	sndp->common.tll2logtbl = sndp->opltbl->tll2log_table;
+	sndp->common.sintablemask = (1 << SINTBL_BITS) - 1;
+	
+	for ( i = 0; i < 9; i++ )
+		chreset(sndp, &sndp->ch [i], clock, freq);
+	
+	if ( sndp->deltatpcm )
+		sndp->deltatpcm->reset(sndp->deltatpcm->ctx, clock, freq);
+	
+	if ( sndp->opl_type & OPL_TYPE_OPL )
+	{
+		XMEMSET(&sndp->regs, 0, 0x100);
+		sndp->common.ar_table = sndp->opltbl->ar_tablepow;
+		sndp->common.sintablemask -= (1 << (SINTBL_BITS - 11)) - 1;
+		for ( i = 0x0; i < 0x100; i++ )
+		{
+			oplwrite(sndp, 0, i);
+			oplwrite(sndp, 1, 0x00);
+		}
+		for ( i = 0xA0; i < 0xA9; i++ )
+		{
+			oplwrite(sndp, 0, 0xA0 + i);
+			oplwrite(sndp, 1, 0x40);
+			oplwrite(sndp, 0, 0xB0 + i);
+			oplwrite(sndp, 1, 0x0E);
+		}
+	}
+	else
+	{
+		const static Uint8 fmbios_initdata [9] = "\x30\x10\x20\x20\xfb\xb2\xf3\xf3";
+		XMEMSET(&sndp->regs, 0, 0x40);
+		sndp->common.ar_table = sndp->opltbl->ar_tablelog;
+		sndp->common.wfe = 1;
+		sndp->common.sintablemask -= (1 << (SINTBL_BITS - 8)) - 1;
+		for ( i = 0; i < sizeof(fmbios_initdata)-1; i++ )
+		{
+			opllwrite(sndp, 0, i);
+			opllwrite(sndp, 1, fmbios_initdata [i]);
+		}
+		opllwrite(sndp, 0, 0x0E);
+		opllwrite(sndp, 1, 0x00);
+		opllwrite(sndp, 0, 0x0F);
+		opllwrite(sndp, 1, 0x00);
+		for ( i = 0; i < 9; i++ )
+		{
+			opllwrite(sndp, 0, 0x10 + i);
+			opllwrite(sndp, 1, 0x20);
+			opllwrite(sndp, 0, 0x20 + i);
+			opllwrite(sndp, 1, 0x07);
+			opllwrite(sndp, 0, 0x30 + i);
+			opllwrite(sndp, 1, 0xB3);
+		}
+	}
+}
+
+static void oplsetinst( OPLSOUND* sndp, Uint32 n, void* p, Uint32 l )
+{
+	if ( sndp->deltatpcm) sndp->deltatpcm->setinst(sndp->deltatpcm->ctx, n, p, l);
+}
+
+__inline static Uint32 GetDwordLE(Uint8* p )
+{
+	return p [0] | (p [1] << 8) | (p [2] << 16) | (p [3] << 24);
+}
+#define GetDwordLEM(p) (Uint32)((((Uint8* )p) [0] | (((Uint8* )p) [1] << 8) | (((Uint8* )p) [2] << 16) | (((Uint8* )p) [3] << 24)) )
+
+static void opllsetinst( OPLSOUND* sndp, Uint32 n, Uint8* p, Uint32 l )
+{
+	Int32 i, j, sb = 9;
+	if ( n )
+		return;
+	if ( (GetDwordLE(p) & 0xF0FFFFFF) == GetDwordLEM("ILL0") )
+	{
+		if ( 0 < p [4] && p [4] <= SINTBL_BITS) sb = p [4];
+		for ( j = 1; j < 16 + 3; j++ )
+			for ( i = 0; i < 8; i++ )
+				sndp->regs [OPLL_INST_WORK + (j << 3) + i] = p [(j << 4) + i];
+		for ( j = 0; j < 16 + 3; j++ )
+		{
+			sndp->regs [OPLL_INST_WORK2 + (j << 1) + 0] = p [(j << 4) + 8];
+			sndp->regs [OPLL_INST_WORK2 + (j << 1) + 1] = p [(j << 4) + 9];
+		}
+	}
+	else
+	{
+		for ( j = 1; j < 16; j++ )
+			for ( i = 0; i < 8; i++ )
+				sndp->regs [OPLL_INST_WORK + (j << 3) + i] = p [((j - 1) << 3) + i];
+	}
+	sndp->common.sintablemask =  (1 <<  SINTBL_BITS)       - 1;
+	sndp->common.sintablemask -= (1 << (SINTBL_BITS - sb)) - 1;
+}
+
+static void sndrelease( OPLSOUND* sndp )
+{
+	if ( sndp->logtbl) sndp->logtbl->release(sndp->logtbl->ctx);
+	if ( sndp->opltbl) sndp->opltbl->release(sndp->opltbl->ctx);
+	if ( sndp->deltatpcm) sndp->deltatpcm->release(sndp->deltatpcm->ctx);
+	XFREE(sndp);
+}
+
+KMIF_SOUND_DEVICE* OPLSoundAlloc(Uint32 opl_type )
+{
+	OPLSOUND* sndp;
+	sndp = (OPLSOUND*) XMALLOC(sizeof(OPLSOUND));
+	if ( !sndp) return 0;
+	sndp->opl_type = opl_type;
+	sndp->kmif.ctx = sndp;
+	sndp->kmif.release = (void (*)( void* )) sndrelease;
+	sndp->kmif.volume = (void (*)( void*, int )) sndvolume;
+	sndp->kmif.reset = (void (*)( void*, Uint32, Uint32 )) sndreset;
+	sndp->kmif.synth = (int (*)( void* )) sndsynth;
+	if ( sndp->opl_type == OPL_TYPE_MSXAUDIO )
+	{
+		sndp->deltatpcm = YMDELTATPCMSoundAlloc(YMDELTATPCM_TYPE_Y8950);
+	}
+	else
+		sndp->deltatpcm = 0;
+	if ( sndp->opl_type & OPL_TYPE_OPL )
+	{
+		sndp->kmif.write = (void (*)( void*, Uint32, Uint32 )) oplwrite;
+		sndp->kmif.read = (Uint32 (*)( void*, Uint32 )) oplread;
+		sndp->kmif.setinst = (void (*)( void*, Uint32, void*, Uint32 )) oplsetinst;
+	}
+	else
+	{
+		sndp->kmif.write = (void (*)( void*, Uint32, Uint32 )) opllwrite;
+		sndp->kmif.read = (Uint32 (*)( void*, Uint32 )) opllread;
+		sndp->kmif.setinst = (void (*)( void*, Uint32, void*, Uint32 )) opllsetinst;
+		switch ( sndp->opl_type )
+		{
+		case OPL_TYPE_OPLL:
+		case OPL_TYPE_MSXMUSIC:
+			opllsetinst(sndp, 0, romtone [0], 16 * 19);
+			break;
+		
+		case OPL_TYPE_SMSFMUNIT:
+			opllsetinst(sndp, 0, romtone [1], 16 * 19);
+			break;
+		
+		case OPL_TYPE_VRC7:
+			opllsetinst(sndp, 0, romtone [2], 16 * 19);
+			break;
+		}
+	}
+	sndp->logtbl = LogTableAddRef();
+	sndp->opltbl = OplTableAddRef();
+	if ( !sndp->logtbl || !sndp->opltbl )
+	{
+		sndrelease(sndp);
+		return 0;
+	}
+
+	return &sndp->kmif;
+}
diff -Nur orig/source/gme/src/s_opl.h mod/source/gme/src/s_opl.h
--- orig/source/gme/src/s_opl.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_opl.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,26 @@
+#ifndef S_OPL_H__
+#define S_OPL_H__
+
+#include "kmsnddev.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum {
+	OPL_TYPE_OPLL       = 0x10, /* YAMAHA YM2413 */
+	OPL_TYPE_MSXMUSIC   = 0x11, /* YAMAHA YM2413 */
+	OPL_TYPE_SMSFMUNIT  = 0x12, /* YAMAHA YM2413? */
+	OPL_TYPE_VRC7       = 0x13, /* KONAMI 053982 VRV VII */
+	OPL_TYPE_OPL        = 0x20, /* YAMAHA YM3526 */
+	OPL_TYPE_MSXAUDIO   = 0x21, /* YAMAHA Y8950 */
+	OPL_TYPE_OPL2       = 0x22  /* YAMAHA YM3812 */
+};
+
+KMIF_SOUND_DEVICE *OPLSoundAlloc(Uint32 opl_type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_OPL_H__ */
diff -Nur orig/source/gme/src/s_opltbl.c mod/source/gme/src/s_opltbl.c
--- orig/source/gme/src/s_opltbl.c	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_opltbl.c	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,136 @@
+#include "nestypes.h"
+#include "s_logtbl.h"
+#include "s_opltbl.h"
+
+#if STATIC_TABLES
+
+static void OplTableRelease(void *ctx)
+{
+}
+
+static KMIF_OPLTABLE opl_static_tables = {
+	&opl_static_tables;
+	OplTableRelease,
+#include "s_oplt.h"
+};
+
+KMIF_OPLTABLE *OplTableAddRef(void)
+{
+	opl_static_tables.release = OplTableRelease;
+	return &opl_static_tables;
+}
+
+#else
+
+#include <math.h>
+#ifndef M_PI
+#ifdef PI
+#define M_PI PI
+#else
+#define M_PI            3.14159265358979323846
+#endif
+#endif
+
+#define AM_DEPTH1 4.8  /* dB */
+#define AM_DEPTH2 1.0  /* dB */
+#define PM_DEPTH1 14.0 /* cent */
+#define PM_DEPTH2  7.0 /* cent */
+#define LOG_KEYOFF (15 << (LOG_BITS + 1))
+
+#define DB0375_TO_LOG(x) ((Uint32)(0.375 * (1 << (LOG_BITS + x)) / 10))
+
+#define AR_OFF (128 << ARTBL_SHIFT)
+#define AR_MAX (127 << ARTBL_SHIFT)
+
+
+static volatile Uint32 opl_tables_mutex = 0;
+static Uint32 opl_tables_refcount = 0;
+static KMIF_OPLTABLE *opl_tables = 0;
+
+static void OplTableRelease(void *ctx)
+{
+	++opl_tables_mutex;
+	while (opl_tables_mutex != 1)
+	{
+		XSLEEP(0);
+	}
+	opl_tables_refcount--;
+	if (!opl_tables_refcount)
+	{
+		XFREE(ctx);
+		opl_tables = 0;
+	}
+	--opl_tables_mutex;
+}
+
+static void OplTableCalc(KMIF_OPLTABLE *tbl)
+{
+	Uint32 u, u2, i;
+	tbl->sin_table[0][0] = tbl->sin_table[0][1 << (SINTBL_BITS - 1)] = LOG_KEYOFF;
+	for (i = 1 ;i < (1 << (SINTBL_BITS - 1)); i++)
+	{
+		double d;
+		d = (1 << LOG_BITS) * -(log(sin(2.0 * M_PI * ((double)i) / (1 << SINTBL_BITS))) / log(2));
+		if (d > (LOG_KEYOFF >> 1)) d = (LOG_KEYOFF >> 1);
+		tbl->sin_table[0][i] = ((Uint32)d) << 1;
+		tbl->sin_table[0][i + (1 << (SINTBL_BITS - 1))] = (((Uint32)d) << 1) + 1;
+	}
+	for (i = 0 ;i < (1 << SINTBL_BITS); i++)
+	{
+		tbl->sin_table[1][i] = (tbl->sin_table[0][i] & 1) ? tbl->sin_table[0][0] : tbl->sin_table[0][i];
+		tbl->sin_table[2][i] = tbl->sin_table[0][i] & ~1;
+		tbl->sin_table[3][i] =  (i & (1 << (SINTBL_BITS - 2))) ? LOG_KEYOFF : tbl->sin_table[2][i];
+	}
+	for (i = 0; i < (1 << TLLTBL_BITS); i++)
+	{
+		tbl->tll2log_table[i] = (i * DB0375_TO_LOG(0)) << 1;
+	}
+	for (i = 0; i < (1 << AMTBL_BITS); i++)
+	{
+		u  = (Uint32)((1 + sin(2 * M_PI * ((double)i) / (1 << AMTBL_BITS))) * ((1 << LOG_BITS) * AM_DEPTH1 / 20.0));
+		u2 = (Uint32)((1 + sin(2 * M_PI * ((double)i) / (1 << AMTBL_BITS))) * ((1 << LOG_BITS) * AM_DEPTH2 / 20.0));
+		tbl->am_table1[i] = u << 1;
+		tbl->am_table2[i] = u2 << 1;
+	}
+	for (i = 0; i < (1 << PMTBL_BITS); i++)
+	{
+		u  = (Uint32)((1 << PM_SHIFT) * pow(2, sin(2 * M_PI * ((double)i) / (1 << PMTBL_BITS)) * PM_DEPTH1 / 1200.0));
+		u2 = (Uint32)((1 << PM_SHIFT) * pow(2, sin(2 * M_PI * ((double)i) / (1 << PMTBL_BITS)) * PM_DEPTH2 / 1200.0));
+		tbl->pm_table1[i] = u;
+		tbl->pm_table2[i] = u2;
+	}
+
+	for (i = 0; i < (1 << ARTBL_BITS); i++)
+	{
+		u = (Uint32)(((double)AR_MAX) * (1 - log(1 + i) / log(1 << ARTBL_BITS)));
+		tbl->ar_tablelog[i] = u;
+#if 1
+		u = (Uint32)(((double)AR_MAX) * (pow(1 - i / (double)(1 << ARTBL_BITS), 8)));
+		tbl->ar_tablepow[i] = u;
+#endif
+	}
+}
+
+KMIF_OPLTABLE *OplTableAddRef(void)
+{
+	++opl_tables_mutex;
+	while (opl_tables_mutex != 1)
+	{
+		XSLEEP(0);
+	}
+	if (!opl_tables_refcount)
+	{
+		opl_tables = (KMIF_OPLTABLE*) XMALLOC(sizeof(KMIF_OPLTABLE));
+		if (opl_tables)
+		{
+			opl_tables->ctx = opl_tables;
+			opl_tables->release = OplTableRelease;
+			OplTableCalc(opl_tables);
+		}
+	}
+	if (opl_tables) opl_tables_refcount++;
+	--opl_tables_mutex;
+	return opl_tables;
+}
+
+#endif
diff -Nur orig/source/gme/src/s_opltbl.h mod/source/gme/src/s_opltbl.h
--- orig/source/gme/src/s_opltbl.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/s_opltbl.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,38 @@
+#ifndef S_OPLTBL_H__
+#define S_OPLTBL_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SINTBL_BITS 11
+#define AMTBL_BITS 8
+#define PMTBL_BITS 8
+#define PM_SHIFT 9
+#define ARTBL_BITS 7
+#define ARTBL_SHIFT 20
+#define TLLTBL_BITS 7
+
+typedef struct
+{
+	void *ctx;
+	void (*release)(void *ctx);
+	Uint32 sin_table[4][1 << SINTBL_BITS];
+	Uint32 tll2log_table[1 << TLLTBL_BITS];
+	Uint32 ar_tablelog[1 << ARTBL_BITS];
+	Uint32 am_table1[1 << AMTBL_BITS];
+	Uint32 pm_table1[1 << PMTBL_BITS];
+#if 1
+	Uint32 ar_tablepow[1 << ARTBL_BITS];
+#endif
+	Uint32 am_table2[1 << AMTBL_BITS];
+	Uint32 pm_table2[1 << PMTBL_BITS];
+} KMIF_OPLTABLE;
+
+KMIF_OPLTABLE *OplTableAddRef(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* S_OPLTBL_H__ */
diff -Nur orig/source/gme/src/Spc_Cpu.cpp mod/source/gme/src/Spc_Cpu.cpp
--- orig/source/gme/src/Spc_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Spc_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,562 @@
+// Core SPC emulation: CPU, timers, SMP registers, memory
+
+// snes_spc 0.9.0. http://www.slack.net/~ant/
+
+#include "Snes_Spc.h"
+
+/* Copyright (C) 2004-2007 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#define RAM         (m.ram.ram)
+#define REGS        (m.smp_regs [0])
+#define REGS_IN     (m.smp_regs [1])
+
+// (n ? n : 256)
+#define IF_0_THEN_256( n ) ((uint8_t) ((n) - 1) + 1)
+
+// Note: SPC_MORE_ACCURACY exists mainly so I can run my validation tests, which
+// do crazy echo buffer accesses.
+#ifndef SPC_MORE_ACCURACY
+	#define SPC_MORE_ACCURACY 0
+#endif
+
+
+//// Timers
+
+#if SPC_DISABLE_TEMPO
+	#define TIMER_DIV( t, n ) ((n) >> t->prescaler)
+	#define TIMER_MUL( t, n ) ((n) << t->prescaler)
+#else
+	#define TIMER_DIV( t, n ) ((n) / t->prescaler)
+	#define TIMER_MUL( t, n ) ((n) * t->prescaler)
+#endif
+
+Snes_Spc::Timer* Snes_Spc::run_timer_( Timer* t, rel_time_t time )
+{
+	int elapsed = TIMER_DIV( t, time - t->next_time ) + 1;
+	t->next_time += TIMER_MUL( t, elapsed );
+	
+	if ( t->enabled )
+	{
+		int remain = IF_0_THEN_256( t->period - t->divider );
+		int divider = t->divider + elapsed;
+		int over = elapsed - remain;
+		if ( over >= 0 )
+		{
+			int n = over / t->period;
+			t->counter = (t->counter + 1 + n) & 0x0F;
+			divider = over - n * t->period;
+		}
+		t->divider = (uint8_t) divider;
+	}
+	return t;
+}
+
+inline Snes_Spc::Timer* Snes_Spc::run_timer( Timer* t, rel_time_t time )
+{
+	if ( time >= t->next_time )
+		t = run_timer_( t, time );
+	return t;
+}
+
+
+//// ROM
+
+void Snes_Spc::enable_rom( int enable )
+{
+	if ( m.rom_enabled != enable )
+	{
+		m.rom_enabled = enable;
+		if ( enable )
+			memcpy( m.hi_ram, &RAM [rom_addr], sizeof m.hi_ram );
+		memcpy( &RAM [rom_addr], (enable ? m.rom : m.hi_ram), rom_size );
+		// TODO: ROM can still get overwritten when DSP writes to echo buffer
+	}
+}
+
+
+//// DSP
+
+#if SPC_LESS_ACCURATE
+	int const max_reg_time = 29;
+	
+	/* Fast DSP only runs every 32nd clock. By adjusting the end time based
+	on which register is being accessed, in most cases the register access
+	is emulated at the precise time. */
+	signed char const Snes_Spc::reg_times_ [256] =
+	{
+		 -1,  0,-11,-10,-15,-11, -2, -2,  4,  3, 14, 14, 26, 26, 14, 22,
+		  2,  3,  0,  1,-12,  0,  1,  1,  7,  6, 14, 14, 27, 14, 14, 23,
+		  5,  6,  3,  4, -1,  3,  4,  4, 10,  9, 14, 14, 26, -5, 14, 23,
+		  8,  9,  6,  7,  2,  6,  7,  7, 13, 12, 14, 14, 27, -4, 14, 24,
+		 11, 12,  9, 10,  5,  9, 10, 10, 16, 15, 14, 14, -2, -4, 14, 24,
+		 14, 15, 12, 13,  8, 12, 13, 13, 19, 18, 14, 14, -2,-36, 14, 24,
+		 17, 18, 15, 16, 11, 15, 16, 16, 22, 21, 14, 14, 28, -3, 14, 25,
+		 20, 21, 18, 19, 14, 18, 19, 19, 25, 24, 14, 14, 14, 29, 14, 25,
+		 
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+		 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+	};
+	
+	#define RUN_DSP( time, offset ) \
+		int count = (time) - (offset) - m.dsp_time;\
+		if ( count >= 0 )\
+		{\
+			int clock_count = (count & ~(clocks_per_sample - 1)) + clocks_per_sample;\
+			m.dsp_time += clock_count;\
+			dsp.run( clock_count );\
+		}
+#else
+	#define RUN_DSP( time, offset ) \
+		{\
+			int count = (time) - m.dsp_time;\
+			if ( !SPC_MORE_ACCURACY || count )\
+			{\
+				assert( count > 0 );\
+				m.dsp_time = (time);\
+				dsp.run( count );\
+			}\
+		}
+#endif
+
+int Snes_Spc::dsp_read( rel_time_t time )
+{
+	RUN_DSP( time, reg_times [REGS [r_dspaddr] & 0x7F] );
+	
+	int result = dsp.read( REGS [r_dspaddr] & 0x7F );
+	
+	#ifdef SPC_DSP_READ_HOOK
+		SPC_DSP_READ_HOOK( spc_time + time, (REGS [r_dspaddr] & 0x7F), result );
+	#endif
+	
+	return result;
+}
+
+inline void Snes_Spc::dsp_write( int data, rel_time_t time )
+{
+	RUN_DSP( time, reg_times [REGS [r_dspaddr]] )
+	#if SPC_LESS_ACCURATE
+		else if ( m.dsp_time == skipping_time )
+		{
+			int r = REGS [r_dspaddr];
+			if ( r == Spc_Dsp::r_kon )
+				m.skipped_kon |= data & ~dsp.read( Spc_Dsp::r_koff );
+			
+			if ( r == Spc_Dsp::r_koff )
+			{
+				m.skipped_koff |= data;
+				m.skipped_kon &= ~data;
+			}
+		}
+	#endif
+	
+	#ifdef SPC_DSP_WRITE_HOOK
+		SPC_DSP_WRITE_HOOK( m.spc_time + time, REGS [r_dspaddr], (uint8_t) data );
+	#endif
+	
+	if ( REGS [r_dspaddr] <= 0x7F )
+		dsp.write( REGS [r_dspaddr], data );
+	else if ( !SPC_MORE_ACCURACY )
+		dprintf( "SPC wrote to DSP register > $7F\n" );
+}
+
+
+//// Memory access extras
+
+#if SPC_MORE_ACCURACY
+	#define MEM_ACCESS( time, addr ) \
+	{\
+		if ( time >= m.dsp_time )\
+		{\
+			RUN_DSP( time, max_reg_time );\
+		}\
+	}
+#elif !defined (NDEBUG)
+	// Debug-only check for read/write within echo buffer, since this might result in
+	// inaccurate emulation due to the DSP not being caught up to the present.
+	
+	bool Snes_Spc::check_echo_access( int addr )
+	{
+		if ( !(dsp.read( Spc_Dsp::r_flg ) & 0x20) )
+		{
+			int start = 0x100 * dsp.read( Spc_Dsp::r_esa );
+			int size  = 0x800 * (dsp.read( Spc_Dsp::r_edl ) & 0x0F);
+			int end   = start + (size ? size : 4);
+			if ( start <= addr && addr < end )
+			{
+				if ( !m.echo_accessed )
+				{
+					m.echo_accessed = 1;
+					return true;
+				}
+			}
+		}
+		return false;
+	}
+	
+	#define MEM_ACCESS( time, addr ) check( !check_echo_access( (uint16_t) addr ) );
+#else
+	#define MEM_ACCESS( time, addr )
+#endif
+
+
+//// CPU write
+
+#if SPC_MORE_ACCURACY
+static unsigned char const glitch_probs [3] [256] =
+{
+	0xC3,0x92,0x5B,0x1C,0xD1,0x92,0x5B,0x1C,0xDB,0x9C,0x72,0x18,0xCD,0x5C,0x38,0x0B,
+	0xE1,0x9C,0x74,0x17,0xCF,0x75,0x45,0x0C,0xCF,0x6E,0x4A,0x0D,0xA3,0x3A,0x1D,0x08,
+	0xDB,0xA0,0x82,0x19,0xD9,0x73,0x3C,0x0E,0xCB,0x76,0x52,0x0B,0xA5,0x46,0x1D,0x09,
+	0xDA,0x74,0x55,0x0F,0xA2,0x3F,0x21,0x05,0x9A,0x40,0x20,0x07,0x63,0x1E,0x10,0x01,
+	0xDF,0xA9,0x85,0x1D,0xD3,0x84,0x4B,0x0E,0xCF,0x6F,0x49,0x0F,0xB3,0x48,0x1E,0x05,
+	0xD8,0x77,0x52,0x12,0xB7,0x49,0x23,0x06,0xAA,0x45,0x28,0x07,0x7D,0x28,0x0F,0x07,
+	0xCC,0x7B,0x4A,0x0E,0xB2,0x4F,0x24,0x07,0xAD,0x43,0x2C,0x06,0x86,0x29,0x11,0x07,
+	0xAE,0x48,0x1F,0x0A,0x76,0x21,0x19,0x05,0x76,0x21,0x14,0x05,0x44,0x11,0x0B,0x01,
+	0xE7,0xAD,0x96,0x23,0xDC,0x86,0x59,0x0E,0xDC,0x7C,0x5F,0x15,0xBB,0x53,0x2E,0x09,
+	0xD6,0x7C,0x4A,0x16,0xBB,0x4A,0x25,0x08,0xB3,0x4F,0x28,0x0B,0x8E,0x23,0x15,0x08,
+	0xCF,0x7F,0x57,0x11,0xB5,0x4A,0x23,0x0A,0xAA,0x42,0x28,0x05,0x7D,0x22,0x12,0x03,
+	0xA6,0x49,0x28,0x09,0x82,0x2B,0x0D,0x04,0x7A,0x20,0x0F,0x04,0x3D,0x0F,0x09,0x03,
+	0xD1,0x7C,0x4C,0x0F,0xAF,0x4E,0x21,0x09,0xA8,0x46,0x2A,0x07,0x85,0x1F,0x0E,0x07,
+	0xA6,0x3F,0x26,0x07,0x7C,0x24,0x14,0x07,0x78,0x22,0x16,0x04,0x46,0x12,0x0A,0x02,
+	0xA6,0x41,0x2C,0x0A,0x7E,0x28,0x11,0x05,0x73,0x1B,0x14,0x05,0x3D,0x11,0x0A,0x02,
+	0x70,0x22,0x17,0x05,0x48,0x13,0x08,0x03,0x3C,0x07,0x0D,0x07,0x26,0x07,0x06,0x01,
+	
+	0xE0,0x9F,0xDA,0x7C,0x4F,0x18,0x28,0x0D,0xE9,0x9F,0xDA,0x7C,0x4F,0x18,0x1F,0x07,
+	0xE6,0x97,0xD8,0x72,0x64,0x13,0x26,0x09,0xDC,0x67,0xA9,0x38,0x21,0x07,0x15,0x06,
+	0xE9,0x91,0xD2,0x6B,0x63,0x14,0x2B,0x0E,0xD6,0x61,0xB7,0x41,0x2B,0x0E,0x10,0x09,
+	0xCF,0x59,0xB0,0x2F,0x35,0x08,0x0F,0x07,0xB6,0x30,0x7A,0x21,0x17,0x07,0x09,0x03,
+	0xE7,0xA3,0xE5,0x6B,0x65,0x1F,0x34,0x09,0xD8,0x6B,0xBE,0x45,0x27,0x07,0x10,0x07,
+	0xDA,0x54,0xB1,0x39,0x2E,0x0E,0x17,0x08,0xA9,0x3C,0x86,0x22,0x16,0x06,0x07,0x03,
+	0xD4,0x51,0xBC,0x3D,0x38,0x0A,0x13,0x06,0xB2,0x37,0x79,0x1C,0x17,0x05,0x0E,0x06,
+	0xA7,0x31,0x74,0x1C,0x11,0x06,0x0C,0x02,0x6D,0x1A,0x38,0x10,0x0B,0x05,0x06,0x03,
+	0xEB,0x9A,0xE1,0x7A,0x6F,0x13,0x34,0x0E,0xE6,0x75,0xC5,0x45,0x3E,0x0B,0x1A,0x05,
+	0xD8,0x63,0xC1,0x40,0x3C,0x1B,0x19,0x06,0xB3,0x42,0x83,0x29,0x18,0x0A,0x08,0x04,
+	0xD4,0x58,0xBA,0x43,0x3F,0x0A,0x1F,0x09,0xB1,0x33,0x8A,0x1F,0x1F,0x06,0x0D,0x05,
+	0xAF,0x3C,0x7A,0x1F,0x16,0x08,0x0A,0x01,0x72,0x1B,0x52,0x0D,0x0B,0x09,0x06,0x01,
+	0xCF,0x63,0xB7,0x47,0x40,0x10,0x14,0x06,0xC0,0x41,0x96,0x20,0x1C,0x09,0x10,0x05,
+	0xA6,0x35,0x82,0x1A,0x20,0x0C,0x0E,0x04,0x80,0x1F,0x53,0x0F,0x0B,0x02,0x06,0x01,
+	0xA6,0x31,0x81,0x1B,0x1D,0x01,0x08,0x08,0x7B,0x20,0x4D,0x19,0x0E,0x05,0x07,0x03,
+	0x6B,0x17,0x49,0x07,0x0E,0x03,0x0A,0x05,0x37,0x0B,0x1F,0x06,0x04,0x02,0x07,0x01,
+	
+	0xF0,0xD6,0xED,0xAD,0xEC,0xB1,0xEB,0x79,0xAC,0x22,0x47,0x1E,0x6E,0x1B,0x32,0x0A,
+	0xF0,0xD6,0xEA,0xA4,0xED,0xC4,0xDE,0x82,0x98,0x1F,0x50,0x13,0x52,0x15,0x2A,0x0A,
+	0xF1,0xD1,0xEB,0xA2,0xEB,0xB7,0xD8,0x69,0xA2,0x1F,0x5B,0x18,0x55,0x18,0x2C,0x0A,
+	0xED,0xB5,0xDE,0x7E,0xE6,0x85,0xD3,0x59,0x59,0x0F,0x2C,0x09,0x24,0x07,0x15,0x09,
+	0xF1,0xD6,0xEA,0xA0,0xEC,0xBB,0xDA,0x77,0xA9,0x23,0x58,0x14,0x5D,0x12,0x2F,0x09,
+	0xF1,0xC1,0xE3,0x86,0xE4,0x87,0xD2,0x4E,0x68,0x15,0x26,0x0B,0x27,0x09,0x15,0x02,
+	0xEE,0xA6,0xE0,0x5C,0xE0,0x77,0xC3,0x41,0x67,0x1B,0x3C,0x07,0x2A,0x06,0x19,0x07,
+	0xE4,0x75,0xC6,0x43,0xCC,0x50,0x95,0x23,0x35,0x09,0x14,0x04,0x15,0x05,0x0B,0x04,
+	0xEE,0xD6,0xED,0xAD,0xEC,0xB1,0xEB,0x79,0xAC,0x22,0x56,0x14,0x5A,0x12,0x26,0x0A,
+	0xEE,0xBB,0xE7,0x7E,0xE9,0x8D,0xCB,0x49,0x67,0x11,0x34,0x07,0x2B,0x0B,0x14,0x07,
+	0xED,0xA7,0xE5,0x76,0xE3,0x7E,0xC4,0x4B,0x77,0x14,0x34,0x08,0x27,0x07,0x14,0x04,
+	0xE7,0x8B,0xD2,0x4C,0xCA,0x56,0x9E,0x31,0x36,0x0C,0x11,0x07,0x14,0x04,0x0A,0x02,
+	0xF0,0x9B,0xEA,0x6F,0xE5,0x81,0xC4,0x43,0x74,0x10,0x30,0x0B,0x2D,0x08,0x1B,0x06,
+	0xE6,0x83,0xCA,0x48,0xD9,0x56,0xA7,0x23,0x3B,0x09,0x12,0x09,0x15,0x07,0x0A,0x03,
+	0xE5,0x5F,0xCB,0x3C,0xCF,0x48,0x91,0x22,0x31,0x0A,0x17,0x08,0x15,0x04,0x0D,0x02,
+	0xD1,0x43,0x91,0x20,0xA9,0x2D,0x54,0x12,0x17,0x07,0x09,0x02,0x0C,0x04,0x05,0x03,
+};
+#endif
+
+// Read/write handlers are divided into multiple functions to keep rarely-used
+// functionality separate so often-used functionality can be optimized better
+// by compiler.
+
+// If write isn't preceded by read, data has this added to it
+int const no_read_before_write = 0x2000;
+
+void Snes_Spc::cpu_write_smp_reg_( int data, rel_time_t time, int addr )
+{
+	switch ( addr )
+	{
+	case r_t0target:
+	case r_t1target:
+	case r_t2target: {
+		Timer* t = &m.timers [addr - r_t0target];
+		int period = IF_0_THEN_256( data );
+		if ( t->period != period )
+		{
+			t = run_timer( t, time );
+			#if SPC_MORE_ACCURACY
+				// Insane behavior when target is written just after counter is
+				// clocked and counter matches new period and new period isn't 1, 2, 4, or 8
+				if ( t->divider == (period & 0xFF) &&
+						t->next_time == time + TIMER_MUL( t, 1 ) &&
+						((period - 1) | ~0x0F) & period )
+				{
+					//dprintf( "SPC pathological timer target write\n" );
+					
+					// If the period is 3, 5, or 9, there's a probability this behavior won't occur,
+					// based on the previous period
+					int prob = 0xFF;
+					int old_period = t->period & 0xFF;
+					if ( period == 3 ) prob = glitch_probs [0] [old_period];
+					if ( period == 5 ) prob = glitch_probs [1] [old_period];
+					if ( period == 9 ) prob = glitch_probs [2] [old_period];
+					
+					// The glitch suppresses incrementing of one of the counter bits, based on
+					// the lowest set bit in the new period
+					int b = 1;
+					while ( !(period & b) )
+						b <<= 1;
+					
+					if ( (rand() >> 4 & 0xFF) <= prob )
+						t->divider = (t->divider - b) & 0xFF;
+				}
+			#endif
+			t->period = period;
+		}
+		break;
+	}
+	
+	case r_t0out:
+	case r_t1out:
+	case r_t2out:
+		if ( !SPC_MORE_ACCURACY )
+			dprintf( "SPC wrote to counter %d\n", (int) addr - r_t0out );
+		
+		if ( data < no_read_before_write  / 2 )
+			run_timer( &m.timers [addr - r_t0out], time - 1 )->counter = 0;
+		break;
+	
+	// Registers that act like RAM
+	case 0x8:
+	case 0x9:
+		REGS_IN [addr] = (uint8_t) data;
+		break;
+	
+	case r_test:
+		if ( (uint8_t) data != 0x0A )
+			dprintf( "SPC wrote to test register\n" );
+		break;
+	
+	case r_control:
+		// port clears
+		if ( data & 0x10 )
+		{
+			REGS_IN [r_cpuio0] = 0;
+			REGS_IN [r_cpuio1] = 0;
+		}
+		if ( data & 0x20 )
+		{
+			REGS_IN [r_cpuio2] = 0;
+			REGS_IN [r_cpuio3] = 0;
+		}
+		
+		// timers
+		{
+			for ( int i = 0; i < timer_count; i++ )
+			{
+				Timer* t = &m.timers [i];
+				int enabled = data >> i & 1;
+				if ( t->enabled != enabled )
+				{
+					t = run_timer( t, time );
+					t->enabled = enabled;
+					if ( enabled )
+					{
+						t->divider = 0;
+						t->counter = 0;
+					}
+				}
+			}
+		}
+		enable_rom( data & 0x80 );
+		break;
+	}
+}
+
+void Snes_Spc::cpu_write_smp_reg( int data, rel_time_t time, int addr )
+{
+	if ( addr == r_dspdata ) // 99%
+		dsp_write( data, time );
+	else
+		cpu_write_smp_reg_( data, time, addr );
+}
+
+void Snes_Spc::cpu_write_high( int data, int i, rel_time_t time )
+{
+	if ( i < rom_size )
+	{
+		m.hi_ram [i] = (uint8_t) data;
+		if ( m.rom_enabled )
+			RAM [i + rom_addr] = m.rom [i]; // restore overwritten ROM
+	}
+	else
+	{
+		assert( RAM [i + rom_addr] == (uint8_t) data );
+		RAM [i + rom_addr] = cpu_pad_fill; // restore overwritten padding
+		cpu_write( data, i + rom_addr - 0x10000, time );
+	}
+}
+
+int const bits_in_int = CHAR_BIT * sizeof (int);
+
+void Snes_Spc::cpu_write( int data, int addr, rel_time_t time )
+{
+	MEM_ACCESS( time, addr )
+	
+	// RAM
+	RAM [addr] = (uint8_t) data;
+	int reg = addr - 0xF0;
+	if ( reg >= 0 ) // 64%
+	{
+		// $F0-$FF
+		if ( reg < reg_count ) // 87%
+		{
+			REGS [reg] = (uint8_t) data;
+			
+			// Ports
+			#ifdef SPC_PORT_WRITE_HOOK
+				if ( (unsigned) (reg - r_cpuio0) < port_count )
+					SPC_PORT_WRITE_HOOK( m.spc_time + time, (reg - r_cpuio0),
+							(uint8_t) data, &REGS [r_cpuio0] );
+			#endif
+			
+			// Registers other than $F2 and $F4-$F7
+			//if ( reg != 2 && reg != 4 && reg != 5 && reg != 6 && reg != 7 )
+			// TODO: this is a bit on the fragile side
+			if ( ((~0x2F00 << (bits_in_int - 16)) << reg) < 0 ) // 36%
+				cpu_write_smp_reg( data, time, reg );
+		}
+		// High mem/address wrap-around
+		else
+		{
+			reg -= rom_addr - 0xF0;
+			if ( reg >= 0 ) // 1% in IPL ROM area or address wrapped around
+				cpu_write_high( data, reg, time );
+		}
+	}
+}
+
+
+//// CPU read
+
+inline int Snes_Spc::cpu_read_smp_reg( int reg, rel_time_t time )
+{
+	int result = REGS_IN [reg];
+	reg -= r_dspaddr;
+	// DSP addr and data
+	if ( (unsigned) reg <= 1 ) // 4% 0xF2 and 0xF3
+	{
+		result = REGS [r_dspaddr];
+		if ( (unsigned) reg == 1 )
+			result = dsp_read( time ); // 0xF3
+	}
+	return result;
+}
+
+int Snes_Spc::cpu_read( int addr, rel_time_t time )
+{
+	MEM_ACCESS( time, addr )
+	
+	// RAM
+	int result = RAM [addr];
+	int reg = addr - 0xF0;
+	if ( reg >= 0 ) // 40%
+	{
+		reg -= 0x10;
+		if ( (unsigned) reg >= 0xFF00 ) // 21%
+		{
+			reg += 0x10 - r_t0out;
+			
+			// Timers
+			if ( (unsigned) reg < timer_count ) // 90%
+			{
+				Timer* t = &m.timers [reg];
+				if ( time >= t->next_time )
+					t = run_timer_( t, time );
+				result = t->counter;
+				t->counter = 0;
+			}
+			// Other registers
+			else if ( reg < 0 ) // 10%
+			{
+				result = cpu_read_smp_reg( reg + r_t0out, time );
+			}
+			else // 1%
+			{
+				assert( reg + (r_t0out + 0xF0 - 0x10000) < 0x100 );
+				result = cpu_read( reg + (r_t0out + 0xF0 - 0x10000), time );
+			}
+		}
+	}
+	
+	return result;
+}
+
+
+//// Run
+
+// Prefix and suffix for CPU emulator function
+#define SPC_CPU_RUN_FUNC \
+BOOST::uint8_t* Snes_Spc::run_until_( time_t end_time )\
+{\
+	rel_time_t rel_time = m.spc_time - end_time;\
+	assert( rel_time <= 0 );\
+	m.spc_time = end_time;\
+	m.dsp_time += rel_time;\
+	m.timers [0].next_time += rel_time;\
+	m.timers [1].next_time += rel_time;\
+	m.timers [2].next_time += rel_time;
+
+#define SPC_CPU_RUN_FUNC_END \
+	m.spc_time += rel_time;\
+	m.dsp_time -= rel_time;\
+	m.timers [0].next_time -= rel_time;\
+	m.timers [1].next_time -= rel_time;\
+	m.timers [2].next_time -= rel_time;\
+	assert( m.spc_time <= end_time );\
+	return &REGS [r_cpuio0];\
+}
+
+int const cpu_lag_max = 12 - 1; // DIV YA,X takes 12 clocks
+
+void Snes_Spc::end_frame( time_t end_time )
+{
+	// Catch CPU up to as close to end as possible. If final instruction
+	// would exceed end, does NOT execute it and leaves m.spc_time < end.
+	if ( end_time > m.spc_time )
+		run_until_( end_time );
+	
+	m.spc_time     -= end_time;
+	m.extra_clocks += end_time;
+	
+	// Greatest number of clocks early that emulation can stop early due to
+	// not being able to execute current instruction without going over
+	// allowed time.
+	assert( -cpu_lag_max <= m.spc_time && m.spc_time <= 0 );
+	
+	// Catch timers up to CPU
+	for ( int i = 0; i < timer_count; i++ )
+		run_timer( &m.timers [i], 0 );
+	
+	// Catch DSP up to CPU
+	if ( m.dsp_time < 0 )
+	{
+		RUN_DSP( 0, max_reg_time );
+	}
+	
+	// Save any extra samples beyond what should be generated
+	if ( m.buf_begin )
+		save_extra();
+}
+
+// Inclusion here allows static memory access functions and better optimization
+#include "Spc_Cpu.h"
diff -Nur orig/source/gme/src/Spc_Cpu.h mod/source/gme/src/Spc_Cpu.h
--- orig/source/gme/src/Spc_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Spc_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1225 @@
+// snes_spc 0.9.0. http://www.slack.net/~ant/
+
+/* Copyright (C) 2004-2007 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+//// Memory access
+
+#if SPC_MORE_ACCURACY
+	#define SUSPICIOUS_OPCODE( name ) ((void) 0)
+#else
+	#define SUSPICIOUS_OPCODE( name ) dprintf( "SPC: suspicious opcode: " name "\n" )
+#endif
+
+#define CPU_READ( time, offset, addr )\
+	cpu_read( addr, time + offset )
+
+#define CPU_WRITE( time, offset, addr, data )\
+	cpu_write( data, addr, time + offset )
+
+#if SPC_MORE_ACCURACY
+	#define CPU_READ_TIMER( time, offset, addr, out )\
+		{ out = CPU_READ( time, offset, addr ); }
+
+#else
+	// timers are by far the most common thing read from dp
+	#define CPU_READ_TIMER( time, offset, addr_, out )\
+	{\
+		rel_time_t adj_time = time + offset;\
+		int dp_addr = addr_;\
+		int ti = dp_addr - (r_t0out + 0xF0);\
+		if ( (unsigned) ti < timer_count )\
+		{\
+			Timer* t = &m.timers [ti];\
+			if ( adj_time >= t->next_time )\
+				t = run_timer_( t, adj_time );\
+			out = t->counter;\
+			t->counter = 0;\
+		}\
+		else\
+		{\
+			out = ram [dp_addr];\
+			int i = dp_addr - 0xF0;\
+			if ( (unsigned) i < 0x10 )\
+				out = cpu_read_smp_reg( i, adj_time );\
+		}\
+	}
+#endif
+
+#define TIME_ADJ( n )   (n)
+
+#define READ_TIMER( time, addr, out )       CPU_READ_TIMER( rel_time, TIME_ADJ(time), (addr), out )
+#define READ(  time, addr )                 CPU_READ ( rel_time, TIME_ADJ(time), (addr) )
+#define WRITE( time, addr, data )           CPU_WRITE( rel_time, TIME_ADJ(time), (addr), (data) )
+
+#define DP_ADDR( addr )                     (dp + (addr))
+
+#define READ_DP_TIMER(  time, addr, out )   CPU_READ_TIMER( rel_time, TIME_ADJ(time), DP_ADDR( addr ), out )
+#define READ_DP(  time, addr )              READ ( time, DP_ADDR( addr ) )
+#define WRITE_DP( time, addr, data )        WRITE( time, DP_ADDR( addr ), data )
+
+#define READ_PROG16( addr )                 GET_LE16( ram + (addr) )
+
+#define SET_PC( n )     (pc = ram + (n))
+#define GET_PC()        (pc - ram)
+#define READ_PC( pc )   (*(pc))
+#define READ_PC16( pc ) GET_LE16( pc )
+
+// TODO: remove non-wrapping versions?
+#define SPC_NO_SP_WRAPAROUND 0
+
+#define SET_SP( v )     (sp = ram + 0x101 + (v))
+#define GET_SP()        (sp - 0x101 - ram)
+
+#if SPC_NO_SP_WRAPAROUND
+#define PUSH16( v )     (sp -= 2, SET_LE16( sp, v ))
+#define PUSH( v )       (void) (*--sp = (uint8_t) (v))
+#define POP( out )      (void) ((out) = *sp++)
+
+#else
+#define PUSH16( data )\
+{\
+	int addr = (sp -= 2) - ram;\
+	if ( addr > 0x100 )\
+	{\
+		SET_LE16( sp, data );\
+	}\
+	else\
+	{\
+		ram [(uint8_t) addr + 0x100] = (uint8_t) data;\
+		sp [1] = (uint8_t) (data >> 8);\
+		sp += 0x100;\
+	}\
+}
+
+#define PUSH( data )\
+{\
+	*--sp = (uint8_t) (data);\
+	if ( sp - ram == 0x100 )\
+		sp += 0x100;\
+}
+
+#define POP( out )\
+{\
+	out = *sp++;\
+	if ( sp - ram == 0x201 )\
+	{\
+		out = sp [-0x101];\
+		sp -= 0x100;\
+	}\
+}
+
+#endif
+
+#define MEM_BIT( rel ) CPU_mem_bit( pc, rel_time + rel )
+
+unsigned Snes_Spc::CPU_mem_bit( uint8_t const* pc, rel_time_t rel_time )
+{
+	unsigned addr = READ_PC16( pc );
+	unsigned t = READ( 0, addr & 0x1FFF ) >> (addr >> 13);
+	return t << 8 & 0x100;
+}
+
+//// Status flag handling
+
+// Flags with hex value for clarity when used as mask.
+// Stored in indicated variable during emulation.
+int const n80 = 0x80; // nz
+int const v40 = 0x40; // psw
+int const p20 = 0x20; // dp
+int const b10 = 0x10; // psw
+int const h08 = 0x08; // psw
+int const i04 = 0x04; // psw
+int const z02 = 0x02; // nz
+int const c01 = 0x01; // c
+
+int const nz_neg_mask = 0x880; // either bit set indicates N flag set
+
+#define GET_PSW( out )\
+{\
+	out = psw & ~(n80 | p20 | z02 | c01);\
+	out |= c  >> 8 & c01;\
+	out |= dp >> 3 & p20;\
+	out |= ((nz >> 4) | nz) & n80;\
+	if ( !(uint8_t) nz ) out |= z02;\
+}
+
+#define SET_PSW( in )\
+{\
+	psw = in;\
+	c   = in << 8;\
+	dp  = in << 3 & 0x100;\
+	nz  = (in << 4 & 0x800) | (~in & z02);\
+}
+
+SPC_CPU_RUN_FUNC
+{
+	uint8_t* const ram = RAM;
+	int a = m.cpu_regs.a;
+	int x = m.cpu_regs.x;
+	int y = m.cpu_regs.y;
+	uint8_t const* pc;
+	uint8_t* sp;
+	int psw;
+	int c;
+	int nz;
+	int dp;
+	
+	SET_PC( m.cpu_regs.pc );
+	SET_SP( m.cpu_regs.sp );
+	SET_PSW( m.cpu_regs.psw );
+	
+	goto loop;
+	
+	
+	// Main loop
+	
+cbranch_taken_loop:
+	pc += *(BOOST::int8_t const*) pc;
+inc_pc_loop:
+	pc++;
+loop:
+{
+	unsigned opcode;
+	unsigned data;
+	
+	check( (unsigned) a < 0x100 );
+	check( (unsigned) x < 0x100 );
+	check( (unsigned) y < 0x100 );
+	
+	opcode = *pc;
+	if ( (rel_time += m.cycle_table [opcode]) > 0 )
+		goto out_of_time;
+	
+	#ifdef SPC_CPU_OPCODE_HOOK
+		SPC_CPU_OPCODE_HOOK( GET_PC(), opcode );
+	#endif
+	
+	#ifdef CPU_INSTR_HOOK
+		CPU_INSTR_HOOK( GET_PC(), pc, a, x, y, GET_SP(), rel_time );
+	#endif
+	
+	/*
+	//SUB_CASE_COUNTER( 1 );
+	#define PROFILE_TIMER_LOOP( op, addr, len )\
+	if ( opcode == op )\
+	{\
+		int cond = (unsigned) ((addr) - 0xFD) < 3 &&\
+				pc [len] == 0xF0 && pc [len+1] == 0xFE - len;\
+		SUB_CASE_COUNTER( op && cond );\
+	}
+	
+	PROFILE_TIMER_LOOP( 0xEC, GET_LE16( pc + 1 ), 3 );
+	PROFILE_TIMER_LOOP( 0xEB, pc [1], 2 );
+	PROFILE_TIMER_LOOP( 0xE4, pc [1], 2 );
+	*/
+	
+	// TODO: if PC is at end of memory, this will get wrong operand (very obscure)
+	data = *++pc;
+	switch ( opcode )
+	{
+	
+// Common instructions
+
+#define BRANCH( cond )\
+{\
+	pc++;\
+	pc += (BOOST::int8_t) data;\
+	if ( cond )\
+		goto loop;\
+	pc -= (BOOST::int8_t) data;\
+	rel_time -= 2;\
+	goto loop;\
+}
+
+	case 0xF0: // BEQ
+		BRANCH( !(uint8_t) nz ) // 89% taken
+	
+	case 0xD0: // BNE
+		BRANCH( (uint8_t) nz )
+	
+	case 0x3F:{// CALL
+		int old_addr = GET_PC() + 2;
+		SET_PC( READ_PC16( pc ) );
+		PUSH16( old_addr );
+		goto loop;
+	}
+	
+	case 0x6F:// RET
+		#if SPC_NO_SP_WRAPAROUND
+		{
+			SET_PC( GET_LE16( sp ) );
+			sp += 2;
+		}
+		#else
+		{
+			int addr = sp - ram;
+			SET_PC( GET_LE16( sp ) );
+			sp += 2;
+			if ( addr < 0x1FF )
+				goto loop;
+			
+			SET_PC( sp [-0x101] * 0x100 + ram [(uint8_t) addr + 0x100] );
+			sp -= 0x100;
+		}
+		#endif
+		goto loop;
+	
+	case 0xE4: // MOV a,dp
+		++pc;
+		// 80% from timer
+		READ_DP_TIMER( 0, data, a = nz );
+		goto loop;
+	
+	case 0xFA:{// MOV dp,dp
+		int temp;
+		READ_DP_TIMER( -2, data, temp );
+		data = temp + no_read_before_write ;
+	}
+	// fall through
+	case 0x8F:{// MOV dp,#imm
+		int temp = READ_PC( pc + 1 );
+		pc += 2;
+		
+		#if !SPC_MORE_ACCURACY
+		{
+			int i = dp + temp;
+			ram [i] = (uint8_t) data;
+			i -= 0xF0;
+			if ( (unsigned) i < 0x10 ) // 76%
+			{
+				REGS [i] = (uint8_t) data;
+				
+				// Registers other than $F2 and $F4-$F7
+				//if ( i != 2 && i != 4 && i != 5 && i != 6 && i != 7 )
+				if ( ((~0x2F00 << (bits_in_int - 16)) << i) < 0 ) // 12%
+					cpu_write_smp_reg( data, rel_time, i );
+			}
+		}
+		#else
+			WRITE_DP( 0, temp, data );
+		#endif
+		goto loop;
+	}
+	
+	case 0xC4: // MOV dp,a
+		++pc;
+		#if !SPC_MORE_ACCURACY
+		{
+			int i = dp + data;
+			ram [i] = (uint8_t) a;
+			i -= 0xF0;
+			if ( (unsigned) i < 0x10 ) // 39%
+			{
+				unsigned sel = i - 2;
+				REGS [i] = (uint8_t) a;
+				
+				if ( sel == 1 ) // 51% $F3
+					dsp_write( a, rel_time );
+				else if ( sel > 1 ) // 1% not $F2 or $F3
+					cpu_write_smp_reg_( a, rel_time, i );
+			}
+		}
+		#else
+			WRITE_DP( 0, data, a );
+		#endif
+		goto loop;
+	
+#define CASE( n )   case n:
+
+// Define common address modes based on opcode for immediate mode. Execution
+// ends with data set to the address of the operand.
+#define ADDR_MODES_( op )\
+	CASE( op - 0x02 ) /* (X) */\
+		data = x + dp;\
+		pc--;\
+		goto end_##op;\
+	CASE( op + 0x0F ) /* (dp)+Y */\
+		data = READ_PROG16( data + dp ) + y;\
+		goto end_##op;\
+	CASE( op - 0x01 ) /* (dp+X) */\
+		data = READ_PROG16( ((uint8_t) (data + x)) + dp );\
+		goto end_##op;\
+	CASE( op + 0x0E ) /* abs+Y */\
+		data += y;\
+		goto abs_##op;\
+	CASE( op + 0x0D ) /* abs+X */\
+		data += x;\
+	CASE( op - 0x03 ) /* abs */\
+	abs_##op:\
+		data += 0x100 * READ_PC( ++pc );\
+		goto end_##op;\
+	CASE( op + 0x0C ) /* dp+X */\
+		data = (uint8_t) (data + x);
+
+#define ADDR_MODES_NO_DP( op )\
+	ADDR_MODES_( op )\
+		data += dp;\
+	end_##op:
+
+#define ADDR_MODES( op )\
+	ADDR_MODES_( op )\
+	CASE( op - 0x04 ) /* dp */\
+		data += dp;\
+	end_##op:
+
+// 1. 8-bit Data Transmission Commands. Group I
+
+	ADDR_MODES_NO_DP( 0xE8 ) // MOV A,addr
+		a = nz = READ( 0, data );
+		goto inc_pc_loop;
+	
+	case 0xBF:{// MOV A,(X)+
+		int temp = x + dp;
+		x = (uint8_t) (x + 1);
+		a = nz = READ( -1, temp );
+		goto loop;
+	}
+	
+	case 0xE8: // MOV A,imm
+		a  = data;
+		nz = data;
+		goto inc_pc_loop;
+	
+	case 0xF9: // MOV X,dp+Y
+		data = (uint8_t) (data + y);
+	case 0xF8: // MOV X,dp
+		READ_DP_TIMER( 0, data, x = nz );
+		goto inc_pc_loop;
+	
+	case 0xE9: // MOV X,abs
+		data = READ_PC16( pc );
+		++pc;
+		data = READ( 0, data );
+	case 0xCD: // MOV X,imm
+		x  = data;
+		nz = data;
+		goto inc_pc_loop;
+	
+	case 0xFB: // MOV Y,dp+X
+		data = (uint8_t) (data + x);
+	case 0xEB: // MOV Y,dp
+		// 70% from timer
+		pc++;
+		READ_DP_TIMER( 0, data, y = nz );
+		goto loop;
+	
+	case 0xEC:{// MOV Y,abs
+		int temp = READ_PC16( pc );
+		pc += 2;
+		READ_TIMER( 0, temp, y = nz );
+		//y = nz = READ( 0, temp );
+		goto loop;
+	}
+	
+	case 0x8D: // MOV Y,imm
+		y  = data;
+		nz = data;
+		goto inc_pc_loop;
+	
+// 2. 8-BIT DATA TRANSMISSION COMMANDS, GROUP 2
+
+	ADDR_MODES_NO_DP( 0xC8 ) // MOV addr,A
+		WRITE( 0, data, a );
+		goto inc_pc_loop;
+	
+	{
+		int temp;
+	case 0xCC: // MOV abs,Y
+		temp = y;
+		goto mov_abs_temp;
+	case 0xC9: // MOV abs,X
+		temp = x;
+	mov_abs_temp:
+		WRITE( 0, READ_PC16( pc ), temp );
+		pc += 2;
+		goto loop;
+	}
+	
+	case 0xD9: // MOV dp+Y,X
+		data = (uint8_t) (data + y);
+	case 0xD8: // MOV dp,X
+		WRITE( 0, data + dp, x );
+		goto inc_pc_loop;
+	
+	case 0xDB: // MOV dp+X,Y
+		data = (uint8_t) (data + x);
+	case 0xCB: // MOV dp,Y
+		WRITE( 0, data + dp, y );
+		goto inc_pc_loop;
+
+// 3. 8-BIT DATA TRANSMISSIN COMMANDS, GROUP 3.
+	
+	case 0x7D: // MOV A,X
+		a  = x;
+		nz = x;
+		goto loop;
+	
+	case 0xDD: // MOV A,Y
+		a  = y;
+		nz = y;
+		goto loop;
+	
+	case 0x5D: // MOV X,A
+		x  = a;
+		nz = a;
+		goto loop;
+	
+	case 0xFD: // MOV Y,A
+		y  = a;
+		nz = a;
+		goto loop;
+	
+	case 0x9D: // MOV X,SP
+		x = nz = GET_SP();
+		goto loop;
+	
+	case 0xBD: // MOV SP,X
+		SET_SP( x );
+		goto loop;
+	
+	//case 0xC6: // MOV (X),A (handled by MOV addr,A in group 2)
+	
+	case 0xAF: // MOV (X)+,A
+		WRITE_DP( 0, x, a + no_read_before_write  );
+		x++;
+		goto loop;
+	
+// 5. 8-BIT LOGIC OPERATION COMMANDS
+	
+#define LOGICAL_OP( op, func )\
+	ADDR_MODES( op ) /* addr */\
+		data = READ( 0, data );\
+	case op: /* imm */\
+		nz = a func##= data;\
+		goto inc_pc_loop;\
+	{   unsigned addr;\
+	case op + 0x11: /* X,Y */\
+		data = READ_DP( -2, y );\
+		addr = x + dp;\
+		goto addr_##op;\
+	case op + 0x01: /* dp,dp */\
+		data = READ_DP( -3, data );\
+	case op + 0x10:{/*dp,imm*/\
+		uint8_t const* addr2 = pc + 1;\
+		pc += 2;\
+		addr = READ_PC( addr2 ) + dp;\
+	}\
+	addr_##op:\
+		nz = data func READ( -1, addr );\
+		WRITE( 0, addr, nz );\
+		goto loop;\
+	}
+	
+	LOGICAL_OP( 0x28, & ); // AND
+	
+	LOGICAL_OP( 0x08, | ); // OR
+	
+	LOGICAL_OP( 0x48, ^ ); // EOR
+	
+// 4. 8-BIT ARITHMETIC OPERATION COMMANDS
+
+	ADDR_MODES( 0x68 ) // CMP addr
+		data = READ( 0, data );
+	case 0x68: // CMP imm
+		nz = a - data;
+		c = ~nz;
+		nz &= 0xFF;
+		goto inc_pc_loop;
+	
+	case 0x79: // CMP (X),(Y)
+		data = READ_DP( -2, y );
+		nz = READ_DP( -1, x ) - data;
+		c = ~nz;
+		nz &= 0xFF;
+		goto loop;
+	
+	case 0x69: // CMP dp,dp
+		data = READ_DP( -3, data );
+	case 0x78: // CMP dp,imm
+		nz = READ_DP( -1, READ_PC( ++pc ) ) - data;
+		c = ~nz;
+		nz &= 0xFF;
+		goto inc_pc_loop;
+	
+	case 0x3E: // CMP X,dp
+		data += dp;
+		goto cmp_x_addr;
+	case 0x1E: // CMP X,abs
+		data = READ_PC16( pc );
+		pc++;
+	cmp_x_addr:
+		data = READ( 0, data );
+	case 0xC8: // CMP X,imm
+		nz = x - data;
+		c = ~nz;
+		nz &= 0xFF;
+		goto inc_pc_loop;
+	
+	case 0x7E: // CMP Y,dp
+		data += dp;
+		goto cmp_y_addr;
+	case 0x5E: // CMP Y,abs
+		data = READ_PC16( pc );
+		pc++;
+	cmp_y_addr:
+		data = READ( 0, data );
+	case 0xAD: // CMP Y,imm
+		nz = y - data;
+		c = ~nz;
+		nz &= 0xFF;
+		goto inc_pc_loop;
+	
+	{
+		int addr;
+	case 0xB9: // SBC (x),(y)
+	case 0x99: // ADC (x),(y)
+		pc--; // compensate for inc later
+		data = READ_DP( -2, y );
+		addr = x + dp;
+		goto adc_addr;
+	case 0xA9: // SBC dp,dp
+	case 0x89: // ADC dp,dp
+		data = READ_DP( -3, data );
+	case 0xB8: // SBC dp,imm
+	case 0x98: // ADC dp,imm
+		addr = READ_PC( ++pc ) + dp;
+	adc_addr:
+		nz = READ( -1, addr );
+		goto adc_data;
+		
+// catch ADC and SBC together, then decode later based on operand
+#undef CASE
+#define CASE( n ) case n: case (n) + 0x20:
+	ADDR_MODES( 0x88 ) // ADC/SBC addr
+		data = READ( 0, data );
+	case 0xA8: // SBC imm
+	case 0x88: // ADC imm
+		addr = -1; // A
+		nz = a;
+	adc_data: {
+		int flags;
+		if ( opcode >= 0xA0 ) // SBC
+			data ^= 0xFF;
+		
+		flags = data ^ nz;
+		nz += data + (c >> 8 & 1);
+		flags ^= nz;
+		
+		psw = (psw & ~(v40 | h08)) |
+				(flags >> 1 & h08) |
+				((flags + 0x80) >> 2 & v40);
+		c = nz;
+		if ( addr < 0 )
+		{
+			a = (uint8_t) nz;
+			goto inc_pc_loop;
+		}
+		WRITE( 0, addr, /*(uint8_t)*/ nz );
+		goto inc_pc_loop;
+	}
+	
+	}
+	
+// 6. ADDITION & SUBTRACTION COMMANDS
+
+#define INC_DEC_REG( reg, op )\
+		nz  = reg op;\
+		reg = (uint8_t) nz;\
+		goto loop;
+
+	case 0xBC: INC_DEC_REG( a, + 1 ) // INC A
+	case 0x3D: INC_DEC_REG( x, + 1 ) // INC X
+	case 0xFC: INC_DEC_REG( y, + 1 ) // INC Y
+	
+	case 0x9C: INC_DEC_REG( a, - 1 ) // DEC A
+	case 0x1D: INC_DEC_REG( x, - 1 ) // DEC X
+	case 0xDC: INC_DEC_REG( y, - 1 ) // DEC Y
+
+	case 0x9B: // DEC dp+X
+	case 0xBB: // INC dp+X
+		data = (uint8_t) (data + x);
+	case 0x8B: // DEC dp
+	case 0xAB: // INC dp
+		data += dp;
+		goto inc_abs;
+	case 0x8C: // DEC abs
+	case 0xAC: // INC abs
+		data = READ_PC16( pc );
+		pc++;
+	inc_abs:
+		nz = (opcode >> 4 & 2) - 1;
+		nz += READ( -1, data );
+		WRITE( 0, data, /*(uint8_t)*/ nz );
+		goto inc_pc_loop;
+	
+// 7. SHIFT, ROTATION COMMANDS
+
+	case 0x5C: // LSR A
+		c = 0;
+	case 0x7C:{// ROR A
+		nz = (c >> 1 & 0x80) | (a >> 1);
+		c = a << 8;
+		a = nz;
+		goto loop;
+	}
+	
+	case 0x1C: // ASL A
+		c = 0;
+	case 0x3C:{// ROL A
+		int temp = c >> 8 & 1;
+		c = a << 1;
+		nz = c | temp;
+		a = (uint8_t) nz;
+		goto loop;
+	}
+	
+	case 0x0B: // ASL dp
+		c = 0;
+		data += dp;
+		goto rol_mem;
+	case 0x1B: // ASL dp+X
+		c = 0;
+	case 0x3B: // ROL dp+X
+		data = (uint8_t) (data + x);
+	case 0x2B: // ROL dp
+		data += dp;
+		goto rol_mem;
+	case 0x0C: // ASL abs
+		c = 0;
+	case 0x2C: // ROL abs
+		data = READ_PC16( pc );
+		pc++;
+	rol_mem:
+		nz = c >> 8 & 1;
+		nz |= (c = READ( -1, data ) << 1);
+		WRITE( 0, data, /*(uint8_t)*/ nz );
+		goto inc_pc_loop;
+	
+	case 0x4B: // LSR dp
+		c = 0;
+		data += dp;
+		goto ror_mem;
+	case 0x5B: // LSR dp+X
+		c = 0;
+	case 0x7B: // ROR dp+X
+		data = (uint8_t) (data + x);
+	case 0x6B: // ROR dp
+		data += dp;
+		goto ror_mem;
+	case 0x4C: // LSR abs
+		c = 0;
+	case 0x6C: // ROR abs
+		data = READ_PC16( pc );
+		pc++;
+	ror_mem: {
+		int temp = READ( -1, data );
+		nz = (c >> 1 & 0x80) | (temp >> 1);
+		c = temp << 8;
+		WRITE( 0, data, nz );
+		goto inc_pc_loop;
+	}
+
+	case 0x9F: // XCN
+		nz = a = (a >> 4) | (uint8_t) (a << 4);
+		goto loop;
+
+// 8. 16-BIT TRANSMISION COMMANDS
+
+	case 0xBA: // MOVW YA,dp
+		a = READ_DP( -2, data );
+		nz = (a & 0x7F) | (a >> 1);
+		y = READ_DP( 0, (uint8_t) (data + 1) );
+		nz |= y;
+		goto inc_pc_loop;
+	
+	case 0xDA: // MOVW dp,YA
+		WRITE_DP( -1, data, a );
+		WRITE_DP( 0, (uint8_t) (data + 1), y + no_read_before_write  );
+		goto inc_pc_loop;
+	
+// 9. 16-BIT OPERATION COMMANDS
+
+	case 0x3A: // INCW dp
+	case 0x1A:{// DECW dp
+		int temp;
+		// low byte
+		data += dp;
+		temp = READ( -3, data );
+		temp += (opcode >> 4 & 2) - 1; // +1 for INCW, -1 for DECW
+		nz = ((temp >> 1) | temp) & 0x7F;
+		WRITE( -2, data, /*(uint8_t)*/ temp );
+		
+		// high byte
+		data = (uint8_t) (data + 1) + dp;
+		temp = (uint8_t) ((temp >> 8) + READ( -1, data ));
+		nz |= temp;
+		WRITE( 0, data, temp );
+		
+		goto inc_pc_loop;
+	}
+		
+	case 0x7A: // ADDW YA,dp
+	case 0x9A:{// SUBW YA,dp
+		int lo = READ_DP( -2, data );
+		int hi = READ_DP( 0, (uint8_t) (data + 1) );
+		int result;
+		int flags;
+		
+		if ( opcode == 0x9A ) // SUBW
+		{
+			lo = (lo ^ 0xFF) + 1;
+			hi ^= 0xFF;
+		}
+		
+		lo += a;
+		result = y + hi + (lo >> 8);
+		flags = hi ^ y ^ result;
+		
+		psw = (psw & ~(v40 | h08)) |
+				(flags >> 1 & h08) |
+				((flags + 0x80) >> 2 & v40);
+		c = result;
+		a = (uint8_t) lo;
+		result = (uint8_t) result;
+		y = result;
+		nz = (((lo >> 1) | lo) & 0x7F) | result;
+		
+		goto inc_pc_loop;
+	}
+	
+	case 0x5A: { // CMPW YA,dp
+		int temp = a - READ_DP( -1, data );
+		nz = ((temp >> 1) | temp) & 0x7F;
+		temp = y + (temp >> 8);
+		temp -= READ_DP( 0, (uint8_t) (data + 1) );
+		nz |= temp;
+		c  = ~temp;
+		nz &= 0xFF;
+		goto inc_pc_loop;
+	}
+	
+// 10. MULTIPLICATION & DIVISON COMMANDS
+
+	case 0xCF: { // MUL YA
+		unsigned temp = y * a;
+		a = (uint8_t) temp;
+		nz = ((temp >> 1) | temp) & 0x7F;
+		y = temp >> 8;
+		nz |= y;
+		goto loop;
+	}
+	
+	case 0x9E: // DIV YA,X
+	{
+		unsigned ya = y * 0x100 + a;
+		
+		psw &= ~(h08 | v40);
+		
+		if ( y >= x )
+			psw |= v40;
+		
+		if ( (y & 15) >= (x & 15) )
+			psw |= h08;
+		
+		if ( y < x * 2 )
+		{
+			a = ya / x;
+			y = ya - a * x;
+		}
+		else
+		{
+			a = 255 - (ya - x * 0x200) / (256 - x);
+			y = x   + (ya - x * 0x200) % (256 - x);
+		}
+		
+		nz = (uint8_t) a;
+		a = (uint8_t) a;
+		
+		goto loop;
+	}
+	
+// 11. DECIMAL COMPENSATION COMMANDS
+	
+	case 0xDF: // DAA
+		SUSPICIOUS_OPCODE( "DAA" );
+		if ( a > 0x99 || c & 0x100 )
+		{
+			a += 0x60;
+			c = 0x100;
+		}
+		
+		if ( (a & 0x0F) > 9 || psw & h08 )
+			a += 0x06;
+		
+		nz = a;
+		a = (uint8_t) a;
+		goto loop;
+	
+	case 0xBE: // DAS
+		SUSPICIOUS_OPCODE( "DAS" );
+		if ( a > 0x99 || !(c & 0x100) )
+		{
+			a -= 0x60;
+			c = 0;
+		}
+		
+		if ( (a & 0x0F) > 9 || !(psw & h08) )
+			a -= 0x06;
+		
+		nz = a;
+		a = (uint8_t) a;
+		goto loop;
+	
+// 12. BRANCHING COMMANDS
+
+	case 0x2F: // BRA rel
+		pc += (BOOST::int8_t) data;
+		goto inc_pc_loop;
+	
+	case 0x30: // BMI
+		BRANCH( (nz & nz_neg_mask) )
+	
+	case 0x10: // BPL
+		BRANCH( !(nz & nz_neg_mask) )
+	
+	case 0xB0: // BCS
+		BRANCH( c & 0x100 )
+	
+	case 0x90: // BCC
+		BRANCH( !(c & 0x100) )
+	
+	case 0x70: // BVS
+		BRANCH( psw & v40 )
+	
+	case 0x50: // BVC
+		BRANCH( !(psw & v40) )
+	
+	#define CBRANCH( cond )\
+	{\
+		pc++;\
+		if ( cond )\
+			goto cbranch_taken_loop;\
+		rel_time -= 2;\
+		goto inc_pc_loop;\
+	}
+	
+	case 0x03: // BBS dp.bit,rel
+	case 0x23:
+	case 0x43:
+	case 0x63:
+	case 0x83:
+	case 0xA3:
+	case 0xC3:
+	case 0xE3:
+		CBRANCH( READ_DP( -4, data ) >> (opcode >> 5) & 1 )
+	
+	case 0x13: // BBC dp.bit,rel
+	case 0x33:
+	case 0x53:
+	case 0x73:
+	case 0x93:
+	case 0xB3:
+	case 0xD3:
+	case 0xF3:
+		CBRANCH( !(READ_DP( -4, data ) >> (opcode >> 5) & 1) )
+	
+	case 0xDE: // CBNE dp+X,rel
+		data = (uint8_t) (data + x);
+		// fall through
+	case 0x2E:{// CBNE dp,rel
+		int temp;
+		// 61% from timer
+		READ_DP_TIMER( -4, data, temp );
+		CBRANCH( temp != a )
+	}
+	
+	case 0x6E: { // DBNZ dp,rel
+		unsigned temp = READ_DP( -4, data ) - 1;
+		WRITE_DP( -3, (uint8_t) data, /*(uint8_t)*/ temp + no_read_before_write  );
+		CBRANCH( temp )
+	}
+	
+	case 0xFE: // DBNZ Y,rel
+		y = (uint8_t) (y - 1);
+		BRANCH( y )
+	
+	case 0x1F: // JMP [abs+X]
+		SET_PC( READ_PC16( pc ) + x );
+		// fall through
+	case 0x5F: // JMP abs
+		SET_PC( READ_PC16( pc ) );
+		goto loop;
+	
+// 13. SUB-ROUTINE CALL RETURN COMMANDS
+	
+	case 0x0F:{// BRK
+		int temp;
+		int ret_addr = GET_PC();
+		SUSPICIOUS_OPCODE( "BRK" );
+		SET_PC( READ_PROG16( 0xFFDE ) ); // vector address verified
+		PUSH16( ret_addr );
+		GET_PSW( temp );
+		psw = (psw | b10) & ~i04;
+		PUSH( temp );
+		goto loop;
+	}
+	
+	case 0x4F:{// PCALL offset
+		int ret_addr = GET_PC() + 1;
+		SET_PC( 0xFF00 | data );
+		PUSH16( ret_addr );
+		goto loop;
+	}
+	
+	case 0x01: // TCALL n
+	case 0x11:
+	case 0x21:
+	case 0x31:
+	case 0x41:
+	case 0x51:
+	case 0x61:
+	case 0x71:
+	case 0x81:
+	case 0x91:
+	case 0xA1:
+	case 0xB1:
+	case 0xC1:
+	case 0xD1:
+	case 0xE1:
+	case 0xF1: {
+		int ret_addr = GET_PC();
+		SET_PC( READ_PROG16( 0xFFDE - (opcode >> 3) ) );
+		PUSH16( ret_addr );
+		goto loop;
+	}
+	
+// 14. STACK OPERATION COMMANDS
+
+	{
+		int temp;
+	case 0x7F: // RET1
+		temp = *sp;
+		SET_PC( GET_LE16( sp + 1 ) );
+		sp += 3;
+		goto set_psw;
+	case 0x8E: // POP PSW
+		POP( temp );
+	set_psw:
+		SET_PSW( temp );
+		goto loop;
+	}
+	
+	case 0x0D: { // PUSH PSW
+		int temp;
+		GET_PSW( temp );
+		PUSH( temp );
+		goto loop;
+	}
+
+	case 0x2D: // PUSH A
+		PUSH( a );
+		goto loop;
+	
+	case 0x4D: // PUSH X
+		PUSH( x );
+		goto loop;
+	
+	case 0x6D: // PUSH Y
+		PUSH( y );
+		goto loop;
+	
+	case 0xAE: // POP A
+		POP( a );
+		goto loop;
+	
+	case 0xCE: // POP X
+		POP( x );
+		goto loop;
+	
+	case 0xEE: // POP Y
+		POP( y );
+		goto loop;
+	
+// 15. BIT OPERATION COMMANDS
+
+	case 0x02: // SET1
+	case 0x22:
+	case 0x42:
+	case 0x62:
+	case 0x82:
+	case 0xA2:
+	case 0xC2:
+	case 0xE2:
+	case 0x12: // CLR1
+	case 0x32:
+	case 0x52:
+	case 0x72:
+	case 0x92:
+	case 0xB2:
+	case 0xD2:
+	case 0xF2: {
+		int bit = 1 << (opcode >> 5);
+		int mask = ~bit;
+		if ( opcode & 0x10 )
+			bit = 0;
+		data += dp;
+		WRITE( 0, data, (READ( -1, data ) & mask) | bit );
+		goto inc_pc_loop;
+	}
+		
+	case 0x0E: // TSET1 abs
+	case 0x4E: // TCLR1 abs
+		data = READ_PC16( pc );
+		pc += 2;
+		{
+			unsigned temp = READ( -2, data );
+			nz = (uint8_t) (a - temp);
+			temp &= ~a;
+			if ( opcode == 0x0E )
+				temp |= a;
+			WRITE( 0, data, temp );
+		}
+		goto loop;
+	
+	case 0x4A: // AND1 C,mem.bit
+		c &= MEM_BIT( 0 );
+		pc += 2;
+		goto loop;
+	
+	case 0x6A: // AND1 C,/mem.bit
+		c &= ~MEM_BIT( 0 );
+		pc += 2;
+		goto loop;
+	
+	case 0x0A: // OR1 C,mem.bit
+		c |= MEM_BIT( -1 );
+		pc += 2;
+		goto loop;
+	
+	case 0x2A: // OR1 C,/mem.bit
+		c |= ~MEM_BIT( -1 );
+		pc += 2;
+		goto loop;
+	
+	case 0x8A: // EOR1 C,mem.bit
+		c ^= MEM_BIT( -1 );
+		pc += 2;
+		goto loop;
+	
+	case 0xEA: // NOT1 mem.bit
+		data = READ_PC16( pc );
+		pc += 2;
+		{
+			unsigned temp = READ( -1, data & 0x1FFF );
+			temp ^= 1 << (data >> 13);
+			WRITE( 0, data & 0x1FFF, temp );
+		}
+		goto loop;
+	
+	case 0xCA: // MOV1 mem.bit,C
+		data = READ_PC16( pc );
+		pc += 2;
+		{
+			unsigned temp = READ( -2, data & 0x1FFF );
+			unsigned bit = data >> 13;
+			temp = (temp & ~(1 << bit)) | ((c >> 8 & 1) << bit);
+			WRITE( 0, data & 0x1FFF, temp + no_read_before_write  );
+		}
+		goto loop;
+	
+	case 0xAA: // MOV1 C,mem.bit
+		c = MEM_BIT( 0 );
+		pc += 2;
+		goto loop;
+	
+// 16. PROGRAM PSW FLAG OPERATION COMMANDS
+
+	case 0x60: // CLRC
+		c = 0;
+		goto loop;
+		
+	case 0x80: // SETC
+		c = ~0;
+		goto loop;
+	
+	case 0xED: // NOTC
+		c ^= 0x100;
+		goto loop;
+		
+	case 0xE0: // CLRV
+		psw &= ~(v40 | h08);
+		goto loop;
+	
+	case 0x20: // CLRP
+		dp = 0;
+		goto loop;
+	
+	case 0x40: // SETP
+		dp = 0x100;
+		goto loop;
+	
+	case 0xA0: // EI
+		SUSPICIOUS_OPCODE( "EI" );
+		psw |= i04;
+		goto loop;
+	
+	case 0xC0: // DI
+		SUSPICIOUS_OPCODE( "DI" );
+		psw &= ~i04;
+		goto loop;
+	
+// 17. OTHER COMMANDS
+
+	case 0x00: // NOP
+		goto loop;
+	
+	case 0xFF:{// STOP
+		// handle PC wrap-around
+		unsigned addr = GET_PC() - 1;
+		if ( addr >= 0x10000 )
+		{
+			addr &= 0xFFFF;
+			SET_PC( addr );
+			dprintf( "SPC: PC wrapped around\n" );
+			goto loop;
+		}
+	}
+	// fall through
+	case 0xEF: // SLEEP
+		SUSPICIOUS_OPCODE( "STOP/SLEEP" );
+		--pc;
+		rel_time = 0;
+		m.cpu_error = "SPC emulation error";
+		goto stop;
+	} // switch
+	
+	assert( 0 ); // catch any unhandled instructions
+}   
+out_of_time:
+	rel_time -= m.cycle_table [*pc]; // undo partial execution of opcode
+stop:
+	
+	// Uncache registers
+	if ( GET_PC() >= 0x10000 )
+		dprintf( "SPC: PC wrapped around\n" );
+	m.cpu_regs.pc = (uint16_t) GET_PC();
+	m.cpu_regs.sp = ( uint8_t) GET_SP();
+	m.cpu_regs.a  = ( uint8_t) a;
+	m.cpu_regs.x  = ( uint8_t) x;
+	m.cpu_regs.y  = ( uint8_t) y;
+	{
+		int temp;
+		GET_PSW( temp );
+		m.cpu_regs.psw = (uint8_t) temp;
+	}
+}
+SPC_CPU_RUN_FUNC_END
diff -Nur orig/source/gme/src/Spc_Dsp.cpp mod/source/gme/src/Spc_Dsp.cpp
--- orig/source/gme/src/Spc_Dsp.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Spc_Dsp.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1387 @@
+// snes_spc 0.9.0. http://www.slack.net/~ant/
+
+#include "Spc_Dsp.h"
+
+#include "blargg_endian.h"
+#include <string.h>
+
+/* Copyright (C) 2007 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#ifdef BLARGG_ENABLE_OPTIMIZER
+	#include BLARGG_ENABLE_OPTIMIZER
+#endif
+
+#if INT_MAX < 0x7FFFFFFF
+	#error "Requires that int type have at least 32 bits"
+#endif
+
+// TODO: add to blargg_endian.h
+#define GET_LE16SA( addr )      ((BOOST::int16_t) GET_LE16( addr ))
+#define GET_LE16A( addr )       GET_LE16( addr )
+#define SET_LE16A( addr, data ) SET_LE16( addr, data )
+
+static BOOST::uint8_t const initial_regs [Spc_Dsp::register_count] =
+{
+	0x45,0x8B,0x5A,0x9A,0xE4,0x82,0x1B,0x78,0x00,0x00,0xAA,0x96,0x89,0x0E,0xE0,0x80,
+	0x2A,0x49,0x3D,0xBA,0x14,0xA0,0xAC,0xC5,0x00,0x00,0x51,0xBB,0x9C,0x4E,0x7B,0xFF,
+	0xF4,0xFD,0x57,0x32,0x37,0xD9,0x42,0x22,0x00,0x00,0x5B,0x3C,0x9F,0x1B,0x87,0x9A,
+	0x6F,0x27,0xAF,0x7B,0xE5,0x68,0x0A,0xD9,0x00,0x00,0x9A,0xC5,0x9C,0x4E,0x7B,0xFF,
+	0xEA,0x21,0x78,0x4F,0xDD,0xED,0x24,0x14,0x00,0x00,0x77,0xB1,0xD1,0x36,0xC1,0x67,
+	0x52,0x57,0x46,0x3D,0x59,0xF4,0x87,0xA4,0x00,0x00,0x7E,0x44,0x9C,0x4E,0x7B,0xFF,
+	0x75,0xF5,0x06,0x97,0x10,0xC3,0x24,0xBB,0x00,0x00,0x7B,0x7A,0xE0,0x60,0x12,0x0F,
+	0xF7,0x74,0x1C,0xE5,0x39,0x3D,0x73,0xC1,0x00,0x00,0x7A,0xB3,0xFF,0x4E,0x7B,0xFF
+};
+
+// if ( io < -32768 ) io = -32768;
+// if ( io >  32767 ) io =  32767;
+#define CLAMP16( io )\
+{\
+	if ( (int16_t) io != io )\
+		io = (io >> 31) ^ 0x7FFF;\
+}
+
+// Access global DSP register
+#define REG(n)      m.regs [r_##n]
+
+// Access voice DSP register
+#define VREG(r,n)   r [v_##n]
+
+#define WRITE_SAMPLES( l, r, out ) \
+{\
+	out [0] = l;\
+	out [1] = r;\
+	out += 2;\
+	if ( out >= m.out_end )\
+	{\
+		check( out == m.out_end );\
+		check( m.out_end != &m.extra [extra_size] || \
+			(m.extra <= m.out_begin && m.extra < &m.extra [extra_size]) );\
+		out       = m.extra;\
+		m.out_end = &m.extra [extra_size];\
+	}\
+}\
+
+void Spc_Dsp::set_output( sample_t* out, int size )
+{
+	require( (size & 1) == 0 ); // must be even
+	if ( !out )
+	{
+		out  = m.extra;
+		size = extra_size;
+	}
+	m.out_begin = out;
+	m.out       = out;
+	m.out_end   = out + size;
+}
+
+// Volume registers and efb are signed! Easy to forget int8_t cast.
+// Prefixes are to avoid accidental use of locals with same names.
+
+// Gaussian interpolation
+
+static short const gauss [512] =
+{
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,
+   2,   2,   3,   3,   3,   3,   3,   4,   4,   4,   4,   4,   5,   5,   5,   5,
+   6,   6,   6,   6,   7,   7,   7,   8,   8,   8,   9,   9,   9,  10,  10,  10,
+  11,  11,  11,  12,  12,  13,  13,  14,  14,  15,  15,  15,  16,  16,  17,  17,
+  18,  19,  19,  20,  20,  21,  21,  22,  23,  23,  24,  24,  25,  26,  27,  27,
+  28,  29,  29,  30,  31,  32,  32,  33,  34,  35,  36,  36,  37,  38,  39,  40,
+  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,
+  58,  59,  60,  61,  62,  64,  65,  66,  67,  69,  70,  71,  73,  74,  76,  77,
+  78,  80,  81,  83,  84,  86,  87,  89,  90,  92,  94,  95,  97,  99, 100, 102,
+ 104, 106, 107, 109, 111, 113, 115, 117, 118, 120, 122, 124, 126, 128, 130, 132,
+ 134, 137, 139, 141, 143, 145, 147, 150, 152, 154, 156, 159, 161, 163, 166, 168,
+ 171, 173, 175, 178, 180, 183, 186, 188, 191, 193, 196, 199, 201, 204, 207, 210,
+ 212, 215, 218, 221, 224, 227, 230, 233, 236, 239, 242, 245, 248, 251, 254, 257,
+ 260, 263, 267, 270, 273, 276, 280, 283, 286, 290, 293, 297, 300, 304, 307, 311,
+ 314, 318, 321, 325, 328, 332, 336, 339, 343, 347, 351, 354, 358, 362, 366, 370,
+ 374, 378, 381, 385, 389, 393, 397, 401, 405, 410, 414, 418, 422, 426, 430, 434,
+ 439, 443, 447, 451, 456, 460, 464, 469, 473, 477, 482, 486, 491, 495, 499, 504,
+ 508, 513, 517, 522, 527, 531, 536, 540, 545, 550, 554, 559, 563, 568, 573, 577,
+ 582, 587, 592, 596, 601, 606, 611, 615, 620, 625, 630, 635, 640, 644, 649, 654,
+ 659, 664, 669, 674, 678, 683, 688, 693, 698, 703, 708, 713, 718, 723, 728, 732,
+ 737, 742, 747, 752, 757, 762, 767, 772, 777, 782, 787, 792, 797, 802, 806, 811,
+ 816, 821, 826, 831, 836, 841, 846, 851, 855, 860, 865, 870, 875, 880, 884, 889,
+ 894, 899, 904, 908, 913, 918, 923, 927, 932, 937, 941, 946, 951, 955, 960, 965,
+ 969, 974, 978, 983, 988, 992, 997,1001,1005,1010,1014,1019,1023,1027,1032,1036,
+1040,1045,1049,1053,1057,1061,1066,1070,1074,1078,1082,1086,1090,1094,1098,1102,
+1106,1109,1113,1117,1121,1125,1128,1132,1136,1139,1143,1146,1150,1153,1157,1160,
+1164,1167,1170,1174,1177,1180,1183,1186,1190,1193,1196,1199,1202,1205,1207,1210,
+1213,1216,1219,1221,1224,1227,1229,1232,1234,1237,1239,1241,1244,1246,1248,1251,
+1253,1255,1257,1259,1261,1263,1265,1267,1269,1270,1272,1274,1275,1277,1279,1280,
+1282,1283,1284,1286,1287,1288,1290,1291,1292,1293,1294,1295,1296,1297,1297,1298,
+1299,1300,1300,1301,1302,1302,1303,1303,1303,1304,1304,1304,1304,1304,1305,1305,
+};
+
+static short const cubic [514] =
+{
+   0,  -4,  -8, -12, -16, -20, -23, -27, -30, -34, -37, -41, -44, -47, -50, -53,
+ -56, -59, -62, -65, -68, -71, -73, -76, -78, -81, -84, -87, -89, -91, -93, -95,
+ -98,-100,-102,-104,-106,-109,-110,-112,-113,-116,-117,-119,-121,-122,-123,-125,
+-126,-128,-129,-131,-132,-134,-134,-136,-136,-138,-138,-140,-141,-141,-142,-143,
+-144,-144,-145,-146,-147,-148,-147,-148,-148,-149,-149,-150,-150,-150,-150,-151,
+-151,-151,-151,-151,-152,-152,-151,-152,-151,-152,-151,-151,-151,-151,-150,-150,
+-150,-149,-149,-149,-149,-148,-147,-147,-146,-146,-145,-145,-144,-144,-143,-142,
+-141,-141,-140,-139,-139,-138,-137,-136,-135,-135,-133,-133,-132,-131,-130,-129,
+-128,-127,-126,-125,-124,-123,-121,-121,-119,-118,-117,-116,-115,-114,-112,-111,
+-110,-109,-107,-106,-105,-104,-102,-102,-100, -99, -97, -97, -95, -94, -92, -91,
+ -90, -88, -87, -86, -85, -84, -82, -81, -79, -78, -76, -76, -74, -73, -71, -70,
+ -68, -67, -66, -65, -63, -62, -60, -60, -58, -57, -55, -55, -53, -52, -50, -49,
+ -48, -46, -45, -44, -43, -42, -40, -39, -38, -37, -36, -35, -34, -32, -31, -30,
+ -29, -28, -27, -26, -25, -24, -23, -22, -21, -20, -19, -19, -17, -16, -15, -14,
+ -14, -13, -12, -11, -11, -10,  -9,  -9,  -8,  -8,  -7,  -7,  -6,  -5,  -4,  -4,
+  -3,  -3,  -3,  -2,  -2,  -2,  -1,  -1,   0,  -1,   0,  -1,   0,   0,   0,   0,
+   0,
+2048,2048,2048,2048,2047,2047,2046,2045,2043,2042,2041,2039,2037,2035,2033,2031,
+2028,2026,2024,2021,2018,2015,2012,2009,2005,2002,1999,1995,1991,1987,1982,1978,
+1974,1969,1965,1960,1955,1951,1946,1940,1934,1929,1924,1918,1912,1906,1900,1895,
+1888,1882,1875,1869,1862,1856,1849,1842,1835,1828,1821,1814,1806,1799,1791,1783,
+1776,1768,1760,1753,1744,1737,1728,1720,1711,1703,1695,1686,1677,1668,1659,1651,
+1641,1633,1623,1614,1605,1596,1587,1577,1567,1559,1549,1539,1529,1520,1510,1499,
+1490,1480,1470,1460,1450,1440,1430,1420,1408,1398,1389,1378,1367,1357,1346,1336,
+1325,1315,1304,1293,1282,1272,1261,1250,1239,1229,1218,1207,1196,1185,1174,1163,
+1152,1141,1130,1119,1108,1097,1086,1075,1063,1052,1042,1030,1019,1008, 997, 986,
+ 974, 964, 952, 941, 930, 919, 908, 897, 886, 875, 864, 853, 842, 831, 820, 809,
+ 798, 787, 776, 765, 754, 744, 733, 722, 711, 700, 690, 679, 668, 658, 647, 637,
+ 626, 616, 605, 595, 584, 574, 564, 554, 543, 534, 524, 514, 503, 494, 483, 473,
+ 464, 454, 444, 435, 425, 416, 407, 397, 387, 378, 370, 360, 351, 342, 333, 325,
+ 315, 307, 298, 290, 281, 273, 265, 256, 248, 241, 233, 225, 216, 209, 201, 193,
+ 186, 178, 171, 164, 157, 150, 143, 137, 129, 123, 117, 110, 103,  97,  91,  85,
+  79,  74,  68,  62,  56,  51,  46,  41,  35,  31,  27,  22,  17,  13,   8,   4,
+   0
+};
+
+static short const sinc [2048] =
+{
+    39,  -315,   666, 15642,   666,  -315,    39,   -38,
+    38,  -302,   613, 15642,   718,  -328,    41,   -38,
+    36,  -288,   561, 15641,   772,  -342,    42,   -38,
+    35,  -275,   510, 15639,   826,  -355,    44,   -38,
+    33,  -263,   459, 15636,   880,  -369,    46,   -38,
+    32,  -250,   408, 15632,   935,  -383,    47,   -38,
+    31,  -237,   358, 15628,   990,  -396,    49,   -38,
+    29,  -224,   309, 15622,  1046,  -410,    51,   -38,
+    28,  -212,   259, 15616,  1103,  -425,    53,   -38,
+    27,  -200,   211, 15609,  1159,  -439,    54,   -38,
+    25,  -188,   163, 15601,  1216,  -453,    56,   -38,
+    24,  -175,   115, 15593,  1274,  -467,    58,   -38,
+    23,  -164,    68, 15583,  1332,  -482,    60,   -38,
+    22,  -152,    22, 15573,  1391,  -496,    62,   -37,
+    21,  -140,   -24, 15562,  1450,  -511,    64,   -37,
+    19,  -128,   -70, 15550,  1509,  -526,    66,   -37,
+    18,  -117,  -115, 15538,  1569,  -540,    68,   -37,
+    17,  -106,  -159, 15524,  1629,  -555,    70,   -37,
+    16,   -94,  -203, 15510,  1690,  -570,    72,   -36,
+    15,   -83,  -247, 15495,  1751,  -585,    74,   -36,
+    14,   -72,  -289, 15479,  1813,  -600,    76,   -36,
+    13,   -62,  -332, 15462,  1875,  -616,    79,   -36,
+    12,   -51,  -374, 15445,  1937,  -631,    81,   -35,
+    11,   -40,  -415, 15426,  2000,  -646,    83,   -35,
+    11,   -30,  -456, 15407,  2063,  -662,    85,   -35,
+    10,   -20,  -496, 15387,  2127,  -677,    88,   -34,
+     9,    -9,  -536, 15366,  2191,  -693,    90,   -34,
+     8,     1,  -576, 15345,  2256,  -708,    92,   -34,
+     7,    10,  -614, 15323,  2321,  -724,    95,   -33,
+     7,    20,  -653, 15300,  2386,  -740,    97,   -33,
+     6,    30,  -690, 15276,  2451,  -755,    99,   -33,
+     5,    39,  -728, 15251,  2517,  -771,   102,   -32,
+     5,    49,  -764, 15226,  2584,  -787,   104,   -32,
+     4,    58,  -801, 15200,  2651,  -803,   107,   -32,
+     3,    67,  -836, 15173,  2718,  -819,   109,   -31,
+     3,    76,  -871, 15145,  2785,  -835,   112,   -31,
+     2,    85,  -906, 15117,  2853,  -851,   115,   -30,
+     2,    93,  -940, 15087,  2921,  -867,   117,   -30,
+     1,   102,  -974, 15057,  2990,  -883,   120,   -29,
+     1,   110, -1007, 15027,  3059,  -899,   122,   -29,
+     0,   118, -1039, 14995,  3128,  -915,   125,   -29,
+     0,   127, -1071, 14963,  3198,  -931,   128,   -28,
+    -1,   135, -1103, 14930,  3268,  -948,   131,   -28,
+    -1,   142, -1134, 14896,  3338,  -964,   133,   -27,
+    -1,   150, -1164, 14862,  3409,  -980,   136,   -27,
+    -2,   158, -1194, 14827,  3480,  -996,   139,   -26,
+    -2,   165, -1224, 14791,  3551, -1013,   142,   -26,
+    -3,   172, -1253, 14754,  3622, -1029,   144,   -25,
+    -3,   179, -1281, 14717,  3694, -1045,   147,   -25,
+    -3,   187, -1309, 14679,  3766, -1062,   150,   -24,
+    -3,   193, -1337, 14640,  3839, -1078,   153,   -24,
+    -4,   200, -1363, 14601,  3912, -1094,   156,   -23,
+    -4,   207, -1390, 14561,  3985, -1110,   159,   -23,
+    -4,   213, -1416, 14520,  4058, -1127,   162,   -22,
+    -4,   220, -1441, 14479,  4131, -1143,   165,   -22,
+    -4,   226, -1466, 14437,  4205, -1159,   168,   -22,
+    -5,   232, -1490, 14394,  4279, -1175,   171,   -21,
+    -5,   238, -1514, 14350,  4354, -1192,   174,   -21,
+    -5,   244, -1537, 14306,  4428, -1208,   177,   -20,
+    -5,   249, -1560, 14261,  4503, -1224,   180,   -20,
+    -5,   255, -1583, 14216,  4578, -1240,   183,   -19,
+    -5,   260, -1604, 14169,  4653, -1256,   186,   -19,
+    -5,   265, -1626, 14123,  4729, -1272,   189,   -18,
+    -5,   271, -1647, 14075,  4805, -1288,   192,   -18,
+    -5,   276, -1667, 14027,  4881, -1304,   195,   -17,
+    -6,   280, -1687, 13978,  4957, -1320,   198,   -17,
+    -6,   285, -1706, 13929,  5033, -1336,   201,   -16,
+    -6,   290, -1725, 13879,  5110, -1352,   204,   -16,
+    -6,   294, -1744, 13829,  5186, -1368,   207,   -15,
+    -6,   299, -1762, 13777,  5263, -1383,   210,   -15,
+    -6,   303, -1779, 13726,  5340, -1399,   213,   -14,
+    -6,   307, -1796, 13673,  5418, -1414,   216,   -14,
+    -6,   311, -1813, 13620,  5495, -1430,   219,   -13,
+    -5,   315, -1829, 13567,  5573, -1445,   222,   -13,
+    -5,   319, -1844, 13512,  5651, -1461,   225,   -13,
+    -5,   322, -1859, 13458,  5728, -1476,   229,   -12,
+    -5,   326, -1874, 13402,  5806, -1491,   232,   -12,
+    -5,   329, -1888, 13347,  5885, -1506,   235,   -11,
+    -5,   332, -1902, 13290,  5963, -1521,   238,   -11,
+    -5,   335, -1915, 13233,  6041, -1536,   241,   -10,
+    -5,   338, -1928, 13176,  6120, -1551,   244,   -10,
+    -5,   341, -1940, 13118,  6199, -1566,   247,   -10,
+    -5,   344, -1952, 13059,  6277, -1580,   250,    -9,
+    -5,   347, -1964, 13000,  6356, -1595,   253,    -9,
+    -5,   349, -1975, 12940,  6435, -1609,   256,    -8,
+    -4,   352, -1986, 12880,  6514, -1623,   259,    -8,
+    -4,   354, -1996, 12819,  6594, -1637,   262,    -8,
+    -4,   356, -2005, 12758,  6673, -1651,   265,    -7,
+    -4,   358, -2015, 12696,  6752, -1665,   268,    -7,
+    -4,   360, -2024, 12634,  6831, -1679,   271,    -7,
+    -4,   362, -2032, 12572,  6911, -1693,   274,    -6,
+    -4,   364, -2040, 12509,  6990, -1706,   277,    -6,
+    -4,   366, -2048, 12445,  7070, -1719,   280,    -6,
+    -3,   367, -2055, 12381,  7149, -1732,   283,    -5,
+    -3,   369, -2062, 12316,  7229, -1745,   286,    -5,
+    -3,   370, -2068, 12251,  7308, -1758,   289,    -5,
+    -3,   371, -2074, 12186,  7388, -1771,   291,    -4,
+    -3,   372, -2079, 12120,  7467, -1784,   294,    -4,
+    -3,   373, -2084, 12054,  7547, -1796,   297,    -4,
+    -3,   374, -2089, 11987,  7626, -1808,   300,    -4,
+    -2,   375, -2094, 11920,  7706, -1820,   303,    -3,
+    -2,   376, -2098, 11852,  7785, -1832,   305,    -3,
+    -2,   376, -2101, 11785,  7865, -1844,   308,    -3,
+    -2,   377, -2104, 11716,  7944, -1855,   311,    -3,
+    -2,   377, -2107, 11647,  8024, -1866,   313,    -2,
+    -2,   378, -2110, 11578,  8103, -1877,   316,    -2,
+    -2,   378, -2112, 11509,  8182, -1888,   318,    -2,
+    -1,   378, -2113, 11439,  8262, -1899,   321,    -2,
+    -1,   378, -2115, 11369,  8341, -1909,   323,    -2,
+    -1,   378, -2116, 11298,  8420, -1920,   326,    -2,
+    -1,   378, -2116, 11227,  8499, -1930,   328,    -1,
+    -1,   378, -2116, 11156,  8578, -1940,   331,    -1,
+    -1,   378, -2116, 11084,  8656, -1949,   333,    -1,
+    -1,   377, -2116, 11012,  8735, -1959,   335,    -1,
+    -1,   377, -2115, 10940,  8814, -1968,   337,    -1,
+    -1,   377, -2114, 10867,  8892, -1977,   340,    -1,
+    -1,   376, -2112, 10795,  8971, -1985,   342,    -1,
+     0,   375, -2111, 10721,  9049, -1994,   344,    -1,
+     0,   375, -2108, 10648,  9127, -2002,   346,     0,
+     0,   374, -2106, 10574,  9205, -2010,   348,     0,
+     0,   373, -2103, 10500,  9283, -2018,   350,     0,
+     0,   372, -2100, 10426,  9360, -2025,   352,     0,
+     0,   371, -2097, 10351,  9438, -2032,   354,     0,
+     0,   370, -2093, 10276,  9515, -2039,   355,     0,
+     0,   369, -2089, 10201,  9592, -2046,   357,     0,
+     0,   367, -2084, 10126,  9669, -2052,   359,     0,
+     0,   366, -2080, 10050,  9745, -2058,   360,     0,
+     0,   365, -2075,  9974,  9822, -2064,   362,     0,
+     0,   363, -2070,  9898,  9898, -2070,   363,     0,
+     0,   362, -2064,  9822,  9974, -2075,   365,     0,
+     0,   360, -2058,  9745, 10050, -2080,   366,     0,
+     0,   359, -2052,  9669, 10126, -2084,   367,     0,
+     0,   357, -2046,  9592, 10201, -2089,   369,     0,
+     0,   355, -2039,  9515, 10276, -2093,   370,     0,
+     0,   354, -2032,  9438, 10351, -2097,   371,     0,
+     0,   352, -2025,  9360, 10426, -2100,   372,     0,
+     0,   350, -2018,  9283, 10500, -2103,   373,     0,
+     0,   348, -2010,  9205, 10574, -2106,   374,     0,
+     0,   346, -2002,  9127, 10648, -2108,   375,     0,
+    -1,   344, -1994,  9049, 10721, -2111,   375,     0,
+    -1,   342, -1985,  8971, 10795, -2112,   376,    -1,
+    -1,   340, -1977,  8892, 10867, -2114,   377,    -1,
+    -1,   337, -1968,  8814, 10940, -2115,   377,    -1,
+    -1,   335, -1959,  8735, 11012, -2116,   377,    -1,
+    -1,   333, -1949,  8656, 11084, -2116,   378,    -1,
+    -1,   331, -1940,  8578, 11156, -2116,   378,    -1,
+    -1,   328, -1930,  8499, 11227, -2116,   378,    -1,
+    -2,   326, -1920,  8420, 11298, -2116,   378,    -1,
+    -2,   323, -1909,  8341, 11369, -2115,   378,    -1,
+    -2,   321, -1899,  8262, 11439, -2113,   378,    -1,
+    -2,   318, -1888,  8182, 11509, -2112,   378,    -2,
+    -2,   316, -1877,  8103, 11578, -2110,   378,    -2,
+    -2,   313, -1866,  8024, 11647, -2107,   377,    -2,
+    -3,   311, -1855,  7944, 11716, -2104,   377,    -2,
+    -3,   308, -1844,  7865, 11785, -2101,   376,    -2,
+    -3,   305, -1832,  7785, 11852, -2098,   376,    -2,
+    -3,   303, -1820,  7706, 11920, -2094,   375,    -2,
+    -4,   300, -1808,  7626, 11987, -2089,   374,    -3,
+    -4,   297, -1796,  7547, 12054, -2084,   373,    -3,
+    -4,   294, -1784,  7467, 12120, -2079,   372,    -3,
+    -4,   291, -1771,  7388, 12186, -2074,   371,    -3,
+    -5,   289, -1758,  7308, 12251, -2068,   370,    -3,
+    -5,   286, -1745,  7229, 12316, -2062,   369,    -3,
+    -5,   283, -1732,  7149, 12381, -2055,   367,    -3,
+    -6,   280, -1719,  7070, 12445, -2048,   366,    -4,
+    -6,   277, -1706,  6990, 12509, -2040,   364,    -4,
+    -6,   274, -1693,  6911, 12572, -2032,   362,    -4,
+    -7,   271, -1679,  6831, 12634, -2024,   360,    -4,
+    -7,   268, -1665,  6752, 12696, -2015,   358,    -4,
+    -7,   265, -1651,  6673, 12758, -2005,   356,    -4,
+    -8,   262, -1637,  6594, 12819, -1996,   354,    -4,
+    -8,   259, -1623,  6514, 12880, -1986,   352,    -4,
+    -8,   256, -1609,  6435, 12940, -1975,   349,    -5,
+    -9,   253, -1595,  6356, 13000, -1964,   347,    -5,
+    -9,   250, -1580,  6277, 13059, -1952,   344,    -5,
+   -10,   247, -1566,  6199, 13118, -1940,   341,    -5,
+   -10,   244, -1551,  6120, 13176, -1928,   338,    -5,
+   -10,   241, -1536,  6041, 13233, -1915,   335,    -5,
+   -11,   238, -1521,  5963, 13290, -1902,   332,    -5,
+   -11,   235, -1506,  5885, 13347, -1888,   329,    -5,
+   -12,   232, -1491,  5806, 13402, -1874,   326,    -5,
+   -12,   229, -1476,  5728, 13458, -1859,   322,    -5,
+   -13,   225, -1461,  5651, 13512, -1844,   319,    -5,
+   -13,   222, -1445,  5573, 13567, -1829,   315,    -5,
+   -13,   219, -1430,  5495, 13620, -1813,   311,    -6,
+   -14,   216, -1414,  5418, 13673, -1796,   307,    -6,
+   -14,   213, -1399,  5340, 13726, -1779,   303,    -6,
+   -15,   210, -1383,  5263, 13777, -1762,   299,    -6,
+   -15,   207, -1368,  5186, 13829, -1744,   294,    -6,
+   -16,   204, -1352,  5110, 13879, -1725,   290,    -6,
+   -16,   201, -1336,  5033, 13929, -1706,   285,    -6,
+   -17,   198, -1320,  4957, 13978, -1687,   280,    -6,
+   -17,   195, -1304,  4881, 14027, -1667,   276,    -5,
+   -18,   192, -1288,  4805, 14075, -1647,   271,    -5,
+   -18,   189, -1272,  4729, 14123, -1626,   265,    -5,
+   -19,   186, -1256,  4653, 14169, -1604,   260,    -5,
+   -19,   183, -1240,  4578, 14216, -1583,   255,    -5,
+   -20,   180, -1224,  4503, 14261, -1560,   249,    -5,
+   -20,   177, -1208,  4428, 14306, -1537,   244,    -5,
+   -21,   174, -1192,  4354, 14350, -1514,   238,    -5,
+   -21,   171, -1175,  4279, 14394, -1490,   232,    -5,
+   -22,   168, -1159,  4205, 14437, -1466,   226,    -4,
+   -22,   165, -1143,  4131, 14479, -1441,   220,    -4,
+   -22,   162, -1127,  4058, 14520, -1416,   213,    -4,
+   -23,   159, -1110,  3985, 14561, -1390,   207,    -4,
+   -23,   156, -1094,  3912, 14601, -1363,   200,    -4,
+   -24,   153, -1078,  3839, 14640, -1337,   193,    -3,
+   -24,   150, -1062,  3766, 14679, -1309,   187,    -3,
+   -25,   147, -1045,  3694, 14717, -1281,   179,    -3,
+   -25,   144, -1029,  3622, 14754, -1253,   172,    -3,
+   -26,   142, -1013,  3551, 14791, -1224,   165,    -2,
+   -26,   139,  -996,  3480, 14827, -1194,   158,    -2,
+   -27,   136,  -980,  3409, 14862, -1164,   150,    -1,
+   -27,   133,  -964,  3338, 14896, -1134,   142,    -1,
+   -28,   131,  -948,  3268, 14930, -1103,   135,    -1,
+   -28,   128,  -931,  3198, 14963, -1071,   127,     0,
+   -29,   125,  -915,  3128, 14995, -1039,   118,     0,
+   -29,   122,  -899,  3059, 15027, -1007,   110,     1,
+   -29,   120,  -883,  2990, 15057,  -974,   102,     1,
+   -30,   117,  -867,  2921, 15087,  -940,    93,     2,
+   -30,   115,  -851,  2853, 15117,  -906,    85,     2,
+   -31,   112,  -835,  2785, 15145,  -871,    76,     3,
+   -31,   109,  -819,  2718, 15173,  -836,    67,     3,
+   -32,   107,  -803,  2651, 15200,  -801,    58,     4,
+   -32,   104,  -787,  2584, 15226,  -764,    49,     5,
+   -32,   102,  -771,  2517, 15251,  -728,    39,     5,
+   -33,    99,  -755,  2451, 15276,  -690,    30,     6,
+   -33,    97,  -740,  2386, 15300,  -653,    20,     7,
+   -33,    95,  -724,  2321, 15323,  -614,    10,     7,
+   -34,    92,  -708,  2256, 15345,  -576,     1,     8,
+   -34,    90,  -693,  2191, 15366,  -536,    -9,     9,
+   -34,    88,  -677,  2127, 15387,  -496,   -20,    10,
+   -35,    85,  -662,  2063, 15407,  -456,   -30,    11,
+   -35,    83,  -646,  2000, 15426,  -415,   -40,    11,
+   -35,    81,  -631,  1937, 15445,  -374,   -51,    12,
+   -36,    79,  -616,  1875, 15462,  -332,   -62,    13,
+   -36,    76,  -600,  1813, 15479,  -289,   -72,    14,
+   -36,    74,  -585,  1751, 15495,  -247,   -83,    15,
+   -36,    72,  -570,  1690, 15510,  -203,   -94,    16,
+   -37,    70,  -555,  1629, 15524,  -159,  -106,    17,
+   -37,    68,  -540,  1569, 15538,  -115,  -117,    18,
+   -37,    66,  -526,  1509, 15550,   -70,  -128,    19,
+   -37,    64,  -511,  1450, 15562,   -24,  -140,    21,
+   -37,    62,  -496,  1391, 15573,    22,  -152,    22,
+   -38,    60,  -482,  1332, 15583,    68,  -164,    23,
+   -38,    58,  -467,  1274, 15593,   115,  -175,    24,
+   -38,    56,  -453,  1216, 15601,   163,  -188,    25,
+   -38,    54,  -439,  1159, 15609,   211,  -200,    27,
+   -38,    53,  -425,  1103, 15616,   259,  -212,    28,
+   -38,    51,  -410,  1046, 15622,   309,  -224,    29,
+   -38,    49,  -396,   990, 15628,   358,  -237,    31,
+   -38,    47,  -383,   935, 15632,   408,  -250,    32,
+   -38,    46,  -369,   880, 15636,   459,  -263,    33,
+   -38,    44,  -355,   826, 15639,   510,  -275,    35,
+   -38,    42,  -342,   772, 15641,   561,  -288,    36,
+   -38,    41,  -328,   718, 15642,   613,  -302,    38,
+};
+
+inline int Spc_Dsp::interpolate( voice_t const* v )
+{
+	// Make pointers into gaussian based on fractional position between samples
+	int offset = v->interp_pos >> 4 & 0xFF;
+	short const* fwd = gauss + 255 - offset;
+	short const* rev = gauss       + offset; // mirror left half of gaussian
+	
+	int const* in = &v->buf [(v->interp_pos >> 12) + v->buf_pos];
+	int out;
+	out  = (fwd [  0] * in [0]) >> 11;
+	out += (fwd [256] * in [1]) >> 11;
+	out += (rev [256] * in [2]) >> 11;
+	out = (int16_t) out;
+	out += (rev [  0] * in [3]) >> 11;
+	
+	CLAMP16( out );
+	out &= ~1;
+	return out;
+}
+
+inline int Spc_Dsp::interpolate_cubic( voice_t const* v )
+{
+	// Make pointers into cubic based on fractional position between samples
+	int offset = v->interp_pos >> 4 & 0xFF;
+	short const* fwd = cubic       + offset;
+	short const* rev = cubic + 256 - offset; // mirror left half of cubic
+	
+	int const* in = &v->buf [(v->interp_pos >> 12) + v->buf_pos];
+	int out;
+	out  = fwd [  0] * in [0];
+	out += fwd [257] * in [1];
+	out += rev [257] * in [2];
+	out += rev [  0] * in [3];
+	out >>= 11;
+	
+	CLAMP16( out );
+	out &= ~1;
+	return out;
+}
+
+inline int Spc_Dsp::interpolate_sinc( voice_t const* v )
+{
+	// Make pointers into cubic based on fractional position between samples
+	int offset = v->interp_pos & 0xFF0;
+	short const* filt = (short const*) (((char const*)sinc) + offset);
+	
+	int const* in = &v->buf [(v->interp_pos >> 12) + v->buf_pos];
+	int out;
+	out  = filt [0] * in [0];
+	out += filt [1] * in [1];
+	out += filt [2] * in [2];
+	out += filt [3] * in [3];
+	out += filt [4] * in [4];
+	out += filt [5] * in [5];
+	out += filt [6] * in [6];
+	out += filt [7] * in [7];
+	out >>= 14;
+	
+	CLAMP16( out );
+	out &= ~1;
+	return out;
+}
+
+//// Counters
+
+int const simple_counter_range = 2048 * 5 * 3; // 30720
+
+static unsigned const counter_rates [32] =
+{
+   simple_counter_range + 1, // never fires
+          2048, 1536,
+	1280, 1024,  768,
+	 640,  512,  384,
+	 320,  256,  192,
+	 160,  128,   96,
+	  80,   64,   48,
+	  40,   32,   24,
+	  20,   16,   12,
+	  10,    8,    6,
+	   5,    4,    3,
+	         2,
+	         1
+};
+
+static unsigned const counter_offsets [32] =
+{
+	  1, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	     0,
+	     0
+};
+
+inline void Spc_Dsp::init_counter()
+{
+	m.counter = 0;
+}
+
+inline void Spc_Dsp::run_counters()
+{
+	if ( --m.counter < 0 )
+		m.counter = simple_counter_range - 1;
+}
+
+inline unsigned Spc_Dsp::read_counter( int rate )
+{
+	return ((unsigned) m.counter + counter_offsets [rate]) % counter_rates [rate];
+}
+
+
+//// Envelope
+
+inline void Spc_Dsp::run_envelope( voice_t* const v )
+{
+	int env = v->env;
+	if ( v->env_mode == env_release ) // 60%
+	{
+		if ( (env -= 0x8) < 0 )
+			env = 0;
+		v->env = env;
+	}
+	else
+	{
+		int rate;
+		int env_data = VREG(v->regs,adsr1);
+		if ( m.t_adsr0 & 0x80 ) // 99% ADSR
+		{
+			if ( v->env_mode >= env_decay ) // 99%
+			{
+				env--;
+				env -= env >> 8;
+				rate = env_data & 0x1F;
+				if ( v->env_mode == env_decay ) // 1%
+					rate = (m.t_adsr0 >> 3 & 0x0E) + 0x10;
+			}
+			else // env_attack
+			{
+				rate = (m.t_adsr0 & 0x0F) * 2 + 1;
+				env += rate < 31 ? 0x20 : 0x400;
+			}
+		}
+		else // GAIN
+		{
+			int mode;
+			env_data = VREG(v->regs,gain);
+			mode = env_data >> 5;
+			if ( mode < 4 ) // direct
+			{
+				env = env_data * 0x10;
+				rate = 31;
+			}
+			else
+			{
+				rate = env_data & 0x1F;
+				if ( mode == 4 ) // 4: linear decrease
+				{
+					env -= 0x20;
+				}
+				else if ( mode < 6 ) // 5: exponential decrease
+				{
+					env--;
+					env -= env >> 8;
+				}
+				else // 6,7: linear increase
+				{
+					env += 0x20;
+					if ( mode > 6 && (unsigned) v->hidden_env >= 0x600 )
+						env += 0x8 - 0x20; // 7: two-slope linear increase
+				}
+			}
+		}
+		
+		// Sustain level
+		if ( (env >> 8) == (env_data >> 5) && v->env_mode == env_decay )
+			v->env_mode = env_sustain;
+		
+		v->hidden_env = env;
+		
+		// unsigned cast because linear decrease going negative also triggers this
+		if ( (unsigned) env > 0x7FF )
+		{
+			env = (env < 0 ? 0 : 0x7FF);
+			if ( v->env_mode == env_attack )
+				v->env_mode = env_decay;
+		}
+		
+		if ( !read_counter( rate ) )
+			v->env = env; // nothing else is controlled by the counter
+	}
+}
+
+
+//// BRR Decoding
+
+inline void Spc_Dsp::decode_brr( voice_t* v )
+{
+	// Arrange the four input nybbles in 0xABCD order for easy decoding
+	int nybbles = m.t_brr_byte * 0x100 + m.ram [(v->brr_addr + v->brr_offset + 1) & 0xFFFF];
+	
+	int const header = m.t_brr_header;
+	
+	// Write to next four samples in circular buffer
+	int* pos = &v->buf [v->buf_pos];
+	int* end;
+	if ( (v->buf_pos += 4) >= brr_buf_size )
+		v->buf_pos = 0;
+	
+	// Decode four samples
+	for ( end = pos + 4; pos < end; pos++, nybbles <<= 4 )
+	{
+		// Extract nybble and sign-extend
+		int s = (int16_t) nybbles >> 12;
+		
+		// Shift sample based on header
+		int const shift = header >> 4;
+		s = (s << shift) >> 1;
+		if ( shift >= 0xD ) // handle invalid range
+			s = (s >> 25) << 11; // same as: s = (s < 0 ? -0x800 : 0)
+		
+		// Apply IIR filter (8 is the most commonly used)
+		int const filter = header & 0x0C;
+		int const p1 = pos [brr_buf_size - 1];
+		int const p2 = pos [brr_buf_size - 2] >> 1;
+		if ( filter >= 8 )
+		{
+			s += p1;
+			s -= p2;
+			if ( filter == 8 ) // s += p1 * 0.953125 - p2 * 0.46875
+			{
+				s += p2 >> 4;
+				s += (p1 * -3) >> 6;
+			}
+			else // s += p1 * 0.8984375 - p2 * 0.40625
+			{
+				s += (p1 * -13) >> 7;
+				s += (p2 * 3) >> 4;
+			}
+		}
+		else if ( filter ) // s += p1 * 0.46875
+		{
+			s += p1 >> 1;
+			s += (-p1) >> 5;
+		}
+		
+		// Adjust and write sample
+		CLAMP16( s );
+		s = (int16_t) (s * 2);
+		pos [brr_buf_size] = pos [0] = s; // second copy simplifies wrap-around
+	}
+}
+
+
+//// Misc
+
+#define MISC_CLOCK( n ) inline void Spc_Dsp::misc_##n()
+
+MISC_CLOCK( 27 )
+{
+	m.t_pmon = REG(pmon) & 0xFE; // voice 0 doesn't support PMON
+}
+MISC_CLOCK( 28 )
+{
+	m.t_non = REG(non);
+	m.t_eon = REG(eon);
+	m.t_dir = REG(dir);
+}
+MISC_CLOCK( 29 )
+{
+	if ( (m.every_other_sample ^= 1) != 0 )
+		m.new_kon &= ~m.kon; // clears KON 63 clocks after it was last read
+}
+MISC_CLOCK( 30 )
+{
+	if ( m.every_other_sample )
+	{
+		m.kon    = m.new_kon;
+		m.t_koff = REG(koff) | m.mute_mask; 
+	}
+	
+	run_counters();
+	
+	// Noise
+	if ( !read_counter( REG(flg) & 0x1F ) )
+	{
+		int feedback = (m.noise << 13) ^ (m.noise << 14);
+		m.noise = (feedback & 0x4000) ^ (m.noise >> 1);
+	}
+}
+
+
+//// Voices
+
+#define VOICE_CLOCK( n ) void Spc_Dsp::voice_##n( voice_t* const v )
+
+inline VOICE_CLOCK( V1 )
+{
+	m.t_dir_addr = m.t_dir * 0x100 + m.t_srcn * 4;
+	m.t_srcn = VREG(v->regs,srcn);
+}
+inline VOICE_CLOCK( V2 )
+{
+	// Read sample pointer (ignored if not needed)
+	uint8_t const* entry = &m.ram [m.t_dir_addr];
+	if ( !v->kon_delay )
+		entry += 2;
+	m.t_brr_next_addr = GET_LE16A( entry );
+	
+	m.t_adsr0 = VREG(v->regs,adsr0);
+	
+	// Read pitch, spread over two clocks
+	m.t_pitch = VREG(v->regs,pitchl);
+}
+inline VOICE_CLOCK( V3a )
+{
+	m.t_pitch += (VREG(v->regs,pitchh) & 0x3F) << 8;
+}
+inline VOICE_CLOCK( V3b )
+{
+	// Read BRR header and byte
+	m.t_brr_byte   = m.ram [(v->brr_addr + v->brr_offset) & 0xFFFF];
+	m.t_brr_header = m.ram [v->brr_addr]; // brr_addr doesn't need masking
+}
+VOICE_CLOCK( V3c )
+{
+	// Pitch modulation using previous voice's output
+	if ( m.t_pmon & v->vbit )
+		m.t_pitch += ((m.t_output >> 5) * m.t_pitch) >> 10;
+	
+	if ( v->kon_delay )
+	{
+		// Get ready to start BRR decoding on next sample
+		if ( v->kon_delay == 5 )
+		{
+			v->brr_addr    = m.t_brr_next_addr;
+			v->brr_offset  = 1;
+			v->buf_pos     = 0;
+			m.t_brr_header = 0; // header is ignored on this sample
+			m.kon_check    = true;
+		}
+		
+		// Envelope is never run during KON
+		v->env        = 0;
+		v->hidden_env = 0;
+		
+		// Disable BRR decoding until last three samples
+		v->interp_pos = 0;
+		if ( --v->kon_delay & 3 )
+			v->interp_pos = 0x4000;
+		
+		// Pitch is never added during KON
+		m.t_pitch = 0;
+	}
+	
+	// Gaussian interpolation
+	{
+		int output;
+		
+		switch ( m.interpolation_level )
+		{
+		case 0:
+		default:
+			output = interpolate( v );
+			break;
+
+		case 1:
+			output = interpolate_cubic( v );
+			break;
+
+		case 2:
+			output = interpolate_sinc( v );
+			break;
+		}
+		
+		// Noise
+		if ( m.t_non & v->vbit )
+			output = (int16_t) (m.noise * 2);
+		
+		// Apply envelope
+		m.t_output = (output * v->env) >> 11 & ~1;
+		v->t_envx_out = (uint8_t) (v->env >> 4);
+	}
+	
+	// Immediate silence due to end of sample or soft reset
+	if ( REG(flg) & 0x80 || (m.t_brr_header & 3) == 1 )
+	{
+		v->env_mode = env_release;
+		v->env      = 0;
+	}
+	
+	if ( m.every_other_sample )
+	{
+		// KOFF
+		if ( m.t_koff & v->vbit )
+			v->env_mode = env_release;
+		
+		// KON
+		if ( m.kon & v->vbit )
+		{
+			v->kon_delay = 5;
+			v->env_mode  = env_attack;
+		}
+	}
+	
+	// Run envelope for next sample
+	if ( !v->kon_delay )
+		run_envelope( v );
+}
+inline void Spc_Dsp::voice_output( voice_t const* v, int ch )
+{
+	// Check surround removal
+	int vol = (int8_t) VREG(v->regs,voll + ch);
+	int voln = (int8_t) VREG(v->regs,voll + ch ^ 1);
+	if ( vol * voln < m.surround_threshold )
+		vol ^= vol >> 7;
+	
+	// Apply left/right volume
+	int amp = (m.t_output * vol) >> 7;
+	
+	// Add to output total
+	m.t_main_out [ch] += amp;
+	CLAMP16( m.t_main_out [ch] );
+	
+	// Optionally add to echo total
+	if ( m.t_eon & v->vbit )
+	{
+		m.t_echo_out [ch] += amp;
+		CLAMP16( m.t_echo_out [ch] );
+	}
+}
+VOICE_CLOCK( V4 )
+{
+	// Decode BRR
+	m.t_looped = 0;
+	if ( v->interp_pos >= 0x4000 )
+	{
+		decode_brr( v );
+		
+		if ( (v->brr_offset += 2) >= brr_block_size )
+		{
+			// Start decoding next BRR block
+			assert( v->brr_offset == brr_block_size );
+			v->brr_addr = (v->brr_addr + brr_block_size) & 0xFFFF;
+			if ( m.t_brr_header & 1 )
+			{
+				v->brr_addr = m.t_brr_next_addr;
+				m.t_looped = v->vbit;
+			}
+			v->brr_offset = 1;
+		}
+	}
+	
+	// Apply pitch
+	v->interp_pos = (v->interp_pos & 0x3FFF) + m.t_pitch;
+	
+	// Keep from getting too far ahead (when using pitch modulation)
+	if ( v->interp_pos > 0x7FFF )
+		v->interp_pos = 0x7FFF;
+	
+	// Output left
+	voice_output( v, 0 );
+}
+inline VOICE_CLOCK( V5 )
+{
+	// Output right
+	voice_output( v, 1 );
+	
+	// ENDX, OUTX, and ENVX won't update if you wrote to them 1-2 clocks earlier
+	int endx_buf = REG(endx) | m.t_looped;
+	
+	// Clear bit in ENDX if KON just began
+	if ( v->kon_delay == 5 )
+		endx_buf &= ~v->vbit;
+	m.endx_buf = (uint8_t) endx_buf;
+}
+inline VOICE_CLOCK( V6 )
+{
+	(void) v; // avoid compiler warning about unused v
+	m.outx_buf = (uint8_t) (m.t_output >> 8);
+}
+inline VOICE_CLOCK( V7 )
+{
+	// Update ENDX
+	REG(endx) = m.endx_buf;
+	
+	m.envx_buf = v->t_envx_out;
+}
+inline VOICE_CLOCK( V8 )
+{
+	// Update OUTX
+	VREG(v->regs,outx) = m.outx_buf;
+}
+inline VOICE_CLOCK( V9 )
+{
+	// Update ENVX
+	VREG(v->regs,envx) = m.envx_buf;
+}
+
+// Most voices do all these in one clock, so make a handy composite
+inline VOICE_CLOCK( V3 )
+{
+	voice_V3a( v );
+	voice_V3b( v );
+	voice_V3c( v );
+}
+
+// Common combinations of voice steps on different voices. This greatly reduces
+// code size and allows everything to be inlined in these functions.
+VOICE_CLOCK(V7_V4_V1) { voice_V7(v); voice_V1(v+3); voice_V4(v+1); }
+VOICE_CLOCK(V8_V5_V2) { voice_V8(v); voice_V5(v+1); voice_V2(v+2); }
+VOICE_CLOCK(V9_V6_V3) { voice_V9(v); voice_V6(v+1); voice_V3(v+2); }
+
+
+//// Echo
+
+// Current echo buffer pointer for left/right channel
+#define ECHO_PTR( ch )      (&m.ram [m.t_echo_ptr + ch * 2])
+
+// Sample in echo history buffer, where 0 is the oldest
+#define ECHO_FIR( i )       (m.echo_hist_pos [i])
+
+// Calculate FIR point for left/right channel
+#define CALC_FIR( i, ch )   ((ECHO_FIR( i + 1 ) [ch] * (int8_t) REG(fir + i * 0x10)) >> 6)
+
+#define ECHO_CLOCK( n ) inline void Spc_Dsp::echo_##n()
+
+inline void Spc_Dsp::echo_read( int ch )
+{
+	int s = GET_LE16SA( ECHO_PTR( ch ) );
+	// second copy simplifies wrap-around handling
+	ECHO_FIR( 0 ) [ch] = ECHO_FIR( 8 ) [ch] = s >> 1;
+}
+
+ECHO_CLOCK( 22 )
+{
+	// History
+	if ( ++m.echo_hist_pos >= &m.echo_hist [echo_hist_size] )
+		m.echo_hist_pos = m.echo_hist;
+	
+	m.t_echo_ptr = (m.t_esa * 0x100 + m.echo_offset) & 0xFFFF;
+	echo_read( 0 );
+	
+	// FIR (using l and r temporaries below helps compiler optimize)
+	int l = CALC_FIR( 0, 0 );
+	int r = CALC_FIR( 0, 1 );
+	
+	m.t_echo_in [0] = l;
+	m.t_echo_in [1] = r;
+}
+ECHO_CLOCK( 23 )
+{
+	int l = CALC_FIR( 1, 0 ) + CALC_FIR( 2, 0 );
+	int r = CALC_FIR( 1, 1 ) + CALC_FIR( 2, 1 );
+	
+	m.t_echo_in [0] += l;
+	m.t_echo_in [1] += r;
+	
+	echo_read( 1 );
+}
+ECHO_CLOCK( 24 )
+{
+	int l = CALC_FIR( 3, 0 ) + CALC_FIR( 4, 0 ) + CALC_FIR( 5, 0 );
+	int r = CALC_FIR( 3, 1 ) + CALC_FIR( 4, 1 ) + CALC_FIR( 5, 1 );
+	
+	m.t_echo_in [0] += l;
+	m.t_echo_in [1] += r;
+}
+ECHO_CLOCK( 25 )
+{
+	int l = m.t_echo_in [0] + CALC_FIR( 6, 0 );
+	int r = m.t_echo_in [1] + CALC_FIR( 6, 1 );
+	
+	l = (int16_t) l;
+	r = (int16_t) r;
+	
+	l += (int16_t) CALC_FIR( 7, 0 );
+	r += (int16_t) CALC_FIR( 7, 1 );
+	
+	CLAMP16( l );
+	CLAMP16( r );
+	
+	m.t_echo_in [0] = l & ~1;
+	m.t_echo_in [1] = r & ~1;
+}
+inline int Spc_Dsp::echo_output( int ch )
+{
+	// Check surround removal
+	int vol = (int8_t) REG(mvoll + ch * 0x10);
+	int voln = (int8_t) REG(mvoll + ch * 0x10 ^ 0x10);
+	if ( vol * voln < m.surround_threshold )
+		vol ^= vol >> 7;
+	
+	int out = (int16_t) ((m.t_main_out [ch] * vol) >> 7) +
+			(int16_t) ((m.t_echo_in [ch] * (int8_t) REG(evoll + ch * 0x10)) >> 7);
+	CLAMP16( out );
+	return out;
+}
+ECHO_CLOCK( 26 )
+{
+	// Left output volumes
+	// (save sample for next clock so we can output both together)
+	m.t_main_out [0] = echo_output( 0 );
+	
+	// Echo feedback
+	int l = m.t_echo_out [0] + (int16_t) ((m.t_echo_in [0] * (int8_t) REG(efb)) >> 7);
+	int r = m.t_echo_out [1] + (int16_t) ((m.t_echo_in [1] * (int8_t) REG(efb)) >> 7);
+	
+	CLAMP16( l );
+	CLAMP16( r );
+	
+	m.t_echo_out [0] = l & ~1;
+	m.t_echo_out [1] = r & ~1;
+}
+ECHO_CLOCK( 27 )
+{
+	// Output
+	int l = m.t_main_out [0];
+	int r = echo_output( 1 );
+	m.t_main_out [0] = 0;
+	m.t_main_out [1] = 0;
+	
+	// TODO: global muting isn't this simple (turns DAC on and off
+	// or something, causing small ~37-sample pulse when first muted)
+	if ( REG(flg) & 0x40 )
+	{
+		l = 0;
+		r = 0;
+	}
+	
+	// Output sample to DAC
+	#ifdef SPC_DSP_OUT_HOOK
+		SPC_DSP_OUT_HOOK( l, r );
+	#else
+		sample_t* out = m.out;
+		WRITE_SAMPLES( l, r, out );
+		m.out = out;
+	#endif
+}
+ECHO_CLOCK( 28 )
+{
+	m.t_echo_enabled = REG(flg);
+}
+inline void Spc_Dsp::echo_write( int ch )
+{
+	if ( !(m.t_echo_enabled & 0x20) )
+		SET_LE16A( ECHO_PTR( ch ), m.t_echo_out [ch] );
+	m.t_echo_out [ch] = 0;
+}
+ECHO_CLOCK( 29 )
+{
+	m.t_esa = REG(esa);
+	
+	if ( !m.echo_offset )
+		m.echo_length = (REG(edl) & 0x0F) * 0x800;
+	
+	m.echo_offset += 4;
+	if ( m.echo_offset >= m.echo_length )
+		m.echo_offset = 0;
+	
+	// Write left echo
+	echo_write( 0 );
+	
+	m.t_echo_enabled = REG(flg);
+}
+ECHO_CLOCK( 30 )
+{
+	// Write right echo
+	echo_write( 1 );
+}
+
+
+//// Timing
+
+// Execute clock for a particular voice
+#define V( clock, voice )   voice_##clock( &m.voices [voice] );
+
+/* The most common sequence of clocks uses composite operations
+for efficiency. For example, the following are equivalent to the
+individual steps on the right:
+
+V(V7_V4_V1,2) -> V(V7,2) V(V4,3) V(V1,5)
+V(V8_V5_V2,2) -> V(V8,2) V(V5,3) V(V2,4)
+V(V9_V6_V3,2) -> V(V9,2) V(V6,3) V(V3,4) */
+
+// Voice      0      1      2      3      4      5      6      7
+#define GEN_DSP_TIMING \
+PHASE( 0)  V(V5,0)V(V2,1)\
+PHASE( 1)  V(V6,0)V(V3,1)\
+PHASE( 2)  V(V7_V4_V1,0)\
+PHASE( 3)  V(V8_V5_V2,0)\
+PHASE( 4)  V(V9_V6_V3,0)\
+PHASE( 5)         V(V7_V4_V1,1)\
+PHASE( 6)         V(V8_V5_V2,1)\
+PHASE( 7)         V(V9_V6_V3,1)\
+PHASE( 8)                V(V7_V4_V1,2)\
+PHASE( 9)                V(V8_V5_V2,2)\
+PHASE(10)                V(V9_V6_V3,2)\
+PHASE(11)                       V(V7_V4_V1,3)\
+PHASE(12)                       V(V8_V5_V2,3)\
+PHASE(13)                       V(V9_V6_V3,3)\
+PHASE(14)                              V(V7_V4_V1,4)\
+PHASE(15)                              V(V8_V5_V2,4)\
+PHASE(16)                              V(V9_V6_V3,4)\
+PHASE(17)  V(V1,0)                            V(V7,5)V(V4,6)\
+PHASE(18)                                     V(V8_V5_V2,5)\
+PHASE(19)                                     V(V9_V6_V3,5)\
+PHASE(20)         V(V1,1)                            V(V7,6)V(V4,7)\
+PHASE(21)                                            V(V8,6)V(V5,7)  V(V2,0)  /* t_brr_next_addr order dependency */\
+PHASE(22)  V(V3a,0)                                  V(V9,6)V(V6,7)  echo_22();\
+PHASE(23)                                                   V(V7,7)  echo_23();\
+PHASE(24)                                                   V(V8,7)  echo_24();\
+PHASE(25)  V(V3b,0)                                         V(V9,7)  echo_25();\
+PHASE(26)                                                            echo_26();\
+PHASE(27) misc_27();                                                 echo_27();\
+PHASE(28) misc_28();                                                 echo_28();\
+PHASE(29) misc_29();                                                 echo_29();\
+PHASE(30) misc_30();V(V3c,0)                                         echo_30();\
+PHASE(31)  V(V4,0)       V(V1,2)\
+
+#if !SPC_DSP_CUSTOM_RUN
+
+void Spc_Dsp::run( int clocks_remain )
+{
+	require( clocks_remain > 0 );
+	
+	int const phase = m.phase;
+	m.phase = (phase + clocks_remain) & 31;
+	switch ( phase )
+	{
+	loop:
+	
+		#define PHASE( n ) if ( n && !--clocks_remain ) break; case n:
+		GEN_DSP_TIMING
+		#undef PHASE
+	
+		if ( --clocks_remain )
+			goto loop;
+	}
+}
+
+#endif
+
+
+//// Setup
+
+void Spc_Dsp::init( void* ram_64k )
+{
+	m.ram = (uint8_t*) ram_64k;
+	mute_voices( 0 );
+	disable_surround( false );
+	interpolation_level( 0 );
+	set_output( 0, 0 );
+	reset();
+	
+	#ifndef NDEBUG
+		// be sure this sign-extends
+		assert( (int16_t) 0x8000 == -0x8000 );
+		
+		// be sure right shift preserves sign
+		assert( (-1 >> 1) == -1 );
+		
+		// check clamp macro
+		int i;
+		i = +0x8000; CLAMP16( i ); assert( i == +0x7FFF );
+		i = -0x8001; CLAMP16( i ); assert( i == -0x8000 );
+		
+		blargg_verify_byte_order();
+	#endif
+}
+
+void Spc_Dsp::soft_reset_common()
+{
+	require( m.ram ); // init() must have been called already
+	
+	m.noise              = 0x4000;
+	m.echo_hist_pos      = m.echo_hist;
+	m.every_other_sample = 1;
+	m.echo_offset        = 0;
+	m.phase              = 0;
+	
+	init_counter();
+}
+
+void Spc_Dsp::soft_reset()
+{
+	REG(flg) = 0xE0;
+	soft_reset_common();
+}
+
+void Spc_Dsp::load( uint8_t const regs [register_count] )
+{
+	memcpy( m.regs, regs, sizeof m.regs );
+	memset( &m.regs [register_count], 0, offsetof (state_t,ram) - register_count );
+	
+	// Internal state
+	for ( int i = voice_count; --i >= 0; )
+	{
+		voice_t* v = &m.voices [i];
+		v->brr_offset = 1;
+		v->vbit       = 1 << i;
+		v->regs       = &m.regs [i * 0x10];
+	}
+	m.new_kon = REG(kon);
+	m.t_dir   = REG(dir);
+	m.t_esa   = REG(esa);
+	
+	soft_reset_common();
+}
+
+void Spc_Dsp::reset() { load( initial_regs ); }
+
+
+//// State save/load
+
+#if !SPC_NO_COPY_STATE_FUNCS
+
+void SPC_State_Copier::copy( void* state, size_t size )
+{
+	func( buf, state, size );
+}
+
+int SPC_State_Copier::copy_int( int state, int size )
+{
+	BOOST::uint8_t s [2];
+	SET_LE16( s, state );
+	func( buf, &s, size );
+	return GET_LE16( s );
+}
+
+void SPC_State_Copier::skip( int count )
+{
+	if ( count > 0 )
+	{
+		char temp [64];
+		memset( temp, 0, sizeof temp );
+		do
+		{
+			int n = sizeof temp;
+			if ( n > count )
+				n = count;
+			count -= n;
+			func( buf, temp, n );
+		}
+		while ( count );
+	}
+}
+
+void SPC_State_Copier::extra()
+{
+	int n = 0;
+	SPC_State_Copier& copier = *this;
+	SPC_COPY( uint8_t, n );
+	skip( n );
+}
+
+void Spc_Dsp::copy_state( unsigned char** io, copy_func_t copy )
+{
+	SPC_State_Copier copier( io, copy );
+	
+	// DSP registers
+	copier.copy( m.regs, register_count );
+	
+	// Internal state
+	
+	// Voices
+	int i;
+	for ( i = 0; i < voice_count; i++ )
+	{
+		voice_t* v = &m.voices [i];
+		
+		// BRR buffer
+		int j;
+		for ( j = 0; j < brr_buf_size; j++ )
+		{
+			int s = v->buf [j];
+			SPC_COPY(  int16_t, s );
+			v->buf [j] = v->buf [j + brr_buf_size] = s;
+		}
+		
+		SPC_COPY( uint16_t, v->interp_pos );
+		SPC_COPY( uint16_t, v->brr_addr );
+		SPC_COPY( uint16_t, v->env );
+		SPC_COPY(  int16_t, v->hidden_env );
+		SPC_COPY(  uint8_t, v->buf_pos );
+		SPC_COPY(  uint8_t, v->brr_offset );
+		SPC_COPY(  uint8_t, v->kon_delay );
+		{
+			int m = v->env_mode;
+			SPC_COPY(  uint8_t, m );
+			v->env_mode = (enum env_mode_t) m;
+		}
+		SPC_COPY(  uint8_t, v->t_envx_out );
+		
+		copier.extra();
+	}
+	
+	// Echo history
+	for ( i = 0; i < echo_hist_size; i++ )
+	{
+		int j;
+		for ( j = 0; j < 2; j++ )
+		{
+			int s = m.echo_hist_pos [i] [j];
+			SPC_COPY( int16_t, s );
+			m.echo_hist [i] [j] = s; // write back at offset 0
+		}
+	}
+	m.echo_hist_pos = m.echo_hist;
+	memcpy( &m.echo_hist [echo_hist_size], m.echo_hist, echo_hist_size * sizeof m.echo_hist [0] );
+	
+	// Misc
+	SPC_COPY(  uint8_t, m.every_other_sample );
+	SPC_COPY(  uint8_t, m.kon );
+	
+	SPC_COPY( uint16_t, m.noise );
+	SPC_COPY( uint16_t, m.counter );
+	SPC_COPY( uint16_t, m.echo_offset );
+	SPC_COPY( uint16_t, m.echo_length );
+	SPC_COPY(  uint8_t, m.phase );
+	
+	SPC_COPY(  uint8_t, m.new_kon );
+	SPC_COPY(  uint8_t, m.endx_buf );
+	SPC_COPY(  uint8_t, m.envx_buf );
+	SPC_COPY(  uint8_t, m.outx_buf );
+	
+	SPC_COPY(  uint8_t, m.t_pmon );
+	SPC_COPY(  uint8_t, m.t_non );
+	SPC_COPY(  uint8_t, m.t_eon );
+	SPC_COPY(  uint8_t, m.t_dir );
+	SPC_COPY(  uint8_t, m.t_koff );
+	
+	SPC_COPY( uint16_t, m.t_brr_next_addr );
+	SPC_COPY(  uint8_t, m.t_adsr0 );
+	SPC_COPY(  uint8_t, m.t_brr_header );
+	SPC_COPY(  uint8_t, m.t_brr_byte );
+	SPC_COPY(  uint8_t, m.t_srcn );
+	SPC_COPY(  uint8_t, m.t_esa );
+	SPC_COPY(  uint8_t, m.t_echo_enabled );
+	
+	SPC_COPY(  int16_t, m.t_main_out [0] );
+	SPC_COPY(  int16_t, m.t_main_out [1] );
+	SPC_COPY(  int16_t, m.t_echo_out [0] );
+	SPC_COPY(  int16_t, m.t_echo_out [1] );
+	SPC_COPY(  int16_t, m.t_echo_in  [0] );
+	SPC_COPY(  int16_t, m.t_echo_in  [1] );
+	
+	SPC_COPY( uint16_t, m.t_dir_addr );
+	SPC_COPY( uint16_t, m.t_pitch );
+	SPC_COPY(  int16_t, m.t_output );
+	SPC_COPY( uint16_t, m.t_echo_ptr );
+	SPC_COPY(  uint8_t, m.t_looped );
+	
+	copier.extra();
+}
+#endif
diff -Nur orig/source/gme/src/Spc_Dsp.h mod/source/gme/src/Spc_Dsp.h
--- orig/source/gme/src/Spc_Dsp.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Spc_Dsp.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,315 @@
+// Highly accurate SNES SPC-700 DSP emulator
+
+// snes_spc 0.9.0
+#ifndef SPC_DSP_H
+#define SPC_DSP_H
+
+#include "blargg_common.h"
+
+extern "C" { typedef void (*dsp_copy_func_t)( unsigned char** io, void* state, size_t ); }
+
+class Spc_Dsp {
+public:
+	typedef BOOST::uint8_t uint8_t;
+	
+// Setup
+
+	// Initializes DSP and has it use the 64K RAM provided
+	void init( void* ram_64k );
+
+	// Sets destination for output samples. If out is NULL or out_size is 0,
+	// doesn't generate any.
+	typedef short sample_t;
+	void set_output( sample_t* out, int out_size );
+
+	// Number of samples written to output since it was last set, always
+	// a multiple of 2. Undefined if more samples were generated than
+	// output buffer could hold.
+	int sample_count() const;
+
+// Emulation
+
+	// Resets DSP to power-on state
+	void reset();
+
+	// Emulates pressing reset switch on SNES
+	void soft_reset();
+	
+	// Reads/writes DSP registers. For accuracy, you must first call run()
+	// to catch the DSP up to present.
+	int  read ( int addr ) const;
+	void write( int addr, int data );
+
+	// Runs DSP for specified number of clocks (~1024000 per second). Every 32 clocks
+	// a pair of samples is be generated.
+	void run( int clock_count );
+	
+// Sound control
+
+	// Mutes voices corresponding to non-zero bits in mask (issues repeated KOFF events).
+	// Reduces emulation accuracy.
+	enum { voice_count = 8 };
+	void mute_voices( int mask );
+
+// State
+	
+	// Resets DSP and uses supplied values to initialize registers
+	enum { register_count = 128 };
+	void load( uint8_t const regs [register_count] );
+
+	// Saves/loads exact emulator state
+	enum { state_size = 640 }; // maximum space needed when saving
+	typedef dsp_copy_func_t copy_func_t;
+	void copy_state( unsigned char** io, copy_func_t );
+
+	// Returns non-zero if new key-on events occurred since last call
+	bool check_kon();
+	
+// DSP register addresses
+
+	// Global registers
+	enum {
+	    r_mvoll = 0x0C, r_mvolr = 0x1C,
+	    r_evoll = 0x2C, r_evolr = 0x3C,
+	    r_kon   = 0x4C, r_koff  = 0x5C,
+	    r_flg   = 0x6C, r_endx  = 0x7C,
+	    r_efb   = 0x0D, r_pmon  = 0x2D,
+	    r_non   = 0x3D, r_eon   = 0x4D,
+	    r_dir   = 0x5D, r_esa   = 0x6D,
+	    r_edl   = 0x7D,
+	    r_fir   = 0x0F // 8 coefficients at 0x0F, 0x1F ... 0x7F
+	};
+
+	// Voice registers
+	enum {
+		v_voll   = 0x00, v_volr   = 0x01,
+		v_pitchl = 0x02, v_pitchh = 0x03,
+		v_srcn   = 0x04, v_adsr0  = 0x05,
+		v_adsr1  = 0x06, v_gain   = 0x07,
+		v_envx   = 0x08, v_outx   = 0x09
+	};
+
+public:
+	enum { extra_size = 16 };
+	sample_t* extra()               { return m.extra; }
+	sample_t const* out_pos() const { return m.out; }
+	void disable_surround( bool disable = true );
+	void interpolation_level( int level = 0 ) { m.interpolation_level = level; }
+public:
+	BLARGG_DISABLE_NOTHROW
+	
+	typedef BOOST::int8_t   int8_t;
+	typedef BOOST::int16_t int16_t;
+	
+	enum { echo_hist_size = 8 };
+	
+	enum env_mode_t { env_release, env_attack, env_decay, env_sustain };
+	enum { brr_buf_size = 12 };
+	struct voice_t
+	{
+		int buf [brr_buf_size*2];// decoded samples (twice the size to simplify wrap handling)
+		int buf_pos;            // place in buffer where next samples will be decoded
+		int interp_pos;         // relative fractional position in sample (0x1000 = 1.0)
+		int brr_addr;           // address of current BRR block
+		int brr_offset;         // current decoding offset in BRR block
+		uint8_t* regs;          // pointer to voice's DSP registers
+		int vbit;               // bitmask for voice: 0x01 for voice 0, 0x02 for voice 1, etc.
+		int kon_delay;          // KON delay/current setup phase
+		env_mode_t env_mode;
+		int env;                // current envelope level
+		int hidden_env;         // used by GAIN mode 7, very obscure quirk
+		uint8_t t_envx_out;
+	};
+
+private:
+	enum { brr_block_size = 9 };
+	
+	struct state_t
+	{
+		uint8_t regs [register_count];
+		
+		// Echo history keeps most recent 8 samples (twice the size to simplify wrap handling)
+		int echo_hist [echo_hist_size * 2] [2];
+		int (*echo_hist_pos) [2]; // &echo_hist [0 to 7]
+		
+		int every_other_sample; // toggles every sample
+		int kon;                // KON value when last checked
+		int noise;
+		int counter;
+		int echo_offset;        // offset from ESA in echo buffer
+		int echo_length;        // number of bytes that echo_offset will stop at
+		int phase;              // next clock cycle to run (0-31)
+		bool kon_check;         // set when a new KON occurs
+		
+		// Hidden registers also written to when main register is written to
+		int new_kon;
+		uint8_t endx_buf;
+		uint8_t envx_buf;
+		uint8_t outx_buf;
+		
+		// Temporary state between clocks
+		
+		// read once per sample
+		int t_pmon;
+		int t_non;
+		int t_eon;
+		int t_dir;
+		int t_koff;
+		
+		// read a few clocks ahead then used
+		int t_brr_next_addr;
+		int t_adsr0;
+		int t_brr_header;
+		int t_brr_byte;
+		int t_srcn;
+		int t_esa;
+		int t_echo_enabled;
+		
+		// internal state that is recalculated every sample
+		int t_dir_addr;
+		int t_pitch;
+		int t_output;
+		int t_looped;
+		int t_echo_ptr;
+		
+		// left/right sums
+		int t_main_out [2];
+		int t_echo_out [2];
+		int t_echo_in  [2];
+		
+		voice_t voices [voice_count];
+		
+		// non-emulation state
+		uint8_t* ram; // 64K shared RAM between DSP and SMP
+		int mute_mask;
+		int surround_threshold;
+		int interpolation_level;
+		sample_t* out;
+		sample_t* out_end;
+		sample_t* out_begin;
+		sample_t extra [extra_size];
+	};
+	state_t m;
+	
+	void init_counter();
+	void run_counters();
+	unsigned read_counter( int rate );
+	
+	int  interpolate( voice_t const* v );
+	int  interpolate_cubic( voice_t const* v );
+	int  interpolate_sinc( voice_t const* v );
+	void run_envelope( voice_t* const v );
+	void decode_brr( voice_t* v );
+
+	void misc_27();
+	void misc_28();
+	void misc_29();
+	void misc_30();
+
+	void voice_output( voice_t const* v, int ch );
+	void voice_V1( voice_t* const );
+	void voice_V2( voice_t* const );
+	void voice_V3( voice_t* const );
+	void voice_V3a( voice_t* const );
+	void voice_V3b( voice_t* const );
+	void voice_V3c( voice_t* const );
+	void voice_V4( voice_t* const );
+	void voice_V5( voice_t* const );
+	void voice_V6( voice_t* const );
+	void voice_V7( voice_t* const );
+	void voice_V8( voice_t* const );
+	void voice_V9( voice_t* const );
+	void voice_V7_V4_V1( voice_t* const );
+	void voice_V8_V5_V2( voice_t* const );
+	void voice_V9_V6_V3( voice_t* const );
+
+	void echo_read( int ch );
+	int  echo_output( int ch );
+	void echo_write( int ch );
+	void echo_22();
+	void echo_23();
+	void echo_24();
+	void echo_25();
+	void echo_26();
+	void echo_27();
+	void echo_28();
+	void echo_29();
+	void echo_30();
+	
+	void soft_reset_common();
+};
+
+#include <assert.h>
+
+inline int Spc_Dsp::sample_count() const { return m.out - m.out_begin; }
+
+inline int Spc_Dsp::read( int addr ) const
+{
+	assert( (unsigned) addr < register_count );
+	return m.regs [addr];
+}
+
+inline void Spc_Dsp::write( int addr, int data )
+{
+	assert( (unsigned) addr < register_count );
+	
+	m.regs [addr] = (uint8_t) data;
+	switch ( addr & 0x0F )
+	{
+	case v_envx:
+		m.envx_buf = (uint8_t) data;
+		break;
+		
+	case v_outx:
+		m.outx_buf = (uint8_t) data;
+		break;
+	
+	case 0x0C:
+		if ( addr == r_kon )
+			m.new_kon = (uint8_t) data;
+		
+		if ( addr == r_endx ) // always cleared, regardless of data written
+		{
+			m.endx_buf = 0;
+			m.regs [r_endx] = 0;
+		}
+		break;
+	}
+}
+
+inline void Spc_Dsp::mute_voices( int mask ) { m.mute_mask = mask; }
+
+inline void Spc_Dsp::disable_surround( bool disable )
+{
+	m.surround_threshold = disable ? 0 : -0x4000;
+}
+
+inline bool Spc_Dsp::check_kon()
+{
+	bool old = m.kon_check;
+	m.kon_check = 0;
+	return old;
+}
+
+#if !SPC_NO_COPY_STATE_FUNCS
+
+class SPC_State_Copier {
+	Spc_Dsp::copy_func_t func;
+	unsigned char** buf;
+public:
+	SPC_State_Copier( unsigned char** p, Spc_Dsp::copy_func_t f ) { func = f; buf = p; }
+	void copy( void* state, size_t size );
+	int copy_int( int state, int size );
+	void skip( int count );
+	void extra();
+};
+
+#define SPC_COPY( type, state )\
+{\
+	state = (BOOST::type) copier.copy_int( state, sizeof (BOOST::type) );\
+	assert( (BOOST::type) state == state );\
+}
+
+#endif
+
+#endif
diff -Nur orig/source/gme/src/Spc_Emu.cpp mod/source/gme/src/Spc_Emu.cpp
--- orig/source/gme/src/Spc_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Spc_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,393 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Spc_Emu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2004-2009 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// TODO: support Spc_Filter's bass
+
+Spc_Emu::Spc_Emu()
+{
+	set_type( gme_spc_type );
+	set_gain( 1.4 );
+}
+
+Spc_Emu::~Spc_Emu() { }
+
+// Track info
+
+int const trailer_offset = 0x10200;
+
+inline byte const* Spc_Emu::trailer_() const { return &file_begin() [min( file_size(), trailer_offset )]; }
+
+inline int Spc_Emu::trailer_size_() const { return max( 0, file_size() - trailer_offset ); }
+
+static void get_spc_xid6( byte const begin [], int size, track_info_t* out )
+{
+	// header
+	byte const* end = begin + size;
+	if ( size < 8 || memcmp( begin, "xid6", 4 ) )
+	{
+		check( false );
+		return;
+	}
+	int info_size = get_le32( begin + 4 );
+	byte const* in = begin + 8; 
+	if ( end - in > info_size )
+	{
+		dprintf( "SPC: Extra data after xid6\n" );
+		end = in + info_size;
+	}
+	
+	int year = 0;
+	char copyright [256 + 5];
+	int copyright_len = 0;
+	int const year_len = 5;
+	int disc = 0, track = 0;
+	
+	while ( end - in >= 4 )
+	{
+		// header
+		int id   = in [0];
+		int data = in [3] * 0x100 + in [2];
+		int type = in [1];
+		int len  = type ? data : 0;
+		in += 4;
+		if ( len > end - in )
+		{
+			dprintf( "SPC: xid6 goes past end" );
+			break; // block goes past end of data
+		}
+		
+		// handle specific block types
+		char* field = NULL;
+		switch ( id )
+		{
+			case 0x01: field = out->song;    break;
+			case 0x02: field = out->game;    break;
+			case 0x03: field = out->author;  break;
+			case 0x04: field = out->dumper;  break;
+			case 0x07: field = out->comment; break;
+			case 0x10: field = out->ost;     break;
+			case 0x11: disc = data;          break;
+			case 0x12: track = data;         break;
+			case 0x14: year = data;          break;
+			
+			//case 0x30: // intro length
+			// Many SPCs have intro length set wrong for looped tracks, making it useless
+			/*
+			case 0x30:
+				check( len == 4 );
+				if ( len >= 4 )
+				{
+					out->intro_length = get_le32( in ) / 64;
+					if ( out->length > 0 )
+					{
+						int loop = out->length - out->intro_length;
+						if ( loop >= 2000 )
+							out->loop_length = loop;
+					}
+				}
+				break;
+			*/
+			
+			case 0x33:
+				check( len == 4 );
+				if ( len >= 4 )
+				{
+					out->fade_length = get_le32( in ) / 64;
+				}
+				break;
+			
+			case 0x13:
+				copyright_len = min( len, (int) sizeof copyright - year_len );
+				memcpy( &copyright [year_len], in, copyright_len );
+				break;
+			
+			default:
+				if ( id < 0x01 || (id > 0x07 && id < 0x10) ||
+						(id > 0x14 && id < 0x30) || id > 0x36 )
+					dprintf( "SPC: Unknown xid6 block: %X\n", (int) id );
+				break;
+		}
+		if ( field )
+		{
+			check( type == 1 );
+			Gme_File::copy_field_( field, (char const*) in, len );
+		}
+		
+		// skip to next block
+		in += len;
+		
+		// blocks are supposed to be 4-byte aligned with zero-padding...
+		byte const* unaligned = in;
+		while ( (in - begin) & 3 && in < end )
+		{
+			if ( *in++ != 0 )
+			{
+				// ...but some files have no padding
+				in = unaligned;
+				//dprintf( "SPC: xid6 info tag wasn't properly padded to align\n" );
+				break;
+			}
+		}
+	}
+	
+	char* p = &copyright [year_len];
+	if ( year )
+	{
+		*--p = ' ';
+		// avoid using bloated printf
+		for ( int n = 4; n--; )
+		{
+			*--p = char (year % 10 + '0');
+			year /= 10;
+		}
+		copyright_len += year_len;
+	}
+	if ( copyright_len )
+		Gme_File::copy_field_( out->copyright, p, copyright_len );
+	
+	if ( disc > 0 && disc <= 9 )
+	{
+		out->disc [0] = disc + '0';
+		out->disc [1] = 0;
+	}
+
+	if ( track > 255 && track < ( ( 100 << 8 ) - 1 ) )
+	{
+		p = &copyright [3];
+		*p = 0;
+		if ( track & 255 ) *--p = char (track & 255);
+		track >>= 8;
+		for ( int n = 2; n-- && track; )
+		{
+			*--p = char (track % 10 + '0');
+			track /= 10;
+		}
+		memcpy( out->track, p, &copyright [4] - p );
+	}
+
+	check( in == end );
+}
+
+static void get_spc_info( Spc_Emu::header_t const& h, byte const xid6 [], int xid6_size,
+		track_info_t* out )
+{
+	// decode length (can be in text or binary format, sometimes ambiguous ugh)
+	int len_secs = 0;
+	int i;
+	for ( i = 0; i < 3; i++ )
+	{
+		unsigned n = h.len_secs [i] - '0';
+		if ( n > 9 )
+		{
+			// ignore single-digit text lengths
+			// (except if author field is present and begins at offset 1, ugh)
+			if ( i == 1 && (h.author [0] || !h.author [1]) )
+				len_secs = 0;
+			break;
+		}
+		len_secs *= 10;
+		len_secs += n;
+	}
+	if ( !len_secs || len_secs > 0x1FFF )
+		len_secs = get_le16( h.len_secs );
+	if ( len_secs < 0x1FFF )
+		out->length = len_secs * 1000;
+	
+	long fade_msec = 0;
+	for ( i = 0; i < 4; i++ )
+	{
+		unsigned n = h.fade_msec [i] - '0';
+		if ( n > 9 )
+		{
+			if ( i == 1 && (h.author [0] || !h.author [1]) )
+				fade_msec = -1;
+			break;
+		}
+		fade_msec *= 10;
+		fade_msec += n;
+	}
+	if ( i == 4 && unsigned( h.author [0] - '0' ) <= 9 )
+		fade_msec = fade_msec * 10 + h.author [0] - '0';
+	if ( fade_msec < 0 || fade_msec > 0x7FFF )
+		fade_msec = get_le32( h.fade_msec );
+	if ( fade_msec < 0x7FFF )
+		out->fade_length = fade_msec;
+
+	int offset = (h.author [0] < ' ' || unsigned (h.author [0] - '0') <= 9);
+	Gme_File::copy_field_( out->author, &h.author [offset], sizeof h.author - offset );
+	
+	GME_COPY_FIELD( h, out, song );
+	GME_COPY_FIELD( h, out, game );
+	GME_COPY_FIELD( h, out, dumper );
+	GME_COPY_FIELD( h, out, comment );
+	
+	if ( xid6_size )
+		get_spc_xid6( xid6, xid6_size, out );
+}
+
+blargg_err_t Spc_Emu::track_info_( track_info_t* out, int ) const
+{
+	get_spc_info( header(), trailer_(), trailer_size_(), out );
+	return blargg_ok;
+}
+
+static blargg_err_t check_spc_header( void const* header )
+{
+	if ( memcmp( header, "SNES-SPC700 Sound File Data", 27 ) )
+		return blargg_err_file_type;
+	return blargg_ok;
+}
+
+struct Spc_File : Gme_Info_
+{
+	Spc_Emu::header_t header;
+	blargg_vector<byte> xid6;
+	
+	Spc_File() { set_type( gme_spc_type ); }
+	
+	blargg_err_t load_( Data_Reader& in )
+	{
+		int file_size = in.remain();
+		if ( file_size < Snes_Spc::spc_min_file_size )
+			return blargg_err_file_type;
+		RETURN_ERR( in.read( &header, header.size ) );
+		RETURN_ERR( check_spc_header( header.tag ) );
+		int const xid6_offset = 0x10200;
+		int xid6_size = file_size - xid6_offset;
+		if ( xid6_size > 0 )
+		{
+			RETURN_ERR( xid6.resize( xid6_size ) );
+			RETURN_ERR( in.skip( xid6_offset - header.size ) );
+			RETURN_ERR( in.read( xid6.begin(), xid6.size() ) );
+		}
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		get_spc_info( header, xid6.begin(), xid6.size(), out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_spc_emu () { return BLARGG_NEW Spc_Emu ; }
+static Music_Emu* new_spc_file() { return BLARGG_NEW Spc_File; }
+
+gme_type_t_ const gme_spc_type [1] = {{ "Super Nintendo", 1, &new_spc_emu, &new_spc_file, "SPC", 0 }};
+
+// Setup
+
+blargg_err_t Spc_Emu::set_sample_rate_( int sample_rate )
+{
+	RETURN_ERR( apu.init() );
+	if ( sample_rate != native_sample_rate )
+	{
+		RETURN_ERR( resampler.resize_buffer( native_sample_rate / 20 * 2 ) );
+		RETURN_ERR( resampler.set_rate( (double) native_sample_rate / sample_rate ) ); // 0.9965 rolloff
+	}
+	return blargg_ok;
+}
+
+void Spc_Emu::mute_voices_( int m )
+{
+	Music_Emu::mute_voices_( m );
+	apu.mute_voices( m );
+}
+
+blargg_err_t Spc_Emu::load_mem_( byte const in [], int size )
+{
+	assert( offsetof (header_t,unused2 [46]) == header_t::size );
+	set_voice_count( Spc_Dsp::voice_count );
+	if ( size < Snes_Spc::spc_min_file_size )
+		return blargg_err_file_type;
+	
+	static const char* const names [Spc_Dsp::voice_count] = {
+		"DSP 1", "DSP 2", "DSP 3", "DSP 4", "DSP 5", "DSP 6", "DSP 7", "DSP 8"
+	};
+	set_voice_names( names );
+	
+	return check_spc_header( in );
+}
+
+// Emulation
+
+void Spc_Emu::set_tempo_( double t )
+{
+	apu.set_tempo( (int) (t * Snes_Spc::tempo_unit) );
+}
+
+blargg_err_t Spc_Emu::start_track_( int track )
+{
+	RETURN_ERR( Music_Emu::start_track_( track ) );
+	resampler.clear();
+	filter.clear();
+	RETURN_ERR( apu.load_spc( file_begin(), file_size() ) );
+	filter.set_gain( (int) (gain() * SPC_Filter::gain_unit) );
+	apu.clear_echo();
+	return blargg_ok;
+}
+
+blargg_err_t Spc_Emu::play_and_filter( int count, sample_t out [] )
+{
+	RETURN_ERR( apu.play( count, out ) );
+	filter.run( out, count );
+	return blargg_ok;
+}
+
+blargg_err_t Spc_Emu::skip_( int count )
+{
+	if ( sample_rate() != native_sample_rate )
+	{
+		count = (int) (count * resampler.rate()) & ~1;
+		count -= resampler.skip_input( count );
+	}
+	
+	// TODO: shouldn't skip be adjusted for the 64 samples read afterwards?
+	
+	if ( count > 0 )
+	{
+		RETURN_ERR( apu.skip( count ) );
+		filter.clear();
+	}
+	
+	// eliminate pop due to resampler
+	const int resampler_latency = 64;
+	sample_t buf [resampler_latency];
+	return play_( resampler_latency, buf );
+}
+
+blargg_err_t Spc_Emu::play_( int count, sample_t out [] )
+{
+	if ( sample_rate() == native_sample_rate )
+		return play_and_filter( count, out );
+	
+	int remain = count;
+	while ( remain > 0 )
+	{
+		remain -= resampler.read( &out [count - remain], remain );
+		if ( remain > 0 )
+		{
+			int n = resampler.buffer_free();
+			RETURN_ERR( play_and_filter( n, resampler.buffer() ) );
+			resampler.write( n );
+		}
+	}
+	check( remain == 0 );
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Spc_Emu.h mod/source/gme/src/Spc_Emu.h
--- orig/source/gme/src/Spc_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Spc_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,85 @@
+// Super Nintendo SPC music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef SPC_EMU_H
+#define SPC_EMU_H
+
+#include "Music_Emu.h"
+#include "Snes_Spc.h"
+#include "SPC_Filter.h"
+
+#if GME_SPC_FAST_RESAMPLER
+	#include "Upsampler.h"
+	typedef Upsampler Spc_Emu_Resampler;
+#else
+	#include "Fir_Resampler.h"
+	typedef Fir_Resampler<24> Spc_Emu_Resampler;
+#endif
+
+class Spc_Emu : public Music_Emu {
+public:
+	// The Super Nintendo hardware samples at 32kHz. Other sample rates are
+	// handled by resampling the 32kHz output; emulation accuracy is not affected.
+	enum { native_sample_rate = 32000 };
+	
+	// Disables annoying pseudo-surround effect some music uses
+	void disable_surround( bool disable = true )    { apu.disable_surround( disable ); }
+
+	// Enables gaussian, cubic or sinc interpolation
+	void interpolation_level( int level = 0 )   { apu.interpolation_level( level ); }
+
+	// SPC file header
+	struct header_t
+	{
+		enum { size = 0x100 };
+		
+		char tag       [35];
+		byte format;
+		byte version;
+		byte pc        [ 2];
+		byte a, x, y, psw, sp;
+		byte unused    [ 2];
+		char song      [32];
+		char game      [32];
+		char dumper    [16];
+		char comment   [32];
+		byte date      [11];
+		byte len_secs  [ 3];
+		byte fade_msec [ 4];
+		char author    [32]; // sometimes first char should be skipped (see official SPC spec)
+		byte mute_mask;
+		byte emulator;
+		byte unused2   [46];
+	};
+	
+	// Header for currently loaded file
+	header_t const& header() const                  { return *(header_t const*) file_begin(); }
+	
+	static gme_type_t static_type()                 { return gme_spc_type; }
+	
+// Implementation
+public:
+	Spc_Emu();
+	~Spc_Emu();
+
+protected:
+	virtual blargg_err_t load_mem_( byte const [], int );
+	virtual blargg_err_t track_info_( track_info_t*, int track ) const;
+	virtual blargg_err_t set_sample_rate_( int );
+	virtual blargg_err_t start_track_( int );
+	virtual blargg_err_t play_( int, sample_t [] );
+	virtual blargg_err_t skip_( int );
+	virtual void mute_voices_( int );
+	virtual void set_tempo_( double );
+
+private:
+	Spc_Emu_Resampler resampler;
+	SPC_Filter filter;
+	Snes_Spc apu;
+	
+	byte const* trailer_() const;
+	int trailer_size_() const;
+	blargg_err_t play_and_filter( int count, sample_t out [] );
+};
+
+#endif
diff -Nur orig/source/gme/src/SPC_Filter.cpp mod/source/gme/src/SPC_Filter.cpp
--- orig/source/gme/src/SPC_Filter.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/SPC_Filter.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,81 @@
+// snes_spc 0.9.0. http://www.slack.net/~ant/
+
+#include "SPC_Filter.h"
+
+/* Copyright (C) 2007 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+void SPC_Filter::clear() { memset( ch, 0, sizeof ch ); }
+
+SPC_Filter::SPC_Filter()
+{
+	enabled = true;
+	gain    = gain_unit;
+	bass    = bass_norm;
+	clear();
+}
+
+void SPC_Filter::run( short io [], int count )
+{
+	require( (count & 1) == 0 ); // must be even
+	
+	int const gain = this->gain;
+	if ( enabled )
+	{
+		int const bass = this->bass;
+		chan_t* c = &ch [2];
+		do
+		{
+			// cache in registers
+			int sum = (--c)->sum;
+			int pp1 = c->pp1;
+			int p1  = c->p1;
+			
+			for ( int i = 0; i < count; i += 2 )
+			{
+				// Low-pass filter (two point FIR with coeffs 0.25, 0.75)
+				int f = io [i] + p1;
+				p1 = io [i] * 3;
+				
+				// High-pass filter ("leaky integrator")
+				int delta = f - pp1;
+				pp1 = f;
+				int s = sum >> (gain_bits + 2);
+				sum += (delta * gain) - (sum >> bass);
+				
+				// Clamp to 16 bits
+				if ( (short) s != s )
+					s = (s >> 31) ^ 0x7FFF;
+				
+				io [i] = (short) s;
+			}
+			
+			c->p1  = p1;
+			c->pp1 = pp1;
+			c->sum = sum;
+			++io;
+		}
+		while ( c != ch );
+	}
+	else if ( gain != gain_unit )
+	{
+		short* const end = io + count;
+		while ( io < end )
+		{
+			int s = (*io * gain) >> gain_bits;
+			if ( (short) s != s )
+				s = (s >> 31) ^ 0x7FFF;
+			*io++ = (short) s;
+		}
+	}
+}
diff -Nur orig/source/gme/src/SPC_Filter.h mod/source/gme/src/SPC_Filter.h
--- orig/source/gme/src/SPC_Filter.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/SPC_Filter.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,53 @@
+// Simple low-pass and high-pass filter to better match sound output of a SNES
+
+// snes_spc 0.9.0
+#ifndef SPC_FILTER_H
+#define SPC_FILTER_H
+
+#include "blargg_common.h"
+
+struct SPC_Filter {
+public:
+	
+	// Filters count samples of stereo sound in place. Count must be a multiple of 2.
+	typedef short sample_t;
+	void run( sample_t io [], int count );
+	
+// Optional features
+
+	// Clears filter to silence
+	void clear();
+	
+	// Sets gain (volume), where gain_unit is normal. Gains greater than gain_unit
+	// are fine, since output is clamped to 16-bit sample range.
+	enum { gain_unit = 0x100 };
+	void set_gain( int gain );
+	
+	// Enables/disables filtering (when disabled, gain is still applied)
+	void enable( bool b );
+	
+	// Sets amount of bass (logarithmic scale)
+	enum { bass_none =  0 };
+	enum { bass_norm =  8 }; // normal amount
+	enum { bass_max  = 31 };
+	void set_bass( int bass );
+	
+public:
+	SPC_Filter();
+	BLARGG_DISABLE_NOTHROW
+private:
+	enum { gain_bits = 8 };
+	int gain;
+	int bass;
+	bool enabled;
+	struct chan_t { int p1, pp1, sum; };
+	chan_t ch [2];
+};
+
+inline void SPC_Filter::enable( bool b )  { enabled = b; }
+
+inline void SPC_Filter::set_gain( int g ) { gain = g; }
+
+inline void SPC_Filter::set_bass( int b ) { bass = b; }
+
+#endif
diff -Nur orig/source/gme/src/Track_Filter.cpp mod/source/gme/src/Track_Filter.cpp
--- orig/source/gme/src/Track_Filter.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Track_Filter.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,293 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Track_Filter.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const fade_block_size = 512;
+int const fade_shift = 8; // fade ends with gain at 1.0 / (1 << fade_shift)
+int const silence_threshold = 8;
+
+blargg_err_t Track_Filter::init( callbacks_t* c )
+{
+	callbacks = c;
+	return buf.resize( buf_size );
+}
+
+void Track_Filter::clear_time_vars()
+{
+	emu_time      = buf_remain;
+	out_time      = 0;
+	silence_time  = 0;
+	silence_count = 0;
+}
+
+void Track_Filter::stop()
+{
+	emu_track_ended_ = true;
+	track_ended_     = true;
+	fade_start       = indefinite_count;
+	fade_step        = 1;
+	buf_remain       = 0;
+	emu_error        = NULL;
+	clear_time_vars();
+}
+
+Track_Filter::Track_Filter() : setup_()
+{
+	callbacks          = NULL;
+	setup_.max_silence = indefinite_count;
+	silence_ignored_   = false;
+	stop();
+}
+
+Track_Filter::~Track_Filter() { }
+
+blargg_err_t Track_Filter::start_track()
+{
+	emu_error = NULL;
+	stop();
+	
+	emu_track_ended_ = false;
+	track_ended_     = false;
+	
+	if ( !silence_ignored_ )
+	{
+		// play until non-silence or end of track
+		while ( emu_time < setup_.max_initial )
+		{
+			fill_buf();
+			if ( buf_remain | emu_track_ended_ )
+				break;
+		}
+	}
+	
+	clear_time_vars();
+	return emu_error;
+}
+
+void Track_Filter::end_track_if_error( blargg_err_t err )
+{
+	if ( err )
+	{
+		emu_error        = err;
+		emu_track_ended_ = true;
+	}
+}
+
+blargg_err_t Track_Filter::skip( int count )
+{
+	emu_error = NULL;
+	out_time += count;
+	
+	// remove from silence and buf first
+	{
+		int n = min( count, silence_count );
+		silence_count -= n;
+		count         -= n;
+		
+		n = min( count, buf_remain );
+		buf_remain -= n;
+		count      -= n;
+	}
+		
+	if ( count && !emu_track_ended_ )
+	{
+		emu_time += count;
+		silence_time = emu_time; // would otherwise be invalid
+		end_track_if_error( callbacks->skip_( count ) );
+	}
+	
+	if ( !(silence_count | buf_remain) ) // caught up to emulator, so update track ended
+		track_ended_ |= emu_track_ended_;
+	
+	return emu_error;
+}
+
+blargg_err_t Track_Filter::skip_( int count )
+{
+	while ( count && !emu_track_ended_ )
+	{
+		int n = buf_size;
+		if ( n > count )
+			n = count;
+		count -= n;
+		RETURN_ERR( callbacks->play_( n, buf.begin() ) );
+	}
+	return blargg_ok;
+}
+
+// Fading
+
+void Track_Filter::set_fade( int start, int length )
+{
+	fade_start = start;
+	fade_step  = length / (fade_block_size * fade_shift);
+	if ( fade_step < 1 )
+		fade_step = 1;
+}
+
+bool Track_Filter::is_fading() const
+{
+	return out_time >= fade_start && fade_start != indefinite_count;
+}
+
+// unit / pow( 2.0, (double) x / step )
+static int int_log( int x, int step, int unit )
+{
+	int shift = x / step;
+	int fraction = (x - shift * step) * unit / step;
+	return ((unit - fraction) + (fraction >> 1)) >> shift;
+}
+
+void Track_Filter::handle_fade( sample_t out [], int out_count )
+{
+	for ( int i = 0; i < out_count; i += fade_block_size )
+	{
+		int const shift = 14;
+		int const unit = 1 << shift;
+		int gain = int_log( (out_time + i - fade_start) / fade_block_size,
+				fade_step, unit );
+		if ( gain < (unit >> fade_shift) )
+			track_ended_ = emu_track_ended_ = true;
+		
+		sample_t* io = &out [i];
+		for ( int count = min( fade_block_size, out_count - i ); count; --count )
+		{
+			*io = sample_t ((*io * gain) >> shift);
+			++io;
+		}
+	}
+}
+
+// Silence detection
+
+void Track_Filter::emu_play( sample_t out [], int count )
+{
+	emu_time += count;
+	if ( !emu_track_ended_ )
+		end_track_if_error( callbacks->play_( count, out ) );
+	else
+		memset( out, 0, count * sizeof *out );
+}
+
+// number of consecutive silent samples at end
+static int count_silence( Track_Filter::sample_t begin [], int size )
+{
+	Track_Filter::sample_t first = *begin;
+	*begin = silence_threshold * 2; // sentinel
+	Track_Filter::sample_t* p = begin + size;
+	while ( (unsigned) (*--p + silence_threshold) <= (unsigned) silence_threshold * 2 ) { }
+	*begin = first;
+	return size - (p - begin);
+}
+
+// fill internal buffer and check it for silence
+void Track_Filter::fill_buf()
+{
+	assert( !buf_remain );
+	if ( !emu_track_ended_ )
+	{
+		emu_play( buf.begin(), buf_size );
+		int silence = count_silence( buf.begin(), buf_size );
+		if ( silence < buf_size )
+		{
+			silence_time = emu_time - silence;
+			buf_remain   = buf_size;
+			return;
+		}
+	}
+	silence_count += buf_size;
+}
+
+blargg_err_t Track_Filter::play( int out_count, sample_t out [] )
+{
+	emu_error = NULL;
+	if ( track_ended_ )
+	{
+		memset( out, 0, out_count * sizeof *out );
+	}
+	else
+	{
+		assert( emu_time >= out_time );
+		
+		// prints nifty graph of how far ahead we are when searching for silence
+		//dprintf( "%*s \n", int ((emu_time - out_time) * 7 / 44100), "*" );
+		
+		// use any remaining silence samples
+		int pos = 0;
+		if ( silence_count )
+		{
+			if ( !silence_ignored_ )
+			{
+				// during a run of silence, run emulator at >=2x speed so it gets ahead
+				int ahead_time = setup_.lookahead * (out_time + out_count - silence_time) +
+						silence_time;
+				while ( emu_time < ahead_time && !(buf_remain | emu_track_ended_) )
+					fill_buf();
+				
+				// end track if sufficient silence has been found
+				if ( emu_time - silence_time > setup_.max_silence )
+				{
+					track_ended_  = emu_track_ended_ = true;
+					silence_count = out_count;
+					buf_remain    = 0;
+				}
+			}
+			
+			// fill from remaining silence
+			pos = min( silence_count, out_count );
+			memset( out, 0, pos * sizeof *out );
+			silence_count -= pos;
+		}
+		
+		// use any remaining samples from buffer
+		if ( buf_remain )
+		{
+			int n = min( buf_remain, (int) (out_count - pos) );
+			memcpy( out + pos, buf.begin() + (buf_size - buf_remain), n * sizeof *out );
+			buf_remain -= n;
+			pos += n;
+		}
+		
+		// generate remaining samples normally
+		int remain = out_count - pos;
+		if ( remain )
+		{
+			emu_play( out + pos, remain );
+			track_ended_ |= emu_track_ended_;
+			
+			if ( silence_ignored_ && !is_fading() )
+			{
+				// if left unupdated, ahead_time could become too large
+				silence_time = emu_time;
+			}
+			else
+			{
+				// check end for a new run of silence
+				int silence = count_silence( out + pos, remain );
+				if ( silence < remain )
+					silence_time = emu_time - silence;
+				
+				if ( emu_time - silence_time >= buf_size )
+					fill_buf(); // cause silence detection on next play()
+			}
+		}
+		
+		if ( is_fading() )
+			handle_fade( out, out_count );
+	}
+	out_time += out_count;
+	return emu_error;
+}
diff -Nur orig/source/gme/src/Track_Filter.h mod/source/gme/src/Track_Filter.h
--- orig/source/gme/src/Track_Filter.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Track_Filter.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,105 @@
+// Removes silence from beginning of track, fades end of track. Also looks ahead
+// for excessive silence, and if found, ends track.
+
+// Game_Music_Emu 0.6-pre
+#ifndef TRACK_FILTER_H
+#define TRACK_FILTER_H
+
+#include "blargg_common.h"
+
+class Track_Filter {
+public:
+	typedef int sample_count_t;
+	typedef short sample_t;
+	
+	enum { indefinite_count = INT_MAX/2 + 1 };
+	
+	struct callbacks_t {
+		// Samples may be stereo or mono
+		virtual blargg_err_t play_( int count, sample_t* out )  BLARGG_PURE( { return blargg_ok; } )
+		virtual blargg_err_t skip_( int count )                 BLARGG_PURE( { return blargg_ok; } )
+		virtual ~callbacks_t() { } // avoids silly "non-virtual dtor" warning
+	};
+	
+	// Initializes filter. Must be done once before using object.
+	blargg_err_t init( callbacks_t* );
+	
+	struct setup_t {
+		sample_count_t max_initial; // maximum silence to strip from beginning of track
+		sample_count_t max_silence; // maximum silence in middle of track without it ending
+		int lookahead;   // internal speed when looking ahead for silence (2=200% etc.)
+	};
+	
+	// Gets/sets setup
+	setup_t const& setup() const                { return setup_; }
+	void setup( setup_t const& s )              { setup_ = s; }
+	
+	// Disables automatic end-of-track detection and skipping of silence at beginning
+	void ignore_silence( bool disable = true )  { silence_ignored_ = disable; }
+	
+	// Clears state and skips initial silence in track
+	blargg_err_t start_track();
+	
+	// Sets time that fade starts, and how long until track ends.
+	void set_fade( sample_count_t start, sample_count_t length );
+	
+	// Generates n samples into buf
+	blargg_err_t play( int n, sample_t buf [] );
+	
+	// Skips n samples
+	blargg_err_t skip( int n );
+	
+	// Number of samples played/skipped since start_track()
+	int sample_count() const                    { return out_time; }
+	
+	// True if track ended. Causes are end of source samples, end of fade,
+	// or excessive silence.
+	bool track_ended() const                    { return (track_ended_ > 0); }
+	
+	// Clears state
+	void stop();
+	
+// For use by callbacks
+
+	// Sets internal "track ended" flag and stops generation of further source samples
+	void set_track_ended()                      { emu_track_ended_ = true; }
+	
+	// For use by skip_() callback
+	blargg_err_t skip_( int count );
+	
+// Implementation
+public:
+	Track_Filter();
+	~Track_Filter();
+	
+private:
+	callbacks_t* callbacks;
+	setup_t setup_;
+	const char* emu_error;
+	bool silence_ignored_;
+	
+	// Timing
+	int out_time;  // number of samples played since start of track
+	int emu_time;  // number of samples emulator has generated since start of track
+	int emu_track_ended_; // emulator has reached end of track
+	volatile int track_ended_;
+	void clear_time_vars();
+	void end_track_if_error( blargg_err_t );
+	
+	// Fading
+	int fade_start;
+	int fade_step;
+	bool is_fading() const;
+	void handle_fade( sample_t out [], int count );
+	
+	// Silence detection
+	int silence_time;   // absolute number of samples where most recent silence began
+	int silence_count;  // number of samples of silence to play before using buf
+	int buf_remain;     // number of samples left in silence buffer
+	enum { buf_size = 2048 };
+	blargg_vector<sample_t> buf;
+	void fill_buf();
+	void emu_play( sample_t out [], int count );
+};
+
+#endif
diff -Nur orig/source/gme/src/Upsampler.cpp mod/source/gme/src/Upsampler.cpp
--- orig/source/gme/src/Upsampler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Upsampler.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,73 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Upsampler.h"
+
+/* Copyright (C) 2004-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const shift = 15;
+int const unit = 1 << shift;
+
+void Upsampler::clear_()
+{
+	pos = 0;
+	Resampler::clear_();
+}
+
+Upsampler::Upsampler()
+{
+	clear();
+}
+
+blargg_err_t Upsampler::set_rate_( double new_factor )
+{
+	step = (int) (new_factor * unit + 0.5);
+	return Resampler::set_rate_( 1.0 / unit * step );
+}
+
+Resampler::sample_t const* Upsampler::resample_( sample_t** out_, sample_t const* out_end,
+		sample_t const in [], int in_size )
+{
+	in_size -= write_offset;
+	if ( in_size > 0 )
+	{
+		sample_t* BLARGG_RESTRICT out = *out_;
+		sample_t const* const in_end = in + in_size;
+		
+		int const step = this->step;
+		int       pos  = this->pos;
+		
+		do
+		{
+			#define INTERP( i, out )\
+			{\
+				int t = in [0 + i] * (unit - pos) + in [stereo + i] * pos;\
+				out = t >> shift;\
+			}
+			
+			int out_0;
+			INTERP( 0,                  out_0 )
+			INTERP( 1, out [0] = out_0; out [1] )
+			out += stereo;
+			
+			pos += step;
+			in  += ((unsigned) pos >> shift) * stereo;
+			pos &= unit - 1;
+		}
+		while ( in < in_end && out < out_end );
+		
+		this->pos = pos;
+		*out_ = out;
+	}
+	return in;
+}
diff -Nur orig/source/gme/src/Upsampler.h mod/source/gme/src/Upsampler.h
--- orig/source/gme/src/Upsampler.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Upsampler.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,25 @@
+// Increases sampling rate using linear interpolation
+
+// Game_Music_Emu 0.6-pre
+#ifndef UPSAMPLER_H
+#define UPSAMPLER_H
+
+#include "Resampler.h"
+
+class Upsampler : public Resampler {
+public:
+	Upsampler();
+	
+protected:
+	virtual blargg_err_t set_rate_( double );
+	virtual void clear_();
+	virtual sample_t const* resample_( sample_t**, sample_t const*, sample_t const [], int );
+
+protected:
+	enum { stereo = 2 };
+	enum { write_offset = 2 * stereo };
+	int pos;
+	int step;
+};
+
+#endif
diff -Nur orig/source/gme/src/Vgm_Core.cpp mod/source/gme/src/Vgm_Core.cpp
--- orig/source/gme/src/Vgm_Core.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Vgm_Core.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,438 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Vgm_Core.h"
+
+#include "blargg_endian.h"
+#include <math.h>
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+int const stereo         =  2;
+int const fm_time_bits   = 12;
+int const blip_time_bits = 12;
+
+enum {
+	cmd_gg_stereo       = 0x4F,
+	cmd_psg             = 0x50,
+	cmd_ym2413          = 0x51,
+	cmd_ym2612_port0    = 0x52,
+	cmd_ym2612_port1    = 0x53,
+	cmd_ym2151          = 0x54,
+	cmd_delay           = 0x61,
+	cmd_delay_735       = 0x62,
+	cmd_delay_882       = 0x63,
+	cmd_byte_delay      = 0x64,
+	cmd_end             = 0x66,
+	cmd_data_block      = 0x67,
+	cmd_short_delay     = 0x70,
+	cmd_pcm_delay       = 0x80,
+	cmd_pcm_seek        = 0xE0,
+	
+	pcm_block_type      = 0x00,
+	ym2612_dac_port     = 0x2A,
+	ym2612_dac_pan_port = 0xB6
+};
+
+inline int command_len( int command )
+{
+	static byte const lens [0x10] = {
+	// 0 1 2 3 4 5 6 7 8 9 A B C D E F
+	   1,1,1,2,2,3,1,1,1,1,3,3,4,4,5,5
+	};
+	int len = lens [command >> 4];
+	check( len != 1 );
+	return len;
+}
+
+int Vgm_Core::run_ym2413( int time )
+{
+	return ym2413.run_until( time );
+}
+
+int Vgm_Core::run_ym2612( int time )
+{
+	return ym2612.run_until( time );
+}
+
+Vgm_Core::Vgm_Core() { blip_buf = stereo_buf.center(); }
+
+void Vgm_Core::set_tempo( double t )
+{
+	if ( file_begin() )
+	{
+		vgm_rate = (int) (44100 * t + 0.5);
+		blip_time_factor = (int) ((double)
+				(1 << blip_time_bits) / vgm_rate * stereo_buf.center()->clock_rate() + 0.5);
+		//dprintf( "blip_time_factor: %ld\n", blip_time_factor );
+		//dprintf( "vgm_rate: %ld\n", vgm_rate );
+		// TODO: remove? calculates vgm_rate more accurately (above differs at most by one Hz only)
+		//blip_time_factor = (int) floor( double (1 << blip_time_bits) * psg_rate_ / 44100 / t + 0.5 );
+		//vgm_rate = (int) floor( double (1 << blip_time_bits) * psg_rate_ / blip_time_factor + 0.5 );
+		
+		fm_time_factor = 2 + (int) (fm_rate * (1 << fm_time_bits) / vgm_rate + 0.5);
+	}
+}
+
+bool Vgm_Core::header_t::valid_tag() const
+{
+	return !memcmp( tag, "Vgm ", 4 );
+}
+
+blargg_err_t Vgm_Core::load_mem_( byte const data [], int size )
+{
+	assert( offsetof (header_t,unused2 [8]) == header_t::size );
+	
+	if ( size <= header_t::size )
+		return blargg_err_file_type;
+	
+	header_t const& h = *(header_t const*) data;
+	
+	if ( !h.valid_tag() )
+		return blargg_err_file_type;
+	
+	check( get_le32( h.version ) <= 0x150 );
+	
+	// Get loop
+	loop_begin = file_end();
+	if ( get_le32( h.loop_offset ) )
+		loop_begin = &data [get_le32( h.loop_offset ) + offsetof (header_t,loop_offset)];
+	
+	// PSG rate
+	int psg_rate = get_le32( h.psg_rate );
+	if ( !psg_rate )
+		psg_rate = 3579545;
+	stereo_buf.clock_rate( psg_rate );
+	
+	// Disable FM
+	fm_rate = 0;
+	ym2612.enable( false );
+	ym2413.enable( false );
+	
+	set_tempo( 1 );
+	
+	return blargg_ok;
+}
+
+// Update pre-1.10 header FM rates by scanning commands
+void Vgm_Core::update_fm_rates( int* ym2413_rate, int* ym2612_rate ) const
+{
+	byte const* p = file_begin() + 0x40;
+	while ( p < file_end() )
+	{
+		switch ( *p )
+		{
+		case cmd_end:
+			return;
+		
+		case cmd_psg:
+		case cmd_byte_delay:
+			p += 2;
+			break;
+		
+		case cmd_delay:
+			p += 3;
+			break;
+		
+		case cmd_data_block:
+			p += 7 + get_le32( p + 3 );
+			break;
+		
+		case cmd_ym2413:
+			*ym2612_rate = 0;
+			return;
+		
+		case cmd_ym2612_port0:
+		case cmd_ym2612_port1:
+			*ym2612_rate = *ym2413_rate;
+			*ym2413_rate = 0;
+			return;
+		
+		case cmd_ym2151:
+			*ym2413_rate = 0;
+			*ym2612_rate = 0;
+			return;
+		
+		default:
+			p += command_len( *p );
+		}
+	}
+}
+
+blargg_err_t Vgm_Core::init_fm( double* rate )
+{
+	int ym2612_rate = get_le32( header().ym2612_rate );
+	int ym2413_rate = get_le32( header().ym2413_rate );
+	if ( ym2413_rate && get_le32( header().version ) < 0x110 )
+		update_fm_rates( &ym2413_rate, &ym2612_rate );
+	
+	if ( ym2612_rate )
+	{
+		if ( !*rate )
+			*rate = ym2612_rate / 144.0;
+		RETURN_ERR( ym2612.set_rate( *rate, ym2612_rate ) );
+		ym2612.enable();
+	}
+	else if ( ym2413_rate )
+	{
+		if ( !*rate )
+			*rate = ym2413_rate / 72.0;
+		int result = ym2413.set_rate( *rate, ym2413_rate );
+		if ( result == 2 )
+			return "YM2413 FM sound not supported";
+		CHECK_ALLOC( !result );
+		ym2413.enable();
+	}
+	
+	fm_rate = *rate;
+	
+	return blargg_ok;
+}
+
+void Vgm_Core::start_track()
+{
+	psg.reset( get_le16( header().noise_feedback ), header().noise_width );
+	
+	blip_buf = stereo_buf.center();
+
+	dac_disabled = -1;
+	pos          = file_begin() + header_t::size;
+	pcm_data     = pos;
+	pcm_pos      = pos;
+	dac_amp      = -1;
+	vgm_time     = 0;
+	if ( get_le32( header().version ) >= 0x150 )
+	{
+		int data_offset = get_le32( header().data_offset );
+		check( data_offset );
+		if ( data_offset )
+			pos += data_offset + offsetof (header_t,data_offset) - 0x40;
+	}
+	
+	if ( uses_fm() )
+	{
+		if ( ym2413.enabled() )
+			ym2413.reset();
+		
+		if ( ym2612.enabled() )
+			ym2612.reset();
+		
+		stereo_buf.clear();
+	}
+	
+	fm_time_offset = 0;
+}
+
+inline Vgm_Core::fm_time_t Vgm_Core::to_fm_time( vgm_time_t t ) const
+{
+	return (t * fm_time_factor + fm_time_offset) >> fm_time_bits;
+}
+
+inline blip_time_t Vgm_Core::to_psg_time( vgm_time_t t ) const
+{
+	return (t * blip_time_factor) >> blip_time_bits;
+}
+
+void Vgm_Core::write_pcm( vgm_time_t vgm_time, int amp )
+{
+	if ( blip_buf )
+	{
+		check( amp >= 0 );
+		blip_time_t blip_time = to_psg_time( vgm_time );
+		int old = dac_amp;
+		int delta = amp - old;
+		dac_amp = amp;
+		blip_buf->set_modified();
+		if ( old >= 0 ) // first write is ignored, to avoid click
+			pcm.offset_inline( blip_time, delta, blip_buf );
+		else
+			dac_amp |= dac_disabled;
+	}
+}
+
+blip_time_t Vgm_Core::run( vgm_time_t end_time )
+{
+	vgm_time_t vgm_time = this->vgm_time; 
+	byte const* pos = this->pos;
+	if ( pos > file_end() )
+		set_warning( "Stream lacked end event" );
+	
+	while ( vgm_time < end_time && pos < file_end() )
+	{
+		// TODO: be sure there are enough bytes left in stream for particular command
+		// so we don't read past end
+		switch ( *pos++ )
+		{
+		case cmd_end:
+			pos = loop_begin; // if not looped, loop_begin == file_end()
+			break;
+		
+		case cmd_delay_735:
+			vgm_time += 735;
+			break;
+		
+		case cmd_delay_882:
+			vgm_time += 882;
+			break;
+		
+		case cmd_gg_stereo:
+			psg.write_ggstereo( to_psg_time( vgm_time ), *pos++ );
+			break;
+		
+		case cmd_psg:
+			psg.write_data( to_psg_time( vgm_time ), *pos++ );
+			break;
+		
+		case cmd_delay:
+			vgm_time += pos [1] * 0x100 + pos [0];
+			pos += 2;
+			break;
+		
+		case cmd_byte_delay:
+			vgm_time += *pos++;
+			break;
+		
+		case cmd_ym2413:
+			if ( run_ym2413( to_fm_time( vgm_time ) ) )
+				ym2413.write( pos [0], pos [1] );
+			pos += 2;
+			break;
+		
+		case cmd_ym2612_port0:
+			if ( pos [0] == ym2612_dac_port )
+			{
+				write_pcm( vgm_time, pos [1] );
+			}
+			else if ( run_ym2612( to_fm_time( vgm_time ) ) )
+			{
+				if ( pos [0] == 0x2B )
+				{
+					dac_disabled = (pos [1] >> 7 & 1) - 1;
+					dac_amp |= dac_disabled;
+				}
+				ym2612.write0( pos [0], pos [1] );
+			}
+			pos += 2;
+			break;
+		
+		case cmd_ym2612_port1:
+			if ( run_ym2612( to_fm_time( vgm_time ) ) )
+			{
+				if ( pos [0] == ym2612_dac_pan_port )
+				{
+					Blip_Buffer * blip_buf = NULL;
+					switch ( pos [1] >> 6 )
+					{
+					case 0: blip_buf = NULL; break;
+					case 1: blip_buf = stereo_buf.right(); break;
+					case 2: blip_buf = stereo_buf.left(); break;
+					case 3: blip_buf = stereo_buf.center(); break;
+					}
+					/*if ( this->blip_buf != blip_buf )
+					{
+						blip_time_t blip_time = to_psg_time( vgm_time );
+						if ( this->blip_buf ) pcm.offset_inline( blip_time, -dac_amp, this->blip_buf );
+						if ( blip_buf )       pcm.offset_inline( blip_time,  dac_amp, blip_buf );
+					}*/
+					this->blip_buf = blip_buf;
+				}
+				ym2612.write1( pos [0], pos [1] );
+			}
+			pos += 2;
+			break;
+			
+		case cmd_data_block: {
+			check( *pos == cmd_end );
+			int type = pos [1];
+			int size = get_le32( pos + 2 );
+			pos += 6;
+			if ( type == pcm_block_type )
+				pcm_data = pos;
+			pos += size;
+			break;
+		}
+		
+		case cmd_pcm_seek:
+			pcm_pos = pcm_data + pos [3] * 0x1000000 + pos [2] * 0x10000 +
+					pos [1] * 0x100 + pos [0];
+			pos += 4;
+			break;
+		
+		default:
+			int cmd = pos [-1];
+			switch ( cmd & 0xF0 )
+			{
+				case cmd_pcm_delay:
+					write_pcm( vgm_time, *pcm_pos++ );
+					vgm_time += cmd & 0x0F;
+					break;
+				
+				case cmd_short_delay:
+					vgm_time += (cmd & 0x0F) + 1;
+					break;
+				
+				case 0x50:
+					pos += 2;
+					break;
+				
+				default:
+					pos += command_len( cmd ) - 1;
+					set_warning( "Unknown stream event" );
+			}
+		}
+	}
+	vgm_time -= end_time;
+	this->pos = pos;
+	this->vgm_time = vgm_time;
+	
+	return to_psg_time( end_time );
+}
+
+blip_time_t Vgm_Core::run_psg( int msec )
+{
+	blip_time_t t = run( msec * vgm_rate / 1000 );
+	psg.end_frame( t );
+	return t;
+}
+
+int Vgm_Core::play_frame( blip_time_t blip_time, int sample_count, blip_sample_t out [] )
+{
+	// to do: timing is working mostly by luck
+	int min_pairs = (unsigned) sample_count / 2;
+	int vgm_time = (min_pairs << fm_time_bits) / fm_time_factor - 1;
+	assert( to_fm_time( vgm_time ) <= min_pairs );
+	int pairs;
+	while ( (pairs = to_fm_time( vgm_time )) < min_pairs )
+		vgm_time++;
+	//dprintf( "pairs: %d, min_pairs: %d\n", pairs, min_pairs );
+	
+	if ( ym2612.enabled() )
+	{
+		ym2612.begin_frame( out );
+		memset( out, 0, pairs * stereo * sizeof *out );
+	}
+	else if ( ym2413.enabled() )
+	{
+		ym2413.begin_frame( out );
+	}
+	
+	run( vgm_time );
+	run_ym2612( pairs );
+	run_ym2413( pairs );
+	
+	fm_time_offset = (vgm_time * fm_time_factor + fm_time_offset) - (pairs << fm_time_bits);
+	
+	psg.end_frame( blip_time );
+	
+	return pairs * stereo;
+}
diff -Nur orig/source/gme/src/Vgm_Core.h mod/source/gme/src/Vgm_Core.h
--- orig/source/gme/src/Vgm_Core.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Vgm_Core.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,160 @@
+// Sega VGM music file emulator core
+
+// Game_Music_Emu 0.6-pre
+#ifndef VGM_CORE_H
+#define VGM_CORE_H
+
+#include "Gme_Loader.h"
+#include "Ym2612_Emu.h"
+#include "Ym2413_Emu.h"
+#include "Sms_Apu.h"
+#include "Multi_Buffer.h"
+
+	template<class Emu>
+	class Ym_Emu : public Emu {
+		int last_time;
+		short* out;
+		enum { disabled_time = -1 };
+	public:
+		Ym_Emu()                        { last_time = disabled_time; out = NULL; }
+		void enable( bool b = true )    { last_time = b ? 0 : disabled_time; }
+		bool enabled() const            { return last_time != disabled_time; }
+		void begin_frame( short* buf )  { out = buf; last_time = 0; }
+		
+		int run_until( int time )
+		{
+			int count = time - last_time;
+			if ( count > 0 )
+			{
+				if ( last_time < 0 )
+					return false;
+				last_time = time;
+				short* p = out;
+				out += count * Emu::out_chan_count;
+				Emu::run( count, p );
+			}
+			return true;
+		}
+	};
+
+class Vgm_Core : public Gme_Loader {
+public:
+
+	// VGM file header
+	struct header_t
+	{
+		enum { size = 0x40 };
+		
+		char tag            [4];
+		byte data_size      [4];
+		byte version        [4];
+		byte psg_rate       [4];
+		byte ym2413_rate    [4];
+		byte gd3_offset     [4];
+		byte track_duration [4];
+		byte loop_offset    [4];
+		byte loop_duration  [4];
+		byte frame_rate     [4];
+		byte noise_feedback [2];
+		byte noise_width;
+		byte unused1;
+		byte ym2612_rate    [4];
+		byte ym2151_rate    [4];
+		byte data_offset    [4];
+		byte unused2        [8];
+		
+		// True if header has valid file signature
+		bool valid_tag() const;
+	};
+	
+	// Header for currently loaded file
+	header_t const& header() const      { return *(header_t const*) file_begin(); }
+	
+	// Raw file data, for parsing GD3 tags
+	byte const* file_begin() const      { return Gme_Loader::file_begin(); }
+	byte const* file_end  () const      { return Gme_Loader::file_end(); }
+	
+	// If file uses FM, initializes FM sound emulator using *sample_rate. If
+	// *sample_rate is zero, sets *sample_rate to the proper accurate rate and
+	// uses that. The output of the FM sound emulator is resampled to the
+	// final sampling rate.
+	blargg_err_t init_fm( double* sample_rate );
+	
+	// True if any FM chips are used by file. Always false until init_fm()
+	// is called.
+	bool uses_fm() const                { return ym2612.enabled() || ym2413.enabled(); }
+	
+	// Adjusts music tempo, where 1.0 is normal. Can be changed while playing.
+	// Loading a file resets tempo to 1.0.
+	void set_tempo( double );
+	
+	// Starts track
+	void start_track();
+	
+	// Runs PSG-only VGM for msec and returns number of clocks it ran for
+	blip_time_t run_psg( int msec );
+	
+	// Plays FM for at most count samples into *out, and returns number of
+	// samples actually generated (always even). Also runs PSG for blip_time.
+	int play_frame( blip_time_t blip_time, int count, blip_sample_t out [] );
+	
+	// True if all of file data has been played
+	bool track_ended() const            { return pos >= file_end(); }
+	
+	// PCM sound is always generated here
+	Stereo_Buffer stereo_buf;
+	Blip_Buffer * blip_buf;
+	
+	// PSG sound chip, for assigning to Blip_Buffer, and setting volume and EQ
+	Sms_Apu psg;
+	
+	// PCM synth, for setting volume and EQ
+	Blip_Synth_Fast pcm;
+	
+	// FM sound chips
+	Ym_Emu<Ym2612_Emu> ym2612;
+	Ym_Emu<Ym2413_Emu> ym2413;
+
+// Implementation
+public:
+	Vgm_Core();
+
+protected:
+	virtual blargg_err_t load_mem_( byte const [], int );
+	
+private:
+	//          blip_time_t // PSG clocks
+	typedef int vgm_time_t; // 44100 per second, REGARDLESS of sample rate
+	typedef int fm_time_t;  // FM sample count
+	
+	int vgm_rate;   // rate of log, 44100 normally, adjusted by tempo
+	double fm_rate; // FM samples per second
+	
+	// VGM to FM time
+	int fm_time_factor;     
+	int fm_time_offset;
+	fm_time_t to_fm_time( vgm_time_t ) const;
+	
+	// VGM to PSG time
+	int blip_time_factor;
+	blip_time_t to_psg_time( vgm_time_t ) const;
+	
+	// Current time and position in log
+	vgm_time_t vgm_time;
+	byte const* pos;
+	byte const* loop_begin;
+	
+	// PCM
+	byte const* pcm_data;   // location of PCM data in log
+	byte const* pcm_pos;    // current position in PCM data
+	int dac_amp;
+	int dac_disabled;       // -1 if disabled
+	void write_pcm( vgm_time_t, int amp );
+	
+	blip_time_t run( vgm_time_t );
+	int run_ym2413( int time );
+	int run_ym2612( int time );
+	void update_fm_rates( int* ym2413_rate, int* ym2612_rate ) const;
+};
+
+#endif
diff -Nur orig/source/gme/src/Vgm_Emu.cpp mod/source/gme/src/Vgm_Emu.cpp
--- orig/source/gme/src/Vgm_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Vgm_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,360 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Vgm_Emu.h"
+
+#include "blargg_endian.h"
+
+/* Copyright (C) 2003-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// FM emulators are internally quieter to avoid 16-bit overflow
+double const fm_gain           = 3.0;
+double const rolloff           = 0.990;
+double const oversample_factor = 1.5;
+
+Vgm_Emu::Vgm_Emu()
+{
+	resampler.set_callback( play_frame_, this );
+	disable_oversampling_ = false;
+	set_type( gme_vgm_type );
+	set_max_initial_silence( 1 );
+	set_silence_lookahead( 1 ); // tracks should already be trimmed
+	
+	static equalizer_t const eq = { -14.0, 80 };
+	set_equalizer( eq );
+}
+
+Vgm_Emu::~Vgm_Emu() { }
+
+void Vgm_Emu::unload()
+{
+	core.unload();
+	Classic_Emu::unload();
+}
+
+// Track info
+
+static byte const* skip_gd3_str( byte const in [], byte const* end )
+{
+	while ( end - in >= 2 )
+	{
+		in += 2;
+		if ( !(in [-2] | in [-1]) )
+			break;
+	}
+	return in;
+}
+
+static byte const* get_gd3_str( byte const* in, byte const* end, char field [] )
+{
+	byte const* mid = skip_gd3_str( in, end );
+	int len = (mid - in) / 2 - 1;
+	if ( len > 0 )
+	{
+		len = min( len, (int) Gme_File::max_field_ );
+		field [len] = 0;
+		for ( int i = 0; i < len; i++ )
+			field [i] = (in [i * 2 + 1] ? '?' : in [i * 2]); // TODO: convert to utf-8
+	}
+	return mid;
+}
+
+static byte const* get_gd3_pair( byte const* in, byte const* end, char field [] )
+{
+	return skip_gd3_str( get_gd3_str( in, end, field ), end );
+}
+
+static void parse_gd3( byte const in [], byte const* end, track_info_t* out )
+{
+	in = get_gd3_pair( in, end, out->song      );
+	in = get_gd3_pair( in, end, out->game      );
+	in = get_gd3_pair( in, end, out->system    );
+	in = get_gd3_pair( in, end, out->author    );
+	in = get_gd3_str ( in, end, out->copyright );
+	in = get_gd3_pair( in, end, out->dumper    );
+	in = get_gd3_str ( in, end, out->comment   );
+}
+
+int const gd3_header_size = 12;
+
+static int check_gd3_header( byte const h [], int remain )
+{
+	if ( remain < gd3_header_size ) return 0;
+	if ( memcmp( h, "Gd3 ", 4 ) ) return 0;
+	if ( get_le32( h + 4 ) >= 0x200 ) return 0;
+	
+	int gd3_size = get_le32( h + 8 );
+	if ( gd3_size > remain - gd3_header_size ) return 0;
+	
+	return gd3_size;
+}
+
+static void get_vgm_length( Vgm_Emu::header_t const& h, track_info_t* out )
+{
+	int length = get_le32( h.track_duration ) * 10 / 441; // 1000 / 44100
+	if ( length > 0 )
+	{
+		int loop = get_le32( h.loop_duration );
+		if ( loop > 0 && get_le32( h.loop_offset ) )
+		{
+			out->loop_length  = loop * 10 / 441;
+			out->intro_length = length - out->loop_length;
+			check( out->loop_length <= length );
+			// TODO: Also set out->length? We now have play_length for suggested play time.
+		}
+		else
+		{
+			out->length       = length;
+			out->intro_length = length;
+			out->loop_length  = 0;
+		}
+	}
+}
+
+blargg_err_t Vgm_Emu::track_info_( track_info_t* out, int ) const
+{
+	get_vgm_length( header(), out );
+	
+	int gd3_offset = get_le32( header().gd3_offset ) - 0x2C;
+	if ( gd3_offset < 0 )
+		return blargg_ok;
+	
+	byte const* gd3 = core.file_begin() + header_t::size + gd3_offset;
+	int gd3_size = check_gd3_header( gd3, core.file_end() - gd3 );
+	if ( gd3_size )
+	{
+		byte const* gd3_data = gd3 + gd3_header_size;
+		parse_gd3( gd3_data, gd3_data + gd3_size, out );
+	}
+	
+	return blargg_ok;
+}
+
+blargg_err_t Vgm_Emu::gd3_data( const unsigned char ** data, int * size )
+{
+	*data = 0;
+	*size = 0;
+
+	int gd3_offset = get_le32( header().gd3_offset ) - 0x2C;
+	if ( gd3_offset < 0 )
+		return blargg_ok;
+
+	byte const* gd3 = core.file_begin() + header_t::size + gd3_offset;
+	int gd3_size = check_gd3_header( gd3, core.file_end() - gd3 );
+	if ( gd3_size )
+	{
+		*data = gd3;
+		*size = gd3_size + gd3_header_size;
+	}
+
+	return blargg_ok;
+}
+
+struct Vgm_File : Gme_Info_
+{
+	Vgm_Emu::header_t h;
+	blargg_vector<byte> gd3;
+	
+	Vgm_File() { set_type( gme_vgm_type ); }
+	
+	blargg_err_t load_( Data_Reader& in )
+	{
+		int file_size = in.remain();
+		if ( file_size <= h.size )
+			return blargg_err_file_type;
+		
+		RETURN_ERR( in.read( &h, h.size ) );
+		if ( !h.valid_tag() )
+			return blargg_err_file_type;
+		
+		int gd3_offset = get_le32( h.gd3_offset ) - 0x2C;
+		int remain = file_size - h.size - gd3_offset;
+		byte gd3_h [gd3_header_size];
+		if ( gd3_offset > 0 && remain >= gd3_header_size )
+		{
+			RETURN_ERR( in.skip( gd3_offset ) );
+			RETURN_ERR( in.read( gd3_h, sizeof gd3_h ) );
+			int gd3_size = check_gd3_header( gd3_h, remain );
+			if ( gd3_size )
+			{
+				RETURN_ERR( gd3.resize( gd3_size ) );
+				RETURN_ERR( in.read( gd3.begin(), gd3.size() ) );
+			}
+		}
+		return blargg_ok;
+	}
+	
+	blargg_err_t track_info_( track_info_t* out, int ) const
+	{
+		get_vgm_length( h, out );
+		if ( gd3.size() )
+			parse_gd3( gd3.begin(), gd3.end(), out );
+		return blargg_ok;
+	}
+};
+
+static Music_Emu* new_vgm_emu () { return BLARGG_NEW Vgm_Emu ; }
+static Music_Emu* new_vgm_file() { return BLARGG_NEW Vgm_File; }
+
+gme_type_t_ const gme_vgm_type [1] = {{ "Sega SMS/Genesis", 1, &new_vgm_emu, &new_vgm_file, "VGM", 1 }};
+
+gme_type_t_ const gme_vgz_type [1] = {{ "Sega SMS/Genesis", 1, &new_vgm_emu, &new_vgm_file, "VGZ", 1 }};
+
+// Setup
+
+void Vgm_Emu::set_tempo_( double t )
+{
+	core.set_tempo( t );
+}
+
+blargg_err_t Vgm_Emu::set_sample_rate_( int sample_rate )
+{
+	RETURN_ERR( core.stereo_buf.set_sample_rate( sample_rate, 1000 / 30 ) );
+	return Classic_Emu::set_sample_rate_( sample_rate );
+}
+
+void Vgm_Emu::update_eq( blip_eq_t const& eq )
+{
+	core.psg.treble_eq( eq );
+	core.pcm.treble_eq( eq );
+}
+
+void Vgm_Emu::set_voice( int i, Blip_Buffer* c, Blip_Buffer* l, Blip_Buffer* r )
+{
+	if ( i < core.psg.osc_count )
+		core.psg.set_output( i, c, l, r );
+}
+
+void Vgm_Emu::mute_voices_( int mask )
+{
+	Classic_Emu::mute_voices_( mask );
+	
+	// TODO: what was this for?
+	//core.pcm.output( &core.blip_buf );
+	
+	// TODO: silence PCM if FM isn't used?
+	if ( core.uses_fm() )
+	{
+		core.psg.set_output( ( mask & 0x80 ) ? 0 : core.stereo_buf.center() );
+		if ( core.ym2612.enabled() )
+		{
+			core.pcm.volume( (mask & 0x40) ? 0.0 : 0.1115 / 256 * fm_gain * gain() );
+			core.ym2612.mute_voices( mask );
+		}
+		
+		if ( core.ym2413.enabled() )
+		{
+			int m = mask & 0x3F;
+			if ( mask & 0x20 )
+				m |= 0x01E0; // channels 5-8
+			if ( mask & 0x40 )
+				m |= 0x3E00;
+			core.ym2413.mute_voices( m );
+		}
+	}
+}
+
+blargg_err_t Vgm_Emu::load_mem_( byte const data [], int size )
+{
+	RETURN_ERR( core.load_mem( data, size ) );
+
+	set_voice_count( core.psg.osc_count );
+	
+	double fm_rate = 0.0;
+	if ( !disable_oversampling_ )
+		fm_rate = sample_rate() * oversample_factor;
+	RETURN_ERR( core.init_fm( &fm_rate ) );
+	
+	if ( core.uses_fm() )
+	{
+		set_voice_count( 8 );
+		RETURN_ERR( resampler.setup( fm_rate / sample_rate(), rolloff, fm_gain * gain() ) );
+		RETURN_ERR( resampler.reset( core.stereo_buf.length() * sample_rate() / 1000 ) );
+		core.psg.volume( 0.135 * fm_gain * gain() );
+	}
+	else
+	{
+		core.psg.volume( gain() );
+	}
+	
+	static const char* const fm_names [] = {
+		"FM 1", "FM 2", "FM 3", "FM 4", "FM 5", "FM 6", "PCM", "PSG"
+	};
+	static const char* const psg_names [] = { "Square 1", "Square 2", "Square 3", "Noise" };
+	set_voice_names( core.uses_fm() ? fm_names : psg_names );
+	
+	static int const types [8] = {
+		wave_type+1, wave_type+2, wave_type+3, noise_type+1,
+		0, 0, 0, 0
+	};
+	set_voice_types( types );
+	
+	return Classic_Emu::setup_buffer( core.stereo_buf.center()->clock_rate() );
+}
+
+// Emulation
+
+blargg_err_t Vgm_Emu::start_track_( int track )
+{
+	RETURN_ERR( Classic_Emu::start_track_( track ) );
+	
+	core.start_track();
+	
+	if ( core.uses_fm() )
+		resampler.clear();
+	
+	return blargg_ok;
+}
+
+inline void Vgm_Emu::check_end()
+{
+	if ( core.track_ended() )
+		set_track_ended();
+}
+
+inline void Vgm_Emu::check_warning()
+{
+	const char* w = core.warning();
+	if ( w )
+		set_warning( w );
+}
+
+blargg_err_t Vgm_Emu::run_clocks( blip_time_t& time_io, int msec )
+{
+	check_end();
+	time_io = core.run_psg( msec );
+	check_warning();
+	return blargg_ok;
+}
+
+inline int Vgm_Emu::play_frame( blip_time_t blip_time, int sample_count, sample_t buf [] )
+{
+	check_end();
+	int result = core.play_frame( blip_time, sample_count, buf );
+	check_warning();
+	return result;
+}
+
+int Vgm_Emu::play_frame_( void* p, blip_time_t a, int b, sample_t c [] )
+{
+	return STATIC_CAST(Vgm_Emu*,p)->play_frame( a, b, c );
+}
+
+blargg_err_t Vgm_Emu::play_( int count, sample_t out [] )
+{
+	if ( !core.uses_fm() )
+		return Classic_Emu::play_( count, out );
+		
+	resampler.dual_play( count, out, core.stereo_buf );
+	return blargg_ok;
+}
diff -Nur orig/source/gme/src/Vgm_Emu.h mod/source/gme/src/Vgm_Emu.h
--- orig/source/gme/src/Vgm_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Vgm_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,66 @@
+// Sega VGM music file emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef VGM_EMU_H
+#define VGM_EMU_H
+
+#include "Classic_Emu.h"
+#include "Dual_Resampler.h"
+#include "Vgm_Core.h"
+
+/* Emulates VGM music using SN76489/SN76496 PSG, and YM2612 and YM2413 FM sound chips.
+Supports custom sound buffer and frequency equalization when VGM uses just the PSG. FM
+sound chips can be run at their proper rates, or slightly higher to reduce aliasing on
+high notes. A YM2413 is supported but not provided separately from the library. */
+class Vgm_Emu : public Classic_Emu {
+public:
+
+	// True if custom buffer and custom equalization are supported
+	// TODO: move into Music_Emu and rename to something like supports_custom_buffer()
+	bool is_classic_emu() const                         { return !core.uses_fm(); }
+	
+	// Disables running FM chips at higher than normal rate. Will result in slightly
+	// more aliasing of high notes.
+	void disable_oversampling( bool disable = true )    { disable_oversampling_ = disable; }
+	
+	// VGM file header (see Vgm_Core.h)
+	typedef Vgm_Core::header_t header_t;
+	
+	// Header for currently loaded file
+	header_t const& header() const                      { return core.header(); }
+
+	// Gd3 tag for currently loaded file
+	blargg_err_t gd3_data( const unsigned char ** data, int * size );
+	
+	static gme_type_t static_type()                     { return gme_vgm_type; }
+
+// Implementation
+public:
+	Vgm_Emu();
+	~Vgm_Emu();
+	
+protected:
+	blargg_err_t track_info_( track_info_t*, int track ) const;
+	blargg_err_t load_mem_( byte const [], int );
+	blargg_err_t set_sample_rate_( int sample_rate );
+	blargg_err_t start_track_( int );
+	blargg_err_t play_( int count, sample_t  []);
+	blargg_err_t run_clocks( blip_time_t&, int );
+	virtual void set_tempo_( double );
+	virtual void mute_voices_( int mask );
+	virtual void set_voice( int, Blip_Buffer*, Blip_Buffer*, Blip_Buffer* );
+	virtual void update_eq( blip_eq_t const& );
+	virtual void unload();
+	
+private:
+	bool disable_oversampling_;
+	Dual_Resampler resampler;
+	Vgm_Core core;
+	
+	void check_end();
+	void check_warning();
+	int play_frame( blip_time_t blip_time, int sample_count, sample_t buf [] );
+	static int play_frame_( void*, blip_time_t, int, sample_t [] );
+};
+
+#endif
diff -Nur orig/source/gme/src/ym2413.c mod/source/gme/src/ym2413.c
--- orig/source/gme/src/ym2413.c	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/ym2413.c	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,2107 @@
+/*
+**
+** File: ym2413.c - software implementation of YM2413
+**                  FM sound generator type OPLL
+**
+** Copyright Jarek Burczynski
+**
+** Version 1.0
+**
+
+   Features as listed in LSI-212413A2 data sheet:
+    1. FM Sound Generator for real sound creation.
+    2. Two Selectable modes: 9 simultaneous sounds or 6 melody sounds plus 5 rhythm sounds
+       (different tones can be used together in either case).
+    3. Built-in Instruments data (15 melody tones, 5 rhythm tones, "CAPTAIN and TELETEXT applicalbe tones).
+    4. Built-in DA Converter.
+    5. Built-in Quartz Oscillator.
+    6. Built-in Vibrato Oscillator/AM Oscillator
+    7. TTL Compatible Input.
+    8. Si-Gate NMOS LSI
+    9. A single 5V power source.
+
+to do:
+
+- make sure of the sinus amplitude bits
+
+- make sure of the EG resolution bits (looks like the biggest
+  modulation index generated by the modulator is 123, 124 = no modulation)
+- find proper algorithm for attack phase of EG
+
+- tune up instruments ROM
+
+- support sample replay in test mode (it is NOT as simple as setting bit 0
+  in register 0x0f and using register 0x10 for sample data).
+  Which games use this feature ?
+
+
+*/
+
+#define _USE_MATH_DEFINES
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+#include "ym2413.h"
+
+#define INLINE static __inline
+#ifndef NULL
+	#define NULL ((void *)0)
+#endif
+#define logerror (void)
+
+#ifndef M_PI
+	#define M_PI 3.14159265358979323846
+#endif
+
+/* output final shift */
+#if (SAMPLE_BITS==16)
+	#define FINAL_SH	(0)
+	#define MAXOUT		(+32767)
+	#define MINOUT		(-32768)
+#else
+	#define FINAL_SH	(8)
+	#define MAXOUT		(+127)
+	#define MINOUT		(-128)
+#endif
+
+
+#define FREQ_SH			16  /* 16.16 fixed point (frequency calculations) */
+#define EG_SH			16  /* 16.16 fixed point (EG timing)              */
+#define LFO_SH			24  /*  8.24 fixed point (LFO calculations)       */
+
+#define FREQ_MASK		((1<<FREQ_SH)-1)
+
+/* envelope output entries */
+#define ENV_BITS		10
+#define ENV_LEN			(1<<ENV_BITS)
+#define ENV_STEP		(128.0/ENV_LEN)
+
+#define MAX_ATT_INDEX	((1<<(ENV_BITS-2))-1) /*255*/
+#define MIN_ATT_INDEX	(0)
+
+/* sinwave entries */
+#define SIN_BITS		10
+#define SIN_LEN			(1<<SIN_BITS)
+#define SIN_MASK		(SIN_LEN-1)
+
+#define TL_RES_LEN		(256)	/* 8 bits addressing (real chip) */
+
+
+
+/* register number to channel number , slot offset */
+#define SLOT1 0
+#define SLOT2 1
+
+/* Envelope Generator phases */
+
+#define EG_DMP			5
+#define EG_ATT			4
+#define EG_DEC			3
+#define EG_SUS			2
+#define EG_REL			1
+#define EG_OFF			0
+
+
+typedef struct{
+	UINT32	ar;			/* attack rate: AR<<2           */
+	UINT32	dr;			/* decay rate:  DR<<2           */
+	UINT32	rr;			/* release rate:RR<<2           */
+	UINT8	KSR;		/* key scale rate               */
+	UINT8	ksl;		/* keyscale level               */
+	UINT8	ksr;		/* key scale rate: kcode>>KSR   */
+	UINT8	mul;		/* multiple: mul_tab[ML]        */
+
+	/* Phase Generator */
+	UINT32	phase;		/* frequency counter            */
+	UINT32	freq;		/* frequency counter step       */
+	UINT8   fb_shift;	/* feedback shift value         */
+	INT32   op1_out[2];	/* slot1 output for feedback    */
+
+	/* Envelope Generator */
+	UINT8	eg_type;	/* percussive/nonpercussive mode*/
+	UINT8	state;		/* phase type                   */
+	UINT32	TL;			/* total level: TL << 2         */
+	INT32	TLL;		/* adjusted now TL              */
+	INT32	volume;		/* envelope counter             */
+	UINT32	sl;			/* sustain level: sl_tab[SL]    */
+
+	UINT8	eg_sh_dp;	/* (dump state)                 */
+	UINT8	eg_sel_dp;	/* (dump state)                 */
+	UINT8	eg_sh_ar;	/* (attack state)               */
+	UINT8	eg_sel_ar;	/* (attack state)               */
+	UINT8	eg_sh_dr;	/* (decay state)                */
+	UINT8	eg_sel_dr;	/* (decay state)                */
+	UINT8	eg_sh_rr;	/* (release state for non-perc.)*/
+	UINT8	eg_sel_rr;	/* (release state for non-perc.)*/
+	UINT8	eg_sh_rs;	/* (release state for perc.mode)*/
+	UINT8	eg_sel_rs;	/* (release state for perc.mode)*/
+
+	UINT32	key;		/* 0 = KEY OFF, >0 = KEY ON     */
+
+	/* LFO */
+	UINT32	AMmask;		/* LFO Amplitude Modulation enable mask */
+	UINT8	vib;		/* LFO Phase Modulation enable flag (active high)*/
+
+	/* waveform select */
+	unsigned int wavetable;
+} OPLL_SLOT;
+
+#define OPLL_MASK_CH(x) (1<<(x))
+#define OPLL_MASK_HH (1<<(9))
+#define OPLL_MASK_CYM (1<<(10))
+#define OPLL_MASK_TOM (1<<(11))
+#define OPLL_MASK_SD (1<<(12))
+#define OPLL_MASK_BD (1<<(13))
+#define OPLL_MASK_RHYTHM ( OPLL_MASK_HH | OPLL_MASK_CYM | OPLL_MASK_TOM | OPLL_MASK_SD | OPLL_MASK_BD )
+
+typedef struct{
+	OPLL_SLOT SLOT[2];
+	/* phase generator state */
+	UINT32  block_fnum;	/* block+fnum                   */
+	UINT32  fc;			/* Freq. freqement base         */
+	UINT32  ksl_base;	/* KeyScaleLevel Base step      */
+	UINT8   kcode;		/* key code (for key scaling)   */
+	UINT8   sus;		/* sus on/off (release speed in percussive mode)*/
+} OPLL_CH;
+
+/* chip state */
+typedef struct {
+	OPLL_CH	P_CH[9];				/* OPLL chips have 9 channels*/
+	UINT8	instvol_r[9];			/* instrument/volume (or volume/volume in percussive mode)*/
+
+	UINT32	eg_cnt;					/* global envelope generator counter    */
+	UINT32	eg_timer;				/* global envelope generator counter works at frequency = chipclock/72 */
+	UINT32	eg_timer_add;			/* step of eg_timer                     */
+	UINT32	eg_timer_overflow;		/* envelope generator timer overlfows every 1 sample (on real chip) */
+
+	UINT8	rhythm;					/* Rhythm mode                  */
+
+	/* LFO */
+	UINT32	lfo_am_cnt;
+	UINT32	lfo_am_inc;
+	UINT32	lfo_pm_cnt;
+	UINT32	lfo_pm_inc;
+
+	UINT32	noise_rng;				/* 23 bit noise shift register  */
+	UINT32	noise_p;				/* current noise 'phase'        */
+	UINT32	noise_f;				/* current noise period         */
+
+
+/* instrument settings */
+/*
+    0-user instrument
+    1-15 - fixed instruments
+    16 -bass drum settings
+    17,18 - other percussion instruments
+*/
+	UINT8 inst_tab[19][8];
+
+	/* external event callback handlers */
+	OPLL_UPDATEHANDLER UpdateHandler; /* stream update handler      */
+	void * UpdateParam;				/* stream update parameter      */
+
+	UINT32	fn_tab[1024];			/* fnumber->increment counter   */
+
+	UINT8 address;					/* address register             */
+	UINT8 status;					/* status flag                  */
+
+	int clock;						/* master clock  (Hz)           */
+	int rate;						/* sampling rate (Hz)           */
+	double freqbase;				/* frequency base               */
+
+	/* work table */
+	OPLL_SLOT *SLOT7_1,*SLOT7_2,*SLOT8_1,*SLOT8_2;
+
+	signed int output[2];
+
+	UINT32	LFO_AM;
+	INT32	LFO_PM;
+
+	int chip_type;
+	UINT32 mask;
+} YM2413;
+
+/* key scale level */
+/* table is 3dB/octave, DV converts this into 6dB/octave */
+/* 0.1875 is bit 0 weight of the envelope counter (volume) expressed in the 'decibel' scale */
+#define DV (0.1875/1.0)
+static double /*const UINT32*/ ksl_tab[8*16]=
+{
+	/* OCT 0 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	/* OCT 1 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 0.750/DV, 1.125/DV, 1.500/DV,
+	 1.875/DV, 2.250/DV, 2.625/DV, 3.000/DV,
+	/* OCT 2 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 0.000/DV,
+	 0.000/DV, 1.125/DV, 1.875/DV, 2.625/DV,
+	 3.000/DV, 3.750/DV, 4.125/DV, 4.500/DV,
+	 4.875/DV, 5.250/DV, 5.625/DV, 6.000/DV,
+	/* OCT 3 */
+	 0.000/DV, 0.000/DV, 0.000/DV, 1.875/DV,
+	 3.000/DV, 4.125/DV, 4.875/DV, 5.625/DV,
+	 6.000/DV, 6.750/DV, 7.125/DV, 7.500/DV,
+	 7.875/DV, 8.250/DV, 8.625/DV, 9.000/DV,
+	/* OCT 4 */
+	 0.000/DV, 0.000/DV, 3.000/DV, 4.875/DV,
+	 6.000/DV, 7.125/DV, 7.875/DV, 8.625/DV,
+	 9.000/DV, 9.750/DV,10.125/DV,10.500/DV,
+	10.875/DV,11.250/DV,11.625/DV,12.000/DV,
+	/* OCT 5 */
+	 0.000/DV, 3.000/DV, 6.000/DV, 7.875/DV,
+	 9.000/DV,10.125/DV,10.875/DV,11.625/DV,
+	12.000/DV,12.750/DV,13.125/DV,13.500/DV,
+	13.875/DV,14.250/DV,14.625/DV,15.000/DV,
+	/* OCT 6 */
+	 0.000/DV, 6.000/DV, 9.000/DV,10.875/DV,
+	12.000/DV,13.125/DV,13.875/DV,14.625/DV,
+	15.000/DV,15.750/DV,16.125/DV,16.500/DV,
+	16.875/DV,17.250/DV,17.625/DV,18.000/DV,
+	/* OCT 7 */
+	 0.000/DV, 9.000/DV,12.000/DV,13.875/DV,
+	15.000/DV,16.125/DV,16.875/DV,17.625/DV,
+	18.000/DV,18.750/DV,19.125/DV,19.500/DV,
+	19.875/DV,20.250/DV,20.625/DV,21.000/DV
+};
+#undef DV
+
+/* sustain level table (3dB per step) */
+/* 0 - 15: 0, 3, 6, 9,12,15,18,21,24,27,30,33,36,39,42,45 (dB)*/
+#define SC(db) (UINT32) ( db * (1.0/ENV_STEP) )
+static const UINT32 sl_tab[16]={
+ SC( 0),SC( 1),SC( 2),SC(3 ),SC(4 ),SC(5 ),SC(6 ),SC( 7),
+ SC( 8),SC( 9),SC(10),SC(11),SC(12),SC(13),SC(14),SC(15)
+};
+#undef SC
+
+
+#define RATE_STEPS (8)
+static const unsigned char eg_inc[15*RATE_STEPS]={
+
+/*cycle:0 1  2 3  4 5  6 7*/
+
+/* 0 */ 0,1, 0,1, 0,1, 0,1, /* rates 00..12 0 (increment by 0 or 1) */
+/* 1 */ 0,1, 0,1, 1,1, 0,1, /* rates 00..12 1 */
+/* 2 */ 0,1, 1,1, 0,1, 1,1, /* rates 00..12 2 */
+/* 3 */ 0,1, 1,1, 1,1, 1,1, /* rates 00..12 3 */
+
+/* 4 */ 1,1, 1,1, 1,1, 1,1, /* rate 13 0 (increment by 1) */
+/* 5 */ 1,1, 1,2, 1,1, 1,2, /* rate 13 1 */
+/* 6 */ 1,2, 1,2, 1,2, 1,2, /* rate 13 2 */
+/* 7 */ 1,2, 2,2, 1,2, 2,2, /* rate 13 3 */
+
+/* 8 */ 2,2, 2,2, 2,2, 2,2, /* rate 14 0 (increment by 2) */
+/* 9 */ 2,2, 2,4, 2,2, 2,4, /* rate 14 1 */
+/*10 */ 2,4, 2,4, 2,4, 2,4, /* rate 14 2 */
+/*11 */ 2,4, 4,4, 2,4, 4,4, /* rate 14 3 */
+
+/*12 */ 4,4, 4,4, 4,4, 4,4, /* rates 15 0, 15 1, 15 2, 15 3 (increment by 4) */
+/*13 */ 8,8, 8,8, 8,8, 8,8, /* rates 15 2, 15 3 for attack */
+/*14 */ 0,0, 0,0, 0,0, 0,0, /* infinity rates for attack and decay(s) */
+};
+
+
+#define O(a) (a*RATE_STEPS)
+
+/*note that there is no O(13) in this table - it's directly in the code */
+static const unsigned char eg_rate_select[16+64+16]={	/* Envelope Generator rates (16 + 64 rates + 16 RKS) */
+/* 16 infinite time rates */
+O(14),O(14),O(14),O(14),O(14),O(14),O(14),O(14),
+O(14),O(14),O(14),O(14),O(14),O(14),O(14),O(14),
+
+/* rates 00-12 */
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+
+/* rate 13 */
+O( 4),O( 5),O( 6),O( 7),
+
+/* rate 14 */
+O( 8),O( 9),O(10),O(11),
+
+/* rate 15 */
+O(12),O(12),O(12),O(12),
+
+/* 16 dummy rates (same as 15 3) */
+O(12),O(12),O(12),O(12),O(12),O(12),O(12),O(12),
+O(12),O(12),O(12),O(12),O(12),O(12),O(12),O(12),
+
+};
+#undef O
+
+/*rate  0,    1,    2,    3,    4,   5,   6,   7,  8,  9, 10, 11, 12, 13, 14, 15 */
+/*shift 13,   12,   11,   10,   9,   8,   7,   6,  5,  4,  3,  2,  1,  0,  0,  0 */
+/*mask  8191, 4095, 2047, 1023, 511, 255, 127, 63, 31, 15, 7,  3,  1,  0,  0,  0 */
+
+#define O(a) (a*1)
+static const unsigned char eg_rate_shift[16+64+16]={	/* Envelope Generator counter shifts (16 + 64 rates + 16 RKS) */
+/* 16 infinite time rates */
+O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
+O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
+
+/* rates 00-12 */
+O(13),O(13),O(13),O(13),
+O(12),O(12),O(12),O(12),
+O(11),O(11),O(11),O(11),
+O(10),O(10),O(10),O(10),
+O( 9),O( 9),O( 9),O( 9),
+O( 8),O( 8),O( 8),O( 8),
+O( 7),O( 7),O( 7),O( 7),
+O( 6),O( 6),O( 6),O( 6),
+O( 5),O( 5),O( 5),O( 5),
+O( 4),O( 4),O( 4),O( 4),
+O( 3),O( 3),O( 3),O( 3),
+O( 2),O( 2),O( 2),O( 2),
+O( 1),O( 1),O( 1),O( 1),
+
+/* rate 13 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 14 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 15 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* 16 dummy rates (same as 15 3) */
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),
+
+};
+#undef O
+
+
+/* multiple table */
+#define ML 2
+static double /*const UINT8*/ mul_tab[16]= {
+/* 1/2, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,10,12,12,15,15 */
+   0.50*ML, 1.00*ML, 2.00*ML, 3.00*ML, 4.00*ML, 5.00*ML, 6.00*ML, 7.00*ML,
+   8.00*ML, 9.00*ML,10.00*ML,10.00*ML,12.00*ML,12.00*ML,15.00*ML,15.00*ML
+};
+#undef ML
+
+/*  TL_TAB_LEN is calculated as:
+*   11 - sinus amplitude bits     (Y axis)
+*   2  - sinus sign bit           (Y axis)
+*   TL_RES_LEN - sinus resolution (X axis)
+*/
+#define TL_TAB_LEN (11*2*TL_RES_LEN)
+static signed int tl_tab[TL_TAB_LEN];
+
+#define ENV_QUIET		(TL_TAB_LEN>>5)
+
+/* sin waveform table in 'decibel' scale */
+/* two waveforms on OPLL type chips */
+static unsigned int sin_tab[SIN_LEN * 2];
+
+
+/* LFO Amplitude Modulation table (verified on real YM3812)
+   27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples
+
+   Length: 210 elements.
+
+    Each of the elements has to be repeated
+    exactly 64 times (on 64 consecutive samples).
+    The whole table takes: 64 * 210 = 13440 samples.
+
+We use data>>1, until we find what it really is on real chip...
+
+*/
+
+#define LFO_AM_TAB_ELEMENTS 210
+
+static const UINT8 lfo_am_table[LFO_AM_TAB_ELEMENTS] = {
+0,0,0,0,0,0,0,
+1,1,1,1,
+2,2,2,2,
+3,3,3,3,
+4,4,4,4,
+5,5,5,5,
+6,6,6,6,
+7,7,7,7,
+8,8,8,8,
+9,9,9,9,
+10,10,10,10,
+11,11,11,11,
+12,12,12,12,
+13,13,13,13,
+14,14,14,14,
+15,15,15,15,
+16,16,16,16,
+17,17,17,17,
+18,18,18,18,
+19,19,19,19,
+20,20,20,20,
+21,21,21,21,
+22,22,22,22,
+23,23,23,23,
+24,24,24,24,
+25,25,25,25,
+26,26,26,
+25,25,25,25,
+24,24,24,24,
+23,23,23,23,
+22,22,22,22,
+21,21,21,21,
+20,20,20,20,
+19,19,19,19,
+18,18,18,18,
+17,17,17,17,
+16,16,16,16,
+15,15,15,15,
+14,14,14,14,
+13,13,13,13,
+12,12,12,12,
+11,11,11,11,
+10,10,10,10,
+9,9,9,9,
+8,8,8,8,
+7,7,7,7,
+6,6,6,6,
+5,5,5,5,
+4,4,4,4,
+3,3,3,3,
+2,2,2,2,
+1,1,1,1
+};
+
+/* LFO Phase Modulation table (verified on real YM2413) */
+static const INT8 lfo_pm_table[8*8] = {
+
+/* FNUM2/FNUM = 0 00xxxxxx (0x0000) */
+0, 0, 0, 0, 0, 0, 0, 0,
+
+/* FNUM2/FNUM = 0 01xxxxxx (0x0040) */
+1, 0, 0, 0,-1, 0, 0, 0,
+
+/* FNUM2/FNUM = 0 10xxxxxx (0x0080) */
+2, 1, 0,-1,-2,-1, 0, 1,
+
+/* FNUM2/FNUM = 0 11xxxxxx (0x00C0) */
+3, 1, 0,-1,-3,-1, 0, 1,
+
+/* FNUM2/FNUM = 1 00xxxxxx (0x0100) */
+4, 2, 0,-2,-4,-2, 0, 2,
+
+/* FNUM2/FNUM = 1 01xxxxxx (0x0140) */
+5, 2, 0,-2,-5,-2, 0, 2,
+
+/* FNUM2/FNUM = 1 10xxxxxx (0x0180) */
+6, 3, 0,-3,-6,-3, 0, 3,
+
+/* FNUM2/FNUM = 1 11xxxxxx (0x01C0) */
+7, 3, 0,-3,-7,-3, 0, 3,
+};
+
+
+
+
+
+
+/* This is not 100% perfect yet but very close */
+/*
+ - multi parameters are 100% correct (instruments and drums)
+ - LFO PM and AM enable are 100% correct
+ - waveform DC and DM select are 100% correct
+*/
+
+static const unsigned char table[19][8] = {
+/* MULT  MULT modTL DcDmFb AR/DR AR/DR SL/RR SL/RR */
+/*   0     1     2     3     4     5     6    7    */
+  {0x49, 0x4c, 0x4c, 0x12, 0x00, 0x00, 0x00, 0x00 },	/* 0 */
+
+  {0x61, 0x61, 0x1e, 0x17, 0xf0, 0x78, 0x00, 0x17 },	/* 1 */
+  {0x13, 0x41, 0x1e, 0x0d, 0xd7, 0xf7, 0x13, 0x13 },	/* 2 */
+  {0x13, 0x01, 0x99, 0x04, 0xf2, 0xf4, 0x11, 0x23 },	/* 3 */
+  {0x21, 0x61, 0x1b, 0x07, 0xaf, 0x64, 0x40, 0x27 },	/* 4 */
+
+/* {0x22, 0x21, 0x1e, 0x09, 0xf0, 0x76, 0x08, 0x28 },    //5 */
+  {0x22, 0x21, 0x1e, 0x06, 0xf0, 0x75, 0x08, 0x18 },	/* 5 */
+
+/* {0x31, 0x22, 0x16, 0x09, 0x90, 0x7f, 0x00, 0x08 },    //6 */
+  {0x31, 0x22, 0x16, 0x05, 0x90, 0x71, 0x00, 0x13 },	/* 6 */
+
+  {0x21, 0x61, 0x1d, 0x07, 0x82, 0x80, 0x10, 0x17 },	/* 7 */
+  {0x23, 0x21, 0x2d, 0x16, 0xc0, 0x70, 0x07, 0x07 },	/* 8 */
+  {0x61, 0x61, 0x1b, 0x06, 0x64, 0x65, 0x10, 0x17 },	/* 9 */
+
+/* {0x61, 0x61, 0x0c, 0x08, 0x85, 0xa0, 0x79, 0x07 },    //A */
+  {0x61, 0x61, 0x0c, 0x18, 0x85, 0xf0, 0x70, 0x07 },	/* A */
+
+  {0x23, 0x01, 0x07, 0x11, 0xf0, 0xa4, 0x00, 0x22 },	/* B */
+  {0x97, 0xc1, 0x24, 0x07, 0xff, 0xf8, 0x22, 0x12 },	/* C */
+
+/* {0x61, 0x10, 0x0c, 0x08, 0xf2, 0xc4, 0x40, 0xc8 },    //D */
+  {0x61, 0x10, 0x0c, 0x05, 0xf2, 0xf4, 0x40, 0x44 },	/* D */
+
+  {0x01, 0x01, 0x55, 0x03, 0xf3, 0x92, 0xf3, 0xf3 },	/* E */
+  {0x61, 0x41, 0x89, 0x03, 0xf1, 0xf4, 0xf0, 0x13 },	/* F */
+
+/* drum instruments definitions */
+/* MULTI MULTI modTL  xxx  AR/DR AR/DR SL/RR SL/RR */
+/*   0     1     2     3     4     5     6    7    */
+  {0x01, 0x01, 0x16, 0x00, 0xfd, 0xf8, 0x2f, 0x6d },/* BD(multi verified, modTL verified, mod env - verified(close), carr. env verifed) */
+  {0x01, 0x01, 0x00, 0x00, 0xd8, 0xd8, 0xf9, 0xf8 },/* HH(multi verified), SD(multi not used) */
+  {0x05, 0x01, 0x00, 0x00, 0xf8, 0xba, 0x49, 0x55 },/* TOM(multi,env verified), TOP CYM(multi verified, env verified) */
+};
+
+static const unsigned char table_vrc7[15][8] =
+{
+/* VRC7 instruments, January 17, 2004 update -Xodnizel */
+    {0x03, 0x21, 0x04, 0x06, 0x8D, 0xF2, 0x42, 0x17}, 
+    {0x13, 0x41, 0x05, 0x0E, 0x99, 0x96, 0x63, 0x12}, 
+    {0x31, 0x11, 0x10, 0x0A, 0xF0, 0x9C, 0x32, 0x02}, 
+    {0x21, 0x61, 0x1D, 0x07, 0x9F, 0x64, 0x20, 0x27}, 
+    {0x22, 0x21, 0x1E, 0x06, 0xF0, 0x76, 0x08, 0x28}, 
+    {0x02, 0x01, 0x06, 0x00, 0xF0, 0xF2, 0x03, 0x95}, 
+    {0x21, 0x61, 0x1C, 0x07, 0x82, 0x81, 0x16, 0x07}, 
+    {0x23, 0x21, 0x1A, 0x17, 0xEF, 0x82, 0x25, 0x15}, 
+    {0x25, 0x11, 0x1F, 0x00, 0x86, 0x41, 0x20, 0x11}, 
+    {0x85, 0x01, 0x1F, 0x0F, 0xE4, 0xA2, 0x11, 0x12}, 
+    {0x07, 0xC1, 0x2B, 0x45, 0xB4, 0xF1, 0x24, 0xF4},
+    {0x61, 0x23, 0x11, 0x06, 0x96, 0x96, 0x13, 0x16}, 
+    {0x01, 0x02, 0xD3, 0x05, 0x82, 0xA2, 0x31, 0x51}, 
+    {0x61, 0x22, 0x0D, 0x02, 0xC3, 0x7F, 0x24, 0x05},
+    {0x21, 0x62, 0x0E, 0x00, 0xA1, 0xA0, 0x44, 0x17},
+
+};
+
+INLINE int limit( int val, int max, int min ) {
+	if ( val > max )
+		val = max;
+	else if ( val < min )
+		val = min;
+
+	return val;
+}
+
+
+/* advance LFO to next sample */
+INLINE void advance_lfo(YM2413 *chip)
+{
+	/* LFO */
+	chip->lfo_am_cnt += chip->lfo_am_inc;
+	if (chip->lfo_am_cnt >= ((UINT32)LFO_AM_TAB_ELEMENTS<<LFO_SH) )	/* lfo_am_table is 210 elements long */
+		chip->lfo_am_cnt -= ((UINT32)LFO_AM_TAB_ELEMENTS<<LFO_SH);
+
+	chip->LFO_AM = lfo_am_table[ chip->lfo_am_cnt >> LFO_SH ] >> 1;
+
+	chip->lfo_pm_cnt += chip->lfo_pm_inc;
+	chip->LFO_PM = (chip->lfo_pm_cnt>>LFO_SH) & 7;
+}
+
+/* advance to next sample */
+INLINE void advance(YM2413 *chip)
+{
+	OPLL_CH *CH;
+	OPLL_SLOT *op;
+	unsigned int i;
+
+	/* Envelope Generator */
+	chip->eg_timer += chip->eg_timer_add;
+
+	while (chip->eg_timer >= chip->eg_timer_overflow)
+	{
+		chip->eg_timer -= chip->eg_timer_overflow;
+
+		chip->eg_cnt++;
+
+		for (i=0; i<9*2; i++)
+		{
+			CH  = &chip->P_CH[i/2];
+
+			op  = &CH->SLOT[i&1];
+
+			switch(op->state)
+			{
+
+			case EG_DMP:		/* dump phase */
+			/*dump phase is performed by both operators in each channel*/
+			/*when CARRIER envelope gets down to zero level,
+            **  phases in BOTH opearators are reset (at the same time ?)
+            */
+				if ( !(chip->eg_cnt & ((1<<op->eg_sh_dp)-1) ) )
+				{
+					op->volume += eg_inc[op->eg_sel_dp + ((chip->eg_cnt>>op->eg_sh_dp)&7)];
+
+					if ( op->volume >= MAX_ATT_INDEX )
+					{
+						op->volume = MAX_ATT_INDEX;
+						op->state = EG_ATT;
+						/* restart Phase Generator  */
+						op->phase = 0;
+					}
+				}
+			break;
+
+			case EG_ATT:		/* attack phase */
+				if ( !(chip->eg_cnt & ((1<<op->eg_sh_ar)-1) ) )
+				{
+					op->volume += (~op->volume *
+	                        		           (eg_inc[op->eg_sel_ar + ((chip->eg_cnt>>op->eg_sh_ar)&7)])
+        			                          ) >>2;
+
+					if (op->volume <= MIN_ATT_INDEX)
+					{
+						op->volume = MIN_ATT_INDEX;
+						op->state = EG_DEC;
+					}
+				}
+			break;
+
+			case EG_DEC:	/* decay phase */
+				if ( !(chip->eg_cnt & ((1<<op->eg_sh_dr)-1) ) )
+				{
+					op->volume += eg_inc[op->eg_sel_dr + ((chip->eg_cnt>>op->eg_sh_dr)&7)];
+
+					if ( op->volume >= op->sl )
+						op->state = EG_SUS;
+				}
+			break;
+
+			case EG_SUS:	/* sustain phase */
+				/* this is important behaviour:
+                one can change percusive/non-percussive modes on the fly and
+                the chip will remain in sustain phase - verified on real YM3812 */
+
+				if(op->eg_type)		/* non-percussive mode (sustained tone) */
+				{
+									/* do nothing */
+				}
+				else				/* percussive mode */
+				{
+					/* during sustain phase chip adds Release Rate (in percussive mode) */
+					if ( !(chip->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )
+					{
+						op->volume += eg_inc[op->eg_sel_rr + ((chip->eg_cnt>>op->eg_sh_rr)&7)];
+
+						if ( op->volume >= MAX_ATT_INDEX )
+							op->volume = MAX_ATT_INDEX;
+					}
+					/* else do nothing in sustain phase */
+				}
+			break;
+
+			case EG_REL:	/* release phase */
+			/* exclude modulators in melody channels from performing anything in this mode*/
+			/* allowed are only carriers in melody mode and rhythm slots in rhythm mode */
+
+			/*This table shows which operators and on what conditions are allowed to perform EG_REL:
+            (a) - always perform EG_REL
+            (n) - never perform EG_REL
+            (r) - perform EG_REL in Rhythm mode ONLY
+                0: 0 (n),  1 (a)
+                1: 2 (n),  3 (a)
+                2: 4 (n),  5 (a)
+                3: 6 (n),  7 (a)
+                4: 8 (n),  9 (a)
+                5: 10(n),  11(a)
+                6: 12(r),  13(a)
+                7: 14(r),  15(a)
+                8: 16(r),  17(a)
+            */
+				if ( (i&1) || ((chip->rhythm&0x20) && (i>=12)) )/* exclude modulators */
+				{
+					if(op->eg_type)		/* non-percussive mode (sustained tone) */
+					/*this is correct: use RR when SUS = OFF*/
+					/*and use RS when SUS = ON*/
+					{
+						if (CH->sus)
+						{
+							if ( !(chip->eg_cnt & ((1<<op->eg_sh_rs)-1) ) )
+							{
+								op->volume += eg_inc[op->eg_sel_rs + ((chip->eg_cnt>>op->eg_sh_rs)&7)];
+								if ( op->volume >= MAX_ATT_INDEX )
+								{
+									op->volume = MAX_ATT_INDEX;
+									op->state = EG_OFF;
+								}
+							}
+						}
+						else
+						{
+							if ( !(chip->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )
+							{
+								op->volume += eg_inc[op->eg_sel_rr + ((chip->eg_cnt>>op->eg_sh_rr)&7)];
+								if ( op->volume >= MAX_ATT_INDEX )
+								{
+									op->volume = MAX_ATT_INDEX;
+									op->state = EG_OFF;
+								}
+							}
+						}
+					}
+					else				/* percussive mode */
+					{
+						if ( !(chip->eg_cnt & ((1<<op->eg_sh_rs)-1) ) )
+						{
+							op->volume += eg_inc[op->eg_sel_rs + ((chip->eg_cnt>>op->eg_sh_rs)&7)];
+							if ( op->volume >= MAX_ATT_INDEX )
+							{
+								op->volume = MAX_ATT_INDEX;
+								op->state = EG_OFF;
+							}
+						}
+					}
+				}
+			break;
+
+			default:
+			break;
+			}
+		}
+	}
+
+	for (i=0; i<9*2; i++)
+	{
+		CH  = &chip->P_CH[i/2];
+		op  = &CH->SLOT[i&1];
+
+		/* Phase Generator */
+		if(op->vib)
+		{
+			UINT8 block;
+
+			unsigned int fnum_lfo   = 8*((CH->block_fnum&0x01c0) >> 6);
+			unsigned int block_fnum = CH->block_fnum * 2;
+			signed int lfo_fn_table_index_offset = lfo_pm_table[chip->LFO_PM + fnum_lfo ];
+
+			if (lfo_fn_table_index_offset)	/* LFO phase modulation active */
+			{
+				block_fnum += lfo_fn_table_index_offset;
+				block = (block_fnum&0x1c00) >> 10;
+				op->phase += (chip->fn_tab[block_fnum&0x03ff] >> (7-block)) * op->mul;
+			}
+			else	/* LFO phase modulation  = zero */
+			{
+				op->phase += op->freq;
+			}
+		}
+		else	/* LFO phase modulation disabled for this operator */
+		{
+			op->phase += op->freq;
+		}
+	}
+
+	/*  The Noise Generator of the YM3812 is 23-bit shift register.
+    *   Period is equal to 2^23-2 samples.
+    *   Register works at sampling frequency of the chip, so output
+    *   can change on every sample.
+    *
+    *   Output of the register and input to the bit 22 is:
+    *   bit0 XOR bit14 XOR bit15 XOR bit22
+    *
+    *   Simply use bit 22 as the noise output.
+    */
+
+	chip->noise_p += chip->noise_f;
+	i = chip->noise_p >> FREQ_SH;		/* number of events (shifts of the shift register) */
+	chip->noise_p &= FREQ_MASK;
+	while (i)
+	{
+		/*
+        UINT32 j;
+        j = ( (chip->noise_rng) ^ (chip->noise_rng>>14) ^ (chip->noise_rng>>15) ^ (chip->noise_rng>>22) ) & 1;
+        chip->noise_rng = (j<<22) | (chip->noise_rng>>1);
+        */
+
+		/*
+            Instead of doing all the logic operations above, we
+            use a trick here (and use bit 0 as the noise output).
+            The difference is only that the noise bit changes one
+            step ahead. This doesn't matter since we don't know
+            what is real state of the noise_rng after the reset.
+        */
+
+		if (chip->noise_rng & 1) chip->noise_rng ^= 0x800302;
+		chip->noise_rng >>= 1;
+
+		i--;
+	}
+}
+
+
+INLINE signed int op_calc(UINT32 phase, unsigned int env, signed int pm, unsigned int wave_tab)
+{
+	UINT32 p;
+
+	p = (env<<5) + sin_tab[wave_tab + ((((signed int)((phase & ~FREQ_MASK) + (pm<<17))) >> FREQ_SH ) & SIN_MASK) ];
+
+	if (p >= TL_TAB_LEN)
+		return 0;
+	return tl_tab[p];
+}
+
+INLINE signed int op_calc1(UINT32 phase, unsigned int env, signed int pm, unsigned int wave_tab)
+{
+	UINT32 p;
+	INT32  i;
+
+	i = (phase & ~FREQ_MASK) + pm;
+
+/*logerror("i=%08x (i>>16)&511=%8i phase=%i [pm=%08x] ",i, (i>>16)&511, phase>>FREQ_SH, pm);*/
+
+	p = (env<<5) + sin_tab[ wave_tab + ((i>>FREQ_SH) & SIN_MASK)];
+
+/*logerror("(p&255=%i p>>8=%i) out= %i\n", p&255,p>>8, tl_tab[p&255]>>(p>>8) );*/
+
+	if (p >= TL_TAB_LEN)
+		return 0;
+	return tl_tab[p];
+}
+
+
+#define volume_calc(OP) ((OP)->TLL + ((UINT32)(OP)->volume) + (chip->LFO_AM & (OP)->AMmask))
+
+/* calculate output */
+INLINE void chan_calc( YM2413 *chip, OPLL_CH *CH )
+{
+	OPLL_SLOT *SLOT;
+	unsigned int env;
+	signed int out;
+	signed int phase_modulation;	/* phase modulation input (SLOT 2) */
+
+
+	/* SLOT 1 */
+	SLOT = &CH->SLOT[SLOT1];
+	env  = volume_calc(SLOT);
+	out  = SLOT->op1_out[0] + SLOT->op1_out[1];
+
+	SLOT->op1_out[0] = SLOT->op1_out[1];
+	phase_modulation = SLOT->op1_out[0];
+
+	SLOT->op1_out[1] = 0;
+
+	if( env < ENV_QUIET )
+	{
+		if (!SLOT->fb_shift)
+			out = 0;
+		SLOT->op1_out[1] = op_calc1(SLOT->phase, env, (out<<SLOT->fb_shift), SLOT->wavetable );
+	}
+
+	/* SLOT 2 */
+
+	SLOT++;
+	env = volume_calc(SLOT);
+	if( env < ENV_QUIET )
+	{
+		signed int outp = op_calc(SLOT->phase, env, phase_modulation, SLOT->wavetable);
+		chip->output[0] += outp;
+		/* output[0] += op_calc(SLOT->phase, env, phase_modulation, SLOT->wavetable); */
+	}
+}
+
+/*
+    operators used in the rhythm sounds generation process:
+
+    Envelope Generator:
+
+channel  operator  register number   Bass  High  Snare Tom  Top
+/ slot   number    TL ARDR SLRR Wave Drum  Hat   Drum  Tom  Cymbal
+ 6 / 0   12        50  70   90   f0  +
+ 6 / 1   15        53  73   93   f3  +
+ 7 / 0   13        51  71   91   f1        +
+ 7 / 1   16        54  74   94   f4              +
+ 8 / 0   14        52  72   92   f2                    +
+ 8 / 1   17        55  75   95   f5                          +
+
+    Phase Generator:
+
+channel  operator  register number   Bass  High  Snare Tom  Top
+/ slot   number    MULTIPLE          Drum  Hat   Drum  Tom  Cymbal
+ 6 / 0   12        30                +
+ 6 / 1   15        33                +
+ 7 / 0   13        31                      +     +           +
+ 7 / 1   16        34                -----  n o t  u s e d -----
+ 8 / 0   14        32                                  +
+ 8 / 1   17        35                      +                 +
+
+channel  operator  register number   Bass  High  Snare Tom  Top
+number   number    BLK/FNUM2 FNUM    Drum  Hat   Drum  Tom  Cymbal
+   6     12,15     B6        A6      +
+
+   7     13,16     B7        A7            +     +           +
+
+   8     14,17     B8        A8            +           +     +
+
+*/
+
+/* calculate rhythm */
+
+INLINE void rhythm_calc( YM2413 *chip, OPLL_CH *CH, unsigned int noise )
+{
+	OPLL_SLOT *SLOT;
+	signed int out;
+	unsigned int env;
+	signed int phase_modulation;	/* phase modulation input (SLOT 2) */
+
+
+	/* Bass Drum (verified on real YM3812):
+      - depends on the channel 6 'connect' register:
+          when connect = 0 it works the same as in normal (non-rhythm) mode (op1->op2->out)
+          when connect = 1 _only_ operator 2 is present on output (op2->out), operator 1 is ignored
+      - output sample always is multiplied by 2
+    */
+
+
+	/* SLOT 1 */
+	if ( !(chip->mask & OPLL_MASK_BD) )
+	{
+		SLOT = &CH[6].SLOT[SLOT1];
+		env = volume_calc(SLOT);
+
+		out = SLOT->op1_out[0] + SLOT->op1_out[1];
+		SLOT->op1_out[0] = SLOT->op1_out[1];
+
+		phase_modulation = SLOT->op1_out[0];
+
+		SLOT->op1_out[1] = 0;
+		if( env < ENV_QUIET )
+		{
+			if (!SLOT->fb_shift)
+				out = 0;
+			SLOT->op1_out[1] = op_calc1(SLOT->phase, env, (out<<SLOT->fb_shift), SLOT->wavetable );
+		}
+
+		/* SLOT 2 */
+		SLOT++;
+		env = volume_calc(SLOT);
+		if( env < ENV_QUIET )
+			chip->output[1] += op_calc(SLOT->phase, env, phase_modulation, SLOT->wavetable) * 2;
+	}
+
+
+	/* Phase generation is based on:
+	HH  (13) channel 7->slot 1 combined with channel 8->slot 2 (same combination as TOP CYMBAL but different output phases)
+	SD  (16) channel 7->slot 1
+	TOM (14) channel 8->slot 1
+	TOP (17) channel 7->slot 1 combined with channel 8->slot 2 (same combination as HIGH HAT but different output phases) */
+
+	/* Envelope generation based on:
+	HH  channel 7->slot1
+	SD  channel 7->slot2
+	TOM channel 8->slot1
+	TOP channel 8->slot2 */
+
+
+	/* The following formulas can be well optimized.
+       I leave them in direct form for now (in case I've missed something).
+    */
+
+	/* High Hat (verified on real YM3812) */
+	if ( !(chip->mask & OPLL_MASK_HH) )
+	{
+		env = volume_calc(chip->SLOT7_1);
+		if( env < ENV_QUIET )
+		{
+
+			/* high hat phase generation:
+			phase = d0 or 234 (based on frequency only)
+			phase = 34 or 2d0 (based on noise)
+			*/
+
+			/* base frequency derived from operator 1 in channel 7 */
+			unsigned char bit7 = ((chip->SLOT7_1->phase>>FREQ_SH)>>7)&1;
+			unsigned char bit3 = ((chip->SLOT7_1->phase>>FREQ_SH)>>3)&1;
+			unsigned char bit2 = ((chip->SLOT7_1->phase>>FREQ_SH)>>2)&1;
+
+			unsigned char res1 = (bit2 ^ bit7) | bit3;
+
+			/* when res1 = 0 phase = 0x000 | 0xd0; */
+			/* when res1 = 1 phase = 0x200 | (0xd0>>2); */
+			UINT32 phase = res1 ? (0x200|(0xd0>>2)) : 0xd0;
+
+			/* enable gate based on frequency of operator 2 in channel 8 */
+			unsigned char bit5e= ((chip->SLOT8_2->phase>>FREQ_SH)>>5)&1;
+			unsigned char bit3e= ((chip->SLOT8_2->phase>>FREQ_SH)>>3)&1;
+
+			unsigned char res2 = (bit3e | bit5e);
+
+			/* when res2 = 0 pass the phase from calculation above (res1); */
+			/* when res2 = 1 phase = 0x200 | (0xd0>>2); */
+			if (res2)
+				phase = (0x200|(0xd0>>2));
+
+
+			/* when phase & 0x200 is set and noise=1 then phase = 0x200|0xd0 */
+			/* when phase & 0x200 is set and noise=0 then phase = 0x200|(0xd0>>2), ie no change */
+			if (phase&0x200)
+			{
+				if (noise)
+					phase = 0x200|0xd0;
+			}
+			else
+				/* when phase & 0x200 is clear and noise=1 then phase = 0xd0>>2 */
+				/* when phase & 0x200 is clear and noise=0 then phase = 0xd0, ie no change */
+			{
+				if (noise)
+					phase = 0xd0>>2;
+			}
+
+			chip->output[1] += op_calc(phase<<FREQ_SH, env, 0, chip->SLOT7_1->wavetable) * 2;
+		}
+	}
+
+	/* Snare Drum (verified on real YM3812) */
+	if ( !(chip->mask & OPLL_MASK_SD) )
+	{
+		env = volume_calc(chip->SLOT7_2);
+		if( env < ENV_QUIET )
+		{
+			/* base frequency derived from operator 1 in channel 7 */
+			unsigned char bit8 = ((chip->SLOT7_1->phase>>FREQ_SH)>>8)&1;
+
+			/* when bit8 = 0 phase = 0x100; */
+			/* when bit8 = 1 phase = 0x200; */
+			UINT32 phase = bit8 ? 0x200 : 0x100;
+
+			/* Noise bit XOR'es phase by 0x100 */
+			/* when noisebit = 0 pass the phase from calculation above */
+			/* when noisebit = 1 phase ^= 0x100; */
+			/* in other words: phase ^= (noisebit<<8); */
+			if (noise)
+				phase ^= 0x100;
+
+			chip->output[1] += op_calc(phase<<FREQ_SH, env, 0, chip->SLOT7_2->wavetable) * 2;
+		}
+	}
+
+	/* Tom Tom (verified on real YM3812) */
+	if ( !(chip->mask & OPLL_MASK_TOM) )
+	{
+		env = volume_calc(chip->SLOT8_1);
+		if( env < ENV_QUIET )
+			chip->output[1] += op_calc(chip->SLOT8_1->phase, env, 0, chip->SLOT8_1->wavetable) * 2;
+	}
+
+	/* Top Cymbal (verified on real YM2413) */
+	if ( !(chip->mask & OPLL_MASK_CYM) )
+	{
+		env = volume_calc(chip->SLOT8_2);
+		if( env < ENV_QUIET )
+		{
+			/* base frequency derived from operator 1 in channel 7 */
+			unsigned char bit7 = ((chip->SLOT7_1->phase>>FREQ_SH)>>7)&1;
+			unsigned char bit3 = ((chip->SLOT7_1->phase>>FREQ_SH)>>3)&1;
+			unsigned char bit2 = ((chip->SLOT7_1->phase>>FREQ_SH)>>2)&1;
+
+			unsigned char res1 = (bit2 ^ bit7) | bit3;
+
+			/* when res1 = 0 phase = 0x000 | 0x100; */
+			/* when res1 = 1 phase = 0x200 | 0x100; */
+			UINT32 phase = res1 ? 0x300 : 0x100;
+
+			/* enable gate based on frequency of operator 2 in channel 8 */
+			unsigned char bit5e= ((chip->SLOT8_2->phase>>FREQ_SH)>>5)&1;
+			unsigned char bit3e= ((chip->SLOT8_2->phase>>FREQ_SH)>>3)&1;
+
+			unsigned char res2 = (bit3e | bit5e);
+			/* when res2 = 0 pass the phase from calculation above (res1); */
+			/* when res2 = 1 phase = 0x200 | 0x100; */
+			if (res2)
+				phase = 0x300;
+
+			chip->output[1] += op_calc(phase<<FREQ_SH, env, 0, chip->SLOT8_2->wavetable) * 2;
+		}
+	}
+}
+
+
+/* generic table initialize */
+static int init_tables(void)
+{
+	signed int i,x;
+	signed int n;
+	double o,m;
+
+
+	for (x=0; x<TL_RES_LEN; x++)
+	{
+		m = (1<<16) / pow(2, (x+1) * (ENV_STEP/4.0) / 8.0);
+		m = floor(m);
+
+		/* we never reach (1<<16) here due to the (x+1) */
+		/* result fits within 16 bits at maximum */
+
+		n = (int)m;		/* 16 bits here */
+		n >>= 4;		/* 12 bits here */
+		if (n&1)		/* round to nearest */
+			n = (n>>1)+1;
+		else
+			n = n>>1;
+						/* 11 bits here (rounded) */
+		tl_tab[ x*2 + 0 ] = n;
+		tl_tab[ x*2 + 1 ] = -tl_tab[ x*2 + 0 ];
+
+		for (i=1; i<11; i++)
+		{
+			tl_tab[ x*2+0 + i*2*TL_RES_LEN ] =  tl_tab[ x*2+0 ]>>i;
+			tl_tab[ x*2+1 + i*2*TL_RES_LEN ] = -tl_tab[ x*2+0 + i*2*TL_RES_LEN ];
+		}
+	#if 0
+			logerror("tl %04i", x*2);
+			for (i=0; i<11; i++)
+				logerror(", [%02i] %5i", i*2, tl_tab[ x*2 /*+1*/ + i*2*TL_RES_LEN ] );
+			logerror("\n");
+	#endif
+	}
+	/*logerror("ym2413.c: TL_TAB_LEN = %i elements (%i bytes)\n",TL_TAB_LEN, (int)sizeof(tl_tab));*/
+
+
+	for (i=0; i<SIN_LEN; i++)
+	{
+		/* non-standard sinus */
+		m = sin( ((i*2)+1) * M_PI / SIN_LEN ); /* checked against the real chip */
+
+		/* we never reach zero here due to ((i*2)+1) */
+
+		if (m>0.0)
+			o = 8*log(1.0/m)/log(2.0);	/* convert to 'decibels' */
+		else
+			o = 8*log(-1.0/m)/log(2.0);	/* convert to 'decibels' */
+
+		o = o / (ENV_STEP/4);
+
+		n = (int)(2.0*o);
+		if (n&1)						/* round to nearest */
+			n = (n>>1)+1;
+		else
+			n = n>>1;
+
+		/* waveform 0: standard sinus  */
+		sin_tab[ i ] = n*2 + (m>=0.0? 0: 1 );
+
+		/*logerror("ym2413.c: sin [%4i (hex=%03x)]= %4i (tl_tab value=%5i)\n", i, i, sin_tab[i], tl_tab[sin_tab[i]] );*/
+
+
+		/* waveform 1:  __      __     */
+		/*             /  \____/  \____*/
+		/* output only first half of the sinus waveform (positive one) */
+		if (i & (1<<(SIN_BITS-1)) )
+			sin_tab[1*SIN_LEN+i] = TL_TAB_LEN;
+		else
+			sin_tab[1*SIN_LEN+i] = sin_tab[i];
+
+		/*logerror("ym2413.c: sin1[%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[1*SIN_LEN+i], tl_tab[sin_tab[1*SIN_LEN+i]] );*/
+	}
+#if 0
+	logerror("YM2413.C: ENV_QUIET= %08x (*32=%08x)\n", ENV_QUIET, ENV_QUIET*32 );
+	for (i=0; i<ENV_QUIET; i++)
+	{
+		logerror("tl_tb[%4x(%4i)]=%8x\n", i<<5, i, tl_tab[i<<5] );
+	}
+#endif
+#ifdef SAVE_SAMPLE
+	sample[0]=fopen("sampsum.pcm","wb");
+#endif
+
+	return 1;
+}
+
+static void OPLL_initalize(YM2413 *chip)
+{
+	int i;
+
+	/* frequency base */
+	chip->freqbase  = (chip->rate) ? ((double)chip->clock / 72.0) / chip->rate  : 0;
+	if ( fabs( chip->freqbase - 1.0 ) < 0.0000001 )
+		chip->freqbase = 1.0;
+#if 0
+	chip->rate = (double)chip->clock / 72.0;
+	chip->freqbase  = 1.0;
+	logerror("freqbase=%f\n", chip->freqbase);
+#endif
+
+
+
+	/* make fnumber -> increment counter table */
+	for( i = 0 ; i < 1024; i++ )
+	{
+		/* OPLL (YM2413) phase increment counter = 18bit */
+
+		chip->fn_tab[i] = (UINT32)( (double)i * 64 * chip->freqbase * (1<<(FREQ_SH-10)) ); /* -10 because chip works with 10.10 fixed point, while we use 16.16 */
+#if 0
+		logerror("ym2413.c: fn_tab[%4i] = %08x (dec=%8i)\n",
+				 i, chip->fn_tab[i]>>6, chip->fn_tab[i]>>6 );
+#endif
+	}
+
+#if 0
+	for( i=0 ; i < 16 ; i++ )
+	{
+		logerror("ym2413.c: sl_tab[%i] = %08x\n", i, sl_tab[i] );
+	}
+	for( i=0 ; i < 8 ; i++ )
+	{
+		int j;
+		logerror("ym2413.c: ksl_tab[oct=%2i] =",i);
+		for (j=0; j<16; j++)
+		{
+			logerror("%08x ", ksl_tab[i*16+j] );
+		}
+		logerror("\n");
+	}
+#endif
+
+
+	/* Amplitude modulation: 27 output levels (triangle waveform); 1 level takes one of: 192, 256 or 448 samples */
+	/* One entry from LFO_AM_TABLE lasts for 64 samples */
+	chip->lfo_am_inc = (UINT32)((1.0 / 64.0 ) * (1<<LFO_SH) * chip->freqbase);
+
+	/* Vibrato: 8 output levels (triangle waveform); 1 level takes 1024 samples */
+	chip->lfo_pm_inc = (UINT32)((1.0 / 1024.0) * (1<<LFO_SH) * chip->freqbase);
+
+	/*logerror ("chip->lfo_am_inc = %8x ; chip->lfo_pm_inc = %8x\n", chip->lfo_am_inc, chip->lfo_pm_inc);*/
+
+	/* Noise generator: a step takes 1 sample */
+	chip->noise_f = (UINT32)((1.0 / 1.0) * (1<<FREQ_SH) * chip->freqbase);
+	/*logerror("YM2413init noise_f=%8x\n", chip->noise_f);*/
+
+	chip->eg_timer_add  = (UINT32)((1<<EG_SH)  * chip->freqbase);
+	chip->eg_timer_overflow = ( 1 ) * (1<<EG_SH);
+	/*logerror("YM2413init eg_timer_add=%8x eg_timer_overflow=%8x\n", chip->eg_timer_add, chip->eg_timer_overflow);*/
+}
+
+INLINE void KEY_ON(OPLL_SLOT *SLOT, UINT32 key_set)
+{
+	if( !SLOT->key )
+	{
+		/* do NOT restart Phase Generator (verified on real YM2413)*/
+		/* phase -> Dump */
+		SLOT->state = EG_DMP;
+	}
+	SLOT->key |= key_set;
+}
+
+INLINE void KEY_OFF(OPLL_SLOT *SLOT, UINT32 key_clr)
+{
+	if( SLOT->key )
+	{
+		SLOT->key &= key_clr;
+
+		if( !SLOT->key )
+		{
+			/* phase -> Release */
+			if (SLOT->state>EG_REL)
+				SLOT->state = EG_REL;
+		}
+	}
+}
+
+/* update phase increment counter of operator (also update the EG rates if necessary) */
+INLINE void CALC_FCSLOT(OPLL_CH *CH,OPLL_SLOT *SLOT)
+{
+	int ksr;
+	UINT32 SLOT_rs;
+	UINT32 SLOT_dp;
+
+	/* (frequency) phase increment counter */
+	SLOT->freq = CH->fc * SLOT->mul;
+	ksr = CH->kcode >> SLOT->KSR;
+
+	if( SLOT->ksr != ksr )
+	{
+		SLOT->ksr = ksr;
+
+		/* calculate envelope generator rates */
+		if ((SLOT->ar + SLOT->ksr) < 16+62)
+		{
+			SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];
+			SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];
+		}
+		else
+		{
+			SLOT->eg_sh_ar  = 0;
+			SLOT->eg_sel_ar = 13*RATE_STEPS;
+		}
+		SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];
+		SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];
+		SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];
+		SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];
+
+	}
+
+	if (CH->sus)
+		SLOT_rs  = 16 + (5<<2);
+	else
+		SLOT_rs  = 16 + (7<<2);
+
+	SLOT->eg_sh_rs  = eg_rate_shift [SLOT_rs + SLOT->ksr ];
+	SLOT->eg_sel_rs = eg_rate_select[SLOT_rs + SLOT->ksr ];
+
+	SLOT_dp  = 16 + (13<<2);
+	SLOT->eg_sh_dp  = eg_rate_shift [SLOT_dp + SLOT->ksr ];
+	SLOT->eg_sel_dp = eg_rate_select[SLOT_dp + SLOT->ksr ];
+}
+
+/* set multi,am,vib,EG-TYP,KSR,mul */
+INLINE void set_mul(YM2413 *chip,int slot,int v)
+{
+	OPLL_CH   *CH   = &chip->P_CH[slot/2];
+	OPLL_SLOT *SLOT = &CH->SLOT[slot&1];
+
+	SLOT->mul     = (UINT8)(mul_tab[v&0x0f]);
+	SLOT->KSR     = (v&0x10) ? 0 : 2;
+	SLOT->eg_type = (v&0x20);
+	SLOT->vib     = (v&0x40);
+	SLOT->AMmask  = (v&0x80) ? ~0 : 0;
+	CALC_FCSLOT(CH,SLOT);
+}
+
+/* set ksl, tl */
+INLINE void set_ksl_tl(YM2413 *chip,int chan,int v)
+{
+	int ksl;
+	OPLL_CH   *CH   = &chip->P_CH[chan];
+/* modulator */
+	OPLL_SLOT *SLOT = &CH->SLOT[SLOT1];
+
+	ksl = v>>6; /* 0 / 1.5 / 3.0 / 6.0 dB/OCT */
+
+	SLOT->ksl = ksl ? 3-ksl : 31;
+	SLOT->TL  = (v&0x3f)<<(ENV_BITS-2-7); /* 7 bits TL (bit 6 = always 0) */
+	SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
+}
+
+/* set ksl , waveforms, feedback */
+INLINE void set_ksl_wave_fb(YM2413 *chip,int chan,int v)
+{
+	int ksl;
+	OPLL_CH   *CH   = &chip->P_CH[chan];
+/* modulator */
+	OPLL_SLOT *SLOT = &CH->SLOT[SLOT1];
+	SLOT->wavetable = ((v&0x08)>>3)*SIN_LEN;
+	SLOT->fb_shift  = (v&7) ? (v&7) + 8 : 0;
+
+/*carrier*/
+	SLOT = &CH->SLOT[SLOT2];
+	ksl = v>>6; /* 0 / 1.5 / 3.0 / 6.0 dB/OCT */
+
+	SLOT->ksl = ksl ? 3-ksl : 31;
+	SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
+
+	SLOT->wavetable = ((v&0x10)>>4)*SIN_LEN;
+}
+
+/* set attack rate & decay rate  */
+INLINE void set_ar_dr(YM2413 *chip,int slot,int v)
+{
+	OPLL_CH   *CH   = &chip->P_CH[slot/2];
+	OPLL_SLOT *SLOT = &CH->SLOT[slot&1];
+
+	SLOT->ar = (v>>4)  ? 16 + ((v>>4)  <<2) : 0;
+
+	if ((SLOT->ar + SLOT->ksr) < 16+62)
+	{
+		SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];
+		SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];
+	}
+	else
+	{
+		SLOT->eg_sh_ar  = 0;
+		SLOT->eg_sel_ar = 13*RATE_STEPS;
+	}
+
+	SLOT->dr    = (v&0x0f)? 16 + ((v&0x0f)<<2) : 0;
+	SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];
+	SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];
+}
+
+/* set sustain level & release rate */
+INLINE void set_sl_rr(YM2413 *chip,int slot,int v)
+{
+	OPLL_CH   *CH   = &chip->P_CH[slot/2];
+	OPLL_SLOT *SLOT = &CH->SLOT[slot&1];
+
+	SLOT->sl  = sl_tab[ v>>4 ];
+
+	SLOT->rr  = (v&0x0f)? 16 + ((v&0x0f)<<2) : 0;
+	SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];
+	SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];
+}
+
+static void load_instrument(YM2413 *chip, UINT32 chan, UINT32 slot, UINT8* inst )
+{
+	set_mul			(chip, slot,   inst[0]);
+	set_mul			(chip, slot+1, inst[1]);
+	set_ksl_tl		(chip, chan,   inst[2]);
+	set_ksl_wave_fb	(chip, chan,   inst[3]);
+	set_ar_dr		(chip, slot,   inst[4]);
+	set_ar_dr		(chip, slot+1, inst[5]);
+	set_sl_rr		(chip, slot,   inst[6]);
+	set_sl_rr		(chip, slot+1, inst[7]);
+}
+static void update_instrument_zero(YM2413 *chip, UINT8 r )
+{
+	UINT8* inst = &chip->inst_tab[0][0]; /* point to user instrument */
+	UINT32 chan;
+	UINT32 chan_max;
+
+	chan_max = 9;
+	if (chip->rhythm & 0x20)
+		chan_max=6;
+
+	switch(r)
+	{
+	case 0:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_mul			(chip, chan*2, inst[0]);
+			}
+		}
+        break;
+	case 1:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_mul			(chip, chan*2+1,inst[1]);
+			}
+		}
+        break;
+	case 2:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_ksl_tl		(chip, chan,   inst[2]);
+			}
+		}
+        break;
+	case 3:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_ksl_wave_fb	(chip, chan,   inst[3]);
+			}
+		}
+        break;
+	case 4:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_ar_dr		(chip, chan*2, inst[4]);
+			}
+		}
+        break;
+	case 5:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_ar_dr		(chip, chan*2+1,inst[5]);
+			}
+		}
+        break;
+	case 6:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_sl_rr		(chip, chan*2, inst[6]);
+			}
+		}
+        break;
+	case 7:
+		for (chan=0; chan<chan_max; chan++)
+		{
+			if ((chip->instvol_r[chan]&0xf0)==0)
+			{
+				set_sl_rr		(chip, chan*2+1,inst[7]);
+			}
+		}
+        break;
+    }
+}
+
+/* write a value v to register r on chip chip */
+static void OPLLWriteReg(YM2413 *chip, int r, int v)
+{
+	OPLL_CH *CH;
+	OPLL_SLOT *SLOT;
+	UINT8 *inst;
+	int chan;
+	int slot;
+
+	/* adjust bus to 8 bits */
+	r &= 0xff;
+	v &= 0xff;
+
+
+	switch(r&0xf0)
+	{
+	case 0x00:	/* 00-0f:control */
+	{
+		switch(r&0x0f)
+		{
+		case 0x00:	/* AM/VIB/EGTYP/KSR/MULTI (modulator) */
+		case 0x01:	/* AM/VIB/EGTYP/KSR/MULTI (carrier) */
+		case 0x02:	/* Key Scale Level, Total Level (modulator) */
+		case 0x03:	/* Key Scale Level, carrier waveform, modulator waveform, Feedback */
+		case 0x04:	/* Attack, Decay (modulator) */
+		case 0x05:	/* Attack, Decay (carrier) */
+		case 0x06:	/* Sustain, Release (modulator) */
+		case 0x07:	/* Sustain, Release (carrier) */
+			chip->inst_tab[0][r & 0x07] = v;
+			update_instrument_zero(chip,r&7);
+		break;
+
+		case 0x0e:	/* x, x, r,bd,sd,tom,tc,hh */
+		{
+			if(v&0x20)
+			{
+				if ((chip->rhythm&0x20)==0)
+				/*rhythm off to on*/
+				{
+					logerror("YM2413: Rhythm mode enable\n");
+
+	/* Load instrument settings for channel seven(chan=6 since we're zero based). (Bass drum) */
+					chan = 6;
+					inst = &chip->inst_tab[16][0];
+					slot = chan*2;
+
+					load_instrument(chip, chan, slot, inst);
+
+	/* Load instrument settings for channel eight. (High hat and snare drum) */
+					chan = 7;
+					inst = &chip->inst_tab[17][0];
+					slot = chan*2;
+
+					load_instrument(chip, chan, slot, inst);
+
+					CH   = &chip->P_CH[chan];
+					SLOT = &CH->SLOT[SLOT1]; /* modulator envelope is HH */
+					SLOT->TL  = ((chip->instvol_r[chan]>>4)<<2)<<(ENV_BITS-2-7); /* 7 bits TL (bit 6 = always 0) */
+					SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
+
+	/* Load instrument settings for channel nine. (Tom-tom and top cymbal) */
+					chan = 8;
+					inst = &chip->inst_tab[18][0];
+					slot = chan*2;
+
+					load_instrument(chip, chan, slot, inst);
+
+					CH   = &chip->P_CH[chan];
+					SLOT = &CH->SLOT[SLOT1]; /* modulator envelope is TOM */
+					SLOT->TL  = ((chip->instvol_r[chan]>>4)<<2)<<(ENV_BITS-2-7); /* 7 bits TL (bit 6 = always 0) */
+					SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
+				}
+				/* BD key on/off */
+				if(v&0x10)
+				{
+					KEY_ON (&chip->P_CH[6].SLOT[SLOT1], 2);
+					KEY_ON (&chip->P_CH[6].SLOT[SLOT2], 2);
+				}
+				else
+				{
+					KEY_OFF(&chip->P_CH[6].SLOT[SLOT1],~2);
+					KEY_OFF(&chip->P_CH[6].SLOT[SLOT2],~2);
+				}
+				/* HH key on/off */
+				if(v&0x01) KEY_ON (&chip->P_CH[7].SLOT[SLOT1], 2);
+				else       KEY_OFF(&chip->P_CH[7].SLOT[SLOT1],~2);
+				/* SD key on/off */
+				if(v&0x08) KEY_ON (&chip->P_CH[7].SLOT[SLOT2], 2);
+				else       KEY_OFF(&chip->P_CH[7].SLOT[SLOT2],~2);
+				/* TOM key on/off */
+				if(v&0x04) KEY_ON (&chip->P_CH[8].SLOT[SLOT1], 2);
+				else       KEY_OFF(&chip->P_CH[8].SLOT[SLOT1],~2);
+				/* TOP-CY key on/off */
+				if(v&0x02) KEY_ON (&chip->P_CH[8].SLOT[SLOT2], 2);
+				else       KEY_OFF(&chip->P_CH[8].SLOT[SLOT2],~2);
+			}
+			else
+			{
+				if ((chip->rhythm&0x20)==1)
+				/*rhythm on to off*/
+				{
+					logerror("YM2413: Rhythm mode disable\n");
+	/* Load instrument settings for channel seven(chan=6 since we're zero based).*/
+					chan = 6;
+					inst = &chip->inst_tab[chip->instvol_r[chan]>>4][0];
+					slot = chan*2;
+
+					load_instrument(chip, chan, slot, inst);
+
+	/* Load instrument settings for channel eight.*/
+					chan = 7;
+					inst = &chip->inst_tab[chip->instvol_r[chan]>>4][0];
+					slot = chan*2;
+
+					load_instrument(chip, chan, slot, inst);
+
+	/* Load instrument settings for channel nine.*/
+					chan = 8;
+					inst = &chip->inst_tab[chip->instvol_r[chan]>>4][0];
+					slot = chan*2;
+
+					load_instrument(chip, chan, slot, inst);
+				}
+				/* BD key off */
+				KEY_OFF(&chip->P_CH[6].SLOT[SLOT1],~2);
+				KEY_OFF(&chip->P_CH[6].SLOT[SLOT2],~2);
+				/* HH key off */
+				KEY_OFF(&chip->P_CH[7].SLOT[SLOT1],~2);
+				/* SD key off */
+				KEY_OFF(&chip->P_CH[7].SLOT[SLOT2],~2);
+				/* TOM key off */
+				KEY_OFF(&chip->P_CH[8].SLOT[SLOT1],~2);
+				/* TOP-CY off */
+				KEY_OFF(&chip->P_CH[8].SLOT[SLOT2],~2);
+			}
+			chip->rhythm  = v&0x3f;
+		}
+		break;
+		}
+	}
+	break;
+
+	case 0x10:
+	case 0x20:
+	{
+		int block_fnum;
+
+		chan = r&0x0f;
+
+		if (chan >= 9)
+			chan -= 9;	/* verified on real YM2413 */
+
+		CH = &chip->P_CH[chan];
+
+		if(r&0x10)
+		{	/* 10-18: FNUM 0-7 */
+			block_fnum  = (CH->block_fnum&0x0f00) | v;
+		}
+		else
+		{	/* 20-28: suson, keyon, block, FNUM 8 */
+			block_fnum = ((v&0x0f)<<8) | (CH->block_fnum&0xff);
+
+			if(v&0x10)
+			{
+				KEY_ON (&CH->SLOT[SLOT1], 1);
+				KEY_ON (&CH->SLOT[SLOT2], 1);
+			}
+			else
+			{
+				KEY_OFF(&CH->SLOT[SLOT1],~1);
+				KEY_OFF(&CH->SLOT[SLOT2],~1);
+			}
+
+
+			if (CH->sus!=(v&0x20))
+				logerror("chan=%i sus=%2x\n",chan,v&0x20);
+
+			CH->sus = v & 0x20;
+		}
+		/* update */
+		if(CH->block_fnum != block_fnum)
+		{
+			UINT8 block;
+
+			CH->block_fnum = block_fnum;
+
+			/* BLK 2,1,0 bits -> bits 3,2,1 of kcode, FNUM MSB -> kcode LSB */
+			CH->kcode    = (block_fnum&0x0f00)>>8;
+
+			CH->ksl_base = (UINT32)(ksl_tab[block_fnum>>5]);
+
+			block_fnum   = block_fnum * 2;
+			block        = (block_fnum&0x1c00) >> 10;
+			CH->fc       = chip->fn_tab[block_fnum&0x03ff] >> (7-block);
+
+			/* refresh Total Level in both SLOTs of this channel */
+			CH->SLOT[SLOT1].TLL = CH->SLOT[SLOT1].TL + (CH->ksl_base>>CH->SLOT[SLOT1].ksl);
+			CH->SLOT[SLOT2].TLL = CH->SLOT[SLOT2].TL + (CH->ksl_base>>CH->SLOT[SLOT2].ksl);
+
+			/* refresh frequency counter in both SLOTs of this channel */
+			CALC_FCSLOT(CH,&CH->SLOT[SLOT1]);
+			CALC_FCSLOT(CH,&CH->SLOT[SLOT2]);
+		}
+	}
+	break;
+
+	case 0x30:	/* inst 4 MSBs, VOL 4 LSBs */
+	{
+		UINT8 old_instvol;
+
+		chan = r&0x0f;
+
+		if (chan >= 9)
+			chan -= 9;	/* verified on real YM2413 */
+
+		old_instvol = chip->instvol_r[chan];
+		chip->instvol_r[chan] = v;	/* store for later use */
+
+		CH   = &chip->P_CH[chan];
+		SLOT = &CH->SLOT[SLOT2]; /* carrier */
+		SLOT->TL  = ((v&0x0f)<<2)<<(ENV_BITS-2-7); /* 7 bits TL (bit 6 = always 0) */
+		SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
+
+
+		/*check wether we are in rhythm mode and handle instrument/volume register accordingly*/
+		if ((chan>=6) && (chip->rhythm&0x20))
+		{
+			/* we're in rhythm mode*/
+
+			if (chan>=7) /* only for channel 7 and 8 (channel 6 is handled in usual way)*/
+			{
+				SLOT = &CH->SLOT[SLOT1]; /* modulator envelope is HH(chan=7) or TOM(chan=8) */
+				SLOT->TL  = ((chip->instvol_r[chan]>>4)<<2)<<(ENV_BITS-2-7); /* 7 bits TL (bit 6 = always 0) */
+				SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
+			}
+		}
+		else
+		{
+			if ( (old_instvol&0xf0) == (v&0xf0) )
+				return;
+
+			inst = &chip->inst_tab[chip->instvol_r[chan]>>4][0];
+			slot = chan*2;
+
+			load_instrument(chip, chan, slot, inst);
+
+		#if 0
+			logerror("YM2413: chan#%02i inst=%02i:  (r=%2x, v=%2x)\n",chan,v>>4,r,v);
+			logerror("  0:%2x  1:%2x\n",inst[0],inst[1]);	logerror("  2:%2x  3:%2x\n",inst[2],inst[3]);
+			logerror("  4:%2x  5:%2x\n",inst[4],inst[5]);	logerror("  6:%2x  7:%2x\n",inst[6],inst[7]);
+		#endif
+		}
+	}
+	break;
+
+	default:
+	break;
+	}
+}
+
+/* lock/unlock for common table */
+static void OPLLResetChip(YM2413 *chip)
+{
+	int c,s;
+	int i;
+
+	chip->eg_timer = 0;
+	chip->eg_cnt   = 0;
+
+	chip->noise_rng = 1;	/* noise shift register */
+
+	chip->mask = 0;
+
+	/* setup instruments table */
+	if (!chip->chip_type)
+	{
+		for (i=0; i<19; i++)
+		{
+			for (c=0; c<8; c++)
+			{
+				chip->inst_tab[i][c] = table[i][c];
+			}
+		}
+	}
+	else
+	{
+		memset( &chip->inst_tab, 0, sizeof(chip->inst_tab) );
+
+		for (i=0; i<15; i++)
+		{
+			for (c=0; c<8; c++)
+			{
+				chip->inst_tab[i+1][c] = table_vrc7[i][c];
+			}
+		}
+	}
+
+
+	/* reset with register write */
+	OPLLWriteReg(chip,0x0f,0); /*test reg*/
+	for(i = 0x3f ; i >= 0x10 ; i-- ) OPLLWriteReg(chip,i,0x00);
+
+	/* reset operator parameters */
+	for( c = 0 ; c < 9 ; c++ )
+	{
+		OPLL_CH *CH = &chip->P_CH[c];
+		for(s = 0 ; s < 2 ; s++ )
+		{
+			/* wave table */
+			CH->SLOT[s].wavetable = 0;
+			CH->SLOT[s].state     = EG_OFF;
+			CH->SLOT[s].volume    = MAX_ATT_INDEX;
+		}
+	}
+}
+
+/* Create one of virtual YM2413 */
+/* 'clock' is chip clock in Hz  */
+/* 'rate'  is sampling rate  */
+static YM2413 *OPLLCreate(int clock, int rate, int type)
+{
+	char *ptr;
+	YM2413 *chip;
+	int state_size;
+
+	init_tables();
+
+	/* calculate chip state size */
+	state_size  = sizeof(YM2413);
+
+	/* allocate memory block */
+	ptr = (char *)malloc(state_size);
+
+	if (ptr==NULL)
+		return NULL;
+
+	/* clear */
+	memset(ptr,0,state_size);
+
+	chip  = (YM2413 *)ptr;
+
+	chip->clock = clock;
+	chip->rate  = rate;
+
+	chip->chip_type = type;
+
+	chip->mask = 0;
+
+	/* init global tables */
+	OPLL_initalize(chip);
+
+	/* reset chip */
+	OPLLResetChip(chip);
+	return chip;
+}
+
+/* Destroy one of virtual YM3812 */
+static void OPLLDestroy(YM2413 *chip)
+{
+	free(chip);
+	chip = NULL;
+}
+
+/* Option handlers */
+
+static void OPLLSetUpdateHandler(YM2413 *chip,OPLL_UPDATEHANDLER UpdateHandler,void * param)
+{
+	chip->UpdateHandler = UpdateHandler;
+	chip->UpdateParam = param;
+}
+
+/* YM3812 I/O interface */
+static void OPLLWrite(YM2413 *chip,int a,int v)
+{
+	if( !(a&1) )
+	{	/* address port */
+		chip->address = v & 0xff;
+	}
+	else
+	{	/* data port */
+		if(chip->UpdateHandler) chip->UpdateHandler(chip->UpdateParam,0);
+		OPLLWriteReg(chip,chip->address,v);
+	}
+}
+
+static unsigned char OPLLRead(YM2413 *chip,int a)
+{
+	if( !(a&1) )
+	{
+		/* status port */
+		return chip->status;
+	}
+	return 0xff;
+}
+
+
+
+
+
+void * ym2413_init(int clock, int rate, int type)
+{
+	/* emulator create */
+	return OPLLCreate(clock, rate, type);
+}
+
+void ym2413_shutdown(void *chip)
+{
+	YM2413 *OPLL = (YM2413 *)chip;
+
+	/* emulator shutdown */
+	OPLLDestroy(OPLL);
+}
+
+void ym2413_reset_chip(void *chip)
+{
+	YM2413 *OPLL = (YM2413 *)chip;
+	OPLLResetChip(OPLL);
+}
+
+void ym2413_write(void *chip, int a, int v)
+{
+	YM2413 *OPLL = (YM2413 *)chip;
+	OPLLWrite(OPLL, a, v);
+}
+
+unsigned char ym2413_read(void *chip, int a)
+{
+	YM2413 *OPLL = (YM2413 *)chip;
+	return OPLLRead(OPLL, a) & 0x03 ;
+}
+
+void ym2413_set_update_handler(void *chip,OPLL_UPDATEHANDLER UpdateHandler,void *param)
+{
+	YM2413 *OPLL = (YM2413 *)chip;
+	OPLLSetUpdateHandler(OPLL, UpdateHandler, param);
+}
+
+
+/*
+** Generate samples for one of the YM2413's
+**
+** 'which' is the virtual YM2413 number
+** '*buffer' is the output buffer pointer
+** 'length' is the number of samples that should be generated
+*/
+void ym2413_update_one(void *_chip, SAMP **buffers, int length)
+{
+	YM2413		*chip  = (YM2413 *)_chip;
+	UINT8		rhythm = chip->rhythm&0x20;
+	SAMP		*bufMO = buffers[0];
+	SAMP		*bufRO = buffers[1];
+
+	int i,j;
+
+	chip->SLOT7_1 = &chip->P_CH[7].SLOT[SLOT1];
+	chip->SLOT7_2 = &chip->P_CH[7].SLOT[SLOT2];
+	chip->SLOT8_1 = &chip->P_CH[8].SLOT[SLOT1];
+	chip->SLOT8_2 = &chip->P_CH[8].SLOT[SLOT2];
+
+
+	for( i=0; i < length ; i++ )
+	{
+		int mo,ro;
+
+		chip->output[0] = 0;
+		chip->output[1] = 0;
+
+		advance_lfo(chip);
+
+#if 0
+		/* FM part */
+		chan_calc(chip,&chip->P_CH[0]);
+/* SAVE_SEPARATE_CHANNEL(0); */
+		chan_calc(chip,&chip->P_CH[1]);
+		chan_calc(chip,&chip->P_CH[2]);
+		chan_calc(chip,&chip->P_CH[3]);
+		chan_calc(chip,&chip->P_CH[4]);
+		chan_calc(chip,&chip->P_CH[5]);
+#else
+		for ( j=0; j < 6; j++ )
+		{
+			if (!(chip->mask & OPLL_MASK_CH(j))) chan_calc(chip, &chip->P_CH[j]);
+		}
+#endif
+
+		if(!rhythm)
+		{
+#if 0
+			chan_calc(chip,&chip->P_CH[6]);
+			chan_calc(chip,&chip->P_CH[7]);
+			chan_calc(chip,&chip->P_CH[8]);
+#else
+			for ( j=6; j < 9; j++ )
+			{
+				if (!(chip->mask & OPLL_MASK_CH(j))) chan_calc(chip, &chip->P_CH[j]);
+			}
+#endif
+		}
+		else		/* Rhythm part */
+		{
+			if ( ( chip->mask & OPLL_MASK_RHYTHM ) != OPLL_MASK_RHYTHM )
+				rhythm_calc(chip,&chip->P_CH[0], (chip->noise_rng>>0)&1 );
+		}
+
+		mo = chip->output[0];
+		ro = chip->output[1];
+
+		mo >>= FINAL_SH;
+		ro >>= FINAL_SH;
+
+		/* limit check */
+		mo = limit( mo , MAXOUT, MINOUT );
+		ro = limit( ro , MAXOUT, MINOUT );
+
+		/* store to sound buffer */
+		bufMO[i] = mo;
+		bufRO[i] = ro;
+
+		advance(chip);
+	}
+
+}
+
+void ym2413_advance_lfo(void *_chip)
+{
+	YM2413		*chip  = (YM2413 *)_chip;
+	advance_lfo(chip);
+}
+
+void ym2413_advance(void *_chip)
+{
+	YM2413		*chip  = (YM2413 *)_chip;
+	advance(chip);
+}
+
+SAMP ym2413_calcch(void *_chip, int ch)
+{
+	YM2413		*chip  = (YM2413 *)_chip;
+
+	int output;
+
+	chip->output[0] = 0;
+	chip->output[1] = 0;
+
+	if (ch >= 0 && ch < 6) chan_calc( chip, &chip->P_CH[ch] );
+	else if (ch >= 6 && ch < 9)
+	{
+		UINT8		rhythm = chip->rhythm&0x20;
+		if (!rhythm) chan_calc( chip, &chip->P_CH[ch] );
+		else if (ch == 6) rhythm_calc(chip,&chip->P_CH[0], (chip->noise_rng>>0)&1 );
+	}
+
+	output = chip->output[0];
+	output += chip->output[1];
+
+	return output;
+}
+
+void * ym2413_get_inst0(void *_chip)
+{
+	YM2413		*chip  = (YM2413 *)_chip;
+
+	return &chip->inst_tab;
+}
+
+void ym2413_set_mask(void *_chip, UINT32 mask)
+{
+	YM2413		*chip  = (YM2413 *)_chip;
+
+	chip->mask = mask;
+}
\ Nincs új sor a fájl végén
diff -Nur orig/source/gme/src/Ym2413_Emu.cpp mod/source/gme/src/Ym2413_Emu.cpp
--- orig/source/gme/src/Ym2413_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ym2413_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,70 @@
+// Game_Music_Emu 0.5.5. http://www.slack.net/~ant/
+
+#include "Ym2413_Emu.h"
+#include "ym2413.h"
+
+Ym2413_Emu::Ym2413_Emu() { opll = 0; }
+
+Ym2413_Emu::~Ym2413_Emu()
+{
+	if ( opll ) ym2413_shutdown( opll );
+}
+
+int Ym2413_Emu::set_rate( double sample_rate, double clock_rate )
+{
+	if ( opll )
+	{
+		ym2413_shutdown( opll );
+		opll = 0;
+	}
+	
+	opll = ym2413_init( int(clock_rate), int(sample_rate), 0 );
+	if ( !opll )
+		return 1;
+	
+	reset();
+	return 0;
+}
+
+void Ym2413_Emu::reset()
+{
+	ym2413_reset_chip( opll );
+	ym2413_set_mask( opll, 0 );
+}
+
+void Ym2413_Emu::write( int addr, int data )
+{
+	ym2413_write( opll, 0, addr );
+	ym2413_write( opll, 1, data );
+}
+
+void Ym2413_Emu::mute_voices( int mask )
+{
+	ym2413_set_mask( opll, mask );
+}
+
+void Ym2413_Emu::run( int pair_count, sample_t* out )
+{
+	SAMP bufMO[ 1024 ];
+	SAMP bufRO[ 1024 ];
+	SAMP * buffers[2] = { bufMO, bufRO };
+
+	while (pair_count > 0)
+	{
+		int todo = pair_count;
+		if (todo > 1024) todo = 1024;
+		ym2413_update_one( opll, buffers, todo );
+
+		for (int i = 0; i < todo; i++)
+		{
+			int output = bufMO [i];
+			output += bufRO [i];
+			if ( (short)output != output ) output = 0x7FFF ^ ( output >> 31 );
+			out [0] = output;
+			out [1] = output;
+			out += 2;
+		}
+
+		pair_count -= todo;
+	}
+}
diff -Nur orig/source/gme/src/Ym2413_Emu.h mod/source/gme/src/Ym2413_Emu.h
--- orig/source/gme/src/Ym2413_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ym2413_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,37 @@
+// YM2413 FM sound chip emulator interface
+
+// Game_Music_Emu 0.6-pre
+#ifndef YM2413_EMU_H
+#define YM2413_EMU_H
+
+struct OPLL;
+
+class Ym2413_Emu  {
+	void* opll;
+public:
+	Ym2413_Emu();
+	~Ym2413_Emu();
+	
+	static bool supported() { return true; }
+	
+	// Sets output sample rate and chip clock rates, in Hz. Returns non-zero
+	// if error.
+	int set_rate( double sample_rate, double clock_rate );
+	
+	// Resets to power-up state
+	void reset();
+	
+	// Mutes voice n if bit n (1 << n) of mask is set
+	enum { channel_count = 14 };
+	void mute_voices( int mask );
+	
+	// Writes data to addr
+	void write( int addr, int data );
+	
+	// Runs and writes pair_count*2 samples to output
+	typedef short sample_t;
+	enum { out_chan_count = 2 }; // stereo
+	void run( int pair_count, sample_t* out );
+};
+
+#endif
diff -Nur orig/source/gme/src/ym2413.h mod/source/gme/src/ym2413.h
--- orig/source/gme/src/ym2413.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/ym2413.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,61 @@
+#pragma once
+
+#ifndef __YM2413_H__
+#define __YM2413_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* select output bits size of output : 8 or 16 */
+#define SAMPLE_BITS 16
+
+/* compiler dependence */
+#ifndef __OSDCOMM_H__
+#define __OSDCOMM_H__
+typedef unsigned char	UINT8;   /* unsigned  8bit */
+typedef unsigned short	UINT16;  /* unsigned 16bit */
+typedef unsigned int	UINT32;  /* unsigned 32bit */
+typedef signed char		INT8;    /* signed  8bit   */
+typedef signed short	INT16;   /* signed 16bit   */
+typedef signed int		INT32;   /* signed 32bit   */
+
+typedef INT32           stream_sample_t;
+#endif
+
+typedef stream_sample_t SAMP;
+/*
+#if (SAMPLE_BITS==16)
+typedef INT16 SAMP;
+#endif
+#if (SAMPLE_BITS==8)
+typedef INT8 SAMP;
+#endif
+*/
+
+
+
+void *ym2413_init(int clock, int rate, int type);
+void ym2413_shutdown(void *chip);
+void ym2413_reset_chip(void *chip);
+void ym2413_write(void *chip, int a, int v);
+unsigned char ym2413_read(void *chip, int a);
+void ym2413_update_one(void *chip, SAMP **buffers, int length);
+
+void ym2413_advance_lfo(void *chip);    /* call this once */
+SAMP ym2413_calcch(void *chip, int ch); /* then call this for each channel */
+void ym2413_advance(void *chip);        /* then call this */
+
+void * ym2413_get_inst0(void *chip);
+
+void ym2413_set_mask(void *chip, UINT32 mask);
+
+typedef void (*OPLL_UPDATEHANDLER)(void *param,int min_interval_us);
+
+void ym2413_set_update_handler(void *chip, OPLL_UPDATEHANDLER UpdateHandler, void *param);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*__YM2413_H__*/
diff -Nur orig/source/gme/src/Ym2612_Emu.cpp mod/source/gme/src/Ym2612_Emu.cpp
--- orig/source/gme/src/Ym2612_Emu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ym2612_Emu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,2512 @@
+// Game_Music_Emu 0.5.5. http://www.slack.net/~ant/
+
+// File: fm.c -- software implementation of Yamaha FM sound generator
+// Copyright (C) 2001, 2002, 2003 Jarek Burczynski (bujar at mame dot net)
+// Copyright (C) 1998 Tatsuyuki Satoh , MultiArcadeMachineEmulator development
+// Version 1.4 (final beta)
+
+#include "Ym2612_Emu.h"
+typedef Ym2612_Impl YM2612;
+
+#include "blargg_errors.h"
+
+// fm.h
+YM2612* YM2612Init( void* user_data, int index, long baseclock, long rate );
+void YM2612Shutdown( YM2612* );
+void YM2612ResetChip( YM2612* );
+void YM2612UpdateOne( YM2612*, short* out, int pair_count );
+int YM2612Write( YM2612*, unsigned int a, unsigned int v );
+unsigned char YM2612Read( YM2612*, int a );
+int YM2612TimerOver( YM2612*, int c );
+void YM2612Postload( YM2612* );
+void YM2612Mute( YM2612*, int mask );
+
+#include <stdlib.h>
+#include <limits.h>
+#include <math.h>
+
+/* Copyright (C) 1997-2005, Nicola Salmoria and the MAME team. All rights
+reserved. Redistribution and use of this code or any derivative works are
+permitted provided that the following conditions are met:
+- Redistributions may not be sold, nor may they be used in a commercial
+product or activity.
+- Redistributions that are modified from the original source must include the
+complete source code, including the source code for all components used by a
+binary built from the modified sources. However, as a special exception, the
+source code distributed need not include anything that is normally distributed
+(in either source or binary form) with the major components (compiler, kernel,
+and so on) of the operating system on which the executable runs, unless that
+component itself accompanies the executable.
+- Redistributions must reproduce the above copyright notice, this list of
+conditions and the following disclaimer in the documentation and/or other
+materials provided with the distribution.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
+
+#define BUILD_YM2612  1
+#define FM_BUSY_FLAG_SUPPORT 0
+#define YM2612UpdateReq( chip ) ((void) 0)
+
+typedef unsigned char   UINT8;
+typedef unsigned short  UINT16;
+
+#if ULONG_MAX == 0xFFFFFFFF
+	typedef long            INT32;
+	typedef unsigned long   UINT32;
+#elif UINT_MAX == 0xFFFFFFFF
+	typedef int             INT32;
+	typedef unsigned int    UINT32;
+#else
+	#error "No suitable 32-bit type available"
+#endif
+
+#define INLINE inline
+
+#define logerror
+#define state_save_register_UINT8(mod, ins, name, val, size)
+#define state_save_register_UINT16(mod, ins, name, val, size)
+#define state_save_register_UINT32(mod, ins, name, val, size)
+#define state_save_register_INT8(mod, ins, name, val, size)
+#define state_save_register_INT16(mod, ins, name, val, size)
+#define state_save_register_INT32(mod, ins, name, val, size)
+#define state_save_register_int(mod, ins, name, val)
+#define state_save_register_func_postload(a) a();
+
+#ifndef PI
+#define PI 3.14159265358979323846
+#endif
+
+/* shared function building option */
+#define BUILD_OPN (BUILD_YM2203||BUILD_YM2608||BUILD_YM2610||BUILD_YM2610B||BUILD_YM2612)
+#define BUILD_OPN_PRESCALER (BUILD_YM2203||BUILD_YM2608)
+
+/* globals */
+#define TYPE_SSG    0x01    /* SSG support          */
+#define TYPE_LFOPAN 0x02    /* OPN type LFO and PAN */
+#define TYPE_6CH    0x04    /* FM 6CH / 3CH         */
+#define TYPE_DAC    0x08    /* YM2612's DAC device  */
+#define TYPE_ADPCM  0x10    /* two ADPCM units      */
+#define TYPE_2610   0x20    /* bogus flag to differentiate 2608 from 2610 */
+
+#define TYPE_YM2203 (TYPE_SSG)
+#define TYPE_YM2608 (TYPE_SSG |TYPE_LFOPAN |TYPE_6CH |TYPE_ADPCM)
+#define TYPE_YM2610 (TYPE_SSG |TYPE_LFOPAN |TYPE_6CH |TYPE_ADPCM |TYPE_2610)
+#define TYPE_YM2612 (TYPE_DAC |TYPE_LFOPAN |TYPE_6CH)
+
+#define FREQ_SH         16  /* 16.16 fixed point (frequency calculations) */
+#define EG_SH           16  /* 16.16 fixed point (envelope generator timing) */
+#define LFO_SH          24  /*  8.24 fixed point (LFO calculations)       */
+#define TIMER_SH        16  /* 16.16 fixed point (timers calculations)    */
+
+#define FREQ_MASK       ((1<<FREQ_SH)-1)
+
+#define ENV_BITS        10
+#define ENV_LEN         (1<<ENV_BITS)
+#define ENV_STEP        (128.0/ENV_LEN)
+
+#define MAX_ATT_INDEX   (ENV_LEN-1) /* 1023 */
+#define MIN_ATT_INDEX   (0)         /* 0 */
+
+#define EG_ATT          4
+#define EG_DEC          3
+#define EG_SUS          2
+#define EG_REL          1
+#define EG_OFF          0
+
+#define SIN_BITS        10
+#define SIN_LEN         (1<<SIN_BITS)
+#define SIN_MASK        (SIN_LEN-1)
+
+#define TL_RES_LEN      (256) /* 8 bits addressing (real chip) */
+
+/*  TL_TAB_LEN is calculated as:
+*   13 - sinus amplitude bits     (Y axis)
+*   2  - sinus sign bit           (Y axis)
+*   TL_RES_LEN - sinus resolution (X axis)
+*/
+#define TL_TAB_LEN (13*2*TL_RES_LEN)
+static signed int tl_tab[TL_TAB_LEN];
+
+#define ENV_QUIET       (TL_TAB_LEN>>3)
+
+/* sin waveform table in 'decibel' scale */
+static unsigned int sin_tab[SIN_LEN];
+
+/* sustain level table (3dB per step) */
+/* bit0, bit1, bit2, bit3, bit4, bit5, bit6 */
+/* 1,    2,    4,    8,    16,   32,   64   (value)*/
+/* 0.75, 1.5,  3,    6,    12,   24,   48   (dB)*/
+
+/* 0 - 15: 0, 3, 6, 9,12,15,18,21,24,27,30,33,36,39,42,93 (dB)*/
+#define SC(db) (UINT32) ( db * (4.0/ENV_STEP) )
+static const UINT32 sl_table[16]={
+ SC( 0),SC( 1),SC( 2),SC(3 ),SC(4 ),SC(5 ),SC(6 ),SC( 7),
+ SC( 8),SC( 9),SC(10),SC(11),SC(12),SC(13),SC(14),SC(31)
+};
+#undef SC
+
+
+#define RATE_STEPS (8)
+static const UINT8 eg_inc[19*RATE_STEPS]={
+
+/*cycle:0 1  2 3  4 5  6 7*/
+
+/* 0 */ 0,1, 0,1, 0,1, 0,1, /* rates 00..11 0 (increment by 0 or 1) */
+/* 1 */ 0,1, 0,1, 1,1, 0,1, /* rates 00..11 1 */
+/* 2 */ 0,1, 1,1, 0,1, 1,1, /* rates 00..11 2 */
+/* 3 */ 0,1, 1,1, 1,1, 1,1, /* rates 00..11 3 */
+
+/* 4 */ 1,1, 1,1, 1,1, 1,1, /* rate 12 0 (increment by 1) */
+/* 5 */ 1,1, 1,2, 1,1, 1,2, /* rate 12 1 */
+/* 6 */ 1,2, 1,2, 1,2, 1,2, /* rate 12 2 */
+/* 7 */ 1,2, 2,2, 1,2, 2,2, /* rate 12 3 */
+
+/* 8 */ 2,2, 2,2, 2,2, 2,2, /* rate 13 0 (increment by 2) */
+/* 9 */ 2,2, 2,4, 2,2, 2,4, /* rate 13 1 */
+/*10 */ 2,4, 2,4, 2,4, 2,4, /* rate 13 2 */
+/*11 */ 2,4, 4,4, 2,4, 4,4, /* rate 13 3 */
+
+/*12 */ 4,4, 4,4, 4,4, 4,4, /* rate 14 0 (increment by 4) */
+/*13 */ 4,4, 4,8, 4,4, 4,8, /* rate 14 1 */
+/*14 */ 4,8, 4,8, 4,8, 4,8, /* rate 14 2 */
+/*15 */ 4,8, 8,8, 4,8, 8,8, /* rate 14 3 */
+
+/*16 */ 8,8, 8,8, 8,8, 8,8, /* rates 15 0, 15 1, 15 2, 15 3 (increment by 8) */
+/*17 */ 16,16,16,16,16,16,16,16, /* rates 15 2, 15 3 for attack */
+/*18 */ 0,0, 0,0, 0,0, 0,0, /* infinity rates for attack and decay(s) */
+};
+
+
+#define O(a) (a*RATE_STEPS)
+
+static const UINT8 eg_rate_select[32+64+32]={    /* Envelope Generator rates (32 + 64 rates + 32 RKS) from tests on YM2612 */
+/* 32 infinite time rates */
+O(18),O(18),O(18),O(18),O(18),O(18),O(18),O(18),
+O(18),O(18),O(18),O(18),O(18),O(18),O(18),O(18),
+O(18),O(18),O(18),O(18),O(18),O(18),O(18),O(18),
+O(18),O(18),O(18),O(18),O(18),O(18),O(18),O(18),
+
+/* rates 00-11 */
+O( 18),O( 18),O( 0),O( 0),
+O( 0),O( 0),O( 2),O( 2),  // Nemesis's tests
+
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+O( 0),O( 1),O( 2),O( 3),
+
+/* rate 12 */
+O( 4),O( 5),O( 6),O( 7),
+
+/* rate 13 */
+O( 8),O( 9),O(10),O(11),
+
+/* rate 14 */
+O(12),O(13),O(14),O(15),
+
+/* rate 15 */
+O(16),O(16),O(16),O(16),
+
+/* 32 dummy rates (same as 15 3) */
+O(16),O(16),O(16),O(16),O(16),O(16),O(16),O(16),
+O(16),O(16),O(16),O(16),O(16),O(16),O(16),O(16),
+O(16),O(16),O(16),O(16),O(16),O(16),O(16),O(16),
+O(16),O(16),O(16),O(16),O(16),O(16),O(16),O(16)
+
+};
+#undef O
+
+/*rate  0,    1,    2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15*/
+/*shift 11,  10,  9,  8,  7,  6,  5,  4,  3,  2, 1,  0,  0,  0,  0,  0 */
+/*mask  2047, 1023, 511, 255, 127, 63, 31, 15, 7,  3, 1,  0,  0,  0,  0,  0 */
+
+#define O(a) (a*1)
+static const UINT8 eg_rate_shift[32+64+32]={    /* Envelope Generator counter shifts (32 + 64 rates + 32 RKS) */
+/* 32 infinite time rates */
+/* O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
+O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
+O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0),
+O(0),O(0),O(0),O(0),O(0),O(0),O(0),O(0), */
+
+/* fixed (should be the same as rate 0, even if it makes no difference since increment value is 0 for these rates) */
+O(11),O(11),O(11),O(11),O(11),O(11),O(11),O(11),
+O(11),O(11),O(11),O(11),O(11),O(11),O(11),O(11),
+O(11),O(11),O(11),O(11),O(11),O(11),O(11),O(11),
+O(11),O(11),O(11),O(11),O(11),O(11),O(11),O(11),
+
+/* rates 00-11 */
+O(11),O(11),O(11),O(11),
+O(10),O(10),O(10),O(10),
+O( 9),O( 9),O( 9),O( 9),
+O( 8),O( 8),O( 8),O( 8),
+O( 7),O( 7),O( 7),O( 7),
+O( 6),O( 6),O( 6),O( 6),
+O( 5),O( 5),O( 5),O( 5),
+O( 4),O( 4),O( 4),O( 4),
+O( 3),O( 3),O( 3),O( 3),
+O( 2),O( 2),O( 2),O( 2),
+O( 1),O( 1),O( 1),O( 1),
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 12 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 13 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 14 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* rate 15 */
+O( 0),O( 0),O( 0),O( 0),
+
+/* 32 dummy rates (same as 15 3) */
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),
+O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0),O( 0)
+
+};
+#undef O
+
+static const UINT8 dt_tab[4 * 32]={
+/* this is YM2151 and YM2612 phase increment data (in 10.10 fixed point format)*/
+/* FD=0 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+/* FD=1 */
+	0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
+	2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 8, 8, 8, 8,
+/* FD=2 */
+	1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5,
+	5, 6, 6, 7, 8, 8, 9,10,11,12,13,14,16,16,16,16,
+/* FD=3 */
+	2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7,
+	8 , 8, 9,10,11,12,13,14,16,17,19,20,22,22,22,22
+};
+
+
+/* OPN key frequency number -> key code follow table */
+/* fnum higher 4bit -> keycode lower 2bit */
+static const UINT8 opn_fktable[16] = {0,0,0,0,0,0,0,1,2,3,3,3,3,3,3,3};
+
+
+/* 8 LFO speed parameters */
+/* each value represents number of samples that one LFO level will last for */
+static const UINT32 lfo_samples_per_step[8] = {108, 77, 71, 67, 62, 44, 8, 5};
+
+
+
+/*There are 4 different LFO AM depths available, they are:
+  0 dB, 1.4 dB, 5.9 dB, 11.8 dB
+  Here is how it is generated (in EG steps):
+
+  11.8 dB = 0, 2, 4, 6, 8, 10,12,14,16...126,126,124,122,120,118,....4,2,0
+   5.9 dB = 0, 1, 2, 3, 4, 5, 6, 7, 8....63, 63, 62, 61, 60, 59,.....2,1,0
+   1.4 dB = 0, 0, 0, 0, 1, 1, 1, 1, 2,...15, 15, 15, 15, 14, 14,.....0,0,0
+
+  (1.4 dB is loosing precision as you can see)
+
+  It's implemented as generator from 0..126 with step 2 then a shift
+  right N times, where N is:
+	8 for 0 dB
+	3 for 1.4 dB
+	1 for 5.9 dB
+	0 for 11.8 dB
+*/
+static const UINT8 lfo_ams_depth_shift[4] = {8, 3, 1, 0};
+
+
+
+/*There are 8 different LFO PM depths available, they are:
+  0, 3.4, 6.7, 10, 14, 20, 40, 80 (cents)
+
+  Modulation level at each depth depends on F-NUMBER bits: 4,5,6,7,8,9,10
+  (bits 8,9,10 = FNUM MSB from OCT/FNUM register)
+
+  Here we store only first quarter (positive one) of full waveform.
+  Full table (lfo_pm_table) containing all 128 waveforms is build
+  at run (init) time.
+
+  One value in table below represents 4 (four) basic LFO steps
+  (1 PM step = 4 AM steps).
+
+  For example:
+   at LFO SPEED=0 (which is 108 samples per basic LFO step)
+   one value from "lfo_pm_output" table lasts for 432 consecutive
+   samples (4*108=432) and one full LFO waveform cycle lasts for 13824
+   samples (32*432=13824; 32 because we store only a quarter of whole
+            waveform in the table below)
+*/
+static const UINT8 lfo_pm_output[7*8][8]={ /* 7 bits meaningful (of F-NUMBER), 8 LFO output levels per one depth (out of 32), 8 LFO depths */
+/* FNUM BIT 4: 000 0001xxxx */
+/* DEPTH 0 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 1 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 2 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 3 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 4 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 5 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 6 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 7 */ {0,   0,   0,   0,   1,   1,   1,   1},
+
+/* FNUM BIT 5: 000 0010xxxx */
+/* DEPTH 0 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 1 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 2 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 3 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 4 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 5 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 6 */ {0,   0,   0,   0,   1,   1,   1,   1},
+/* DEPTH 7 */ {0,   0,   1,   1,   2,   2,   2,   3},
+
+/* FNUM BIT 6: 000 0100xxxx */
+/* DEPTH 0 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 1 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 2 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 3 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 4 */ {0,   0,   0,   0,   0,   0,   0,   1},
+/* DEPTH 5 */ {0,   0,   0,   0,   1,   1,   1,   1},
+/* DEPTH 6 */ {0,   0,   1,   1,   2,   2,   2,   3},
+/* DEPTH 7 */ {0,   0,   2,   3,   4,   4,   5,   6},
+
+/* FNUM BIT 7: 000 1000xxxx */
+/* DEPTH 0 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 1 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 2 */ {0,   0,   0,   0,   0,   0,   1,   1},
+/* DEPTH 3 */ {0,   0,   0,   0,   1,   1,   1,   1},
+/* DEPTH 4 */ {0,   0,   0,   1,   1,   1,   1,   2},
+/* DEPTH 5 */ {0,   0,   1,   1,   2,   2,   2,   3},
+/* DEPTH 6 */ {0,   0,   2,   3,   4,   4,   5,   6},
+/* DEPTH 7 */ {0,   0,   4,   6,   8,   8, 0xa, 0xc},
+
+/* FNUM BIT 8: 001 0000xxxx */
+/* DEPTH 0 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 1 */ {0,   0,   0,   0,   1,   1,   1,   1},
+/* DEPTH 2 */ {0,   0,   0,   1,   1,   1,   2,   2},
+/* DEPTH 3 */ {0,   0,   1,   1,   2,   2,   3,   3},
+/* DEPTH 4 */ {0,   0,   1,   2,   2,   2,   3,   4},
+/* DEPTH 5 */ {0,   0,   2,   3,   4,   4,   5,   6},
+/* DEPTH 6 */ {0,   0,   4,   6,   8,   8, 0xa, 0xc},
+/* DEPTH 7 */ {0,   0,   8, 0xc,0x10,0x10,0x14,0x18},
+
+/* FNUM BIT 9: 010 0000xxxx */
+/* DEPTH 0 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 1 */ {0,   0,   0,   0,   2,   2,   2,   2},
+/* DEPTH 2 */ {0,   0,   0,   2,   2,   2,   4,   4},
+/* DEPTH 3 */ {0,   0,   2,   2,   4,   4,   6,   6},
+/* DEPTH 4 */ {0,   0,   2,   4,   4,   4,   6,   8},
+/* DEPTH 5 */ {0,   0,   4,   6,   8,   8, 0xa, 0xc},
+/* DEPTH 6 */ {0,   0,   8, 0xc,0x10,0x10,0x14,0x18},
+/* DEPTH 7 */ {0,   0,0x10,0x18,0x20,0x20,0x28,0x30},
+
+/* FNUM BIT10: 100 0000xxxx */
+/* DEPTH 0 */ {0,   0,   0,   0,   0,   0,   0,   0},
+/* DEPTH 1 */ {0,   0,   0,   0,   4,   4,   4,   4},
+/* DEPTH 2 */ {0,   0,   0,   4,   4,   4,   8,   8},
+/* DEPTH 3 */ {0,   0,   4,   4,   8,   8, 0xc, 0xc},
+/* DEPTH 4 */ {0,   0,   4,   8,   8,   8, 0xc,0x10},
+/* DEPTH 5 */ {0,   0,   8, 0xc,0x10,0x10,0x14,0x18},
+/* DEPTH 6 */ {0,   0,0x10,0x18,0x20,0x20,0x28,0x30},
+/* DEPTH 7 */ {0,   0,0x20,0x30,0x40,0x40,0x50,0x60},
+
+};
+
+/* all 128 LFO PM waveforms */
+static INT32 lfo_pm_table[128*8*32]; /* 128 combinations of 7 bits meaningful (of F-NUMBER), 8 LFO depths, 32 LFO output levels per one depth */
+
+
+
+
+
+/* register number to channel number , slot offset */
+#define OPN_CHAN(N) (N&3)
+#define OPN_SLOT(N) ((N>>2)&3)
+
+/* slot number */
+#define SLOT1 0
+#define SLOT2 2
+#define SLOT3 1
+#define SLOT4 3
+
+/* bit0 = Right enable , bit1 = Left enable */
+#define OUTD_RIGHT  1
+#define OUTD_LEFT   2
+#define OUTD_CENTER 3
+
+
+/* save output as raw 16-bit sample */
+/* #define SAVE_SAMPLE */
+
+#ifdef SAVE_SAMPLE
+static FILE *sample[1];
+	#if 1   /*save to MONO file */
+		#define SAVE_ALL_CHANNELS \
+		{   signed int pom = lt; \
+			fputc((unsigned short)pom&0xff,sample[0]); \
+			fputc(((unsigned short)pom>>8)&0xff,sample[0]); \
+		}
+	#else   /*save to STEREO file */
+		#define SAVE_ALL_CHANNELS \
+		{   signed int pom = lt; \
+			fputc((unsigned short)pom&0xff,sample[0]); \
+			fputc(((unsigned short)pom>>8)&0xff,sample[0]); \
+			pom = rt; \
+			fputc((unsigned short)pom&0xff,sample[0]); \
+			fputc(((unsigned short)pom>>8)&0xff,sample[0]); \
+		}
+	#endif
+#endif
+
+
+/* struct describing a single operator (SLOT) */
+typedef struct
+{
+	INT32   *DT;        /* detune          :dt_tab[DT] */
+	UINT8   KSR;        /* key scale rate  :3-KSR */
+	UINT32  ar;         /* attack rate  */
+	UINT32  d1r;        /* decay rate   */
+	UINT32  d2r;        /* sustain rate */
+	UINT32  rr;         /* release rate */
+	UINT8   ksr;        /* key scale rate  :kcode>>(3-KSR) */
+	UINT32  mul;        /* multiple        :ML_TABLE[ML] */
+
+	/* Phase Generator */
+	UINT32  phase;      /* phase counter */
+	INT32	Incr;		/* phase step */
+
+	/* Envelope Generator */
+	UINT8   state;      /* phase type */
+	UINT32  tl;         /* total level: TL << 3 */
+	INT32   volume;     /* envelope counter */
+	UINT32  sl;         /* sustain level:sl_table[SL] */
+	UINT32  vol_out;    /* current output from EG circuit (without AM from LFO) */
+
+	UINT8   eg_sh_ar;   /*  (attack state) */
+	UINT8   eg_sel_ar;  /*  (attack state) */
+	UINT8   eg_sh_d1r;  /*  (decay state) */
+	UINT8   eg_sel_d1r; /*  (decay state) */
+	UINT8   eg_sh_d2r;  /*  (sustain state) */
+	UINT8   eg_sel_d2r; /*  (sustain state) */
+	UINT8   eg_sh_rr;   /*  (release state) */
+	UINT8   eg_sel_rr;  /*  (release state) */
+
+	UINT8   ssg;        /* SSG-EG waveform */
+	UINT8   ssgn;       /* SSG-EG negated output */
+
+	UINT8   key;        /* 0=last key was KEY OFF, 1=KEY ON */
+
+	/* LFO */
+	UINT32  AMmask;     /* AM enable flag */
+
+} FM_SLOT;
+
+typedef struct
+{
+	FM_SLOT SLOT[4];    /* four SLOTs (operators) */
+
+	UINT8   ALGO;       /* algorithm */
+	UINT8   FB;         /* feedback shift */
+	INT32   op1_out[2]; /* op1 output for feedback */
+
+	INT32   *connect1;  /* SLOT1 output pointer */
+	INT32   *connect3;  /* SLOT3 output pointer */
+	INT32   *connect2;  /* SLOT2 output pointer */
+	INT32   *connect4;  /* SLOT4 output pointer */
+
+	INT32   *mem_connect;/* where to put the delayed sample (MEM) */
+	INT32   mem_value;  /* delayed sample (MEM) value */
+
+	INT32   pms;        /* channel PMS */
+	UINT8   ams;        /* channel AMS */
+
+	UINT32  fc;         /* fnum,blk:adjusted to sample rate */
+	UINT8   kcode;      /* key code:                        */
+	UINT32  block_fnum; /* current blk/fnum value for this slot (can be different betweeen slots of one channel in 3slot mode) */
+} FM_CH;
+
+
+typedef struct
+{
+	void *  param;      /* this chip parameter  */
+	float   clock;      /* master clock  (Hz)   */
+	int     rate;       /* sampling rate (Hz)   */
+	double  freqbase;   /* frequency base       */
+#if FM_BUSY_FLAG_SUPPORT
+	double  BusyExpire; /* ExpireTime of Busy clear */
+#endif
+	UINT16  address;    /* address register     */
+	UINT8   irq;        /* interrupt level      */
+	UINT8   irqmask;    /* irq mask             */
+	UINT8   status;     /* status flag          */
+	UINT32  mode;       /* mode  CSM / 3SLOT    */
+	UINT8   prescaler_sel;/* prescaler selector */
+	UINT8   fn_h;       /* freq latch           */
+	INT32   TimerBase;  /* Timer base time      */
+	INT32   TA;         /* timer a value        */
+	INT32   TAL;        /* timer a base         */
+	INT32   TAC;        /* timer a counter      */
+	INT32   TB;         /* timer b value        */
+	INT32   TBL;        /* timer b base         */
+	INT32   TBC;        /* timer b counter      */
+	/* Extention Timer and IRQ handler */
+	//const struct ssg_callbacks *SSG;
+	/* local time tables */
+	INT32   dt_tab[8][32];/* DeTune table       */
+} FM_ST;
+
+
+
+/***********************************************************/
+/* OPN unit                                                */
+/***********************************************************/
+
+/* OPN 3slot struct */
+typedef struct
+{
+	UINT32  fc[3];          /* fnum3,blk3: calculated */
+	UINT8   fn_h;           /* freq3 latch */
+	UINT8   kcode[3];       /* key code */
+	UINT32  block_fnum[3];  /* current fnum value for this slot (can be different betweeen slots of one channel in 3slot mode) */
+	UINT8   key_csm;
+} FM_3SLOT;
+
+/* OPN/A/B common state */
+typedef struct
+{
+	FM_ST   ST;             /* general state */
+	FM_3SLOT SL3;           /* 3 slot mode state */
+	FM_CH   *P_CH;          /* pointer of CH */
+	unsigned char pan_regs [6]; /* last pan register write (high two bits) */
+	unsigned char pan_mutes [6]; /* external channel *disable* mask to apply to pan registers */
+	unsigned int pan[6*2];  /* fm channels output masks (0xffffffff = enable) */
+
+	UINT32  eg_cnt;         /* global envelope generator counter */
+	UINT32  eg_timer;       /* global envelope generator counter works at frequency = chipclock/144/3 */
+	UINT32  eg_timer_add;   /* step of eg_timer */
+	UINT32  eg_timer_overflow;/* envelope generator timer overlfows every 3 samples (on real chip) */
+
+	/* LFO */
+	UINT32  lfo_cnt;
+	UINT32  lfo_timer;
+	UINT32  lfo_timer_add;
+	UINT32  lfo_timer_overflow;
+	UINT32  LFO_AM;         /* runtime LFO calculations helper */
+	INT32   LFO_PM;         /* runtime LFO calculations helper */
+	
+	/* there are 2048 FNUMs that can be generated using FNUM/BLK registers
+		but LFO works with one more bit of a precision so we really need 4096 elements */
+
+	UINT32  fn_table[4096]; /* fnumber->increment counter */
+
+	UINT32  fn_max;
+
+	INT32   m2,c1,c2;       /* Phase Modulation input for operators 2,3,4 */
+	INT32   mem;            /* one sample delay memory */
+
+	INT32   out_fm[8];      /* outputs of working channels */
+} FM_OPN;
+
+
+/* limitter */
+#define Limit(val) { \
+	if ( (short)(val) != (val) ) val = 0x7FFF ^ ( ( val ) >> 31 ); \
+}
+
+
+/* status set and IRQ handling */
+INLINE void FM_STATUS_SET(FM_ST *ST,int flag)
+{
+	/* set status flag */
+	ST->status |= flag;
+	if ( !(ST->irq) && (ST->status & ST->irqmask) )
+	{
+		ST->irq = 1;
+	}
+}
+
+/* status reset and IRQ handling */
+INLINE void FM_STATUS_RESET(FM_ST *ST,int flag)
+{
+	/* reset status flag */
+	ST->status &=~flag;
+	if ( (ST->irq) && !(ST->status & ST->irqmask) )
+	{
+		ST->irq = 0;
+	}
+}
+
+/* IRQ mask set */
+INLINE void FM_IRQMASK_SET(FM_ST *ST,int flag)
+{
+	ST->irqmask = flag;
+	/* IRQ handling check */
+	FM_STATUS_SET(ST,0);
+	FM_STATUS_RESET(ST,0);
+}
+
+/* Timer A Overflow */
+INLINE void TimerAOver(FM_ST *ST)
+{
+	/* set status (if enabled) */
+	if(ST->mode & 0x04) FM_STATUS_SET(ST,0x01);
+	/* clear or reload the counter */
+	ST->TAC = (1024-ST->TA);
+}
+/* Timer B Overflow */
+INLINE void TimerBOver(FM_ST *ST)
+{
+	/* set status (if enabled) */
+	if(ST->mode & 0x08) FM_STATUS_SET(ST,0x02);
+	/* clear or reload the counter */
+	ST->TBC = ( 256-ST->TB)<<4;
+}
+
+
+#if FM_BUSY_FLAG_SUPPORT
+INLINE UINT8 FM_STATUS_FLAG(FM_ST *ST)
+{
+	if( ST->BusyExpire )
+	{
+		if( (ST->BusyExpire - FM_GET_TIME_NOW()) > 0)
+			return ST->status | 0x80;	/* with busy */
+		/* expire */
+		ST->BusyExpire = 0;
+	}
+	return ST->status;
+}
+INLINE void FM_BUSY_SET(FM_ST *ST,int busyclock )
+{
+	ST->BusyExpire = FM_GET_TIME_NOW() + (ST->TimerBase * busyclock);
+}
+#define FM_BUSY_CLEAR(ST) ((ST)->BusyExpire = 0)
+#else
+#define FM_STATUS_FLAG(ST) ((ST)->status)
+#define FM_BUSY_SET(ST,bclock) {}
+#define FM_BUSY_CLEAR(ST) {}
+#endif
+
+
+
+
+INLINE void FM_KEYON(FM_OPN *OPN, FM_CH *CH , int s )
+{
+	FM_SLOT *SLOT = &CH->SLOT[s];
+	if( !SLOT->key && !OPN->SL3.key_csm)
+	{
+		/* restart Phase Generator */
+		SLOT->phase = 0;
+
+		/* reset SSG-EG inversion flag */
+		SLOT->ssgn = 0;
+
+		if( (SLOT->ar + SLOT->ksr) < 94 /*32+62*/)
+		{
+			SLOT->state = (SLOT->volume <= MIN_ATT_INDEX) ? ((SLOT->sl == MIN_ATT_INDEX) ? EG_SUS : EG_DEC) : EG_ATT;
+		}
+		else
+		{
+			/* force attenuation level to 0 */
+			SLOT->volume = MIN_ATT_INDEX;
+
+			/* directly switch to Decay (or Sustain) */
+			SLOT->state = (SLOT->sl == MIN_ATT_INDEX) ? EG_SUS : EG_DEC;
+		}
+
+		/* recalculate EG output */
+		if ((SLOT->ssg&0x08) && (SLOT->ssgn ^ (SLOT->ssg&0x04)))
+			SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+		else
+			SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+	}
+
+	SLOT->key = 1;
+}
+
+INLINE void FM_KEYOFF(FM_OPN *OPN, FM_CH *CH , int s )
+{
+	FM_SLOT *SLOT = &CH->SLOT[s];
+	if( SLOT->key && !OPN->SL3.key_csm)
+	{
+		if (SLOT->state>EG_REL)
+		{
+			SLOT->state = EG_REL; /* phase -> Release */
+
+			if ( SLOT->ssg & 0x8 )
+			{
+				/* convert EG attenuation level */
+				if (SLOT->ssgn ^ (SLOT->ssg&0x04))
+			        	SLOT->volume = (0x200 - SLOT->volume);
+
+				/* force EG attenuation level */
+				if (SLOT->volume >= 0x200)
+				{
+					SLOT->volume = MAX_ATT_INDEX;
+					SLOT->state  = EG_OFF;
+				}
+
+				/* recalculate EG output */
+				SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+			}
+		}
+	}
+
+	SLOT->key = 0;
+}
+
+INLINE void FM_KEYON_CSM(FM_OPN *OPN, FM_CH *CH , int s )
+{
+	FM_SLOT *SLOT = &CH->SLOT[s];
+
+	if( !SLOT->key && !OPN->SL3.key_csm)
+	{
+		/* restart Phase Generator */
+		SLOT->phase = 0;
+
+		/* reset SSG-EG inversion flag */
+		SLOT->ssgn = 0;
+
+		if ((SLOT->ar + SLOT->ksr) < 94 /*32+62*/)
+		{
+			SLOT->state = (SLOT->volume <= MIN_ATT_INDEX) ? ((SLOT->sl == MIN_ATT_INDEX) ? EG_SUS : EG_DEC) : EG_ATT;
+		}
+		else
+		{
+			/* force attenuation level to 0 */
+			SLOT->volume = MIN_ATT_INDEX;
+
+			/* directly switch to Decay (or Sustain) */
+			SLOT->state = (SLOT->sl == MIN_ATT_INDEX) ? EG_SUS : EG_DEC;
+		}
+
+		/* recalculate EG output */
+		if ((SLOT->ssg&0x08) && (SLOT->ssgn ^ (SLOT->ssg&0x04)))
+			SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+		else
+			SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+	}
+}
+
+INLINE void FM_KEYOFF_CSM(FM_CH *CH , int s )
+{
+	FM_SLOT *SLOT = &CH->SLOT[s];
+	if (!SLOT->key)
+	{
+		if (SLOT->state>EG_REL)
+		{
+			SLOT->state = EG_REL; /* phase -> Release */
+
+			/* SSG-EG specific update */
+			if (SLOT->ssg&0x08)
+			{
+				/* convert EG attenuation level */
+				if (SLOT->ssgn ^ (SLOT->ssg&0x04))
+					SLOT->volume = (0x200 - SLOT->volume);
+
+				/* force EG attenuation level */
+				if (SLOT->volume >= 0x200)
+				{
+					SLOT->volume = MAX_ATT_INDEX;
+					SLOT->state  = EG_OFF;
+				}
+
+				/* recalculate EG output */
+				SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+			}
+		}
+	}
+}
+
+/* CSM Key Controll */
+INLINE void CSMKeyControll(FM_OPN *OPN, FM_CH *CH)
+{
+	/* all key ON (verified by Nemesis on real hardware) */
+	FM_KEYON_CSM(OPN,CH,SLOT1);
+	FM_KEYON_CSM(OPN,CH,SLOT2);
+	FM_KEYON_CSM(OPN,CH,SLOT3);
+	FM_KEYON_CSM(OPN,CH,SLOT4);
+	OPN->SL3.key_csm = 1;
+}
+
+INLINE void INTERNAL_TIMER_A(FM_OPN * OPN)
+{
+  if (OPN->ST.mode & 0x01)
+  {
+    if ((OPN->ST.TAC -= OPN->ST.TimerBase) <= 0)
+    {
+      /* set status (if enabled) */
+      if (OPN->ST.mode & 0x04) OPN->ST.status |= 0x01;
+
+      /* reload the counter */
+      if (OPN->ST.TAL) OPN->ST.TAC += OPN->ST.TAL;
+      else OPN->ST.TAC = OPN->ST.TAL;
+
+      /* CSM mode auto key on */
+      if ((OPN->ST.mode & 0xC0) == 0x80) CSMKeyControll(OPN, &OPN->P_CH[2]);
+    }
+  }
+}
+
+INLINE void INTERNAL_TIMER_B(FM_ST * ST, int step)
+{
+  if (ST->mode & 0x02)
+  {
+    if ((ST->TBC -= (ST->TimerBase * step)) <= 0)
+    {
+      /* set status (if enabled) */
+      if (ST->mode & 0x08) ST->status |= 0x02;
+
+      /* reload the counter */
+      if (ST->TBL) ST->TBC += ST->TBL;
+      else ST->TBC = ST->TBL;
+    }
+  }
+}
+
+/* OPN Mode Register Write */
+INLINE void set_timers( FM_OPN *OPN, int v )
+{
+	/* b7 = CSM MODE */
+	/* b6 = 3 slot mode */
+	/* b5 = reset b */
+	/* b4 = reset a */
+	/* b3 = timer enable b */
+	/* b2 = timer enable a */
+	/* b1 = load b */
+	/* b0 = load a */
+
+	if ((OPN->ST.mode ^ v) & 0xC0)
+	{
+		/* phase increment need to be recalculated */
+		OPN->P_CH[2].SLOT[SLOT1].Incr=-1;
+
+		/* CSM mode disabled and CSM key ON active*/
+		if (((v & 0xC0) != 0x80) && OPN->SL3.key_csm)
+		{
+			/* CSM Mode Key OFF (verified by Nemesis on real hardware) */
+			FM_KEYOFF_CSM(&OPN->P_CH[2],SLOT1);
+			FM_KEYOFF_CSM(&OPN->P_CH[2],SLOT2);
+			FM_KEYOFF_CSM(&OPN->P_CH[2],SLOT3);
+			FM_KEYOFF_CSM(&OPN->P_CH[2],SLOT4);
+			OPN->SL3.key_csm = 0;
+		}
+	}
+
+	/* reload Timers */
+	if ((v&1) & !(OPN->ST.mode&1)) OPN->ST.TAC = OPN->ST.TAL;
+	if ((v&2) & !(OPN->ST.mode&2)) OPN->ST.TBC = OPN->ST.TBL;
+
+	/* reset Timers flags */
+	OPN->ST.status &= (~v >> 4); 
+
+	OPN->ST.mode = v;
+}
+
+
+/* set algorithm connection */
+static void setup_connection( FM_OPN *OPN, FM_CH *CH, int ch )
+{
+	INT32 *carrier = &OPN->out_fm[ch];
+
+	INT32 **om1 = &CH->connect1;
+	INT32 **om2 = &CH->connect3;
+	INT32 **oc1 = &CH->connect2;
+
+	INT32 **memc = &CH->mem_connect;
+
+	switch( CH->ALGO ){
+	case 0:
+		/* M1---C1---MEM---M2---C2---OUT */
+		*om1 = &OPN->c1;
+		*oc1 = &OPN->mem;
+		*om2 = &OPN->c2;
+		*memc= &OPN->m2;
+		break;
+	case 1:
+		/* M1------+-MEM---M2---C2---OUT */
+		/*      C1-+                     */
+		*om1 = &OPN->mem;
+		*oc1 = &OPN->mem;
+		*om2 = &OPN->c2;
+		*memc= &OPN->m2;
+		break;
+	case 2:
+		/* M1-----------------+-C2---OUT */
+		/*      C1---MEM---M2-+          */
+		*om1 = &OPN->c2;
+		*oc1 = &OPN->mem;
+		*om2 = &OPN->c2;
+		*memc= &OPN->m2;
+		break;
+	case 3:
+		/* M1---C1---MEM------+-C2---OUT */
+		/*                 M2-+          */
+		*om1 = &OPN->c1;
+		*oc1 = &OPN->mem;
+		*om2 = &OPN->c2;
+		*memc= &OPN->c2;
+		break;
+	case 4:
+		/* M1---C1-+-OUT */
+		/* M2---C2-+     */
+		/* MEM: not used */
+		*om1 = &OPN->c1;
+		*oc1 = carrier;
+		*om2 = &OPN->c2;
+		*memc= &OPN->mem;	/* store it anywhere where it will not be used */
+		break;
+	case 5:
+		/*    +----C1----+     */
+		/* M1-+-MEM---M2-+-OUT */
+		/*    +----C2----+     */
+		*om1 = 0;	/* special mark */
+		*oc1 = carrier;
+		*om2 = carrier;
+		*memc= &OPN->m2;
+		break;
+	case 6:
+		/* M1---C1-+     */
+		/*      M2-+-OUT */
+		/*      C2-+     */
+		/* MEM: not used */
+		*om1 = &OPN->c1;
+		*oc1 = carrier;
+		*om2 = carrier;
+		*memc= &OPN->mem;	/* store it anywhere where it will not be used */
+		break;
+	case 7:
+		/* M1-+     */
+		/* C1-+-OUT */
+		/* M2-+     */
+		/* C2-+     */
+		/* MEM: not used*/
+		*om1 = carrier;
+		*oc1 = carrier;
+		*om2 = carrier;
+		*memc= &OPN->mem;	/* store it anywhere where it will not be used */
+		break;
+	}
+
+	CH->connect4 = carrier;
+}
+
+/* set detune & multiple */
+INLINE void set_det_mul(FM_ST *ST,FM_CH *CH,FM_SLOT *SLOT,int v)
+{
+	SLOT->mul = (v&0x0f)? (v&0x0f)*2 : 1;
+	SLOT->DT  = ST->dt_tab[(v>>4)&7];
+	CH->SLOT[SLOT1].Incr=-1;
+}
+
+/* set total level */
+INLINE void set_tl(FM_CH *CH,FM_SLOT *SLOT , int v)
+{
+	SLOT->tl = (v&0x7f)<<(ENV_BITS-7); /* 7bit TL */
+
+	/* recalculate EG output */
+	if ((SLOT->ssg&0x08) && (SLOT->ssgn ^ (SLOT->ssg&0x04)) && (SLOT->state > EG_REL))
+		SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+	else
+		SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+}
+
+/* set attack rate & key scale  */
+INLINE void set_ar_ksr(FM_CH *CH,FM_SLOT *SLOT,int v)
+{
+	UINT8 old_KSR = SLOT->KSR;
+
+	SLOT->ar = (v&0x1f) ? 32 + ((v&0x1f)<<1) : 0;
+
+	SLOT->KSR = 3-(v>>6);
+	if (SLOT->KSR != old_KSR)
+	{
+		CH->SLOT[SLOT1].Incr=-1;
+	}
+
+	/* Even if it seems unnecessary, in some odd case, KSR and KC are both modified   */
+	/* and could result in SLOT->kc remaining unchanged.                              */
+	/* In such case, AR values would not be recalculated despite SLOT->ar has changed */
+	/* This fixes the introduction music of Batman & Robin    (Eke-Eke)               */
+	if ((SLOT->ar + SLOT->ksr) < 94 /*32+62*/)
+	{
+		SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar  + SLOT->ksr ];
+		SLOT->eg_sel_ar = eg_rate_select[SLOT->ar  + SLOT->ksr ];
+	}
+	else
+	{
+		SLOT->eg_sh_ar  = 0;
+		SLOT->eg_sel_ar = 18*RATE_STEPS;	/* verified by Nemesis on real hardware */
+	}
+}
+
+/* set decay rate */
+INLINE void set_dr(FM_SLOT *SLOT,int v)
+{
+	SLOT->d1r = (v&0x1f) ? 32 + ((v&0x1f)<<1) : 0;
+
+	SLOT->eg_sh_d1r = eg_rate_shift [SLOT->d1r + SLOT->ksr];
+	SLOT->eg_sel_d1r= eg_rate_select[SLOT->d1r + SLOT->ksr];
+}
+
+/* set sustain rate */
+INLINE void set_sr(FM_SLOT *SLOT,int v)
+{
+	SLOT->d2r = (v&0x1f) ? 32 + ((v&0x1f)<<1) : 0;
+
+	SLOT->eg_sh_d2r = eg_rate_shift [SLOT->d2r + SLOT->ksr];
+	SLOT->eg_sel_d2r= eg_rate_select[SLOT->d2r + SLOT->ksr];
+}
+
+/* set release rate */
+INLINE void set_sl_rr(FM_SLOT *SLOT,int v)
+{
+	SLOT->sl = sl_table[ v>>4 ];
+
+	/* check EG state changes */
+	if ((SLOT->state == EG_DEC) && (SLOT->volume >= (INT32)(SLOT->sl)))
+		SLOT->state = EG_SUS;
+
+	SLOT->rr  = 34 + ((v&0x0f)<<2);
+
+	SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr  + SLOT->ksr];
+	SLOT->eg_sel_rr = eg_rate_select[SLOT->rr  + SLOT->ksr];
+}
+
+
+
+/* advance LFO to next sample */
+INLINE void advance_lfo(FM_OPN *OPN)
+{
+	if (OPN->lfo_timer_overflow)   /* LFO enabled ? */
+	{
+		/* increment LFO timer */
+		OPN->lfo_timer +=  OPN->lfo_timer_add;
+
+		/* when LFO is enabled, one level will last for 108, 77, 71, 67, 62, 44, 8 or 5 samples */
+		while (OPN->lfo_timer >= OPN->lfo_timer_overflow)
+		{
+			OPN->lfo_timer -= OPN->lfo_timer_overflow;
+
+			/* There are 128 LFO steps */
+			OPN->lfo_cnt = ( OPN->lfo_cnt + 1 ) & 127;
+
+			/* triangle */
+			/* AM: 0 to 126 step +2, 126 to 0 step -2 */
+			if (OPN->lfo_cnt<64)
+				OPN->LFO_AM = OPN->lfo_cnt * 2;
+			else
+				OPN->LFO_AM = 126 - ((OPN->lfo_cnt&63) * 2);
+
+			/* PM works with 4 times slower clock */
+			OPN->LFO_PM = OPN->lfo_cnt >> 2;
+		}
+	}
+}
+
+/* changed from INLINE to static here to work around gcc 4.2.1 codegen bug */
+static void advance_eg_channel(FM_OPN *OPN, FM_SLOT *SLOT)
+{
+	unsigned int i = 4; /* four operators per channel */
+
+	do
+	{
+		switch(SLOT->state)
+		{
+		case EG_ATT:    /* attack phase */
+			if (!(OPN->eg_cnt & ((1<<SLOT->eg_sh_ar)-1)))
+			{
+				/* update attenuation level */
+				SLOT->volume += (~SLOT->volume * (eg_inc[SLOT->eg_sel_ar + ((OPN->eg_cnt>>SLOT->eg_sh_ar)&7)]))>>4;
+
+				/* check phase transition*/
+				if (SLOT->volume <= MIN_ATT_INDEX)
+				{
+					SLOT->volume = MIN_ATT_INDEX;
+					SLOT->state = (SLOT->sl == MIN_ATT_INDEX) ? EG_SUS : EG_DEC; /* special case where SL=0 */
+				}
+
+				/* recalculate EG output */
+				if ((SLOT->ssg&0x08) && (SLOT->ssgn ^ (SLOT->ssg&0x04)))  /* SSG-EG Output Inversion */
+					SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+				else
+					SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+			}
+			break;
+
+		case EG_DEC:  /* decay phase */
+			if (!(OPN->eg_cnt & ((1<<SLOT->eg_sh_d1r)-1)))
+			{
+				/* SSG EG type */
+				if (SLOT->ssg&0x08)
+				{
+					/* update attenuation level */
+					if (SLOT->volume < 0x200)
+					{
+						SLOT->volume += 4 * eg_inc[SLOT->eg_sel_d1r + ((OPN->eg_cnt>>SLOT->eg_sh_d1r)&7)];
+
+						/* recalculate EG output */
+						if (SLOT->ssgn ^ (SLOT->ssg&0x04))   /* SSG-EG Output Inversion */
+							SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+						else
+							SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+					}
+				}
+				else
+				{
+					/* update attenuation level */
+					SLOT->volume += eg_inc[SLOT->eg_sel_d1r + ((OPN->eg_cnt>>SLOT->eg_sh_d1r)&7)];
+
+					/* recalculate EG output */
+					SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+				}
+
+				/* check phase transition*/
+				if (SLOT->volume >= (INT32)(SLOT->sl))
+					SLOT->state = EG_SUS;
+			}
+			break;
+
+		case EG_SUS:  /* sustain phase */
+			if (!(OPN->eg_cnt & ((1<<SLOT->eg_sh_d2r)-1)))
+			{
+				/* SSG EG type */
+				if (SLOT->ssg&0x08)
+				{
+					/* update attenuation level */
+					if (SLOT->volume < 0x200)
+					{
+						SLOT->volume += 4 * eg_inc[SLOT->eg_sel_d2r + ((OPN->eg_cnt>>SLOT->eg_sh_d2r)&7)];
+
+						/* recalculate EG output */
+						if (SLOT->ssgn ^ (SLOT->ssg&0x04))   /* SSG-EG Output Inversion */
+							SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+						else
+							SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+					}
+				}
+				else
+				{
+					/* update attenuation level */
+					SLOT->volume += eg_inc[SLOT->eg_sel_d2r + ((OPN->eg_cnt>>SLOT->eg_sh_d2r)&7)];
+
+					/* check phase transition*/
+					if ( SLOT->volume >= MAX_ATT_INDEX )
+						SLOT->volume = MAX_ATT_INDEX;
+					/* do not change SLOT->state (verified on real chip) */
+
+					/* recalculate EG output */
+					SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+				}
+			}
+			break;
+
+		case EG_REL:  /* release phase */
+			if (!(OPN->eg_cnt & ((1<<SLOT->eg_sh_rr)-1)))
+			{
+				/* SSG EG type */
+				if (SLOT->ssg&0x08)
+				{
+					/* update attenuation level */
+					if (SLOT->volume < 0x200)
+						SLOT->volume += 4 * eg_inc[SLOT->eg_sel_rr + ((OPN->eg_cnt>>SLOT->eg_sh_rr)&7)];
+					/* check phase transition */
+					if (SLOT->volume >= 0x200)
+					{
+						SLOT->volume = MAX_ATT_INDEX;
+						SLOT->state = EG_OFF;
+					}
+				}
+				else
+				{
+					/* update attenuation level */
+					SLOT->volume += eg_inc[SLOT->eg_sel_rr + ((OPN->eg_cnt>>SLOT->eg_sh_rr)&7)];
+
+					/* check phase transition*/
+					if (SLOT->volume >= MAX_ATT_INDEX)
+					{
+						SLOT->volume = MAX_ATT_INDEX;
+						SLOT->state = EG_OFF;
+					}
+				}
+
+				/* recalculate EG output */
+				SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+
+			}
+			break;
+		}
+
+		SLOT++;
+		i--;
+	} while (i);
+}
+
+/* SSG-EG update process */
+/* The behavior is based upon Nemesis tests on real hardware */
+/* This is actually executed before each samples */
+static void update_ssg_eg_channel(FM_SLOT *SLOT)
+{
+	unsigned int i = 4; /* four operators per channel */
+
+	do
+	{
+		/* detect SSG-EG transition */
+		/* this is not required during release phase as the attenuation has been forced to MAX and output invert flag is not used */
+		/* if an Attack Phase is programmed, inversion can occur on each sample */
+		if ((SLOT->ssg & 0x08) && (SLOT->volume >= 0x200) && (SLOT->state > EG_REL))
+		{
+			if (SLOT->ssg & 0x01)  /* bit 0 = hold SSG-EG */
+			{
+				/* set inversion flag */
+			        if (SLOT->ssg & 0x02)
+				       SLOT->ssgn = 4;
+
+				/* force attenuation level during decay phases */
+				if ((SLOT->state != EG_ATT) && !(SLOT->ssgn ^ (SLOT->ssg & 0x04)))
+					SLOT->volume  = MAX_ATT_INDEX;
+			}
+			else  /* loop SSG-EG */
+			{
+				/* toggle output inversion flag or reset Phase Generator */
+			        if (SLOT->ssg & 0x02)
+			        	SLOT->ssgn ^= 4;
+			        else
+			        	SLOT->phase = 0;
+
+				/* same as Key ON */
+				if (SLOT->state != EG_ATT)
+				{
+					if ((SLOT->ar + SLOT->ksr) < 94 /*32+62*/)
+					{
+						SLOT->state = (SLOT->volume <= MIN_ATT_INDEX) ? ((SLOT->sl == MIN_ATT_INDEX) ? EG_SUS : EG_DEC) : EG_ATT;
+					}
+					else
+					{
+						/* Attack Rate is maximal: directly switch to Decay or Substain */
+						SLOT->volume = MIN_ATT_INDEX;
+						SLOT->state = (SLOT->sl == MIN_ATT_INDEX) ? EG_SUS : EG_DEC;
+					}
+				}
+			}
+
+			/* recalculate EG output */
+			if (SLOT->ssgn ^ (SLOT->ssg&0x04))
+				SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+			else
+				SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+		}
+
+		/* next slot */
+		SLOT++;
+		i--;
+	} while (i);
+}
+
+
+INLINE void update_phase_lfo_slot(FM_OPN *OPN, FM_SLOT *SLOT, INT32 pms, UINT32 block_fnum)
+{
+	UINT32 fnum_lfo   = ((block_fnum & 0x7f0) >> 4) * 32 * 8;
+	INT32  lfo_fn_table_index_offset = lfo_pm_table[ fnum_lfo + pms + OPN->LFO_PM ];
+
+	if (lfo_fn_table_index_offset)    /* LFO phase modulation active */
+	{
+		block_fnum = block_fnum*2 + lfo_fn_table_index_offset;
+
+		UINT8 blk = (block_fnum&0x7000) >> 12;
+		UINT32 fn  = block_fnum & 0xfff;
+
+		/* recalculate keyscale code */
+		int kc = (blk<<2) | opn_fktable[fn >> 8];
+
+		/* recalculate (frequency) phase increment counter */
+		int fc = (OPN->fn_table[fn]>>(7-blk)) + SLOT->DT[kc];
+
+		/* (frequency) phase overflow (credits to Nemesis) */
+		if (fc < 0) fc += OPN->fn_max;
+
+		/* update phase */
+		SLOT->phase += (fc * SLOT->mul) >> 1;
+	}
+	else    /* LFO phase modulation  = zero */
+	{
+		SLOT->phase += SLOT->Incr;
+	}
+}
+
+INLINE void update_phase_lfo_channel(FM_OPN *OPN, FM_CH *CH)
+{
+	UINT32 block_fnum = CH->block_fnum;
+
+	UINT32 fnum_lfo  = ((block_fnum & 0x7f0) >> 4) * 32 * 8;
+	INT32  lfo_fn_table_index_offset = lfo_pm_table[ fnum_lfo + CH->pms + OPN->LFO_PM ];
+
+	if (lfo_fn_table_index_offset)    /* LFO phase modulation active */
+	{
+		block_fnum = block_fnum*2 + lfo_fn_table_index_offset;
+
+		UINT8 blk = (block_fnum&0x7000) >> 12;
+		UINT32 fn  = block_fnum & 0xfff;
+
+		/* recalculate keyscale code */
+		int kc = (blk<<2) | opn_fktable[fn >> 8];
+
+		/* recalculate (frequency) phase increment counter */
+		int fc = (OPN->fn_table[fn]>>(7-blk));
+
+		/* (frequency) phase overflow (credits to Nemesis) */
+		int finc = fc + CH->SLOT[SLOT1].DT[kc];
+		if (finc < 0) finc += OPN->fn_max;
+		CH->SLOT[SLOT1].phase += (finc*CH->SLOT[SLOT1].mul) >> 1;
+
+		finc = fc + CH->SLOT[SLOT2].DT[kc];
+		if (finc < 0) finc += OPN->fn_max;
+		CH->SLOT[SLOT2].phase += (finc*CH->SLOT[SLOT2].mul) >> 1;
+
+		finc = fc + CH->SLOT[SLOT3].DT[kc];
+		if (finc < 0) finc += OPN->fn_max;
+		CH->SLOT[SLOT3].phase += (finc*CH->SLOT[SLOT3].mul) >> 1;
+
+		finc = fc + CH->SLOT[SLOT4].DT[kc];
+		if (finc < 0) finc += OPN->fn_max;
+		CH->SLOT[SLOT4].phase += (finc*CH->SLOT[SLOT4].mul) >> 1;
+	}
+	else    /* LFO phase modulation  = zero */
+	{
+	        CH->SLOT[SLOT1].phase += CH->SLOT[SLOT1].Incr;
+	        CH->SLOT[SLOT2].phase += CH->SLOT[SLOT2].Incr;
+	        CH->SLOT[SLOT3].phase += CH->SLOT[SLOT3].Incr;
+	        CH->SLOT[SLOT4].phase += CH->SLOT[SLOT4].Incr;
+	}
+}
+
+/* update phase increment and envelope generator */
+INLINE void refresh_fc_eg_slot(FM_OPN *OPN, FM_SLOT *SLOT , int fc , int kc )
+{
+	int ksr = kc >> SLOT->KSR;
+
+	fc += SLOT->DT[kc];
+
+	/* detects frequency overflow (credits to Nemesis) */
+	if (fc < 0) fc += OPN->fn_max;
+
+	/* (frequency) phase increment counter */
+	SLOT->Incr = (fc * SLOT->mul) >> 1;
+
+	if( SLOT->ksr != ksr )
+	{
+		SLOT->ksr = ksr;
+
+		/* calculate envelope generator rates */
+		if ((SLOT->ar + SLOT->ksr) < 32+62)
+		{
+			SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar  + SLOT->ksr ];
+			SLOT->eg_sel_ar = eg_rate_select[SLOT->ar  + SLOT->ksr ];
+		}
+		else
+		{
+			/* verified by Nemesis on real hardware (Attack phase is blocked) */
+			SLOT->eg_sh_ar  = 0;
+			SLOT->eg_sel_ar = 18*RATE_STEPS;
+		}
+
+		SLOT->eg_sh_d1r = eg_rate_shift [SLOT->d1r + SLOT->ksr];
+		SLOT->eg_sel_d1r= eg_rate_select[SLOT->d1r + SLOT->ksr];
+
+		SLOT->eg_sh_d2r = eg_rate_shift [SLOT->d2r + SLOT->ksr];
+		SLOT->eg_sel_d2r= eg_rate_select[SLOT->d2r + SLOT->ksr];
+
+		SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr  + SLOT->ksr];
+		SLOT->eg_sel_rr = eg_rate_select[SLOT->rr  + SLOT->ksr];
+	}
+}
+
+/* update phase increment counters */
+INLINE void refresh_fc_eg_chan(FM_OPN *OPN, FM_CH *CH )
+{
+	if( CH->SLOT[SLOT1].Incr==-1){
+		int fc = CH->fc;
+		int kc = CH->kcode;
+		refresh_fc_eg_slot(OPN, &CH->SLOT[SLOT1] , fc , kc );
+		refresh_fc_eg_slot(OPN, &CH->SLOT[SLOT2] , fc , kc );
+		refresh_fc_eg_slot(OPN, &CH->SLOT[SLOT3] , fc , kc );
+		refresh_fc_eg_slot(OPN, &CH->SLOT[SLOT4] , fc , kc );
+	}
+}
+
+#define volume_calc(OP) ((OP)->vol_out + (AM & (OP)->AMmask))
+
+INLINE signed int op_calc(UINT32 phase, unsigned int env, signed int pm)
+{
+	UINT32 p;
+
+	p = (env<<3) + sin_tab[ ( ((signed int)((phase & ~FREQ_MASK) + (pm<<15))) >> FREQ_SH ) & SIN_MASK ];
+
+	if (p >= TL_TAB_LEN)
+		return 0;
+	return tl_tab[p];
+}
+
+INLINE signed int op_calc1(UINT32 phase, unsigned int env, signed int pm)
+{
+	UINT32 p;
+
+	p = (env<<3) + sin_tab[ ( ((signed int)((phase & ~FREQ_MASK) + pm      )) >> FREQ_SH ) & SIN_MASK ];
+
+	if (p >= TL_TAB_LEN)
+		return 0;
+	return tl_tab[p];
+}
+
+INLINE void chan_calc(FM_OPN *OPN, FM_CH *CH)
+{
+	UINT32 AM = OPN->LFO_AM >> CH->ams;
+
+	OPN->m2 = OPN->c1 = OPN->c2 = OPN->mem = 0;
+
+	*CH->mem_connect = CH->mem_value;  /* restore delayed sample (MEM) value to m2 or c2 */
+
+	unsigned int eg_out = volume_calc(&CH->SLOT[SLOT1]);
+	{
+		INT32 out = CH->op1_out[0] + CH->op1_out[1];
+		CH->op1_out[0] = CH->op1_out[1];
+
+		if( !CH->connect1 ){
+			/* algorithm 5  */
+			OPN->mem = OPN->c1 = OPN->c2 = CH->op1_out[0];
+		}else{
+			/* other algorithms */
+			*CH->connect1 += CH->op1_out[0];
+		}
+
+		CH->op1_out[1] = 0;
+		if( eg_out < ENV_QUIET )  /* SLOT 1 */
+		{
+			if (!CH->FB)
+				out=0;
+
+			CH->op1_out[1] = op_calc1(CH->SLOT[SLOT1].phase, eg_out, (out<<CH->FB) );
+		}
+	}
+
+	eg_out = volume_calc(&CH->SLOT[SLOT3]);
+	if( eg_out < ENV_QUIET )    /* SLOT 3 */
+		*CH->connect3 += op_calc(CH->SLOT[SLOT3].phase, eg_out, OPN->m2);
+
+	eg_out = volume_calc(&CH->SLOT[SLOT2]);
+	if( eg_out < ENV_QUIET )    /* SLOT 2 */
+		*CH->connect2 += op_calc(CH->SLOT[SLOT2].phase, eg_out, OPN->c1);
+
+	eg_out = volume_calc(&CH->SLOT[SLOT4]);
+	if( eg_out < ENV_QUIET )    /* SLOT 4 */
+		*CH->connect4 += op_calc(CH->SLOT[SLOT4].phase, eg_out, OPN->c2);
+
+
+	/* store current MEM */
+	CH->mem_value = OPN->mem;
+
+	/* update phase counters AFTER output calculations */
+	if(CH->pms)
+	{
+		/* add support for 3 slot mode */
+		if ((OPN->ST.mode & 0xC0) && (CH == &OPN->P_CH[2]))
+		{
+			update_phase_lfo_slot(OPN, &CH->SLOT[SLOT1], CH->pms, OPN->SL3.block_fnum[1]);
+			update_phase_lfo_slot(OPN, &CH->SLOT[SLOT2], CH->pms, OPN->SL3.block_fnum[2]);
+			update_phase_lfo_slot(OPN, &CH->SLOT[SLOT3], CH->pms, OPN->SL3.block_fnum[0]);
+			update_phase_lfo_slot(OPN, &CH->SLOT[SLOT4], CH->pms, CH->block_fnum);
+		}
+		else update_phase_lfo_channel(OPN, CH);
+	}
+	else  /* no LFO phase modulation */
+	{
+		CH->SLOT[SLOT1].phase += CH->SLOT[SLOT1].Incr;
+		CH->SLOT[SLOT2].phase += CH->SLOT[SLOT2].Incr;
+		CH->SLOT[SLOT3].phase += CH->SLOT[SLOT3].Incr;
+		CH->SLOT[SLOT4].phase += CH->SLOT[SLOT4].Incr;
+	}
+}
+
+/* initialize time tables */
+static void init_timetables( FM_OPN *OPN )
+{
+	int i,d;
+	double rate;
+
+	/* DeTune table */
+	for (d = 0;d <= 3;d++)
+	{
+		for (i = 0;i <= 31;i++)
+		{
+			rate = ((double)dt_tab[d*32 + i]) * OPN->ST.freqbase * (1<<(FREQ_SH-10)); /* -10 because chip works with 10.10 fixed point, while we use 16.16 */
+			OPN->ST.dt_tab[d][i]   = (INT32) rate;
+			OPN->ST.dt_tab[d+4][i] = -OPN->ST.dt_tab[d][i];
+		}
+	}
+
+	/* there are 2048 FNUMs that can be generated using FNUM/BLK registers
+	but LFO works with one more bit of a precision so we really need 4096 elements */
+	/* calculate fnumber -> increment counter table */
+	for(i = 0; i < 4096; i++)
+	{
+		/* freq table for octave 7 */
+		/* OPN phase increment counter = 20bit */
+		/* the correct formula is : F-Number = (144 * fnote * 2^20 / M) / 2^(B-1) */
+		/* where sample clock is  M/144 */
+		/* this means the increment value for one clock sample is FNUM * 2^(B-1) = FNUM * 64 for octave 7 */
+		/* we also need to handle the ratio between the chip frequency and the emulated frequency (can be 1.0)  */
+		OPN->fn_table[i] = (UINT32)( (double)i * 32 * OPN->ST.freqbase * (1<<(FREQ_SH-10)) ); /* -10 because chip works with 10.10 fixed point, while we use 16.16 */
+	}
+
+	/* maximal frequency is required for Phase overflow calculation, register size is 17 bits (Nemesis) */
+	OPN->fn_max = (UINT32)( (double)0x20000 * OPN->ST.freqbase * (1<<(FREQ_SH-10)) );
+}
+
+
+static void reset_channels( FM_CH *CH , int num )
+{
+	int c,s;
+
+	for( c = 0 ; c < num ; c++ )
+	{
+		CH[c].mem_value   = 0;
+		CH[c].op1_out[0]  = 0;
+		CH[c].op1_out[1]  = 0;
+		for(s = 0 ; s < 4 ; s++ )
+		{
+			CH[c].SLOT[s].Incr    = -1;
+			CH[c].SLOT[s].key     = 0;
+			CH[c].SLOT[s].phase   = 0;
+			CH[c].SLOT[s].ssgn    = 0;
+			CH[c].SLOT[s].state   = EG_OFF;
+			CH[c].SLOT[s].volume  = MAX_ATT_INDEX;
+			CH[c].SLOT[s].vol_out = MAX_ATT_INDEX;
+		}
+	}
+}
+
+/* initialize generic tables */
+static int init_tables(void)
+{
+	signed int i,x;
+	signed int n;
+	double o,m;
+
+	for (x=0; x<TL_RES_LEN; x++)
+	{
+		m = (1<<16) / pow(2, (x+1) * (ENV_STEP/4.0) / 8.0);
+		m = floor(m);
+
+		/* we never reach (1<<16) here due to the (x+1) */
+		/* result fits within 16 bits at maximum */
+
+		n = (int)m;		/* 16 bits here */
+		n >>= 4;		/* 12 bits here */
+		if (n&1)		/* round to nearest */
+			n = (n>>1)+1;
+		else
+			n = n>>1;
+						/* 11 bits here (rounded) */
+		n <<= 2;		/* 13 bits here (as in real chip) */
+		tl_tab[ x*2 + 0 ] = n;
+		tl_tab[ x*2 + 1 ] = -tl_tab[ x*2 + 0 ];
+
+		for (i=1; i<13; i++)
+		{
+			tl_tab[ x*2+0 + i*2*TL_RES_LEN ] =  tl_tab[ x*2+0 ]>>i;
+			tl_tab[ x*2+1 + i*2*TL_RES_LEN ] = -tl_tab[ x*2+0 + i*2*TL_RES_LEN ];
+		}
+	#if 0
+			logerror("tl %04i", x);
+			for (i=0; i<13; i++)
+				logerror(", [%02i] %4x", i*2, tl_tab[ x*2 /*+1*/ + i*2*TL_RES_LEN ]);
+			logerror("\n");
+		}
+	#endif
+	}
+	/*logerror("FM.C: TL_TAB_LEN = %i elements (%i bytes)\n",TL_TAB_LEN, (int)sizeof(tl_tab));*/
+
+
+	for (i=0; i<SIN_LEN; i++)
+	{
+		/* non-standard sinus */
+		m = sin( ((i*2)+1) * PI / SIN_LEN ); /* checked against the real chip */
+
+		/* we never reach zero here due to ((i*2)+1) */
+
+		if (m>0.0)
+			o = 8*log(1.0/m)/log(2.);	/* convert to 'decibels' */
+		else
+			o = 8*log(-1.0/m)/log(2.);	/* convert to 'decibels' */
+
+		o = o / (ENV_STEP/4);
+
+		n = (int)(2.0*o);
+		if (n&1)						/* round to nearest */
+			n = (n>>1)+1;
+		else
+			n = n>>1;
+
+		sin_tab[ i ] = n*2 + (m>=0.0? 0: 1 );
+		/*logerror("FM.C: sin [%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[i],tl_tab[sin_tab[i]]);*/
+	}
+
+	/*logerror("FM.C: ENV_QUIET= %08x\n",ENV_QUIET );*/
+
+
+	/* build LFO PM modulation table */
+	for(i = 0; i < 8; i++) /* 8 PM depths */
+	{
+		UINT8 fnum;
+		for (fnum=0; fnum<128; fnum++) /* 7 bits meaningful of F-NUMBER */
+		{
+			UINT8 value;
+			UINT8 step;
+			UINT32 offset_depth = i;
+			UINT32 offset_fnum_bit;
+			UINT32 bit_tmp;
+
+			for (step=0; step<8; step++)
+			{
+				value = 0;
+				for (bit_tmp=0; bit_tmp<7; bit_tmp++) /* 7 bits */
+				{
+					if (fnum & (1<<bit_tmp)) /* only if bit "bit_tmp" is set */
+					{
+						offset_fnum_bit = bit_tmp * 8;
+						value += lfo_pm_output[offset_fnum_bit + offset_depth][step];
+					}
+				}
+				lfo_pm_table[(fnum*32*8) + (i*32) + step   + 0] = value;
+				lfo_pm_table[(fnum*32*8) + (i*32) +(step^7)+ 8] = value;
+				lfo_pm_table[(fnum*32*8) + (i*32) + step   +16] = -value;
+				lfo_pm_table[(fnum*32*8) + (i*32) +(step^7)+24] = -value;
+			}
+#if 0
+			logerror("LFO depth=%1x FNUM=%04x (<<4=%4x): ", i, fnum, fnum<<4);
+			for (step=0; step<16; step++) /* dump only positive part of waveforms */
+				logerror("%02x ", lfo_pm_table[(fnum*32*8) + (i*32) + step] );
+			logerror("\n");
+#endif
+
+		}
+	}
+
+
+
+#ifdef SAVE_SAMPLE
+	sample[0]=fopen("sampsum.pcm","wb");
+#endif
+
+	return 1;
+
+}
+
+
+
+static void FMCloseTable( void )
+{
+#ifdef SAVE_SAMPLE
+	fclose(sample[0]);
+#endif
+	return;
+}
+
+
+#ifdef _STATE_H
+/* FM channel save , internal state only */
+static void FMsave_state_channel(const char *name,int num,FM_CH *CH,int num_ch)
+{
+	int slot , ch;
+	char state_name[20];
+	const char slot_array[4] = { 1 , 3 , 2 , 4 };
+
+	for(ch=0;ch<num_ch;ch++,CH++)
+	{
+		/* channel */
+		sprintf(state_name,"%s.CH%d",name,ch);
+		state_save_register_INT32(state_name, num, "feedback" , CH->op1_out , 2);
+		state_save_register_UINT32(state_name, num, "phasestep"   , &CH->fc , 1);
+		/* slots */
+		for(slot=0;slot<4;slot++)
+		{
+			FM_SLOT *SLOT = &CH->SLOT[slot];
+
+			sprintf(state_name,"%s.CH%d.SLOT%d",name,ch,slot_array[slot]);
+			state_save_register_UINT32(state_name, num, "phasecount" , &SLOT->phase, 1);
+			state_save_register_UINT8 (state_name, num, "state"      , &SLOT->state, 1);
+			state_save_register_INT32 (state_name, num, "volume"     , &SLOT->volume, 1);
+		}
+	}
+}
+
+static void FMsave_state_st(const char *state_name,int num,FM_ST *ST)
+{
+#if FM_BUSY_FLAG_SUPPORT
+	state_save_register_double(state_name, num, "BusyExpire", &ST->BusyExpire , 1);
+#endif
+	state_save_register_UINT8 (state_name, num, "address"   , &ST->address , 1);
+	state_save_register_UINT8 (state_name, num, "IRQ"       , &ST->irq     , 1);
+	state_save_register_UINT8 (state_name, num, "IRQ MASK"  , &ST->irqmask , 1);
+	state_save_register_UINT8 (state_name, num, "status"    , &ST->status  , 1);
+	state_save_register_UINT32(state_name, num, "mode"      , &ST->mode    , 1);
+	state_save_register_UINT8 (state_name, num, "prescaler" , &ST->prescaler_sel , 1);
+	state_save_register_UINT8 (state_name, num, "freq latch", &ST->fn_h , 1);
+	state_save_register_int   (state_name, num, "TIMER A"   , &ST->TA   );
+	state_save_register_int   (state_name, num, "TIMER Acnt", &ST->TAC  );
+	state_save_register_UINT8 (state_name, num, "TIMER B"   , &ST->TB   , 1);
+	state_save_register_int   (state_name, num, "TIMER Bcnt", &ST->TBC  );
+}
+#endif /* _STATE_H */
+
+#if BUILD_OPN
+
+
+
+/* prescaler set (and make time tables) */
+static void OPNSetPres(FM_OPN *OPN , int pres , int TimerPres, int SSGpres)
+{
+	/* frequency base */
+	OPN->ST.freqbase = (OPN->ST.rate) ? ((double)OPN->ST.clock / OPN->ST.rate) / pres : 0;
+	if ( fabs( OPN->ST.freqbase - 1.0 ) < 0.0001 )
+		OPN->ST.freqbase = 1.0;
+
+	OPN->eg_timer_add  = (UINT32)((1<<EG_SH) * OPN->ST.freqbase);
+	OPN->eg_timer_overflow = ( 3 ) * (1<<EG_SH);
+
+	/* LFO timer increment (every samples) */
+	OPN->lfo_timer_add = (UINT32)((1<<LFO_SH) * OPN->ST.freqbase);
+
+	/* Timer base time (every samples) */
+	OPN->ST.TimerBase = (int) ((1 << TIMER_SH) * OPN->ST.freqbase);
+
+	/* make time tables */
+	init_timetables( OPN );
+}
+
+
+
+/* write a OPN mode register 0x20-0x2f */
+static void OPNWriteMode(FM_OPN *OPN, int r, int v)
+{
+	UINT8 c;
+	FM_CH *CH;
+
+	switch(r){
+	case 0x21:	/* Test */
+		break;
+	case 0x22:	/* LFO FREQ (YM2608/YM2610/YM2610B/YM2612) */
+		if (v&8) /* LFO enabled ? */
+		{
+			if (!OPN->lfo_timer_overflow)
+			{
+				/* restart LFO */
+				OPN->lfo_cnt  = 0;
+				OPN->lfo_timer = 0;
+				OPN->LFO_AM  = 0;
+				OPN->LFO_PM  = 0;
+			}
+
+			OPN->lfo_timer_overflow = lfo_samples_per_step[v&7] << LFO_SH;
+		}
+		else
+		{
+			OPN->lfo_timer_overflow = 0;
+		}
+		break;
+	case 0x24:	/* timer A High 8*/
+		OPN->ST.TA = (OPN->ST.TA & 0x03)|(((int)v)<<2);
+		OPN->ST.TAL = (1024 - OPN->ST.TA) << TIMER_SH;
+		break;
+	case 0x25:	/* timer A Low 2*/
+		OPN->ST.TA = (OPN->ST.TA & 0x3fc)|(v&3);
+		OPN->ST.TAL = (1024 - OPN->ST.TA) << TIMER_SH;
+		break;
+	case 0x26:	/* timer B */
+		OPN->ST.TB = v;
+		OPN->ST.TBL = (256 - OPN->ST.TB) << (TIMER_SH + 4);
+		break;
+	case 0x27:	/* mode, timer control */
+		set_timers( OPN, v );
+		break;
+	case 0x28:	/* key on / off */
+		c = v & 0x03;
+		if( c == 3 ) break;
+		if( (v&0x04) ) c+=3;
+		CH = OPN->P_CH;
+		CH = &CH[c];
+		if(v&0x10) FM_KEYON(OPN,CH,SLOT1); else FM_KEYOFF(OPN,CH,SLOT1);
+		if(v&0x20) FM_KEYON(OPN,CH,SLOT2); else FM_KEYOFF(OPN,CH,SLOT2);
+		if(v&0x40) FM_KEYON(OPN,CH,SLOT3); else FM_KEYOFF(OPN,CH,SLOT3);
+		if(v&0x80) FM_KEYON(OPN,CH,SLOT4); else FM_KEYOFF(OPN,CH,SLOT4);
+		break;
+	}
+}
+
+INLINE void OPNUpdatePan( FM_OPN *OPN, int c )
+{
+	int v = OPN->pan_regs [c] & ~OPN->pan_mutes [c];
+	OPN->pan[ c*2   ] = (v & 0x80) ? ~0 : 0;
+	OPN->pan[ c*2+1 ] = (v & 0x40) ? ~0 : 0;
+}
+
+/* write a OPN register (0x30-0xff) */
+static void OPNWriteReg(FM_OPN *OPN, int r, int v)
+{
+	FM_CH *CH;
+	FM_SLOT *SLOT;
+
+	UINT8 c = OPN_CHAN(r);
+
+	if (c == 3) return; /* 0xX3,0xX7,0xXB,0xXF */
+
+	if (r >= 0x100) c+=3;
+
+	CH = OPN->P_CH;
+	CH = &CH[c];
+
+	SLOT = &(CH->SLOT[OPN_SLOT(r)]);
+
+	switch( r & 0xf0 ) {
+	case 0x30:	/* DET , MUL */
+		set_det_mul(&OPN->ST,CH,SLOT,v);
+		break;
+
+	case 0x40:	/* TL */
+		set_tl(CH,SLOT,v);
+		break;
+
+	case 0x50:	/* KS, AR */
+		set_ar_ksr(CH,SLOT,v);
+		break;
+
+	case 0x60:	/* bit7 = AM ENABLE, DR */
+		set_dr(SLOT,v);
+
+		SLOT->AMmask = (v&0x80) ? ~0 : 0;
+		break;
+
+	case 0x70:	/*     SR */
+		set_sr(SLOT,v);
+		break;
+
+	case 0x80:	/* SL, RR */
+		set_sl_rr(SLOT,v);
+		break;
+
+	case 0x90:	/* SSG-EG */
+		SLOT->ssg  =  v&0x0f;
+
+	      /* recalculate EG output */
+		if ((SLOT->ssg&0x08) && (SLOT->ssgn ^ (SLOT->ssg&0x04)) && (SLOT->state > EG_REL))
+			SLOT->vol_out = ((UINT32)(0x200 - SLOT->volume) & MAX_ATT_INDEX) + SLOT->tl;
+		else
+			SLOT->vol_out = (UINT32)SLOT->volume + SLOT->tl;
+
+		/* SSG-EG envelope shapes :
+
+        E AtAlH
+        1 0 0 0  \\\\
+
+        1 0 0 1  \___
+
+        1 0 1 0  \/\/
+                  ___
+        1 0 1 1  \
+
+        1 1 0 0  ////
+                  ___
+        1 1 0 1  /
+
+        1 1 1 0  /\/\
+
+        1 1 1 1  /___
+
+
+        E = SSG-EG enable
+
+
+        The shapes are generated using Attack, Decay and Sustain phases.
+
+        Each single character in the diagrams above represents this whole
+        sequence:
+
+        - when KEY-ON = 1, normal Attack phase is generated (*without* any
+          difference when compared to normal mode),
+
+        - later, when envelope level reaches minimum level (max volume),
+          the EG switches to Decay phase (which works with bigger steps
+          when compared to normal mode - see below),
+
+        - later when envelope level passes the SL level,
+          the EG swithes to Sustain phase (which works with bigger steps
+          when compared to normal mode - see below),
+
+        - finally when envelope level reaches maximum level (min volume),
+          the EG switches to Attack phase again (depends on actual waveform).
+
+        Important is that when switch to Attack phase occurs, the phase counter
+        of that operator will be zeroed-out (as in normal KEY-ON) but not always.
+        (I havent found the rule for that - perhaps only when the output level is low)
+
+        The difference (when compared to normal Envelope Generator mode) is
+        that the resolution in Decay and Sustain phases is 4 times lower;
+        this results in only 256 steps instead of normal 1024.
+        In other words:
+        when SSG-EG is disabled, the step inside of the EG is one,
+        when SSG-EG is enabled, the step is four (in Decay and Sustain phases).
+
+        Times between the level changes are the same in both modes.
+
+
+        Important:
+        Decay 1 Level (so called SL) is compared to actual SSG-EG output, so
+        it is the same in both SSG and no-SSG modes, with this exception:
+
+        when the SSG-EG is enabled and is generating raising levels
+        (when the EG output is inverted) the SL will be found at wrong level !!!
+        For example, when SL=02:
+            0 -6 = -6dB in non-inverted EG output
+            96-6 = -90dB in inverted EG output
+        Which means that EG compares its level to SL as usual, and that the
+        output is simply inverted afterall.
+
+
+        The Yamaha's manuals say that AR should be set to 0x1f (max speed).
+        That is not necessary, but then EG will be generating Attack phase.
+
+        */
+
+
+		break;
+
+	case 0xa0:
+		switch( OPN_SLOT(r) ){
+		case 0:		/* 0xa0-0xa2 : FNUM1 */
+			{
+				UINT32 fn = (((UINT32)( (OPN->ST.fn_h)&7))<<8) + v;
+				UINT8 blk = OPN->ST.fn_h>>3;
+				/* keyscale code */
+				CH->kcode = (blk<<2) | opn_fktable[fn >> 7];
+				/* phase increment counter */
+				CH->fc = OPN->fn_table[fn*2]>>(7-blk);
+
+				/* store fnum in clear form for LFO PM calculations */
+				CH->block_fnum = (blk<<11) | fn;
+
+				CH->SLOT[SLOT1].Incr=-1;
+			}
+			break;
+		case 1:		/* 0xa4-0xa6 : FNUM2,BLK */
+			OPN->ST.fn_h = v&0x3f;
+			break;
+		case 2:		/* 0xa8-0xaa : 3CH FNUM1 */
+			if(r < 0x100)
+			{
+				UINT32 fn = (((UINT32)(OPN->SL3.fn_h&7))<<8) + v;
+				UINT8 blk = OPN->SL3.fn_h>>3;
+				/* keyscale code */
+				OPN->SL3.kcode[c]= (blk<<2) | opn_fktable[fn >> 7];
+				/* phase increment counter */
+				OPN->SL3.fc[c] = OPN->fn_table[fn*2]>>(7-blk);
+				OPN->SL3.block_fnum[c] = (blk<<11) | fn;
+				(OPN->P_CH)[2].SLOT[SLOT1].Incr=-1;
+			}
+			break;
+		case 3:		/* 0xac-0xae : 3CH FNUM2,BLK */
+			if(r < 0x100)
+				OPN->SL3.fn_h = v&0x3f;
+			break;
+		}
+		break;
+
+	case 0xb0:
+		switch( OPN_SLOT(r) ){
+		case 0:		/* 0xb0-0xb2 : FB,ALGO */
+			{
+				int feedback = (v>>3)&7;
+				CH->ALGO = v&7;
+				CH->FB   = feedback ? feedback+6 : 0;
+				setup_connection( OPN, CH, c );
+			}
+			break;
+		case 1:		/* 0xb4-0xb6 : L , R , AMS , PMS (YM2612/YM2610B/YM2610/YM2608) */
+			{
+				/* b0-2 PMS */
+				CH->pms = (v & 7) * 32; /* CH->pms = PM depth * 32 (index in lfo_pm_table) */
+
+				/* b4-5 AMS */
+				CH->ams = lfo_ams_depth_shift[(v>>4) & 0x03];
+
+				/* PAN :  b7 = L, b6 = R */
+				OPN->pan_regs [c] = v & 0xc0;
+				OPNUpdatePan( OPN, c );
+
+			}
+			break;
+		}
+		break;
+	}
+}
+
+#endif /* BUILD_OPN */
+
+#if BUILD_YM2612
+/*******************************************************************************/
+/*		YM2612 local section                                                   */
+/*******************************************************************************/
+/* here's the virtual YM2612 */
+struct Ym2612_Impl
+{
+#ifdef _STATE_H
+	UINT8		REGS[512];			/* registers			*/
+#endif
+	FM_OPN		OPN;				/* OPN state			*/
+	FM_CH		CH[6];				/* channel state		*/
+
+	/* dac output (YM2612) */
+	int			dacen;
+	INT32		dacout;
+};
+
+//static int dacen;
+
+/* Generate samples for one of the YM2612s */
+void YM2612UpdateOne(YM2612 *F2612, short *buffer, int length)
+{
+	FM_OPN *OPN   = &F2612->OPN;
+	int i;
+	INT32 dacout  = F2612->dacout;
+	FM_CH	*cch[6];
+	int dacen;
+
+	cch[0]   = &F2612->CH[0];
+	cch[1]   = &F2612->CH[1];
+	cch[2]   = &F2612->CH[2];
+	cch[3]   = &F2612->CH[3];
+	cch[4]   = &F2612->CH[4];
+	cch[5]   = &F2612->CH[5];
+	/* DAC mode */
+	dacen = F2612->dacen;
+
+	/* refresh PG and EG */
+	refresh_fc_eg_chan( OPN, cch[0] );
+	refresh_fc_eg_chan( OPN, cch[1] );
+	if( (OPN->ST.mode & 0xc0) )
+	{
+		/* 3SLOT MODE */
+		if( cch[2]->SLOT[SLOT1].Incr==-1)
+		{
+			refresh_fc_eg_slot(OPN, &cch[2]->SLOT[SLOT1] , OPN->SL3.fc[1] , OPN->SL3.kcode[1] );
+			refresh_fc_eg_slot(OPN, &cch[2]->SLOT[SLOT2] , OPN->SL3.fc[2] , OPN->SL3.kcode[2] );
+			refresh_fc_eg_slot(OPN, &cch[2]->SLOT[SLOT3] , OPN->SL3.fc[0] , OPN->SL3.kcode[0] );
+			refresh_fc_eg_slot(OPN, &cch[2]->SLOT[SLOT4] , cch[2]->fc , cch[2]->kcode );
+		}
+	}else refresh_fc_eg_chan( OPN, cch[2] );
+	refresh_fc_eg_chan( OPN, cch[3] );
+	refresh_fc_eg_chan( OPN, cch[4] );
+	refresh_fc_eg_chan( OPN, cch[5] );
+
+	/* buffering */
+	for(i=0; i < length ; i++)
+	{
+		/* clear outputs */
+		OPN->out_fm[0] = 0;
+		OPN->out_fm[1] = 0;
+		OPN->out_fm[2] = 0;
+		OPN->out_fm[3] = 0;
+		OPN->out_fm[4] = 0;
+		OPN->out_fm[5] = 0;
+
+		/* update SSG-EG output */
+		update_ssg_eg_channel(&cch[0]->SLOT[SLOT1]);
+		update_ssg_eg_channel(&cch[1]->SLOT[SLOT1]);
+		update_ssg_eg_channel(&cch[2]->SLOT[SLOT1]);
+		update_ssg_eg_channel(&cch[3]->SLOT[SLOT1]);
+		update_ssg_eg_channel(&cch[4]->SLOT[SLOT1]);
+		update_ssg_eg_channel(&cch[5]->SLOT[SLOT1]);
+
+		/* calculate FM */
+		chan_calc(OPN, cch[0] );
+		chan_calc(OPN, cch[1] );
+		chan_calc(OPN, cch[2] );
+		chan_calc(OPN, cch[3] );
+		chan_calc(OPN, cch[4] );
+		if( dacen )
+			/* *cch[5]->connect4 += dacout */;
+		else
+			chan_calc(OPN, cch[5] );
+
+		/* advance LFO */
+		advance_lfo(OPN);
+
+		/* advance envelope generator */
+		OPN->eg_timer += OPN->eg_timer_add;
+		while (OPN->eg_timer >= OPN->eg_timer_overflow)
+		{
+			OPN->eg_timer -= OPN->eg_timer_overflow;
+			OPN->eg_cnt++;
+
+			advance_eg_channel(OPN, &cch[0]->SLOT[SLOT1]);
+			advance_eg_channel(OPN, &cch[1]->SLOT[SLOT1]);
+			advance_eg_channel(OPN, &cch[2]->SLOT[SLOT1]);
+			advance_eg_channel(OPN, &cch[3]->SLOT[SLOT1]);
+			advance_eg_channel(OPN, &cch[4]->SLOT[SLOT1]);
+			advance_eg_channel(OPN, &cch[5]->SLOT[SLOT1]);
+		}
+
+		{
+			int lt,rt;
+
+			if (OPN->out_fm[0] > 8191) OPN->out_fm[0] = 8191;
+			else if (OPN->out_fm[0] < -8192) OPN->out_fm[0] = -8192;
+			if (OPN->out_fm[1] > 8191) OPN->out_fm[1] = 8191;
+			else if (OPN->out_fm[1] < -8192) OPN->out_fm[1] = -8192;
+			if (OPN->out_fm[2] > 8191) OPN->out_fm[2] = 8191;
+			else if (OPN->out_fm[2] < -8192) OPN->out_fm[2] = -8192;
+			if (OPN->out_fm[3] > 8191) OPN->out_fm[3] = 8191;
+			else if (OPN->out_fm[3] < -8192) OPN->out_fm[3] = -8192;
+			if (OPN->out_fm[4] > 8191) OPN->out_fm[4] = 8191;
+			else if (OPN->out_fm[4] < -8192) OPN->out_fm[4] = -8192;
+			if (OPN->out_fm[5] > 8191) OPN->out_fm[5] = 8191;
+			else if (OPN->out_fm[5] < -8192) OPN->out_fm[5] = -8192;
+
+			lt  = ((OPN->out_fm[0]>>0) & OPN->pan[0]);
+			rt  = ((OPN->out_fm[0]>>0) & OPN->pan[1]);
+			lt += ((OPN->out_fm[1]>>0) & OPN->pan[2]);
+			rt += ((OPN->out_fm[1]>>0) & OPN->pan[3]);
+			lt += ((OPN->out_fm[2]>>0) & OPN->pan[4]);
+			rt += ((OPN->out_fm[2]>>0) & OPN->pan[5]);
+			lt += ((OPN->out_fm[3]>>0) & OPN->pan[6]);
+			rt += ((OPN->out_fm[3]>>0) & OPN->pan[7]);
+			lt += ((OPN->out_fm[4]>>0) & OPN->pan[8]);
+			rt += ((OPN->out_fm[4]>>0) & OPN->pan[9]);
+			lt += ((OPN->out_fm[5]>>0) & OPN->pan[10]);
+			rt += ((OPN->out_fm[5]>>0) & OPN->pan[11]);
+
+			lt >>= 1;
+			rt >>= 1;
+
+			Limit( lt );
+			Limit( rt );
+
+			#ifdef SAVE_SAMPLE
+				SAVE_ALL_CHANNELS
+			#endif
+
+			/* buffering */
+			buffer[i*2] = lt;
+			buffer[i*2+1] = rt;
+		}
+
+		/* CSM mode: if CSM Key ON has occured, CSM Key OFF need to be sent       */
+		/* only if Timer A does not overflow again (i.e CSM Key ON not set again) */
+		OPN->SL3.key_csm <<= 1;
+
+		/* timer A control */
+		INTERNAL_TIMER_A( OPN );
+
+		/* CSM Mode Key ON still disabled */
+		/* CSM Mode Key OFF (verified by Nemesis on real hardware) */
+		FM_KEYOFF_CSM(cch[2],SLOT1);
+		FM_KEYOFF_CSM(cch[2],SLOT2);
+		FM_KEYOFF_CSM(cch[2],SLOT3);
+		FM_KEYOFF_CSM(cch[2],SLOT4);
+		OPN->SL3.key_csm = 0;
+	}
+	INTERNAL_TIMER_B(&OPN->ST,length);
+
+}
+
+#ifdef _STATE_H
+void YM2612Postload(void *chip)
+{
+	if (chip)
+	{
+		YM2612 *F2612 = (YM2612 *)chip;
+		int r;
+
+		/* DAC data & port */
+			F2612->dacout = ((int)F2612->REGS[0x2a] - 0x80) << 0;	/* level unknown */
+			F2612->dacen  = F2612->REGS[0x2d] & 0x80;
+		/* OPN registers */
+		/* DT / MULTI , TL , KS / AR , AMON / DR , SR , SL / RR , SSG-EG */
+		for(r=0x30;r<0x9e;r++)
+			if((r&3) != 3)
+			{
+					OPNWriteReg(&F2612->OPN,r,F2612->REGS[r]);
+					OPNWriteReg(&F2612->OPN,r|0x100,F2612->REGS[r|0x100]);
+			}
+		/* FB / CONNECT , L / R / AMS / PMS */
+		for(r=0xb0;r<0xb6;r++)
+			if((r&3) != 3)
+			{
+					OPNWriteReg(&F2612->OPN,r,F2612->REGS[r]);
+					OPNWriteReg(&F2612->OPN,r|0x100,F2612->REGS[r|0x100]);
+			}
+		/* channels */
+			/*FM_channel_postload(F2612->CH,6);*/
+			OPN->cur_chip = NULL;
+		}
+}
+
+static void YM2612_save_state(YM2612 *F2612, int index)
+{
+	const char statename[] = "YM2612";
+
+	state_save_register_UINT8 (statename, index, "regs"   , F2612->REGS   , 512);
+	FMsave_state_st(statename,index,&F2612->OPN.ST);
+	FMsave_state_channel(statename,index,F2612->CH,6);
+		/* 3slots */
+	state_save_register_UINT32 (statename, index, "slot3fc" , F2612->OPN.SL3.fc ,   3);
+	state_save_register_UINT8  (statename, index, "slot3fh" , &F2612->OPN.SL3.fn_h, 1);
+	state_save_register_UINT8  (statename, index, "slot3kc" , F2612->OPN.SL3.kcode, 3);
+		/* address register1 */
+	state_save_register_UINT8 (statename, index, "addr_A1" , &F2612->addr_A1, 1);
+}
+#endif /* _STATE_H */
+
+/* initialize YM2612 emulator(s) */
+YM2612 * YM2612Init(void *param, int index, long clock, long rate)
+{
+	YM2612 *F2612;
+
+	/* allocate extend state space */
+	if( (F2612 = (YM2612 *)calloc(1, sizeof(YM2612)))==NULL)
+		return NULL;
+	/* allocate total level table (128kb space) */
+	if( !init_tables() )
+	{
+		free( F2612 );
+		F2612 = NULL;
+		return NULL;
+	}
+
+	F2612->OPN.ST.param = param;
+	F2612->OPN.P_CH = F2612->CH;
+	F2612->OPN.ST.clock = float(clock);
+	F2612->OPN.ST.rate = rate;
+	/* F2612->OPN.ST.irq = 0; */
+	/* F2612->OPN.ST.status = 0; */
+		/* Extend handler */
+	OPNSetPres(&F2612->OPN, 6*24, 6*24, 0);
+	YM2612ResetChip( F2612 );
+
+#ifdef _STATE_H
+	YM2612_save_state(F2612, index);
+#endif
+	return F2612;
+}
+
+void YM2612Mute(YM2612* F2612, int mask)
+{
+	int c;
+	for ( c = 0; c < 6; c++ )
+	{
+		F2612->OPN.pan_mutes [c] = -(mask >> c & 1);
+		OPNUpdatePan( &F2612->OPN, c );
+	}
+}
+
+/* shut down emulator */
+void YM2612Shutdown(YM2612 *F2612)
+{
+	FMCloseTable();
+	free(F2612);
+	F2612 = NULL;
+}
+
+/* reset one of chip */
+void YM2612ResetChip(YM2612 *F2612)
+{
+	int i;
+	FM_OPN *OPN   = &F2612->OPN;
+
+	OPN->eg_timer = 0;
+	OPN->eg_cnt   = 0;
+
+	OPN->lfo_timer = 0;
+	OPN->lfo_cnt = 0;
+	OPN->LFO_AM  = 0;
+	OPN->LFO_PM  = 0;
+
+	OPN->ST.TAC = 0;
+	OPN->ST.TBC = 0;
+
+	OPN->SL3.key_csm = 0;
+
+	OPNWriteMode(OPN,0x27,0x30);
+	OPNWriteMode(OPN,0x26,0x00);
+	OPNWriteMode(OPN,0x25,0x00);
+	OPNWriteMode(OPN,0x24,0x00);
+	OPNWriteMode(OPN,0x22,0x00);
+
+	reset_channels( &F2612->CH[0] , 6 );
+
+	for(i = 0xb6 ; i >= 0xb4 ; i-- )
+	{
+		OPNWriteReg(OPN,i      ,0xc0);
+		OPNWriteReg(OPN,i|0x100,0xc0);
+	}
+	for(i = 0xb2 ; i >= 0x30 ; i-- )
+	{
+		OPNWriteReg(OPN,i      ,0);
+		OPNWriteReg(OPN,i|0x100,0);
+	}
+}
+
+/* YM2612 write */
+/* n = number  */
+/* a = address */
+/* v = value   */
+int YM2612Write(YM2612 *F2612, unsigned int a, unsigned int v)
+{
+	v &= 0xff;	/* adjust to 8 bit bus */
+
+	switch( a )
+	{
+	case 0:	/* address port 0 */
+		F2612->OPN.ST.address = v;
+		break;
+
+	case 2:	/* address port 1 */
+		F2612->OPN.ST.address = v | 0x100;
+		break;
+
+	default:
+		{
+			int addr = F2612->OPN.ST.address; /* verified by Nemesis on real YM2612 */
+#ifdef _STATE_H
+			F2612->REGS[addr] = v;
+#endif
+			switch( addr & 0x1f0 )
+			{
+			case 0x20:	/* 0x20-0x2f Mode */
+				switch( addr )
+				{
+				case 0x2a:	/* DAC data (YM2612) */
+					YM2612UpdateReq(F2612->OPN.ST.param);
+					F2612->dacout = ((int)v - 0x80) << 8;	/* level unknown */
+					break;
+				case 0x2b:	/* DAC Sel  (YM2612) */
+					/* b7 = dac enable */
+					F2612->dacen = v & 0x80;
+					break;
+				default:	/* OPN section */
+					YM2612UpdateReq(F2612->OPN.ST.param);
+					/* write register */
+					OPNWriteMode(&(F2612->OPN),addr,v);
+				}
+				break;
+			default:	/* 0x30-0xff OPN section */
+				YM2612UpdateReq(F2612->OPN.ST.param);
+				/* write register */
+				OPNWriteReg(&(F2612->OPN),addr,v);
+			}
+			break;
+		}
+	}
+	return F2612->OPN.ST.irq;
+}
+
+UINT8 YM2612Read(YM2612 *F2612,int a)
+{
+	switch( a&3){
+	case 0:	/* status 0 */
+		return FM_STATUS_FLAG(&F2612->OPN.ST);
+	case 1:
+	case 2:
+	case 3:
+		logerror("YM2612 #%p:A=%d read unmapped area\n",F2612->OPN.ST.param,a);
+		return FM_STATUS_FLAG(&F2612->OPN.ST);
+	}
+	return 0;
+}
+
+int YM2612TimerOver(YM2612 *F2612,int c)
+{
+	if( c )
+	{	/* Timer B */
+		TimerBOver( &(F2612->OPN.ST) );
+	}
+	else
+	{	/* Timer A */
+		YM2612UpdateReq(F2612->OPN.ST.param);
+		/* timer update */
+		TimerAOver( &(F2612->OPN.ST) );
+		/* CSM mode key,TL controll */
+		if ((F2612->OPN.ST.mode & 0xc0) == 0x80)
+		{	/* CSM mode total level latch and auto key on */
+			CSMKeyControll( &F2612->OPN, &(F2612->CH[2]) );
+		}
+	}
+	return F2612->OPN.ST.irq;
+}
+
+#endif /* BUILD_YM2612 */
+
+// Ym2612_Emu
+
+Ym2612_Emu::~Ym2612_Emu()
+{
+	if ( impl )
+		YM2612Shutdown( impl );
+}
+
+const char* Ym2612_Emu::set_rate( double sample_rate, double clock_rate )
+{
+	if ( impl )
+	{
+		YM2612Shutdown( impl );
+		impl = 0;
+	}
+
+	if ( !clock_rate )
+		clock_rate = sample_rate * 144.;
+
+	impl = YM2612Init( 0, 0, (long) (clock_rate + 0.5), (long) (sample_rate + 0.5) );
+	if ( !impl )
+		return blargg_err_memory;
+	
+	return 0;
+}
+
+void Ym2612_Emu::reset()
+{
+	YM2612ResetChip( impl );
+}
+
+void Ym2612_Emu::write0( int addr, int data )
+{
+	YM2612Write( impl, 0, addr );
+	YM2612Write( impl, 1, data );
+}
+
+void Ym2612_Emu::write1( int addr, int data )
+{
+	YM2612Write( impl, 2, addr );
+	YM2612Write( impl, 3, data );
+}
+
+void Ym2612_Emu::mute_voices( int mask )
+{
+	YM2612Mute( impl, mask );
+}
+
+void Ym2612_Emu::run( int pair_count, sample_t* out )
+{
+	YM2612UpdateOne( impl, out, pair_count );
+}
+
diff -Nur orig/source/gme/src/Ym2612_Emu.h mod/source/gme/src/Ym2612_Emu.h
--- orig/source/gme/src/Ym2612_Emu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Ym2612_Emu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,38 @@
+// YM2612 FM sound chip emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef YM2612_EMU_H
+#define YM2612_EMU_H
+
+struct Ym2612_Impl;
+
+class Ym2612_Emu  {
+	Ym2612_Impl* impl;
+public:
+	Ym2612_Emu() { impl = 0; }
+	~Ym2612_Emu();
+	
+	// Sets sample rate and chip clock rate, in Hz. Returns non-zero
+	// if error. If clock_rate=0, uses sample_rate*144
+	const char* set_rate( double sample_rate, double clock_rate = 0 );
+	
+	// Resets to power-up state
+	void reset();
+	
+	// Mutes voice n if bit n (1 << n) of mask is set
+	enum { channel_count = 6 };
+	void mute_voices( int mask );
+	
+	// Writes addr to register 0 then data to register 1
+	void write0( int addr, int data );
+	
+	// Writes addr to register 2 then data to register 3
+	void write1( int addr, int data );
+	
+	// Runs and adds pair_count*2 samples into current output buffer contents
+	typedef short sample_t;
+	enum { out_chan_count = 2 }; // stereo
+	void run( int pair_count, sample_t* out );
+};
+
+#endif
diff -Nur orig/source/gme/src/ymdeltat.cpp mod/source/gme/src/ymdeltat.cpp
--- orig/source/gme/src/ymdeltat.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/ymdeltat.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,655 @@
+/*
+**
+** File: ymdeltat.c
+**
+** YAMAHA DELTA-T adpcm sound emulation subroutine
+** used by fmopl.c (Y8950) and fm.c (YM2608 and YM2610/B)
+**
+** Base program is YM2610 emulator by Hiromitsu Shioya.
+** Written by Tatsuyuki Satoh
+** Improvements by Jarek Burczynski (bujar at mame dot net)
+**
+**
+** History:
+**
+** 03-08-2003 Jarek Burczynski:
+**  - fixed BRDY flag implementation.
+**
+** 24-07-2003 Jarek Burczynski, Frits Hilderink:
+**  - fixed delault value for control2 in YM_DELTAT_ADPCM_Reset
+**
+** 22-07-2003 Jarek Burczynski, Frits Hilderink:
+**  - fixed external memory support
+**
+** 15-06-2003 Jarek Burczynski:
+**  - implemented CPU -> AUDIO ADPCM synthesis (via writes to the ADPCM data reg $08)
+**  - implemented support for the Limit address register
+**  - supported two bits from the control register 2 ($01): RAM TYPE (x1 bit/x8 bit), ROM/RAM
+**  - implemented external memory access (read/write) via the ADPCM data reg reads/writes
+**    Thanks go to Frits Hilderink for the example code.
+**
+** 14-06-2003 Jarek Burczynski:
+**  - various fixes to enable proper support for status register flags: BSRDY, PCM BSY, ZERO
+**  - modified EOS handling
+**
+** 05-04-2003 Jarek Burczynski:
+**  - implemented partial support for external/processor memory on sample replay
+**
+** 01-12-2002 Jarek Burczynski:
+**  - fixed first missing sound in gigandes thanks to previous fix (interpolator) by ElSemi
+**  - renamed/removed some YM_DELTAT struct fields
+**
+** 28-12-2001 Acho A. Tang
+**  - added EOS status report on ADPCM playback.
+**
+** 05-08-2001 Jarek Burczynski:
+**  - now_step is initialized with 0 at the start of play.
+**
+** 12-06-2001 Jarek Burczynski:
+**  - corrected end of sample bug in YM_DELTAT_ADPCM_CALC.
+**    Checked on real YM2610 chip - address register is 24 bits wide.
+**    Thanks go to Stefan Jokisch (stefan.jokisch@gmx.de) for tracking down the problem.
+**
+** TO DO:
+**      Check size of the address register on the other chips....
+**
+** Version 0.72
+**
+** sound chips that have this unit:
+** YM2608   OPNA
+** YM2610/B OPNB
+** Y8950    MSX AUDIO
+**
+*/
+
+#include "ymdeltat.h"
+#define INLINE __inline
+#define logerror (void)
+
+#define YM_DELTAT_DELTA_MAX (24576)
+#define YM_DELTAT_DELTA_MIN (127)
+#define YM_DELTAT_DELTA_DEF (127)
+
+#define YM_DELTAT_DECODE_RANGE 32768
+#define YM_DELTAT_DECODE_MIN (-(YM_DELTAT_DECODE_RANGE))
+#define YM_DELTAT_DECODE_MAX ((YM_DELTAT_DECODE_RANGE)-1)
+
+
+/* Forecast to next Forecast (rate = *8) */
+/* 1/8 , 3/8 , 5/8 , 7/8 , 9/8 , 11/8 , 13/8 , 15/8 */
+static const INT32 ym_deltat_decode_tableB1[16] = {
+  1,   3,   5,   7,   9,  11,  13,  15,
+  -1,  -3,  -5,  -7,  -9, -11, -13, -15,
+};
+/* delta to next delta (rate= *64) */
+/* 0.9 , 0.9 , 0.9 , 0.9 , 1.2 , 1.6 , 2.0 , 2.4 */
+static const INT32 ym_deltat_decode_tableB2[16] = {
+  57,  57,  57,  57, 77, 102, 128, 153,
+  57,  57,  57,  57, 77, 102, 128, 153
+};
+
+#if 0
+void YM_DELTAT_BRDY_callback(YM_DELTAT *DELTAT)
+{
+	logerror("BRDY_callback reached (flag set) !\n");
+
+	/* set BRDY bit in status register */
+	if(DELTAT->status_set_handler)
+		if(DELTAT->status_change_BRDY_bit)
+			(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+}
+#endif
+
+UINT8 YM_DELTAT_ADPCM_Read(YM_DELTAT *DELTAT)
+{
+	UINT8 v = 0;
+
+	/* external memory read */
+	if ( (DELTAT->portstate & 0xe0)==0x20 )
+	{
+		/* two dummy reads */
+		if (DELTAT->memread)
+		{
+			DELTAT->now_addr = DELTAT->start << 1;
+			DELTAT->memread--;
+			return 0;
+		}
+
+
+		if ( DELTAT->now_addr != (DELTAT->end<<1) )
+		{
+			v = DELTAT->memory[DELTAT->now_addr>>1];
+
+			/*logerror("YM Delta-T memory read  $%08x, v=$%02x\n", DELTAT->now_addr >> 1, v);*/
+
+			DELTAT->now_addr+=2; /* two nibbles at a time */
+
+			/* reset BRDY bit in status register, which means we are reading the memory now */
+			if(DELTAT->status_reset_handler)
+				if(DELTAT->status_change_BRDY_bit)
+					(DELTAT->status_reset_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+
+	/* setup a timer that will callback us in 10 master clock cycles for Y8950
+    * in the callback set the BRDY flag to 1 , which means we have another data ready.
+    * For now, we don't really do this; we simply reset and set the flag in zero time, so that the IRQ will work.
+    */
+			/* set BRDY bit in status register */
+			if(DELTAT->status_set_handler)
+				if(DELTAT->status_change_BRDY_bit)
+					(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+		}
+		else
+		{
+			/* set EOS bit in status register */
+			if(DELTAT->status_set_handler)
+				if(DELTAT->status_change_EOS_bit)
+					(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_EOS_bit);
+		}
+	}
+
+	return v;
+}
+
+
+/* 0-DRAM x1, 1-ROM, 2-DRAM x8, 3-ROM (3 is bad setting - not allowed by the manual) */
+static const UINT8 dram_rightshift[4]={3,0,0,0};
+
+/* DELTA-T ADPCM write register */
+void YM_DELTAT_ADPCM_Write(YM_DELTAT *DELTAT,int r,int v)
+{
+	if(r>=0x10) return;
+	DELTAT->reg[r] = v; /* stock data */
+
+	switch( r )
+	{
+	case 0x00:
+/*
+START:
+    Accessing *external* memory is started when START bit (D7) is set to "1", so
+    you must set all conditions needed for recording/playback before starting.
+    If you access *CPU-managed* memory, recording/playback starts after
+    read/write of ADPCM data register $08.
+
+REC:
+    0 = ADPCM synthesis (playback)
+    1 = ADPCM analysis (record)
+
+MEMDATA:
+    0 = processor (*CPU-managed*) memory (means: using register $08)
+    1 = external memory (using start/end/limit registers to access memory: RAM or ROM)
+
+
+SPOFF:
+    controls output pin that should disable the speaker while ADPCM analysis
+
+RESET and REPEAT only work with external memory.
+
+
+some examples:
+value:   START, REC, MEMDAT, REPEAT, SPOFF, x,x,RESET   meaning:
+  C8     1      1    0       0       1      0 0 0       Analysis (recording) from AUDIO to CPU (to reg $08), sample rate in PRESCALER register
+  E8     1      1    1       0       1      0 0 0       Analysis (recording) from AUDIO to EXT.MEMORY,       sample rate in PRESCALER register
+  80     1      0    0       0       0      0 0 0       Synthesis (playing) from CPU (from reg $08) to AUDIO,sample rate in DELTA-N register
+  a0     1      0    1       0       0      0 0 0       Synthesis (playing) from EXT.MEMORY to AUDIO,        sample rate in DELTA-N register
+
+  60     0      1    1       0       0      0 0 0       External memory write via ADPCM data register $08
+  20     0      0    1       0       0      0 0 0       External memory read via ADPCM data register $08
+
+*/
+		/* handle emulation mode */
+		if(DELTAT->emulation_mode == YM_DELTAT_EMULATION_MODE_YM2610)
+		{
+			v |= 0x20;		/*  YM2610 always uses external memory and doesn't even have memory flag bit. */
+		}
+
+		DELTAT->portstate = v & (0x80|0x40|0x20|0x10|0x01); /* start, rec, memory mode, repeat flag copy, reset(bit0) */
+
+		if( DELTAT->portstate&0x80 )/* START,REC,MEMDATA,REPEAT,SPOFF,--,--,RESET */
+		{
+			/* set PCM BUSY bit */
+			DELTAT->PCM_BSY = 1;
+
+			/* start ADPCM */
+			DELTAT->now_step = 0;
+			DELTAT->acc      = 0;
+			DELTAT->prev_acc = 0;
+			DELTAT->adpcml   = 0;
+			DELTAT->adpcmd   = YM_DELTAT_DELTA_DEF;
+			DELTAT->now_data = 0;
+
+		}
+
+		if( DELTAT->portstate&0x20 ) /* do we access external memory? */
+		{
+			DELTAT->now_addr = DELTAT->start << 1;
+			DELTAT->memread = 2;	/* two dummy reads needed before accesing external memory via register $08*/
+
+			/* if yes, then let's check if ADPCM memory is mapped and big enough */
+			if(DELTAT->memory == 0)
+			{
+				logerror("YM Delta-T ADPCM rom not mapped\n");
+				DELTAT->portstate = 0x00;
+				DELTAT->PCM_BSY = 0;
+			}
+			else
+			{
+				if( DELTAT->end >= DELTAT->memory_size )	/* Check End in Range */
+				{
+					logerror("YM Delta-T ADPCM end out of range: $%08x\n", DELTAT->end);
+					DELTAT->end = DELTAT->memory_size - 1;
+				}
+				if( DELTAT->start >= DELTAT->memory_size )	/* Check Start in Range */
+				{
+					logerror("YM Delta-T ADPCM start out of range: $%08x\n", DELTAT->start);
+					DELTAT->portstate = 0x00;
+					DELTAT->PCM_BSY = 0;
+				}
+			}
+		}
+		else	/* we access CPU memory (ADPCM data register $08) so we only reset now_addr here */
+		{
+			DELTAT->now_addr = 0;
+		}
+
+		if( DELTAT->portstate&0x01 )
+		{
+			DELTAT->portstate = 0x00;
+
+			/* clear PCM BUSY bit (in status register) */
+			DELTAT->PCM_BSY = 0;
+
+			/* set BRDY flag */
+			if(DELTAT->status_set_handler)
+				if(DELTAT->status_change_BRDY_bit)
+					(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+		}
+		break;
+	case 0x01:	/* L,R,-,-,SAMPLE,DA/AD,RAMTYPE,ROM */
+		/* handle emulation mode */
+		if(DELTAT->emulation_mode == YM_DELTAT_EMULATION_MODE_YM2610)
+		{
+			v |= 0x01;		/*  YM2610 always uses ROM as an external memory and doesn't tave ROM/RAM memory flag bit. */
+		}
+
+		DELTAT->pan = &DELTAT->output_pointer[(v>>6)&0x03];
+		if ((DELTAT->control2 & 3) != (v & 3))
+		{
+			/*0-DRAM x1, 1-ROM, 2-DRAM x8, 3-ROM (3 is bad setting - not allowed by the manual) */
+			if (DELTAT->DRAMportshift != dram_rightshift[v&3])
+			{
+				DELTAT->DRAMportshift = dram_rightshift[v&3];
+
+				/* final shift value depends on chip type and memory type selected:
+                        8 for YM2610 (ROM only),
+                        5 for ROM for Y8950 and YM2608,
+                        5 for x8bit DRAMs for Y8950 and YM2608,
+                        2 for x1bit DRAMs for Y8950 and YM2608.
+                */
+
+				/* refresh addresses */
+				DELTAT->start  = (DELTAT->reg[0x3]*0x0100 | DELTAT->reg[0x2]) << (DELTAT->portshift - DELTAT->DRAMportshift);
+				DELTAT->end    = (DELTAT->reg[0x5]*0x0100 | DELTAT->reg[0x4]) << (DELTAT->portshift - DELTAT->DRAMportshift);
+				DELTAT->end   += (1 << (DELTAT->portshift-DELTAT->DRAMportshift) ) - 1;
+				DELTAT->limit  = (DELTAT->reg[0xd]*0x0100 | DELTAT->reg[0xc]) << (DELTAT->portshift - DELTAT->DRAMportshift);
+			}
+		}
+		DELTAT->control2 = v;
+		break;
+	case 0x02:	/* Start Address L */
+	case 0x03:	/* Start Address H */
+		DELTAT->start  = (DELTAT->reg[0x3]*0x0100 | DELTAT->reg[0x2]) << (DELTAT->portshift - DELTAT->DRAMportshift);
+		/*logerror("DELTAT start: 02=%2x 03=%2x addr=%8x\n",DELTAT->reg[0x2], DELTAT->reg[0x3],DELTAT->start );*/
+		break;
+	case 0x04:	/* Stop Address L */
+	case 0x05:	/* Stop Address H */
+		DELTAT->end    = (DELTAT->reg[0x5]*0x0100 | DELTAT->reg[0x4]) << (DELTAT->portshift - DELTAT->DRAMportshift);
+		DELTAT->end   += (1 << (DELTAT->portshift-DELTAT->DRAMportshift) ) - 1;
+		/*logerror("DELTAT end  : 04=%2x 05=%2x addr=%8x\n",DELTAT->reg[0x4], DELTAT->reg[0x5],DELTAT->end   );*/
+		break;
+	case 0x06:	/* Prescale L (ADPCM and Record frq) */
+	case 0x07:	/* Prescale H */
+		break;
+	case 0x08:	/* ADPCM data */
+
+/*
+some examples:
+value:   START, REC, MEMDAT, REPEAT, SPOFF, x,x,RESET   meaning:
+  C8     1      1    0       0       1      0 0 0       Analysis (recording) from AUDIO to CPU (to reg $08), sample rate in PRESCALER register
+  E8     1      1    1       0       1      0 0 0       Analysis (recording) from AUDIO to EXT.MEMORY,       sample rate in PRESCALER register
+  80     1      0    0       0       0      0 0 0       Synthesis (playing) from CPU (from reg $08) to AUDIO,sample rate in DELTA-N register
+  a0     1      0    1       0       0      0 0 0       Synthesis (playing) from EXT.MEMORY to AUDIO,        sample rate in DELTA-N register
+
+  60     0      1    1       0       0      0 0 0       External memory write via ADPCM data register $08
+  20     0      0    1       0       0      0 0 0       External memory read via ADPCM data register $08
+
+*/
+
+		/* external memory write */
+		if ( (DELTAT->portstate & 0xe0)==0x60 )
+		{
+			if (DELTAT->memread)
+			{
+				DELTAT->now_addr = DELTAT->start << 1;
+				DELTAT->memread = 0;
+			}
+
+			/*logerror("YM Delta-T memory write $%08x, v=$%02x\n", DELTAT->now_addr >> 1, v);*/
+
+			if ( DELTAT->now_addr != (DELTAT->end<<1) )
+			{
+				DELTAT->memory[DELTAT->now_addr>>1] = v;
+			 	DELTAT->now_addr+=2; /* two nibbles at a time */
+
+				/* reset BRDY bit in status register, which means we are processing the write */
+				if(DELTAT->status_reset_handler)
+					if(DELTAT->status_change_BRDY_bit)
+						(DELTAT->status_reset_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+
+	/* setup a timer that will callback us in 10 master clock cycles for Y8950
+    * in the callback set the BRDY flag to 1 , which means we have written the data.
+    * For now, we don't really do this; we simply reset and set the flag in zero time, so that the IRQ will work.
+    */
+				/* set BRDY bit in status register */
+				if(DELTAT->status_set_handler)
+					if(DELTAT->status_change_BRDY_bit)
+						(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+
+			}
+			else
+			{
+				/* set EOS bit in status register */
+				if(DELTAT->status_set_handler)
+					if(DELTAT->status_change_EOS_bit)
+						(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_EOS_bit);
+			}
+
+			return;
+		}
+
+		/* ADPCM synthesis from CPU */
+		if ( (DELTAT->portstate & 0xe0)==0x80 )
+		{
+			DELTAT->CPU_data = v;
+
+			/* Reset BRDY bit in status register, which means we are full of data */
+			if(DELTAT->status_reset_handler)
+				if(DELTAT->status_change_BRDY_bit)
+					(DELTAT->status_reset_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+			return;
+		}
+
+	  break;
+	case 0x09:	/* DELTA-N L (ADPCM Playback Prescaler) */
+	case 0x0a:	/* DELTA-N H */
+		DELTAT->delta  = (DELTAT->reg[0xa]*0x0100 | DELTAT->reg[0x9]);
+		DELTAT->step     = (UINT32)( (double)(DELTAT->delta /* *(1<<(YM_DELTAT_SHIFT-16)) */ ) * (DELTAT->freqbase) );
+		/*logerror("DELTAT deltan:09=%2x 0a=%2x\n",DELTAT->reg[0x9], DELTAT->reg[0xa]);*/
+		break;
+	case 0x0b:	/* Output level control (volume, linear) */
+		{
+			INT32 oldvol = DELTAT->volume;
+			DELTAT->volume = (v&0xff) * (DELTAT->output_range/256) / YM_DELTAT_DECODE_RANGE;
+/*                              v     *     ((1<<16)>>8)        >>  15;
+*                       thus:   v     *     (1<<8)              >>  15;
+*                       thus: output_range must be (1 << (15+8)) at least
+*                               v     *     ((1<<23)>>8)        >>  15;
+*                               v     *     (1<<15)             >>  15;
+*/
+			/*logerror("DELTAT vol = %2x\n",v&0xff);*/
+			if( oldvol != 0 )
+			{
+				DELTAT->adpcml = (int)((double)DELTAT->adpcml / (double)oldvol * (double)DELTAT->volume);
+			}
+		}
+		break;
+	case 0x0c:	/* Limit Address L */
+	case 0x0d:	/* Limit Address H */
+		DELTAT->limit  = (DELTAT->reg[0xd]*0x0100 | DELTAT->reg[0xc]) << (DELTAT->portshift - DELTAT->DRAMportshift);
+		/*logerror("DELTAT limit: 0c=%2x 0d=%2x addr=%8x\n",DELTAT->reg[0xc], DELTAT->reg[0xd],DELTAT->limit );*/
+		break;
+	}
+}
+
+void YM_DELTAT_ADPCM_Reset(YM_DELTAT *DELTAT,int pan,int emulation_mode)
+{
+	DELTAT->now_addr  = 0;
+	DELTAT->now_step  = 0;
+	DELTAT->step      = 0;
+	DELTAT->start     = 0;
+	DELTAT->end       = 0;
+	DELTAT->limit     = ~0; /* this way YM2610 and Y8950 (both of which don't have limit address reg) will still work */
+	DELTAT->volume    = 0;
+	DELTAT->pan       = &DELTAT->output_pointer[pan];
+	DELTAT->acc       = 0;
+	DELTAT->prev_acc  = 0;
+	DELTAT->adpcmd    = 127;
+	DELTAT->adpcml    = 0;
+	DELTAT->emulation_mode = (UINT8)emulation_mode;
+	DELTAT->portstate = (emulation_mode == YM_DELTAT_EMULATION_MODE_YM2610) ? 0x20 : 0;
+	DELTAT->control2  = (emulation_mode == YM_DELTAT_EMULATION_MODE_YM2610) ? 0x01 : 0;	/* default setting depends on the emulation mode. MSX demo called "facdemo_4" doesn't setup control2 register at all and still works */
+	DELTAT->DRAMportshift = dram_rightshift[DELTAT->control2 & 3];
+
+	/* The flag mask register disables the BRDY after the reset, however
+    ** as soon as the mask is enabled the flag needs to be set. */
+
+	/* set BRDY bit in status register */
+	if(DELTAT->status_set_handler)
+		if(DELTAT->status_change_BRDY_bit)
+			(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+}
+
+#if 0
+void YM_DELTAT_postload(YM_DELTAT *DELTAT,UINT8 *regs)
+{
+	int r;
+
+	/* to keep adpcml */
+	DELTAT->volume = 0;
+	/* update */
+	for(r=1;r<16;r++)
+		YM_DELTAT_ADPCM_Write(DELTAT,r,regs[r]);
+	DELTAT->reg[0] = regs[0];
+
+	/* current rom data */
+	if (DELTAT->memory)
+		DELTAT->now_data = *(DELTAT->memory + (DELTAT->now_addr>>1) );
+
+}
+void YM_DELTAT_savestate(const device_config *device,YM_DELTAT *DELTAT)
+{
+#ifdef __STATE_H__
+	state_save_register_device_item(device, 0, DELTAT->portstate);
+	state_save_register_device_item(device, 0, DELTAT->now_addr);
+	state_save_register_device_item(device, 0, DELTAT->now_step);
+	state_save_register_device_item(device, 0, DELTAT->acc);
+	state_save_register_device_item(device, 0, DELTAT->prev_acc);
+	state_save_register_device_item(device, 0, DELTAT->adpcmd);
+	state_save_register_device_item(device, 0, DELTAT->adpcml);
+#endif
+}
+#endif
+
+
+#define YM_DELTAT_Limit(val,max,min)	\
+{										\
+	if ( val > max ) val = max;			\
+	else if ( val < min ) val = min;	\
+}
+
+INLINE void YM_DELTAT_synthesis_from_external_memory(YM_DELTAT *DELTAT)
+{
+	UINT32 step;
+	int data;
+
+	DELTAT->now_step += DELTAT->step;
+	if ( DELTAT->now_step >= (1<<YM_DELTAT_SHIFT) )
+	{
+		step = DELTAT->now_step >> YM_DELTAT_SHIFT;
+		DELTAT->now_step &= (1<<YM_DELTAT_SHIFT)-1;
+		do{
+
+			if ( DELTAT->now_addr == (DELTAT->limit<<1) )
+				DELTAT->now_addr = 0;
+
+			if ( DELTAT->now_addr == (DELTAT->end<<1) ) {	/* 12-06-2001 JB: corrected comparison. Was > instead of == */
+				if( DELTAT->portstate&0x10 ){
+					/* repeat start */
+					DELTAT->now_addr = DELTAT->start<<1;
+					DELTAT->acc      = 0;
+					DELTAT->adpcmd   = YM_DELTAT_DELTA_DEF;
+					DELTAT->prev_acc = 0;
+				}else{
+					/* set EOS bit in status register */
+					if(DELTAT->status_set_handler)
+						if(DELTAT->status_change_EOS_bit)
+							(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_EOS_bit);
+
+					/* clear PCM BUSY bit (reflected in status register) */
+					DELTAT->PCM_BSY = 0;
+
+					DELTAT->portstate = 0;
+					DELTAT->adpcml = 0;
+					DELTAT->prev_acc = 0;
+					return;
+				}
+			}
+
+			if( DELTAT->now_addr&1 ) data = DELTAT->now_data & 0x0f;
+			else
+			{
+				DELTAT->now_data = *(DELTAT->memory + (DELTAT->now_addr>>1));
+				data = DELTAT->now_data >> 4;
+			}
+
+			DELTAT->now_addr++;
+			/* 12-06-2001 JB: */
+			/* YM2610 address register is 24 bits wide.*/
+			/* The "+1" is there because we use 1 bit more for nibble calculations.*/
+			/* WARNING: */
+			/* Side effect: we should take the size of the mapped ROM into account */
+			DELTAT->now_addr &= ( (1<<(24+1))-1);
+
+			/* store accumulator value */
+			DELTAT->prev_acc = DELTAT->acc;
+
+			/* Forecast to next Forecast */
+			DELTAT->acc += (ym_deltat_decode_tableB1[data] * DELTAT->adpcmd / 8);
+			YM_DELTAT_Limit(DELTAT->acc,YM_DELTAT_DECODE_MAX, YM_DELTAT_DECODE_MIN);
+
+			/* delta to next delta */
+			DELTAT->adpcmd = (DELTAT->adpcmd * ym_deltat_decode_tableB2[data] ) / 64;
+			YM_DELTAT_Limit(DELTAT->adpcmd,YM_DELTAT_DELTA_MAX, YM_DELTAT_DELTA_MIN );
+
+			/* ElSemi: Fix interpolator. */
+			/*DELTAT->prev_acc = prev_acc + ((DELTAT->acc - prev_acc) / 2 );*/
+
+		}while(--step);
+
+	}
+
+	/* ElSemi: Fix interpolator. */
+	DELTAT->adpcml = DELTAT->prev_acc * (int)((1<<YM_DELTAT_SHIFT)-DELTAT->now_step);
+	DELTAT->adpcml += (DELTAT->acc * (int)DELTAT->now_step);
+	DELTAT->adpcml = (DELTAT->adpcml>>YM_DELTAT_SHIFT) * (int)DELTAT->volume;
+
+	/* output for work of output channels (outd[OPNxxxx])*/
+	*(DELTAT->pan) += DELTAT->adpcml;
+}
+
+
+
+INLINE void YM_DELTAT_synthesis_from_CPU_memory(YM_DELTAT *DELTAT)
+{
+	UINT32 step;
+	int data;
+
+	DELTAT->now_step += DELTAT->step;
+	if ( DELTAT->now_step >= (1<<YM_DELTAT_SHIFT) )
+	{
+		step = DELTAT->now_step >> YM_DELTAT_SHIFT;
+		DELTAT->now_step &= (1<<YM_DELTAT_SHIFT)-1;
+		do{
+
+			if( DELTAT->now_addr&1 )
+			{
+				data = DELTAT->now_data & 0x0f;
+
+				DELTAT->now_data = DELTAT->CPU_data;
+
+				/* after we used CPU_data, we set BRDY bit in status register,
+                * which means we are ready to accept another byte of data */
+				if(DELTAT->status_set_handler)
+					if(DELTAT->status_change_BRDY_bit)
+						(DELTAT->status_set_handler)(DELTAT->status_change_which_chip, DELTAT->status_change_BRDY_bit);
+			}
+			else
+			{
+				data = DELTAT->now_data >> 4;
+			}
+
+			DELTAT->now_addr++;
+
+			/* store accumulator value */
+			DELTAT->prev_acc = DELTAT->acc;
+
+			/* Forecast to next Forecast */
+			DELTAT->acc += (ym_deltat_decode_tableB1[data] * DELTAT->adpcmd / 8);
+			YM_DELTAT_Limit(DELTAT->acc,YM_DELTAT_DECODE_MAX, YM_DELTAT_DECODE_MIN);
+
+			/* delta to next delta */
+			DELTAT->adpcmd = (DELTAT->adpcmd * ym_deltat_decode_tableB2[data] ) / 64;
+			YM_DELTAT_Limit(DELTAT->adpcmd,YM_DELTAT_DELTA_MAX, YM_DELTAT_DELTA_MIN );
+
+
+		}while(--step);
+
+	}
+
+	/* ElSemi: Fix interpolator. */
+	DELTAT->adpcml = DELTAT->prev_acc * (int)((1<<YM_DELTAT_SHIFT)-DELTAT->now_step);
+	DELTAT->adpcml += (DELTAT->acc * (int)DELTAT->now_step);
+	DELTAT->adpcml = (DELTAT->adpcml>>YM_DELTAT_SHIFT) * (int)DELTAT->volume;
+
+	/* output for work of output channels (outd[OPNxxxx])*/
+	*(DELTAT->pan) += DELTAT->adpcml;
+}
+
+
+
+/* ADPCM B (Delta-T control type) */
+void YM_DELTAT_ADPCM_CALC(YM_DELTAT *DELTAT)
+{
+
+/*
+some examples:
+value:   START, REC, MEMDAT, REPEAT, SPOFF, x,x,RESET   meaning:
+  80     1      0    0       0       0      0 0 0       Synthesis (playing) from CPU (from reg $08) to AUDIO,sample rate in DELTA-N register
+  a0     1      0    1       0       0      0 0 0       Synthesis (playing) from EXT.MEMORY to AUDIO,        sample rate in DELTA-N register
+  C8     1      1    0       0       1      0 0 0       Analysis (recording) from AUDIO to CPU (to reg $08), sample rate in PRESCALER register
+  E8     1      1    1       0       1      0 0 0       Analysis (recording) from AUDIO to EXT.MEMORY,       sample rate in PRESCALER register
+
+  60     0      1    1       0       0      0 0 0       External memory write via ADPCM data register $08
+  20     0      0    1       0       0      0 0 0       External memory read via ADPCM data register $08
+
+*/
+
+	if ( (DELTAT->portstate & 0xe0)==0xa0 )
+	{
+		YM_DELTAT_synthesis_from_external_memory(DELTAT);
+		return;
+	}
+
+	if ( (DELTAT->portstate & 0xe0)==0x80 )
+	{
+		/* ADPCM synthesis from CPU-managed memory (from reg $08) */
+		YM_DELTAT_synthesis_from_CPU_memory(DELTAT);	/* change output based on data in ADPCM data reg ($08) */
+		return;
+	}
+
+//todo: ADPCM analysis
+//  if ( (DELTAT->portstate & 0xe0)==0xc0 )
+//  if ( (DELTAT->portstate & 0xe0)==0xe0 )
+
+	return;
+}
+
diff -Nur orig/source/gme/src/ymdeltat.h mod/source/gme/src/ymdeltat.h
--- orig/source/gme/src/ymdeltat.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/ymdeltat.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,98 @@
+#pragma once
+
+#ifndef __YMDELTAT_H__
+#define __YMDELTAT_H__
+
+/* compiler dependence */
+#ifndef __OSDCOMM_H__
+#define __OSDCOMM_H__
+typedef unsigned char	UINT8;   /* unsigned  8bit */
+typedef unsigned short	UINT16;  /* unsigned 16bit */
+typedef unsigned int	UINT32;  /* unsigned 32bit */
+typedef signed char		INT8;    /* signed  8bit   */
+typedef signed short	INT16;   /* signed 16bit   */
+typedef signed int		INT32;   /* signed 32bit   */
+
+typedef INT32 stream_sample_t;
+
+#endif /* __OSDCOMM_H__ */
+
+#define YM_DELTAT_SHIFT    (16)
+
+#define YM_DELTAT_EMULATION_MODE_NORMAL	0
+#define YM_DELTAT_EMULATION_MODE_YM2610	1
+
+
+typedef void (*STATUS_CHANGE_HANDLER)(void *chip, UINT8 status_bits);
+
+
+/* DELTA-T (adpcm type B) struct */
+typedef struct deltat_adpcm_state {     /* AT: rearranged and tigntened structure */
+	UINT8	*memory;
+	INT32	*output_pointer;/* pointer of output pointers   */
+	INT32	*pan;			/* pan : &output_pointer[pan]   */
+	double	freqbase;
+#if 0
+	double	write_time;		/* Y8950: 10 cycles of main clock; YM2608: 20 cycles of main clock */
+	double	read_time;		/* Y8950: 8 cycles of main clock;  YM2608: 18 cycles of main clock */
+#endif
+	UINT32	memory_size;
+	int		output_range;
+	UINT32	now_addr;		/* current address      */
+	UINT32	now_step;		/* currect step         */
+	UINT32	step;			/* step                 */
+	UINT32	start;			/* start address        */
+	UINT32	limit;			/* limit address        */
+	UINT32	end;			/* end address          */
+	UINT32	delta;			/* delta scale          */
+	INT32	volume;			/* current volume       */
+	INT32	acc;			/* shift Measurement value*/
+	INT32	adpcmd;			/* next Forecast        */
+	INT32	adpcml;			/* current value        */
+	INT32	prev_acc;		/* leveling value       */
+	UINT8	now_data;		/* current rom data     */
+	UINT8	CPU_data;		/* current data from reg 08 */
+	UINT8	portstate;		/* port status          */
+	UINT8	control2;		/* control reg: SAMPLE, DA/AD, RAM TYPE (x8bit / x1bit), ROM/RAM */
+	UINT8	portshift;		/* address bits shift-left:
+                            ** 8 for YM2610,
+                            ** 5 for Y8950 and YM2608 */
+
+	UINT8	DRAMportshift;	/* address bits shift-right:
+                            ** 0 for ROM and x8bit DRAMs,
+                            ** 3 for x1 DRAMs */
+
+	UINT8	memread;		/* needed for reading/writing external memory */
+
+	/* handlers and parameters for the status flags support */
+	STATUS_CHANGE_HANDLER	status_set_handler;
+	STATUS_CHANGE_HANDLER	status_reset_handler;
+
+	/* note that different chips have these flags on different
+    ** bits of the status register
+    */
+	void *	status_change_which_chip;	/* this chip id */
+	UINT8	status_change_EOS_bit;		/* 1 on End Of Sample (record/playback/cycle time of AD/DA converting has passed)*/
+	UINT8	status_change_BRDY_bit;		/* 1 after recording 2 datas (2x4bits) or after reading/writing 1 data */
+	UINT8	status_change_ZERO_bit;		/* 1 if silence lasts for more than 290 miliseconds on ADPCM recording */
+
+	/* neither Y8950 nor YM2608 can generate IRQ when PCMBSY bit changes, so instead of above,
+    ** the statusflag gets ORed with PCM_BSY (below) (on each read of statusflag of Y8950 and YM2608)
+    */
+	UINT8	PCM_BSY;		/* 1 when ADPCM is playing; Y8950/YM2608 only */
+
+	UINT8	reg[16];		/* adpcm registers      */
+	UINT8	emulation_mode;	/* which chip we're emulating */
+}YM_DELTAT;
+
+/*void YM_DELTAT_BRDY_callback(YM_DELTAT *DELTAT);*/
+
+UINT8 YM_DELTAT_ADPCM_Read(YM_DELTAT *DELTAT);
+void YM_DELTAT_ADPCM_Write(YM_DELTAT *DELTAT,int r,int v);
+void YM_DELTAT_ADPCM_Reset(YM_DELTAT *DELTAT,int pan,int emulation_mode);
+void YM_DELTAT_ADPCM_CALC(YM_DELTAT *DELTAT);
+
+/*void YM_DELTAT_postload(YM_DELTAT *DELTAT,UINT8 *regs);
+void YM_DELTAT_savestate(const device_config *device,YM_DELTAT *DELTAT);*/
+
+#endif /* __YMDELTAT_H__ */
diff -Nur orig/source/gme/src/Z80_Cpu.cpp mod/source/gme/src/Z80_Cpu.cpp
--- orig/source/gme/src/Z80_Cpu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Z80_Cpu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,82 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+#include "Z80_Cpu.h"
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+// flags, named with hex value for clarity
+int const S80 = 0x80;
+int const Z40 = 0x40;
+int const F20 = 0x20;
+int const H10 = 0x10;
+int const F08 = 0x08;
+int const V04 = 0x04;
+int const P04 = 0x04;
+int const N02 = 0x02;
+int const C01 = 0x01;
+
+Z80_Cpu::Z80_Cpu()
+{
+	cpu_state = &cpu_state_;
+	
+	for ( int i = 0x100; --i >= 0; )
+	{
+		int even = 1;
+		for ( int p = i; p; p >>= 1 )
+			even ^= p;
+		int n = (i & (S80 | F20 | F08)) | ((even & 1) * P04);
+		szpc [i] = n;
+		szpc [i + 0x100] = n | C01;
+	}
+	szpc [0x000] |= Z40;
+	szpc [0x100] |= Z40;
+}
+
+inline void Z80_Cpu::set_page( int i, void* write, void const* read )
+{
+	int offset = Z80_CPU_OFFSET( i * page_size );
+	byte      * write2 = STATIC_CAST(byte      *,write) - offset;
+	byte const* read2  = STATIC_CAST(byte const*,read ) - offset;
+	cpu_state_.write [i] = write2;
+	cpu_state_.read  [i] = read2;
+	cpu_state->write [i] = write2;
+	cpu_state->read  [i] = read2;
+}
+
+void Z80_Cpu::reset( void* unmapped_write, void const* unmapped_read )
+{
+	check( cpu_state == &cpu_state_ );
+	cpu_state = &cpu_state_;
+	cpu_state_.time = 0;
+	cpu_state_.base = 0;
+	end_time_   = 0;
+	
+	for ( int i = 0; i < page_count + 1; i++ )
+		set_page( i, unmapped_write, unmapped_read );
+	
+	memset( &r, 0, sizeof r );
+}
+
+void Z80_Cpu::map_mem( addr_t start, int size, void* write, void const* read )
+{
+	// address range must begin and end on page boundaries
+	require( start % page_size == 0 );
+	require( size  % page_size == 0 );
+	require( start + size <= 0x10000 );
+	
+	for ( int offset = 0; offset < size; offset += page_size )
+		set_page( (start + offset) >> page_bits,
+				STATIC_CAST(char      *,write) + offset,
+				STATIC_CAST(char const*,read ) + offset );
+}
diff -Nur orig/source/gme/src/Z80_Cpu.h mod/source/gme/src/Z80_Cpu.h
--- orig/source/gme/src/Z80_Cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Z80_Cpu.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,122 @@
+// Z80 CPU emulator
+
+// Game_Music_Emu 0.6-pre
+#ifndef Z80_CPU_H
+#define Z80_CPU_H
+
+#include "blargg_endian.h"
+
+class Z80_Cpu {
+public:
+	typedef int time_t;
+	typedef int addr_t;
+	typedef BOOST::uint8_t byte;
+	
+	// Clears registers and maps all pages to unmapped
+	void reset( void* unmapped_write, void const* unmapped_read );
+	
+	// TODO: split mapping out of CPU
+	
+	// Maps memory. Start and size must be multiple of page_size.
+	enum { page_bits = 10 };
+	enum { page_size = 1 << page_bits };
+	void map_mem( addr_t addr, int size, void* write, void const* read );
+	void map_mem( addr_t addr, int size, void* read_write );
+	
+	// Maps address to pointer to that byte
+	byte      * write( addr_t addr );
+	byte const* read(  addr_t addr );
+	
+	// Time of beginning of next instruction
+	time_t time() const             { return cpu_state->time + cpu_state->base; }
+	
+	// Alter current time
+	void set_time( time_t t )       { cpu_state->time = t - cpu_state->base; }
+	void adjust_time( int delta )   { cpu_state->time += delta; }
+	
+	#if BLARGG_BIG_ENDIAN
+		struct regs_t { byte b,c, d,e, h,l, flags,a; };
+	#else
+		struct regs_t { byte c,b, e,d, l,h, a,flags; };
+	#endif
+	BLARGG_STATIC_ASSERT( sizeof (regs_t) == 8 );
+	
+	struct pairs_t { BOOST::uint16_t bc, de, hl, fa; };
+	
+	// Registers are not updated until run() returns
+	struct registers_t {
+		BOOST::uint16_t pc;
+		BOOST::uint16_t sp;
+		BOOST::uint16_t ix;
+		BOOST::uint16_t iy;
+		union {
+			regs_t b; //  b.b, b.c, b.d, b.e, b.h, b.l, b.flags, b.a
+			pairs_t w; // w.bc, w.de, w.hl. w.fa
+		};
+		union {
+			regs_t b;
+			pairs_t w;
+		} alt;
+		byte iff1;
+		byte iff2;
+		byte r;
+		byte i;
+		byte im;
+	};
+	//registers_t r; (below for efficiency)
+	
+	// can read this far past end of memory
+	enum { cpu_padding = 0x100 };
+	
+	// Can read this many bytes past end of a page
+	enum { page_padding = 4 };
+	
+	void set_end_time( time_t t );
+public:
+	Z80_Cpu();
+	
+	enum { page_count = 0x10000 / page_size };
+	byte szpc [0x200];
+	time_t end_time_;
+	struct cpu_state_t {
+		byte const* read  [page_count + 1];
+		byte      * write [page_count + 1];
+		time_t base;
+		time_t time;
+	};
+	cpu_state_t* cpu_state; // points to cpu_state_ or a local copy within run()
+	cpu_state_t cpu_state_;
+	void set_page( int i, void* write, void const* read );
+public:
+	registers_t r;
+};
+
+#if BLARGG_NONPORTABLE
+	#define Z80_CPU_OFFSET( addr ) (addr)
+#else
+	#define Z80_CPU_OFFSET( addr ) ((addr) & (Z80_Cpu::page_size - 1))
+#endif
+
+inline Z80_Cpu::byte* Z80_Cpu::write( addr_t addr )
+{
+	return cpu_state->write [(unsigned) addr >> page_bits] + Z80_CPU_OFFSET( addr );
+}
+
+inline Z80_Cpu::byte const* Z80_Cpu::read( addr_t addr )
+{
+	return cpu_state->read [(unsigned) addr >> page_bits] + Z80_CPU_OFFSET( addr );
+}
+
+inline void Z80_Cpu::map_mem( addr_t addr, int size, void* p )
+{
+	map_mem( addr, size, p, p );
+}
+
+inline void Z80_Cpu::set_end_time( time_t t )
+{
+	time_t delta = cpu_state->base - t;
+	cpu_state->base = t;
+	cpu_state->time += delta;
+}
+
+#endif
diff -Nur orig/source/gme/src/Z80_Cpu_run.h mod/source/gme/src/Z80_Cpu_run.h
--- orig/source/gme/src/Z80_Cpu_run.h	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/gme/src/Z80_Cpu_run.h	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,1695 @@
+// Game_Music_Emu 0.6-pre. http://www.slack.net/~ant/
+
+// Last validated with zexall 2009.12.05.
+// Doesn't implement the R register or immediate interrupt after EI.
+// Address wrap-around isn't completely correct, but is prevented from crashing emulator.
+// 16-bit memory accesses are made directly to mapped memory, instead of using macro.
+
+#if 0
+/* Define these macros in the source file before #including this file.
+- Parameters might be expressions, so they are best evaluated only once,
+though they NEVER have side-effects, so multiple evaluation is OK.
+- Output parameters might be a multiple-assignment expression like "a=x",
+so they must NOT be parenthesized.
+- Except where noted, time() and related functions will NOT work
+correctly inside a macro. TIME() is always correct, and between FLUSH_TIME() and
+CACHE_TIME() the normal time changing functions can be used.
+- Macros "returning" void may use a {} statement block. */
+
+	// 0 <= addr <= 0xFFFF + 0x100
+	// Optional; default uses whatever was set with map_mem()
+	int  READ_MEM(  addr_t );
+	void WRITE_MEM( addr_t, int data );
+	
+	// 0 <= port <= 0xFFFF (apparently upper 8 bits are output by hardware)
+	void OUT_PORT( int port, int data );
+	int  IN_PORT   int port );
+	
+	// Reference to Z80_Cpu object used for emulation
+	#define CPU cpu
+	
+// The following can be used within macros:
+	
+	// Current time
+	time_t TIME();
+	
+	// Allows use of time functions
+	void FLUSH_TIME();
+	
+	// Must be used before end of macro if FLUSH_TIME() was used earlier
+	void CACHE_TIME();
+
+// Configuration (optional; commented behavior if defined)
+	
+	// Optimizes as if map_mem( 0, 0x10000, FLAT_MEM, FLAT_MEM ) is always in effect
+	#define FLAT_MEM my_mem_array
+	
+	// If RST 7 ($FF) is encountered and PC = IDLE_ADDR, stops execution
+	#define IDLE_ADDR 0x1234
+	
+	// Expanded just before beginning of code, to help debugger
+	#define CPU_BEGIN void my_run_cpu() {
+	
+#endif
+
+/* Copyright (C) 2006-2008 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#ifdef CPU_BEGIN
+	CPU_BEGIN
+#endif
+
+#define R CPU.r
+
+// flags, named with hex value for clarity
+int const S80 = 0x80;
+int const Z40 = 0x40;
+int const F20 = 0x20;
+int const H10 = 0x10;
+int const F08 = 0x08;
+int const V04 = 0x04;
+int const P04 = 0x04;
+int const N02 = 0x02;
+int const C01 = 0x01;
+
+#define SZ28P( n )  CPU.szpc [n]
+#define SZ28PC( n ) CPU.szpc [n]
+#define SZ28C( n )  (CPU.szpc [n] & ~P04)
+#define SZ28( n )   SZ28C( n )
+
+#define SET_R( n )  (void) (R.r = n)
+#define GET_R()     (R.r)
+
+// Time
+#define TIME()          (s_time + s.base)
+#define FLUSH_TIME()    {s.time = s_time;}
+#define CACHE_TIME()    {s_time = s.time;}
+
+// Memory
+#define RW_MEM( addr, rw )          RW_PAGE( addr, rw ) [RW_OFFSET( addr )]
+#define READ_CODE( addr )           RW_MEM( addr, read )
+
+#ifdef FLAT_MEM
+	#define RW_PAGE( addr, rw )     FLAT_MEM
+	#define RW_OFFSET( addr )       (addr)
+	#define INSTR( off, addr )      READ_CODE( addr )
+#else
+	#define RW_PAGE( addr, rw )     s.rw [(unsigned) (addr) >> Z80_Cpu::page_bits]
+	#define RW_OFFSET( addr )       Z80_CPU_OFFSET( addr )
+	#define INSTR( off, addr )      instr [off]
+#endif
+
+#ifndef READ_MEM
+	#define READ_MEM( addr )        RW_MEM( addr, read )
+#endif
+	
+#ifndef WRITE_MEM
+	#define WRITE_MEM( addr, data ) (RW_MEM( addr, write ) = data)
+#endif
+
+#define READ_WORD( addr )           GET_LE16( &RW_MEM( addr, read ) )
+#define WRITE_WORD( addr, data )    SET_LE16( &RW_MEM( addr, write ), data )
+
+// Truncation
+#define BYTE(  n ) ((BOOST::uint8_t ) (n)) /* (unsigned) n & 0xFF */
+#define SBYTE( n ) ((BOOST::int8_t  ) (n)) /* (BYTE( n ) ^ 0x80) - 0x80 */
+#define WORD(  n ) ((BOOST::uint16_t) (n)) /* (unsigned) n & 0xFFFF */
+
+// Misc
+#define CASE5( a, b, c, d, e          ) case 0x##a:case 0x##b:case 0x##c:case 0x##d:case 0x##e
+#define CASE6( a, b, c, d, e, f       ) CASE5( a, b, c, d, e       ): case 0x##f
+#define CASE7( a, b, c, d, e, f, g    ) CASE6( a, b, c, d, e, f    ): case 0x##g
+#define CASE8( a, b, c, d, e, f, g, h ) CASE7( a, b, c, d, e, f, g ): case 0x##h
+
+#if BLARGG_BIG_ENDIAN
+	#define R8( n, offset ) ((r.r8_ - offset) [n]) 
+#elif BLARGG_LITTLE_ENDIAN
+	#define R8( n, offset ) ((r.r8_ - offset) [(n) ^ 1]) 
+#else
+	#error "Byte order of CPU must be known"
+#endif
+
+#define R16( n, shift, offset ) (r.r16_ [((unsigned) (n) >> shift) - (offset >> shift)])
+
+#define EX( x, y ) \
+	{\
+		int temp = x;\
+		x = y;\
+		y = temp;\
+	}
+		
+#define EXX( name ) \
+	EX( R.alt.name, r.name )
+		
+bool warning = false;
+{
+	Z80_Cpu::cpu_state_t s;
+	#ifdef FLAT_MEM
+		s.base = CPU.cpu_state_.base;
+	#else
+		s = CPU.cpu_state_;
+	#endif
+	CPU.cpu_state = &s;
+	
+	
+	union r_t {
+		Z80_Cpu::regs_t b;
+		Z80_Cpu::pairs_t w;
+		byte r8_ [8]; // indexed
+		BOOST::uint16_t r16_ [4];
+	} r;
+	r.b = R.b;
+	
+	Z80_Cpu::time_t s_time = CPU.cpu_state_.time;
+	int pc = R.pc;
+	int sp = R.sp;
+	int ix = R.ix; // TODO: keep in memory for direct access?
+	int iy = R.iy;
+	int flags = R.b.flags;
+	
+	//goto loop; // confuses optimizer
+	s_time += 7;
+	pc -= 2;
+	
+call_not_taken:
+	s_time -= 7; 
+jp_not_taken:
+	pc += 2;
+loop:
+	
+	check( (unsigned) pc < 0x10000 + 1 ); // +1 so emulator can catch wrap-around
+	check( (unsigned) sp < 0x10000 );
+	check( (unsigned) flags < 0x100 );
+	check( (unsigned) ix < 0x10000 );
+	check( (unsigned) iy < 0x10000 );
+	
+	byte const* instr = RW_PAGE( pc, read );
+	
+	int opcode;
+	
+	if ( RW_OFFSET( ~0 ) == ~0 )
+	{
+		opcode = instr [RW_OFFSET( pc )];
+		pc++;
+		instr += RW_OFFSET( pc );
+	}
+	else
+	{
+		instr += RW_OFFSET( pc );
+		opcode = *instr++;
+		pc++;
+	}
+	
+	static byte const clock_table [256 * 2] = {
+	//   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
+		 4,10, 7, 6, 4, 4, 7, 4, 4,11, 7, 6, 4, 4, 7, 4, // 0
+		 8,10, 7, 6, 4, 4, 7, 4,12,11, 7, 6, 4, 4, 7, 4, // 1
+		 7,10,16, 6, 4, 4, 7, 4, 7,11,16, 6, 4, 4, 7, 4, // 2
+		 7,10,13, 6,11,11,10, 4, 7,11,13, 6, 4, 4, 7, 4, // 3
+		 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4, // 4
+		 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4, // 5
+		 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4, // 6
+		 7, 7, 7, 7, 7, 7, 4, 7, 4, 4, 4, 4, 4, 4, 7, 4, // 7
+		 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4, // 8
+		 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4, // 9
+		 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4, // A
+		 4, 4, 4, 4, 4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 7, 4, // B
+		11,10,10,10,17,11, 7,11,11,10,10, 8,17,17, 7,11, // C
+		11,10,10,11,17,11, 7,11,11, 4,10,11,17, 8, 7,11, // D
+		11,10,10,19,17,11, 7,11,11, 4,10, 4,17, 8, 7,11, // E
+		11,10,10, 4,17,11, 7,11,11, 6,10, 4,17, 8, 7,11, // F
+		
+		// high four bits are $ED time - 8, low four bits are $DD/$FD time - 8
+		//0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x06,0x0C,0x02,0x00,0x00,0x03,0x00,0x00,0x07,0x0C,0x02,0x00,0x00,0x03,0x00,
+		0x00,0x00,0x00,0x00,0x0F,0x0F,0x0B,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x40,0x40,0x70,0xC0,0x00,0x60,0x0B,0x10,0x40,0x40,0x70,0xC0,0x00,0x60,0x0B,0x10,
+		0x40,0x40,0x70,0xC0,0x00,0x60,0x0B,0x10,0x40,0x40,0x70,0xC0,0x00,0x60,0x0B,0x10,
+		0x40,0x40,0x70,0xC0,0x00,0x60,0x0B,0xA0,0x40,0x40,0x70,0xC0,0x00,0x60,0x0B,0xA0,
+		0x4B,0x4B,0x7B,0xCB,0x0B,0x6B,0x00,0x0B,0x40,0x40,0x70,0xC0,0x00,0x60,0x0B,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0B,0x00,
+		0x80,0x80,0x80,0x80,0x00,0x00,0x0B,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0B,0x00,
+		0xD0,0xD0,0xD0,0xD0,0x00,0x00,0x0B,0x00,0xD0,0xD0,0xD0,0xD0,0x00,0x00,0x0B,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x06,0x00,0x0F,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
+	};
+	
+	if ( s_time >= 0 )
+		goto out_of_time;
+	s_time += clock_table [opcode];
+	
+	#ifdef Z80_CPU_LOG_H
+		//log_opcode( opcode, READ_CODE( pc ) );
+		z80_cpu_log( "log.txt", pc - 1, opcode, READ_CODE( pc ),
+				READ_CODE( pc + 1 ), READ_CODE( pc + 2 ) );
+		z80_log_regs( r.b.a, r.w.bc, r.w.de, r.w.hl, sp, ix, iy );
+	#endif
+	
+#define GET_ADDR()  GET_LE16( &INSTR( 0, pc ) )
+
+	int data;
+	data = INSTR( 0, pc );
+	
+	switch ( opcode )
+	{
+// Common
+
+	case 0x00: // NOP
+	CASE7( 40, 49, 52, 5B, 64, 6D, 7F ): // LD B,B etc.
+		goto loop;
+	
+	case 0x08:{// EX AF,AF'
+		EXX( b.a );
+		EX( R.alt.b.flags, flags );
+		goto loop;
+	}
+	
+	case 0xD3: // OUT (imm),A
+		pc++;
+		OUT_PORT( (data + r.b.a * 0x100), r.b.a );
+		goto loop;
+		
+	case 0x2E: // LD L,imm
+		pc++;
+		r.b.l = data;
+		goto loop;
+	
+	case 0x3E: // LD A,imm
+		pc++;
+		r.b.a = data;
+		goto loop;
+	
+	case 0x3A:{// LD A,(addr)
+		int addr = GET_ADDR();
+		pc += 2;
+		r.b.a = READ_MEM( addr );
+		goto loop;
+	}
+	
+// Conditional
+
+#define ZERO    (flags & Z40)
+#define CARRY   (flags & C01)
+#define EVEN    (flags & P04)
+#define MINUS   (flags & S80)
+
+// JR
+// TODO: more efficient way to handle negative branch that wraps PC around
+#define JR_( cond, clocks ) {\
+	pc++;\
+	if ( !(cond) )\
+		goto loop;\
+	int offset = SBYTE( data );\
+	pc = WORD( pc + offset );\
+	s_time += clocks;\
+	goto loop;\
+}
+
+#define JR( cond ) JR_( cond, 5 )
+	
+	case 0x20: JR( !ZERO  ) // JR NZ,disp
+	case 0x28: JR(  ZERO  ) // JR Z,disp
+	case 0x30: JR( !CARRY ) // JR NC,disp
+	case 0x38: JR(  CARRY ) // JR C,disp
+	case 0x18: JR_( true,0) // JR disp
+
+	case 0x10:{// DJNZ disp
+		int temp = r.b.b - 1;
+		r.b.b = temp;
+		JR( temp )
+	}
+	
+// JP
+#define JP( cond ) \
+	if ( !(cond) )\
+		goto jp_not_taken;\
+	pc = GET_ADDR();\
+	goto loop;
+	
+	case 0xC2: JP( !ZERO  ) // JP NZ,addr
+	case 0xCA: JP(  ZERO  ) // JP Z,addr
+	case 0xD2: JP( !CARRY ) // JP NC,addr
+	case 0xDA: JP(  CARRY ) // JP C,addr
+	case 0xE2: JP( !EVEN  ) // JP PO,addr
+	case 0xEA: JP(  EVEN  ) // JP PE,addr
+	case 0xF2: JP( !MINUS ) // JP P,addr
+	case 0xFA: JP(  MINUS ) // JP M,addr
+	
+	case 0xC3: // JP addr
+		pc = GET_ADDR();
+		goto loop;
+	
+	case 0xE9: // JP HL
+		pc = r.w.hl;
+		goto loop;
+
+// RET
+#define RET( cond ) \
+	if ( cond )\
+		goto ret_taken;\
+	s_time -= 6;\
+	goto loop;
+	
+	case 0xC0: RET( !ZERO  ) // RET NZ
+	case 0xC8: RET(  ZERO  ) // RET Z
+	case 0xD0: RET( !CARRY ) // RET NC
+	case 0xD8: RET(  CARRY ) // RET C
+	case 0xE0: RET( !EVEN  ) // RET PO
+	case 0xE8: RET(  EVEN  ) // RET PE
+	case 0xF0: RET( !MINUS ) // RET P
+	case 0xF8: RET(  MINUS ) // RET M
+	
+	case 0xC9: // RET
+	ret_taken:
+		pc = READ_WORD( sp );
+		sp = WORD( sp + 2 );
+		goto loop;
+	
+// CALL
+#define CALL( cond ) \
+	if ( cond )\
+		goto call_taken;\
+	goto call_not_taken;
+
+	case 0xC4: CALL( !ZERO  ) // CALL NZ,addr
+	case 0xCC: CALL(  ZERO  ) // CALL Z,addr
+	case 0xD4: CALL( !CARRY ) // CALL NC,addr
+	case 0xDC: CALL(  CARRY ) // CALL C,addr
+	case 0xE4: CALL( !EVEN  ) // CALL PO,addr
+	case 0xEC: CALL(  EVEN  ) // CALL PE,addr
+	case 0xF4: CALL( !MINUS ) // CALL P,addr
+	case 0xFC: CALL(  MINUS ) // CALL M,addr
+	
+	case 0xCD:{// CALL addr
+	call_taken:
+		int addr = pc + 2;
+		pc = GET_ADDR();
+		sp = WORD( sp - 2 );
+		WRITE_WORD( sp, addr );
+		goto loop;
+	}
+	
+	case 0xFF: // RST
+		#ifdef IDLE_ADDR
+			if ( pc == IDLE_ADDR + 1 )
+				goto hit_idle_addr;
+		#else
+			if ( pc > 0x10000 )
+			{
+				pc = WORD( pc - 1 );
+				s_time -= 11;
+				goto loop;
+			}
+		#endif
+	CASE7( C7, CF, D7, DF, E7, EF, F7 ):
+		data = pc;
+		pc = opcode & 0x38;
+		#ifdef RST_BASE
+			pc += RST_BASE;
+		#endif
+		goto push_data;
+
+// PUSH/POP
+	case 0xF5: // PUSH AF
+		data = r.b.a * 0x100u + flags;
+		goto push_data;
+	
+	case 0xC5: // PUSH BC
+	case 0xD5: // PUSH DE
+	case 0xE5: // PUSH HL
+		data = R16( opcode, 4, 0xC5 );
+	push_data:
+		sp = WORD( sp - 2 );
+		WRITE_WORD( sp, data );
+		goto loop;
+	
+	case 0xF1: // POP AF
+		flags = READ_MEM( sp );
+		r.b.a = READ_MEM( (sp + 1) );
+		sp = WORD( sp + 2 );
+		goto loop;
+	
+	case 0xC1: // POP BC
+	case 0xD1: // POP DE
+	case 0xE1: // POP HL
+		R16( opcode, 4, 0xC1 ) = READ_WORD( sp );
+		sp = WORD( sp + 2 );
+		goto loop;
+	
+// ADC/ADD/SBC/SUB
+	case 0x96: // SUB (HL)
+	case 0x86: // ADD (HL)
+		flags &= ~C01;
+	case 0x9E: // SBC (HL)
+	case 0x8E: // ADC (HL)
+		data = READ_MEM( r.w.hl );
+		goto adc_data;
+	
+	case 0xD6: // SUB A,imm
+	case 0xC6: // ADD imm
+		flags &= ~C01;
+	case 0xDE: // SBC A,imm
+	case 0xCE: // ADC imm
+		pc++;
+		goto adc_data;
+	
+	CASE7( 90, 91, 92, 93, 94, 95, 97 ): // SUB r
+	CASE7( 80, 81, 82, 83, 84, 85, 87 ): // ADD r
+		flags &= ~C01;
+	CASE7( 98, 99, 9A, 9B, 9C, 9D, 9F ): // SBC r
+	CASE7( 88, 89, 8A, 8B, 8C, 8D, 8F ): // ADC r
+		data = R8( opcode & 7, 0 );
+	adc_data: {
+		int result = data + (flags & C01);
+		data ^= r.b.a;
+		flags = opcode >> 3 & N02; // bit 4 is set in subtract opcodes
+		if ( flags )
+			result = -result;
+		result += r.b.a;
+		data ^= result;
+		flags +=(data & H10) +
+				((data + 0x80) >> 6 & V04) +
+				SZ28C( result & 0x1FF );
+		r.b.a = result;
+		goto loop;
+	}
+
+// CP
+	case 0xBE: // CP (HL)
+		data = READ_MEM( r.w.hl );
+		goto cp_data;
+	
+	case 0xFE: // CP imm
+		pc++;
+		goto cp_data;
+	
+	CASE7( B8, B9, BA, BB, BC, BD, BF ): // CP r
+		data = R8( opcode, 0xB8 );
+	cp_data: {
+		int result = r.b.a - data;
+		flags = N02 + (data & (F20 | F08)) + (result >> 8 & C01);
+		data ^= r.b.a;
+		flags +=(((result ^ r.b.a) & data) >> 5 & V04) +
+				(((data & H10) ^ result) & (S80 | H10));
+		if ( BYTE( result ) )
+			goto loop;
+		flags += Z40;
+		goto loop;
+	}
+	
+// ADD HL,r.w
+	
+	case 0x39: // ADD HL,SP
+		data = sp;
+		goto add_hl_data;
+	
+	case 0x09: // ADD HL,BC
+	case 0x19: // ADD HL,DE
+	case 0x29: // ADD HL,HL
+		data = R16( opcode, 4, 0x09 );
+	add_hl_data: {
+		int sum = r.w.hl + data;
+		data ^= r.w.hl;
+		r.w.hl = sum;
+		flags = (flags & (S80 | Z40 | V04)) +
+				(sum >> 16) +
+				(sum >> 8 & (F20 | F08)) +
+				((data ^ sum) >> 8 & H10);
+		goto loop;
+	}
+	
+	case 0x27:{// DAA
+		int a = r.b.a;
+		if ( a > 0x99 )
+			flags |= C01;
+		
+		int adjust = 0x60 * (flags & C01);
+		
+		if ( flags & H10 || (a & 0x0F) > 9 )
+			adjust += 0x06;
+		
+		if ( flags & N02 )
+			adjust = -adjust;
+		a += adjust;
+		
+		flags = (flags & (C01 | N02)) +
+				((r.b.a ^ a) & H10) +
+				SZ28P( BYTE( a ) );
+		r.b.a = a;
+		goto loop;
+	}
+	
+// INC/DEC
+	case 0x34: // INC (HL)
+		data = READ_MEM( r.w.hl ) + 1;
+		WRITE_MEM( r.w.hl, data );
+		goto inc_set_flags;
+	
+	CASE7( 04, 0C, 14, 1C, 24, 2C, 3C ): // INC r
+		data = ++R8( opcode >> 3, 0 );
+	inc_set_flags:
+		flags = (flags & C01) +
+				(((data & 0x0F) - 1) & H10) +
+				SZ28( BYTE( data ) );
+		if ( data != 0x80 )
+			goto loop;
+		flags += V04;
+		goto loop;
+	
+	case 0x35: // DEC (HL)
+		data = READ_MEM( r.w.hl ) - 1;
+		WRITE_MEM( r.w.hl, data );
+		goto dec_set_flags;
+	
+	CASE7( 05, 0D, 15, 1D, 25, 2D, 3D ): // DEC r
+		data = --R8( opcode >> 3, 0 );
+	dec_set_flags:
+		flags = (flags & C01) + N02 +
+				(((data & 0x0F) + 1) & H10) +
+				SZ28( BYTE( data ) );
+		if ( data != 0x7F )
+			goto loop;
+		flags += V04;
+		goto loop;
+
+	case 0x03: // INC BC
+	case 0x13: // INC DE
+	case 0x23: // INC HL
+		R16( opcode, 4, 0x03 )++;
+		goto loop;
+	
+	case 0x33: // INC SP
+		sp = WORD( sp + 1 );
+		goto loop;
+	
+	case 0x0B: // DEC BC
+	case 0x1B: // DEC DE
+	case 0x2B: // DEC HL
+		R16( opcode, 4, 0x0B )--;
+		goto loop;
+	
+	case 0x3B: // DEC SP
+		sp = WORD( sp - 1 );
+		goto loop;
+	
+// AND
+	case 0xA6: // AND (HL)
+		data = READ_MEM( r.w.hl );
+		goto and_data;
+	
+	case 0xE6: // AND imm
+		pc++;
+		goto and_data;
+	
+	CASE7( A0, A1, A2, A3, A4, A5, A7 ): // AND r
+		data = R8( opcode, 0xA0 );
+	and_data:
+		r.b.a &= data;
+		flags = SZ28P( r.b.a ) + H10;
+		goto loop;
+	
+// OR
+	case 0xB6: // OR (HL)
+		data = READ_MEM( r.w.hl );
+		goto or_data;
+	
+	case 0xF6: // OR imm
+		pc++;
+		goto or_data;
+	
+	CASE7( B0, B1, B2, B3, B4, B5, B7 ): // OR r
+		data = R8( opcode, 0xB0 );
+	or_data:
+		r.b.a |= data;
+		flags = SZ28P( r.b.a );
+		goto loop;
+
+// XOR
+	case 0xAE: // XOR (HL)
+		data = READ_MEM( r.w.hl );
+		goto xor_data;
+	
+	case 0xEE: // XOR imm
+		pc++;
+		goto xor_data;
+	
+	CASE7( A8, A9, AA, AB, AC, AD, AF ): // XOR r
+		data = R8( opcode, 0xA8 );
+	xor_data:
+		r.b.a ^= data;
+		flags = SZ28P( r.b.a );
+		goto loop;
+
+// LD
+	CASE7( 70, 71, 72, 73, 74, 75, 77 ): // LD (HL),r
+		WRITE_MEM( r.w.hl, R8( opcode, 0x70 ) );
+		goto loop;
+	
+	CASE6( 41, 42, 43, 44, 45, 47 ): // LD B,r
+	CASE6( 48, 4A, 4B, 4C, 4D, 4F ): // LD C,r
+	CASE6( 50, 51, 53, 54, 55, 57 ): // LD D,r
+	CASE6( 58, 59, 5A, 5C, 5D, 5F ): // LD E,r
+	CASE6( 60, 61, 62, 63, 65, 67 ): // LD H,r
+	CASE6( 68, 69, 6A, 6B, 6C, 6F ): // LD L,r
+	CASE6( 78, 79, 7A, 7B, 7C, 7D ): // LD A,r
+		R8( opcode >> 3 & 7, 0 ) = R8( opcode & 7, 0 );
+		goto loop;
+	
+	CASE5( 06, 0E, 16, 1E, 26 ): // LD r,imm
+		R8( opcode >> 3, 0 ) = data;
+		pc++;
+		goto loop;
+	
+	case 0x36: // LD (HL),imm
+		pc++;
+		WRITE_MEM( r.w.hl, data );
+		goto loop;
+	
+	CASE7( 46, 4E, 56, 5E, 66, 6E, 7E ): // LD r,(HL)
+		R8( opcode >> 3, 8 ) = READ_MEM( r.w.hl );
+		goto loop;
+	
+	case 0x01: // LD r.w,imm
+	case 0x11:
+	case 0x21:
+		R16( opcode, 4, 0x01 ) = GET_ADDR();
+		pc += 2;
+		goto loop;
+	
+	case 0x31: // LD sp,imm
+		sp = GET_ADDR();
+		pc += 2;
+		goto loop;
+	
+	case 0x2A:{// LD HL,(addr)
+		int addr = GET_ADDR();
+		pc += 2;
+		r.w.hl = READ_WORD( addr );
+		goto loop;
+	}
+	
+	case 0x32:{// LD (addr),A
+		int addr = GET_ADDR();
+		pc += 2;
+		WRITE_MEM( addr, r.b.a );
+		goto loop;
+	}
+	
+	case 0x22:{// LD (addr),HL
+		int addr = GET_ADDR();
+		pc += 2;
+		WRITE_WORD( addr, r.w.hl );
+		goto loop;
+	}
+	
+	case 0x02: // LD (BC),A
+	case 0x12: // LD (DE),A
+		WRITE_MEM( R16( opcode, 4, 0x02 ), r.b.a );
+		goto loop;
+	
+	case 0x0A: // LD A,(BC)
+	case 0x1A: // LD A,(DE)
+		r.b.a = READ_MEM( R16( opcode, 4, 0x0A ) );
+		goto loop;
+	
+	case 0xF9: // LD SP,HL
+		sp = r.w.hl;
+		goto loop;
+	
+// Rotate
+	
+	case 0x07:{// RLCA
+		int temp = r.b.a;
+		temp = (temp << 1) + (temp >> 7);
+		flags = (flags & (S80 | Z40 | P04)) +
+				(temp & (F20 | F08 | C01));
+		r.b.a = temp;
+		goto loop;
+	}
+	
+	case 0x0F:{// RRCA
+		int temp = r.b.a;
+		flags = (flags & (S80 | Z40 | P04)) +
+				(temp & C01);
+		temp = (temp << 7) + (temp >> 1);
+		flags += temp & (F20 | F08);
+		r.b.a = temp;
+		goto loop;
+	}
+	
+	case 0x17:{// RLA
+		int temp = (r.b.a << 1) + (flags & C01);
+		flags = (flags & (S80 | Z40 | P04)) +
+				(temp & (F20 | F08)) +
+				(temp >> 8);
+		r.b.a = temp;
+		goto loop;
+	}
+	
+	case 0x1F:{// RRA
+		int temp = (flags << 7) + (r.b.a >> 1);
+		flags = (flags & (S80 | Z40 | P04)) +
+				(temp & (F20 | F08)) +
+				(r.b.a & C01);
+		r.b.a = temp;
+		goto loop;
+	}
+	
+// Misc
+	case 0x2F:{// CPL
+		int temp = ~r.b.a;
+		flags = (flags & (S80 | Z40 | P04 | C01)) +
+				(temp & (F20 | F08)) +
+				(H10 | N02);
+		r.b.a = temp;
+		goto loop;
+	}
+	
+	case 0x3F:{// CCF
+		flags = ((flags & (S80 | Z40 | P04 | C01)) ^ C01) +
+				(flags << 4 & H10) +
+				(r.b.a & (F20 | F08));
+		goto loop;
+	}
+	
+	case 0x37: // SCF
+		flags = (flags & (S80 | Z40 | P04)) | C01 +
+				(r.b.a & (F20 | F08));
+		goto loop;
+	
+	case 0xDB: // IN A,(imm)
+		pc++;
+		r.b.a = IN_PORT( (data + r.b.a * 0x100) );
+		goto loop;
+
+	case 0xE3:{// EX (SP),HL
+		int temp = READ_WORD( sp );
+		WRITE_WORD( sp, r.w.hl );
+		r.w.hl = temp;
+		goto loop;
+	}
+	
+	case 0xEB: // EX DE,HL
+		EX( r.w.hl, r.w.de );
+		goto loop;
+	
+	case 0xD9: // EXX DE,HL
+		EXX( w.bc );
+		EXX( w.de );
+		EXX( w.hl );
+		goto loop;
+	
+	case 0xF3: // DI
+		R.iff1 = 0;
+		R.iff2 = 0;
+		goto loop;
+	
+	case 0xFB: // EI
+		R.iff1 = 1;
+		R.iff2 = 1;
+		// TODO: delayed effect
+		goto loop;
+	
+	case 0x76: // HALT
+		goto halt;
+	
+//////////////////////////////////////// CB prefix
+	{
+	case 0xCB:
+		pc++;
+		switch ( data )
+		{
+	
+	// Rotate left
+		
+	#define RLC( read, write ) {\
+		int result = read;\
+		result = BYTE( result << 1 ) + (result >> 7);\
+		flags = SZ28P( result ) + (result & C01);\
+		write;\
+		goto loop;\
+	}
+		
+		case 0x06: // RLC (HL)
+			s_time += 7;
+			data = r.w.hl;
+		rlc_data_addr:
+			RLC( READ_MEM( data ), WRITE_MEM( data, result ) )
+		
+		CASE7( 00, 01, 02, 03, 04, 05, 07 ):{// RLC r
+			byte& reg = R8( data, 0 );
+			RLC( reg, reg = result )
+		}
+		
+	#define RL( read, write ) {\
+		int result = (read << 1) + (flags & C01);\
+		flags = SZ28PC( result );\
+		write;\
+		goto loop;\
+	}
+		
+		case 0x16: // RL (HL)
+			s_time += 7;
+			data = r.w.hl;
+		rl_data_addr:
+			RL( READ_MEM( data ), WRITE_MEM( data, result ) )
+		
+		CASE7( 10, 11, 12, 13, 14, 15, 17 ):{// RL r
+			byte& reg = R8( data, 0x10 );
+			RL( reg, reg = result )
+		}
+		
+	#define SLA( read, low_bit, write ) {\
+		int result = (read << 1) + low_bit;\
+		flags = SZ28PC( result );\
+		write;\
+		goto loop;\
+	}
+		
+		case 0x26: // SLA (HL)
+			s_time += 7;
+			data = r.w.hl;
+		sla_data_addr:
+			SLA( READ_MEM( data ), 0, WRITE_MEM( data, result ) )
+		
+		CASE7( 20, 21, 22, 23, 24, 25, 27 ):{// SLA r
+			byte& reg = R8( data, 0x20 );
+			SLA( reg, 0, reg = result )
+		}
+		
+		case 0x36: // SLL (HL)
+			s_time += 7;
+			data = r.w.hl;
+		sll_data_addr:
+			SLA( READ_MEM( data ), 1, WRITE_MEM( data, result ) )
+		
+		CASE7( 30, 31, 32, 33, 34, 35, 37 ):{// SLL r
+			byte& reg = R8( data, 0x30 );
+			SLA( reg, 1, reg = result )
+		}
+		
+	// Rotate right
+		
+	#define RRC( read, write ) {\
+		int result = read;\
+		flags = result & C01;\
+		result = BYTE( result << 7 ) + (result >> 1);\
+		flags += SZ28P( result );\
+		write;\
+		goto loop;\
+	}
+		
+		case 0x0E: // RRC (HL)
+			s_time += 7;
+			data = r.w.hl;
+		rrc_data_addr:
+			RRC( READ_MEM( data ), WRITE_MEM( data, result ) )
+		
+		CASE7( 08, 09, 0A, 0B, 0C, 0D, 0F ):{// RRC r
+			byte& reg = R8( data, 0x08 );
+			RRC( reg, reg = result )
+		}
+		
+	#define RR( read, write ) {\
+		int result = read;\
+		int temp = result & C01;\
+		result = BYTE( flags << 7 ) + (result >> 1);\
+		flags = SZ28P( result ) + temp;\
+		write;\
+		goto loop;\
+	}
+		
+		case 0x1E: // RR (HL)
+			s_time += 7;
+			data = r.w.hl;
+		rr_data_addr:
+			RR( READ_MEM( data ), WRITE_MEM( data, result ) )
+		
+		CASE7( 18, 19, 1A, 1B, 1C, 1D, 1F ):{// RR r
+			byte& reg = R8( data, 0x18 );
+			RR( reg, reg = result )
+		}
+		
+	#define SRA( read, write ) {\
+		int result = read;\
+		flags = result & C01;\
+		result = (result & 0x80) + (result >> 1);\
+		flags += SZ28P( result );\
+		write;\
+		goto loop;\
+	}
+		
+		case 0x2E: // SRA (HL)
+			data = r.w.hl;
+			s_time += 7;
+		sra_data_addr:
+			SRA( READ_MEM( data ), WRITE_MEM( data, result ) )
+		
+		CASE7( 28, 29, 2A, 2B, 2C, 2D, 2F ):{// SRA r
+			byte& reg = R8( data, 0x28 );
+			SRA( reg, reg = result )
+		}
+		
+	#define SRL( read, write ) {\
+		int result = read;\
+		flags = result & C01;\
+		result >>= 1;\
+		flags += SZ28P( result );\
+		write;\
+		goto loop;\
+	}
+		
+		case 0x3E: // SRL (HL)
+			s_time += 7;
+			data = r.w.hl;
+		srl_data_addr:
+			SRL( READ_MEM( data ), WRITE_MEM( data, result ) )
+		
+		CASE7( 38, 39, 3A, 3B, 3C, 3D, 3F ):{// SRL r
+			byte& reg = R8( data, 0x38 );
+			SRL( reg, reg = result )
+		}
+		
+	// BIT
+		{
+			int temp;
+		CASE8( 46, 4E, 56, 5E, 66, 6E, 76, 7E ): // BIT b,(HL)
+			s_time += 4;
+			temp = READ_MEM( r.w.hl );
+			flags &= C01;
+			goto bit_temp;
+		CASE7( 40, 41, 42, 43, 44, 45, 47 ): // BIT 0,r
+		CASE7( 48, 49, 4A, 4B, 4C, 4D, 4F ): // BIT 1,r
+		CASE7( 50, 51, 52, 53, 54, 55, 57 ): // BIT 2,r
+		CASE7( 58, 59, 5A, 5B, 5C, 5D, 5F ): // BIT 3,r
+		CASE7( 60, 61, 62, 63, 64, 65, 67 ): // BIT 4,r
+		CASE7( 68, 69, 6A, 6B, 6C, 6D, 6F ): // BIT 5,r
+		CASE7( 70, 71, 72, 73, 74, 75, 77 ): // BIT 6,r
+		CASE7( 78, 79, 7A, 7B, 7C, 7D, 7F ): // BIT 7,r
+			temp = R8( data & 7, 0 );
+			flags = (flags & C01) + (temp & (F20 | F08));
+		bit_temp:
+			temp = temp & (1 << (data >> 3 & 7));
+			flags += (temp & S80) + H10;
+			flags += (unsigned) --temp >> 8 & (Z40 | P04);
+			goto loop;
+		}
+		
+	// SET/RES
+		CASE8( 86, 8E, 96, 9E, A6, AE, B6, BE ): // RES b,(HL)
+		CASE8( C6, CE, D6, DE, E6, EE, F6, FE ):{// SET b,(HL)
+			s_time += 7;
+			int temp = READ_MEM( r.w.hl );
+			int bit = 1 << (data >> 3 & 7);
+			temp |= bit; // SET
+			if ( !(data & 0x40) )
+				temp ^= bit; // RES
+			WRITE_MEM( r.w.hl, temp );
+			goto loop;
+		}
+		
+		CASE7( C0, C1, C2, C3, C4, C5, C7 ): // SET 0,r
+		CASE7( C8, C9, CA, CB, CC, CD, CF ): // SET 1,r
+		CASE7( D0, D1, D2, D3, D4, D5, D7 ): // SET 2,r
+		CASE7( D8, D9, DA, DB, DC, DD, DF ): // SET 3,r
+		CASE7( E0, E1, E2, E3, E4, E5, E7 ): // SET 4,r
+		CASE7( E8, E9, EA, EB, EC, ED, EF ): // SET 5,r
+		CASE7( F0, F1, F2, F3, F4, F5, F7 ): // SET 6,r
+		CASE7( F8, F9, FA, FB, FC, FD, FF ): // SET 7,r
+			R8( data & 7, 0 ) |= 1 << (data >> 3 & 7);
+			goto loop;
+		
+		CASE7( 80, 81, 82, 83, 84, 85, 87 ): // RES 0,r
+		CASE7( 88, 89, 8A, 8B, 8C, 8D, 8F ): // RES 1,r
+		CASE7( 90, 91, 92, 93, 94, 95, 97 ): // RES 2,r
+		CASE7( 98, 99, 9A, 9B, 9C, 9D, 9F ): // RES 3,r
+		CASE7( A0, A1, A2, A3, A4, A5, A7 ): // RES 4,r
+		CASE7( A8, A9, AA, AB, AC, AD, AF ): // RES 5,r
+		CASE7( B0, B1, B2, B3, B4, B5, B7 ): // RES 6,r
+		CASE7( B8, B9, BA, BB, BC, BD, BF ): // RES 7,r
+			R8( data & 7, 0 ) &= ~(1 << (data >> 3 & 7));
+			goto loop;
+		}
+		assert( false );
+	}
+
+#undef GET_ADDR
+#define GET_ADDR()  GET_LE16( &INSTR( 1, pc ) )
+
+//////////////////////////////////////// ED prefix
+	{
+	case 0xED:
+		pc++;
+		s_time += (clock_table + 256) [data] >> 4;
+		switch ( data )
+		{
+		{
+			int temp;
+		case 0x72: // SBC HL,SP
+		case 0x7A: // ADC HL,SP
+			temp = sp;
+			if ( 0 )
+		case 0x42: // SBC HL,BC
+		case 0x52: // SBC HL,DE
+		case 0x62: // SBC HL,HL
+		case 0x4A: // ADC HL,BC
+		case 0x5A: // ADC HL,DE
+		case 0x6A: // ADC HL,HL
+				temp = R16( data >> 3 & 6, 1, 0 );
+			int sum = temp + (flags & C01);
+			flags = ~data >> 2 & N02;
+			if ( flags )
+				sum = -sum;
+			sum += r.w.hl;
+			temp ^= r.w.hl;
+			temp ^= sum;
+			flags +=(sum >> 16 & C01) +
+					(temp >> 8 & H10) +
+					(sum >> 8 & (S80 | F20 | F08)) +
+					((temp + 0x8000) >> 14 & V04);
+			r.w.hl = sum;
+			if ( WORD( sum ) )
+				goto loop;
+			flags += Z40;
+			goto loop;
+		}
+		
+		CASE8( 40, 48, 50, 58, 60, 68, 70, 78 ):{// IN r,(C)
+			int temp = IN_PORT( r.w.bc );
+			R8( data >> 3, 8 ) = temp;
+			flags = (flags & C01) + SZ28P( temp );
+			goto loop;
+		}
+		
+		case 0x71: // OUT (C),0
+			r.b.flags = 0;
+		CASE7( 41, 49, 51, 59, 61, 69, 79 ): // OUT (C),r
+			OUT_PORT( r.w.bc, R8( data >> 3, 8 ) );
+			goto loop;
+		
+		{
+			int temp;
+		case 0x73: // LD (ADDR),SP
+			temp = sp;
+			if ( 0 )
+		case 0x43: // LD (ADDR),BC
+		case 0x53: // LD (ADDR),DE
+				temp = R16( data, 4, 0x43 );
+			int addr = GET_ADDR();
+			pc += 2;
+			WRITE_WORD( addr, temp );
+			goto loop;
+		}
+		
+		case 0x4B: // LD BC,(ADDR)
+		case 0x5B:{// LD DE,(ADDR)
+			int addr = GET_ADDR();
+			pc += 2;
+			R16( data, 4, 0x4B ) = READ_WORD( addr );
+			goto loop;
+		}
+		
+		case 0x7B:{// LD SP,(ADDR)
+			int addr = GET_ADDR();
+			pc += 2;
+			sp = READ_WORD( addr );
+			goto loop;
+		}
+		
+		case 0x67:{// RRD
+			int temp = READ_MEM( r.w.hl );
+			WRITE_MEM( r.w.hl, ((r.b.a << 4) + (temp >> 4)) );
+			temp = (r.b.a & 0xF0) + (temp & 0x0F);
+			flags = (flags & C01) + SZ28P( temp );
+			r.b.a = temp;
+			goto loop;
+		}
+		
+		case 0x6F:{// RLD
+			int temp = READ_MEM( r.w.hl );
+			WRITE_MEM( r.w.hl, ((temp << 4) + (r.b.a & 0x0F)) );
+			temp = (r.b.a & 0xF0) + (temp >> 4);
+			flags = (flags & C01) + SZ28P( temp );
+			r.b.a = temp;
+			goto loop;
+		}
+		
+		CASE8( 44, 4C, 54, 5C, 64, 6C, 74, 7C ): // NEG
+			opcode = 0x10; // flag to do SBC instead of ADC
+			flags &= ~C01;
+			data = r.b.a;
+			r.b.a = 0;
+			goto adc_data;
+		
+		{
+			int inc;
+		case 0xA9: // CPD
+		case 0xB9: // CPDR
+			inc = -1;
+			if ( 0 )
+		case 0xA1: // CPI
+		case 0xB1: // CPIR
+				inc = +1;
+			int addr = r.w.hl;
+			r.w.hl = addr + inc;
+			int temp = READ_MEM( addr );
+			
+			int result = r.b.a - temp;
+			flags = (flags & C01) + N02 +
+					((((temp ^ r.b.a) & H10) ^ result) & (S80 | H10));
+			
+			if ( !BYTE( result ) )
+				flags += Z40;
+			result -= (flags & H10) >> 4;
+			flags += result & F08;
+			flags += result << 4 & F20;
+			if ( !--r.w.bc )
+				goto loop;
+			
+			flags += V04;
+			if ( flags & Z40 || data < 0xB0 )
+				goto loop;
+			
+			pc -= 2;
+			s_time += 5;
+			goto loop;
+		}
+		
+		{
+			int inc;
+		case 0xA8: // LDD
+		case 0xB8: // LDDR
+			inc = -1;
+			if ( 0 )
+		case 0xA0: // LDI
+		case 0xB0: // LDIR
+				inc = +1;
+			int addr = r.w.hl;
+			r.w.hl = addr + inc;
+			int temp = READ_MEM( addr );
+			
+			addr = r.w.de;
+			r.w.de = addr + inc;
+			WRITE_MEM( addr, temp );
+			
+			temp += r.b.a;
+			flags = (flags & (S80 | Z40 | C01)) +
+					(temp & F08) + (temp << 4 & F20);
+			if ( !--r.w.bc )
+				goto loop;
+			
+			flags += V04;
+			if ( data < 0xB0 )
+				goto loop;
+			
+			pc -= 2;
+			s_time += 5;
+			goto loop;
+		}
+		
+		{
+			int inc;
+		case 0xAB: // OUTD
+		case 0xBB: // OTDR
+			inc = -1;
+			if ( 0 )
+		case 0xA3: // OUTI
+		case 0xB3: // OTIR
+				inc = +1;
+			int addr = r.w.hl;
+			r.w.hl = addr + inc;
+			int temp = READ_MEM( addr );
+			
+			int b = --r.b.b;
+			flags = (temp >> 6 & N02) + SZ28( b );
+			if ( b && data >= 0xB0 )
+			{
+				pc -= 2;
+				s_time += 5;
+			}
+			
+			OUT_PORT( r.w.bc, temp );
+			goto loop;
+		}
+		
+		{
+			int inc;
+		case 0xAA: // IND
+		case 0xBA: // INDR
+			inc = -1;
+			if ( 0 )
+		case 0xA2: // INI
+		case 0xB2: // INIR
+				inc = +1;
+			
+			int addr = r.w.hl;
+			r.w.hl = addr + inc;
+			
+			int temp = IN_PORT( r.w.bc );
+			
+			int b = --r.b.b;
+			flags = (temp >> 6 & N02) + SZ28( b );
+			if ( b && data >= 0xB0 )
+			{
+				pc -= 2;
+				s_time += 5;
+			}
+			
+			WRITE_MEM( addr, temp );
+			goto loop;
+		}
+		
+		case 0x47: // LD I,A
+			R.i = r.b.a;
+			goto loop;
+		
+		case 0x4F: // LD R,A
+			SET_R( r.b.a );
+			dprintf( "LD R,A not supported\n" );
+			warning = true;
+			goto loop;
+		
+		case 0x57: // LD A,I
+			r.b.a = R.i;
+			goto ld_ai_common;
+		
+		case 0x5F: // LD A,R
+			r.b.a = GET_R();
+			dprintf( "LD A,R not supported\n" );
+			warning = true;
+		ld_ai_common:
+			flags = (flags & C01) + SZ28( r.b.a ) + (R.iff2 << 2 & V04);
+			goto loop;
+		
+		CASE8( 45, 4D, 55, 5D, 65, 6D, 75, 7D ): // RETI/RETN
+			R.iff1 = R.iff2;
+			goto ret_taken;
+		
+		case 0x46: case 0x4E: case 0x66: case 0x6E: // IM 0
+			R.im = 0;
+			goto loop;
+		
+		case 0x56: case 0x76: // IM 1
+			R.im = 1;
+			goto loop;
+		
+		case 0x5E: case 0x7E: // IM 2
+			R.im = 2;
+			goto loop;
+		
+		default:
+			dprintf( "Opcode $ED $%02X not supported\n", data );
+			warning = true;
+			goto loop;
+		}
+		assert( false );
+	}
+
+//////////////////////////////////////// DD/FD prefix
+	{
+	int ixy;
+	case 0xDD:
+		ixy = ix;
+		goto ix_prefix;
+	case 0xFD:
+		ixy = iy;
+	ix_prefix:
+		pc++;
+		int data2 = READ_CODE( pc );
+		s_time += (clock_table + 256) [data] & 0x0F;
+		switch ( data )
+		{
+	// TODO: more efficient way of avoid negative address
+	// TODO: avoid using this as argument to READ_MEM() since it is evaluated twice
+	#define IXY_DISP( ixy, disp )   WORD( (ixy ) + (disp))
+	
+	#define SET_IXY( in ) if ( opcode == 0xDD ) ix = in; else iy = in;
+	
+	// ADD/ADC/SUB/SBC
+	
+		case 0x96: // SUB (IXY+disp)
+		case 0x86: // ADD (IXY+disp)
+			flags &= ~C01;
+		case 0x9E: // SBC (IXY+disp)
+		case 0x8E: // ADC (IXY+disp)
+			pc++;
+			opcode = data;
+			data = READ_MEM( IXY_DISP( ixy, SBYTE( data2 ) ) );
+			goto adc_data;
+		
+		case 0x94: // SUB HXY
+		case 0x84: // ADD HXY
+			flags &= ~C01;
+		case 0x9C: // SBC HXY
+		case 0x8C: // ADC HXY
+			opcode = data;
+			data = ixy >> 8;
+			goto adc_data;
+		
+		case 0x95: // SUB LXY
+		case 0x85: // ADD LXY
+			flags &= ~C01;
+		case 0x9D: // SBC LXY
+		case 0x8D: // ADC LXY
+			opcode = data;
+			data = BYTE( ixy );
+			goto adc_data;
+		
+		{
+			int temp;
+		case 0x39: // ADD IXY,SP
+			temp = sp;
+			goto add_ixy_data;
+		
+		case 0x29: // ADD IXY,HL
+			temp = ixy;
+			goto add_ixy_data;
+		
+		case 0x09: // ADD IXY,BC
+		case 0x19: // ADD IXY,DE
+			temp = R16( data, 4, 0x09 );
+		add_ixy_data: {
+			int sum = ixy + temp;
+			temp ^= ixy;
+			ixy = WORD( sum );
+			flags = (flags & (S80 | Z40 | V04)) +
+					(sum >> 16) +
+					(sum >> 8 & (F20 | F08)) +
+					((temp ^ sum) >> 8 & H10);
+			goto set_ixy;
+		}
+		}
+	
+	// AND
+		case 0xA6: // AND (IXY+disp)
+			pc++;
+			data = READ_MEM( IXY_DISP( ixy, SBYTE( data2 ) ) );
+			goto and_data;
+		
+		case 0xA4: // AND HXY
+			data = ixy >> 8;
+			goto and_data;
+		
+		case 0xA5: // AND LXY
+			data = BYTE( ixy );
+			goto and_data;
+	
+	// OR
+		case 0xB6: // OR (IXY+disp)
+			pc++;
+			data = READ_MEM( IXY_DISP( ixy, SBYTE( data2 ) ) );
+			goto or_data;
+		
+		case 0xB4: // OR HXY
+			data = ixy >> 8;
+			goto or_data;
+		
+		case 0xB5: // OR LXY
+			data = BYTE( ixy );
+			goto or_data;
+	
+	// XOR
+		case 0xAE: // XOR (IXY+disp)
+			pc++;
+			data = READ_MEM( IXY_DISP( ixy, SBYTE( data2 ) ) );
+			goto xor_data;
+		
+		case 0xAC: // XOR HXY
+			data = ixy >> 8;
+			goto xor_data;
+		
+		case 0xAD: // XOR LXY
+			data = BYTE( ixy );
+			goto xor_data;
+	
+	// CP
+		case 0xBE: // CP (IXY+disp)
+			pc++;
+			data = READ_MEM( IXY_DISP( ixy, SBYTE( data2 ) )  );
+			goto cp_data;
+		
+		case 0xBC: // CP HXY
+			data = ixy >> 8;
+			goto cp_data;
+		
+		case 0xBD: // CP LXY
+			data = BYTE( ixy );
+			goto cp_data;
+		
+	// LD
+		CASE7( 70, 71, 72, 73, 74, 75, 77 ): // LD (IXY+disp),r
+			data = R8( data, 0x70 );
+			if ( 0 )
+		case 0x36: // LD (IXY+disp),imm
+				pc++, data = READ_CODE( pc );
+			pc++;
+			WRITE_MEM( IXY_DISP( ixy, SBYTE( data2 ) ), data );
+			goto loop;
+
+		CASE5( 44, 4C, 54, 5C, 7C ): // LD r,HXY
+			R8( data >> 3, 8 ) = ixy >> 8;
+			goto loop;
+		
+		case 0x64: // LD HXY,HXY
+		case 0x6D: // LD LXY,LXY
+			goto loop;
+		
+		CASE5( 45, 4D, 55, 5D, 7D ): // LD r,LXY
+			R8( data >> 3, 8 ) = ixy;
+			goto loop;
+		
+		CASE7( 46, 4E, 56, 5E, 66, 6E, 7E ): // LD r,(IXY+disp)
+			pc++;
+			R8( data >> 3, 8 ) = READ_MEM( IXY_DISP( ixy, SBYTE( data2 ) ) );
+			goto loop;
+		
+		case 0x26: // LD HXY,imm
+			pc++;
+			goto ld_hxy_data;
+			
+		case 0x65: // LD HXY,LXY
+			data2 = BYTE( ixy );
+			goto ld_hxy_data;
+		
+		CASE5( 60, 61, 62, 63, 67 ): // LD HXY,r
+			data2 = R8( data, 0x60 );
+		ld_hxy_data:
+			ixy = BYTE( ixy ) + (data2 << 8);
+			goto set_ixy;
+		
+		case 0x2E: // LD LXY,imm
+			pc++;
+			goto ld_lxy_data;
+			
+		case 0x6C: // LD LXY,HXY
+			data2 = ixy >> 8;
+			goto ld_lxy_data;
+		
+		CASE5( 68, 69, 6A, 6B, 6F ): // LD LXY,r
+			data2 = R8( data, 0x68 );
+		ld_lxy_data:
+			ixy = (ixy & 0xFF00) + data2;
+		set_ixy:
+			if ( opcode == 0xDD )
+			{
+				ix = ixy;
+				goto loop;
+			}
+			iy = ixy;
+			goto loop;
+
+		case 0xF9: // LD SP,IXY
+			sp = ixy;
+			goto loop;
+	
+		case 0x22:{// LD (ADDR),IXY
+			int addr = GET_ADDR();
+			pc += 2;
+			WRITE_WORD( addr, ixy );
+			goto loop;
+		}
+		
+		case 0x21: // LD IXY,imm
+			ixy = GET_ADDR();
+			pc += 2;
+			goto set_ixy;
+		
+		case 0x2A:{// LD IXY,(addr)
+			int addr = GET_ADDR();
+			ixy = READ_WORD( addr );
+			pc += 2;
+			goto set_ixy;
+		}
+		
+	// DD/FD CB prefix
+		case 0xCB: {
+			data = IXY_DISP( ixy, SBYTE( data2 ) );
+			pc++;
+			data2 = READ_CODE( pc );
+			pc++;
+			switch ( data2 )
+			{
+			case 0x06: goto rlc_data_addr; // RLC (IXY)
+			case 0x16: goto rl_data_addr;  // RL (IXY)
+			case 0x26: goto sla_data_addr; // SLA (IXY)
+			case 0x36: goto sll_data_addr; // SLL (IXY)
+			case 0x0E: goto rrc_data_addr; // RRC (IXY)
+			case 0x1E: goto rr_data_addr;  // RR (IXY)
+			case 0x2E: goto sra_data_addr; // SRA (IXY)
+			case 0x3E: goto srl_data_addr; // SRL (IXY)
+			
+			CASE8( 46, 4E, 56, 5E, 66, 6E, 76, 7E ):{// BIT b,(IXY+disp)
+				int temp = READ_MEM( data );
+				temp = temp & (1 << (data2 >> 3 & 7));
+				flags = (flags & C01) + H10 + (temp & S80);
+				flags += (unsigned) --temp >> 8 & (Z40 | P04);
+				goto loop;
+			}
+			
+			CASE8( 86, 8E, 96, 9E, A6, AE, B6, BE ): // RES b,(IXY+disp)
+			CASE8( C6, CE, D6, DE, E6, EE, F6, FE ):{// SET b,(IXY+disp)
+				int temp = READ_MEM( data );
+				int bit = 1 << (data2 >> 3 & 7);
+				temp |= bit; // SET
+				if ( !(data2 & 0x40) )
+					temp ^= bit; // RES
+				WRITE_MEM( data, temp );
+				goto loop;
+			}
+			
+			default:
+				dprintf( "Opcode $%02X $CB $%02X not supported\n", opcode, data2 );
+				warning = true;
+				goto loop;
+			}
+			assert( false );
+		}
+		
+	// INC/DEC
+		case 0x23: // INC IXY
+			ixy = WORD( ixy + 1 );
+			goto set_ixy;
+		
+		case 0x2B: // DEC IXY
+			ixy = WORD( ixy - 1 );
+			goto set_ixy;
+		
+		case 0x34: // INC (IXY+disp)
+			ixy = IXY_DISP( ixy, SBYTE( data2 ) );
+			pc++;
+			data = READ_MEM( ixy ) + 1;
+			WRITE_MEM( ixy, data );
+			goto inc_set_flags;
+		
+		case 0x35: // DEC (IXY+disp)
+			ixy = IXY_DISP( ixy, SBYTE( data2 ) );
+			pc++;
+			data = READ_MEM( ixy ) - 1;
+			WRITE_MEM( ixy, data );
+			goto dec_set_flags;
+		
+		case 0x24: // INC HXY
+			ixy = WORD( ixy + 0x100 );
+			data = ixy >> 8;
+			goto inc_xy_common;
+		
+		case 0x2C: // INC LXY
+			data = BYTE( ixy + 1 );
+			ixy = (ixy & 0xFF00) + data;
+		inc_xy_common:
+			if ( opcode == 0xDD )
+			{
+				ix = ixy;
+				goto inc_set_flags;
+			}
+			iy = ixy;
+			goto inc_set_flags;
+		
+		case 0x25: // DEC HXY
+			ixy = WORD( ixy - 0x100 );
+			data = ixy >> 8;
+			goto dec_xy_common;
+		
+		case 0x2D: // DEC LXY
+			data = BYTE( ixy - 1 );
+			ixy = (ixy & 0xFF00) + data;
+		dec_xy_common:
+			if ( opcode == 0xDD )
+			{
+				ix = ixy;
+				goto dec_set_flags;
+			}
+			iy = ixy;
+			goto dec_set_flags;
+		
+	// PUSH/POP
+		case 0xE5: // PUSH IXY
+			data = ixy;
+			goto push_data;
+		
+		case 0xE1:{// POP IXY
+			ixy = READ_WORD( sp );
+			sp = WORD( sp + 2 );
+			goto set_ixy;
+		}
+	
+	// Misc
+		
+		case 0xE9: // JP (IXY)
+			pc = ixy;
+			goto loop;
+		
+		case 0xE3:{// EX (SP),IXY
+			int temp = READ_WORD( sp );
+			WRITE_WORD( sp, ixy );
+			ixy = temp;
+			goto set_ixy;
+		}
+		
+		default:
+			dprintf( "Unnecessary DD/FD prefix encountered\n" );
+			warning = true;
+			pc--;
+			goto loop;
+		}
+		assert( false );
+	}
+	
+	}
+	dprintf( "Unhandled main opcode: $%02X\n", opcode );
+	assert( false );
+	
+#ifdef IDLE_ADDR
+hit_idle_addr:
+	s_time -= 11;
+	goto out_of_time;
+#endif
+halt:
+	s_time &= 3; // increment by multiple of 4
+out_of_time:
+	pc--;
+	
+	r.b.flags = flags;
+	R.ix     = ix;
+	R.iy     = iy;
+	R.sp     = sp;
+	R.pc     = pc;
+	R.b      = r.b;
+	
+	CPU.cpu_state_.base = s.base;
+	CPU.cpu_state_.time = s_time;
+	CPU.cpu_state = &CPU.cpu_state_;
+}
diff -Nur orig/source/host.cpp mod/source/host.cpp
--- orig/source/host.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/host.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: host.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -29,7 +29,8 @@
 #include "network.h"
 #include "cl_local.h"
 #include "ui.h"
-#include "svnrev.h"
+#include "gitrev.h"
+#include <time.h>
 
 // MACROS ------------------------------------------------------------------
 
@@ -94,7 +95,7 @@
 
 static VCvarI	respawnparm("RespawnMonsters", "0");	// checkparm of -respawn
 static VCvarI	randomclass("RandomClass", "0");		// checkparm of -randclass
-static VCvarI	fastparm("Fast", "0");				// checkparm of -fast
+static VCvarI	fastparm("Fast", "0");					// checkparm of -fast
 
 static VCvarI	show_time("show_time", "0");
 
@@ -107,6 +108,21 @@
 
 //==========================================================================
 //
+//	Host_PrintVersion
+//
+//==========================================================================
+
+void Host_PrintVersion()
+{
+	dprintf("%s\n", "VAVOOM version " VERSION_TEXT" (r" GIT_DESCRIPTION ").");
+	#ifdef SPECIAL_VERSION_TEXT
+		dprintf("%s\n", SPECIAL_VERSION_TEXT".");
+	#endif
+		dprintf("%s\n", "Compiled " __DATE__" " __TIME__".");
+}
+
+//==========================================================================
+//
 //	Host_Init
 //
 //==========================================================================
@@ -135,7 +151,14 @@
 	OpenDebugFile("basev/debug.txt");
 #endif
 
-	// init subsystems
+   // Seed the random-number generator with the current time so that
+   // the numbers will be different every time we run.
+   srand((unsigned)time(NULL));
+
+   Host_PrintVersion();
+   dprintf("Running Host_Init\n");
+   
+   // init subsystems
 
 	M_InitByteOrder();
 
@@ -250,10 +273,19 @@
 
 	realtime += time;
 
-	if (!real_time)
+	if (real_time)
 	{
-		if (realtime - oldrealtime < 0.027777f/*1.0 / 36.0*/)
+		if (realtime - oldrealtime < 1.0 / 90.0)
+		{
 			return false;		// framerate is too high
+		}
+	}
+	else
+	{
+		if (realtime - oldrealtime < 1.0 / 35.0)
+		{
+			return false;		// framerate is too high
+		}
 	}
 
 	host_frametime = realtime - oldrealtime;
@@ -265,9 +297,13 @@
 	else
 	{	// don't allow really long or short frames
 		if (host_frametime > 0.1)
+		{
 			host_frametime = 0.1;
+		}
 		if (host_frametime < 0.001)
+		{
 			host_frametime = 0.001;
+		}
 	}
 	
 	int			thistime;
@@ -276,9 +312,13 @@
 	thistime = (int)(realtime * TICRATE);
 	host_frametics = thistime - lasttime;
 	if (!real_time && host_frametics < 1)
+	{
 		return false;		//	No tics to run
+	}
 	if (host_frametics > 3)
+	{
 		host_frametics = 3;	//	Don't run too slow
+	}
 	oldrealtime = realtime;
 	lasttime = thistime;
 
@@ -336,9 +376,6 @@
 
 	try
 	{
-		//	Keep the random time dependent
-		rand();
-
 		//	Decide the simulation time
 		if (!FilterTime())
 		{
@@ -377,10 +414,10 @@
 		if (GGameInfo->NetMode != NM_None &&
 			GGameInfo->NetMode != NM_Client)
 		{
-clock(host_cycles[0]);
+clock_cycle(host_cycles[0]);
 			//	Server operations
 			ServerFrame(host_frametics);
-unclock(host_cycles[0]);
+unclock_cycle(host_cycles[0]);
 		}
 #endif
 
@@ -398,12 +435,16 @@
 
 		//	Update video
 		if (show_time)
+		{
 			time1 = Sys_Time();
+		}
 
 		SCR_Update();
 
 		if (show_time)
+		{
 			time2 = Sys_Time();
+		}
 
 		if (cls.signon)
 		{
@@ -522,8 +563,8 @@
 
 COMMAND(Version)
 {
-	GCon->Log("VAVOOM version " VERSION_TEXT" (r" SVN_REVISION_STRING ").");
-	GCon->Log("Compiled "__DATE__" "__TIME__".");
+	GCon->Log("VAVOOM version " VERSION_TEXT" (r" REVISION GIT_HASH ").");
+	GCon->Log("Compiled " __DATE__ " " __TIME__ ".");
 }
 
 //==========================================================================
diff -Nur orig/source/host.h mod/source/host.h
--- orig/source/host.h	2008-11-26 20:04:42.000000000 +0100
+++ mod/source/host.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: host.h 3871 2008-11-26 19:09:25Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/iline.cpp mod/source/iline.cpp
--- orig/source/iline.cpp	2006-06-27 21:47:25.000000000 +0200
+++ mod/source/iline.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: iline.cpp 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/iline.h mod/source/iline.h
--- orig/source/iline.h	2006-06-27 21:47:25.000000000 +0200
+++ mod/source/iline.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: iline.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/in_alleg.cpp mod/source/in_alleg.cpp
--- orig/source/in_alleg.cpp	2008-06-15 02:09:26.000000000 +0200
+++ mod/source/in_alleg.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: in_alleg.cpp 3694 2008-06-15 00:09:53Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/infostr.cpp mod/source/infostr.cpp
--- orig/source/infostr.cpp	2009-11-11 21:56:56.000000000 +0100
+++ mod/source/infostr.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: infostr.cpp 4099 2009-11-11 20:58:30Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/infostr.h mod/source/infostr.h
--- orig/source/infostr.h	2006-06-27 21:47:25.000000000 +0200
+++ mod/source/infostr.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: infostr.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/in_input.cpp mod/source/in_input.cpp
--- orig/source/in_input.cpp	2010-11-30 12:36:12.000000000 +0100
+++ mod/source/in_input.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: in_input.cpp 4336 2010-09-17 21:54:34Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/input.h mod/source/input.h
--- orig/source/input.h	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/input.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: input.h 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/in_sdl.cpp mod/source/in_sdl.cpp
--- orig/source/in_sdl.cpp	2009-01-03 20:21:48.000000000 +0100
+++ mod/source/in_sdl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: in_sdl.cpp 3483 2008-04-10 18:03:34Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2002 J306nis Legzdi267375
 //**
diff -Nur orig/source/in_win32.cpp mod/source/in_win32.cpp
--- orig/source/in_win32.cpp	2008-05-24 16:33:42.000000000 +0200
+++ mod/source/in_win32.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: in_win32.cpp 3662 2008-05-21 21:50:15Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/language.cpp mod/source/language.cpp
--- orig/source/language.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/language.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: language.cpp 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/language.h mod/source/language.h
--- orig/source/language.h	2008-01-06 14:28:37.000000000 +0100
+++ mod/source/language.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: language.h 2975 2008-01-03 16:24:30Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/level.cpp mod/source/level.cpp
--- orig/source/level.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/level.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: level.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -73,8 +73,7 @@
 	do
 	{
 		const node_t* node = Nodes + nodenum;
-		nodenum = node->children[point.x * node->normal.x +
-			point.y * node->normal.y < node->dist];
+		nodenum = node->children[node->PointOnSide(point)];
 	}
 	while (!(nodenum & NF_SUBSECTOR));
 	return &Subsectors[nodenum & ~NF_SUBSECTOR];
@@ -112,7 +111,6 @@
 {
 	guard(VLevel::Serialise);
 	int i;
-	int j;
 	sector_t* sec;
 	line_t* li;
 	side_t* si;
@@ -120,7 +118,7 @@
 	//
 	//	Sectors
 	//
-	guard(Sectors);
+	guard(VLevel::Serialise::Sectors);
 	for (i = 0, sec = Sectors; i < NumSectors; i++, sec++)
 	{
 		Strm << sec->floor.dist
@@ -187,7 +185,7 @@
 	//
 	//	Lines
 	//
-	guard(Lines);
+	guard(VLevel::Serialise::Lines);
 	for (i = 0, li = Lines; i < NumLines; i++, li++)
 	{
 		Strm << li->flags
@@ -200,7 +198,7 @@
 			<< li->arg5
 			<< li->LineTag
 			<< li->alpha;
-		for (j = 0; j < 2; j++)
+		for (int j = 0; j < 2; j++)
 		{
 			if (li->sidenum[j] == -1)
 			{
@@ -229,7 +227,7 @@
 	//
 	//	Polyobjs
 	//
-	guard(Polyobjs);
+	guard(VLevel::Serialise::Polyobjs);
 	for (i = 0; i < NumPolyObjs; i++)
 	{
 		if (Strm.IsLoading())
@@ -257,7 +255,7 @@
 	//
 	//	Static lights
 	//
-	guard(StaticLights);
+	guard(VLevel::Serialise::StaticLights);
 	Strm << STRM_INDEX(NumStaticLights);
 	if (Strm.IsLoading())
 	{
@@ -271,7 +269,7 @@
 			StaticLights = new rep_light_t[NumStaticLights];
 		}
 	}
-	for (int i = 0; i < NumStaticLights; i++)
+	for (i = 0; i < NumStaticLights; i++)
 	{
 		Strm << StaticLights[i].Origin
 			<< StaticLights[i].Radius
@@ -282,14 +280,14 @@
 	//
 	//	ACS
 	//
-	guard(ACS);
+	guard(VLevel::Serialise::ACS);
 	Acs->Serialise(Strm);
 	unguard;
 
 	//
 	//	Camera textures
 	//
-	guard(CameraTextures);
+	guard(VLevel::Serialise::CameraTextures);
 	int NumCamTex = CameraTextures.Num();
 	Strm << STRM_INDEX(NumCamTex);
 	if (Strm.IsLoading())
@@ -307,7 +305,7 @@
 	//
 	//	Translation tables
 	//
-	guard(Translations);
+	guard(VLevel::Serialise::Translations);
 	int NumTrans = Translations.Num();
 	Strm << STRM_INDEX(NumTrans);
 	if (Strm.IsLoading())
@@ -339,7 +337,7 @@
 	//
 	//	Body queue translation tables
 	//
-	guard(BoduQueueTranslations);
+	guard(VLevel::Serialise::BodyQueueTranslations);
 	int NumTrans = BodyQueueTrans.Num();
 	Strm << STRM_INDEX(NumTrans);
 	if (Strm.IsLoading())
@@ -371,7 +369,7 @@
 	//
 	//	Zones
 	//
-	guard(Zones);
+	guard(VLevel::Serialise::Zones);
 	for (i = 0; i < NumZones; i++)
 	{
 		Strm << STRM_INDEX(Zones[i]);
@@ -466,8 +464,14 @@
 			{
 				polyblock_t* Next = pb->next;
 				delete pb;
-				pb = NULL;
-				pb = Next;
+				if (Next)
+				{
+					pb = Next;
+				}
+				else
+				{
+					pb = NULL;
+				}
 			}
 		}
 		delete[] PolyBlockMap;
@@ -1017,13 +1021,25 @@
 	src = line->frontsector;
 	src->SectorFlags |= sector_t::SF_ExtrafloorSource;
 	dst->SectorFlags |= sector_t::SF_HasExtrafloors;
+
 	float floorz = src->floor.GetPointZ(dst->soundorg);
 	float ceilz = src->ceiling.GetPointZ(dst->soundorg);
+
+	// Swap planes for 3d floors like those of GZDoom
+	if (floorz < ceilz)
+	{
+		SwapPlanes(src);
+		floorz = src->floor.GetPointZ(dst->soundorg);
+		ceilz = src->ceiling.GetPointZ(dst->soundorg);
+		GCon->Logf("Swapped planes for tag: %d, ceilz: %f, floorz: %f", line->arg1, ceilz, floorz);
+	}
+
 	for (inregion = dst->botregion; inregion; inregion = inregion->next)
 	{
 		float infloorz = inregion->floor->GetPointZ(dst->soundorg);
 		float inceilz = inregion->ceiling->GetPointZ(dst->soundorg);
-		if (infloorz <= ceilz && inceilz >= floorz)
+
+		if (infloorz <= floorz && inceilz >= ceilz)
 		{
 			region = new sec_region_t;
 			memset(region, 0, sizeof(*region));
@@ -1032,6 +1048,7 @@
 			region->params = &src->params;
 			region->extraline = line;
 			inregion->floor = &src->floor;
+
 			if (inregion->prev)
 			{
 				inregion->prev->next = region;
@@ -1043,6 +1060,7 @@
 			region->prev = inregion->prev;
 			region->next = inregion;
 			inregion->prev = region;
+
 			return region;
 		}
 		// Check for sloped floor
@@ -1057,6 +1075,7 @@
 				region->params = &src->params;
 				region->extraline = line;
 				inregion->floor = &src->floor;
+
 				if (inregion->prev)
 				{
 					inregion->prev->next = region;
@@ -1068,8 +1087,13 @@
 				region->prev = inregion->prev;
 				region->next = inregion;
 				inregion->prev = region;
+
 				return region;
 			}
+			/*else
+			{
+				GCon->Logf("tag: %d, floor->maxz: %f, ceiling.minz: %f, ceiling->maxz: %f, floor.minz: %f", line->arg1, inregion->floor->maxz, src->ceiling.minz, inregion->ceiling->maxz, src->floor.minz);
+			}*/
 		}
 		// Check for sloped ceiling
 		else if (inregion->ceiling->normal.z != -1.0)
@@ -1083,6 +1107,7 @@
 				region->params = &src->params;
 				region->extraline = line;
 				inregion->floor = &src->floor;
+
 				if (inregion->prev)
 				{
 					inregion->prev->next = region;
@@ -1094,11 +1119,21 @@
 				region->prev = inregion->prev;
 				region->next = inregion;
 				inregion->prev = region;
+
 				return region;
 			}
+			/*else
+			{
+				GCon->Logf("tag: %d, floor->minz: %f, ceiling.maxz: %f, ceiling->minz: %f, floor.maxz: %f", line->arg1, inregion->floor->minz, src->ceiling.maxz, inregion->ceiling->minz, src->floor.maxz);
+			}*/
 		}
+		/*else
+		{
+			GCon->Logf("tag: %d, infloorz: %f, ceilz: %f, inceilz: %f, floorz: %f", line->arg1, infloorz, ceilz, inceilz, floorz);
+		}*/
 	}
 	GCon->Logf("Invalid extra floor, tag %d", dst->tag);
+
 	return NULL;
 	unguard;
 }
diff -Nur orig/source/level.h mod/source/level.h
--- orig/source/level.h	2009-12-23 15:27:40.000000000 +0100
+++ mod/source/level.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: level.h 4120 2009-12-24 14:28:21Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/l_glbsp.cpp mod/source/l_glbsp.cpp
--- orig/source/l_glbsp.cpp	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/l_glbsp.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: l_glbsp.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/l_glvis.cpp mod/source/l_glvis.cpp
--- orig/source/l_glvis.cpp	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/l_glvis.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: l_glvis.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/lockdefs.cpp mod/source/lockdefs.cpp
--- orig/source/lockdefs.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/lockdefs.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: lockdefs.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/lockdefs.h mod/source/lockdefs.h
--- orig/source/lockdefs.h	2007-08-05 12:31:32.000000000 +0200
+++ mod/source/lockdefs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: lockdefs.h 2577 2007-08-05 10:32:29Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/mapinfo.cpp mod/source/mapinfo.cpp
--- orig/source/mapinfo.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/mapinfo.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: mapinfo.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -1532,9 +1532,32 @@
 //
 //==========================================================================
 
-const char* P_GetMapName(int map)
+VStr P_GetMapName(int map)
 {
-	return *MapInfo[QualifyMap(map)].GetName();
+	return MapInfo[QualifyMap(map)].GetName();
+}
+
+//==========================================================================
+//
+//	P_GetMapInfoIndexByLevelNum
+//
+//	Returns map info index given a level number
+//
+//==========================================================================
+
+int P_GetMapIndexByLevelNum(int map)
+{
+	guard(P_GetMapNameByLevelNum);
+	for (int i = 0; i < MapInfo.Num(); i++)
+	{
+		if (MapInfo[i].LevelNum == map)
+		{
+			return i;
+		}
+	}
+	// Not found
+	return 0;
+	unguard;
 }
 
 //==========================================================================
@@ -1552,7 +1575,7 @@
 //
 // P_TranslateMap
 //
-// Returns the actual map number given a warp map number.
+// Returns the map lump name given a warp map number.
 //
 //==========================================================================
 
@@ -1573,13 +1596,13 @@
 
 //==========================================================================
 //
-//	P_GetMapNameByLevelNum
+//	P_GetMapLumpNameByLevelNum
 //
-//	Returns the actual map name given a level number.
+//	Returns the map lump name given a level number.
 //
 //==========================================================================
 
-VName P_GetMapNameByLevelNum(int map)
+VName P_GetMapLumpNameByLevelNum(int map)
 {
 	guard(P_GetMapNameByLevelNum);
 	for (int i = 0; i < MapInfo.Num(); i++)
diff -Nur orig/source/mapinfo.h mod/source/mapinfo.h
--- orig/source/mapinfo.h	2008-07-18 22:20:30.000000000 +0200
+++ mod/source/mapinfo.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: mapinfo.h 3729 2008-07-18 20:21:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -202,10 +202,11 @@
 void InitMapInfo();
 void ShutdownMapInfo();
 const mapInfo_t& P_GetMapInfo(VName);
-const char* P_GetMapName(int);
+VStr P_GetMapName(int);
 VName P_GetMapLumpName(int);
+int P_GetMapIndexByLevelNum(int);
 VName P_TranslateMap(int);
-VName P_GetMapNameByLevelNum(int);
+VName P_GetMapLumpNameByLevelNum(int);
 void P_PutMapSongLump(int, VName);
 const VClusterDef* P_GetClusterDef(int);
 int P_GetNumEpisodes();
diff -Nur orig/source/maths.cpp mod/source/maths.cpp
--- orig/source/maths.cpp	2010-12-15 23:20:47.000000000 +0100
+++ mod/source/maths.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: maths.cpp 4341 2010-12-15 22:20:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/maths.h mod/source/maths.h
--- orig/source/maths.h	2010-12-15 23:20:47.000000000 +0100
+++ mod/source/maths.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: maths.h 4341 2010-12-15 22:20:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -219,7 +219,7 @@
 	//	Returns side 0 (front) or 1 (back).
 	int PointOnSide(const TVec& point) const
 	{
-		return DotProduct(point, normal) - dist < 0;
+		return DotProduct(point, normal) - dist <= 0;
 	}
 
 	//	Returns side 0 (front), 1 (back), or 2 (on).
diff -Nur orig/source/menu.cpp mod/source/menu.cpp
--- orig/source/menu.cpp	2008-12-01 21:19:11.000000000 +0100
+++ mod/source/menu.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: menu.cpp 3883 2008-12-01 20:23:04Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/menu.h mod/source/menu.h
--- orig/source/menu.h	2006-12-05 18:51:21.000000000 +0100
+++ mod/source/menu.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: menu.h 1878 2006-12-05 09:25:14Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/misc.cpp mod/source/misc.cpp
--- orig/source/misc.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/misc.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: misc.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -119,7 +119,7 @@
 
 void VLogSysError::Serialise(const char* V, EName)
 {
-	Sys_Error(V);
+	Sys_Error("%s", V);
 }
 
 //==========================================================================
@@ -130,7 +130,7 @@
 
 void VLogHostError::Serialise(const char* V, EName)
 {
-	Host_Error(V);
+	Host_Error("%s", V);
 }
 
 //==========================================================================
@@ -569,7 +569,7 @@
 		break;
 	case 1:
 		r = q;
-		b = v;
+		g = v;
 		b = p;
 		break;
 	case 2:
diff -Nur orig/source/misc.h mod/source/misc.h
--- orig/source/misc.h	2010-04-04 10:18:00.000000000 +0200
+++ mod/source/misc.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: misc.h 4215 2010-04-04 08:22:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_channel_control.cpp mod/source/net_channel_control.cpp
--- orig/source/net_channel_control.cpp	2008-08-07 21:36:16.000000000 +0200
+++ mod/source/net_channel_control.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_channel_control.cpp 2218 2007-04-29 15:05:21Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_channel.cpp mod/source/net_channel.cpp
--- orig/source/net_channel.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/net_channel.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_channel.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -83,15 +83,27 @@
 	{
 		VMessageIn* Next = Msg->Next;
 		delete Msg;
-		Msg = NULL;
-		Msg = Next;
+		if (Next)
+		{
+			Msg = Next;
+		}
+		else
+		{
+			Msg = NULL;
+		}
 	}
 	for (VMessageOut* Msg = OutMsg; Msg; )
 	{
 		VMessageOut* Next = Msg->Next;
 		delete Msg;
-		Msg = NULL;
-		Msg = Next;
+		if (Next)
+		{
+			Msg = Next;
+		}
+		else
+		{
+			Msg = NULL;
+		}
 	}
 	if (Index != -1 && Connection->Channels[Index] == this)
 	{
@@ -305,7 +317,7 @@
 	Msg.WriteInt(Func->NetIndex, Owner->GetClass()->NumNetFields);
 
 	//	Serialise arguments
-	guard(SerialiseArguments);
+	guard(VChannel::SendRpc::SerialiseArguments);
 	VStack* Param = pr_stackPtr - Func->ParamsSize + 1;	//	Skip self
 	for (int i = 0; i < Func->NumParams; i++)
 	{
diff -Nur orig/source/net_channel_level.cpp mod/source/net_channel_level.cpp
--- orig/source/net_channel_level.cpp	2008-12-01 21:43:51.000000000 +0100
+++ mod/source/net_channel_level.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_channel_level.cpp 3884 2008-12-01 20:47:53Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_channel_object_map.cpp mod/source/net_channel_object_map.cpp
--- orig/source/net_channel_object_map.cpp	2008-10-27 18:37:34.000000000 +0100
+++ mod/source/net_channel_object_map.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_channel_object_map.cpp 3854 2008-10-27 17:40:33Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -144,12 +144,12 @@
 			{
 				return;
 			}
-			int Cnt = 0;
+			int Cnt_msg = 0;
 			for (VMessageOut* M = OutMsg; M; M = M->Next)
 			{
-				Cnt++;
+				Cnt_msg++;
 			}
-			if (Cnt >= 10)
+			if (Cnt_msg >= 10)
 			{
 				return;
 			}
@@ -168,12 +168,12 @@
 		if (Msg.GetNumBytes() + 4 > OUT_MESSAGE_SIZE / 8)
 		{
 			SendMessage(&Msg);
-			int Cnt = 0;
+			int Cnt_msg = 0;
 			for (VMessageOut* M = OutMsg; M; M = M->Next)
 			{
-				Cnt++;
+				Cnt_msg++;
 			}
-			if (Cnt >= 10)
+			if (Cnt_msg >= 10)
 			{
 				return;
 			}
diff -Nur orig/source/net_channel_player.cpp mod/source/net_channel_player.cpp
--- orig/source/net_channel_player.cpp	2008-12-17 20:19:00.000000000 +0100
+++ mod/source/net_channel_player.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_channel_player.cpp 3892 2008-12-17 19:27:17Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_channel_thinker.cpp mod/source/net_channel_thinker.cpp
--- orig/source/net_channel_thinker.cpp	2008-12-17 20:19:00.000000000 +0100
+++ mod/source/net_channel_thinker.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_channel_thinker.cpp 3892 2008-12-17 19:27:17Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -186,7 +186,7 @@
 	{
 		Thinker->ThinkerFlags |= VThinker::TF_NetInitial;
 	}
-	if (Ent && Ent->GetTopOwner() == Connection->Owner->MO)
+	if (Ent != NULL && Ent->GetTopOwner() == Connection->Owner->MO)
 	{
 		Thinker->ThinkerFlags |= VThinker::TF_NetOwner;
 	}
diff -Nur orig/source/net_connection.cpp mod/source/net_connection.cpp
--- orig/source/net_connection.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/net_connection.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_connection.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -167,7 +167,7 @@
 				vuint8 LastByte = Data[Data.Num() - 1];
 				if (LastByte)
 				{
-					//	Find out real length by stepping back untill the trailing bit.
+					//	Find out real length by stepping back until the trailing bit.
 					vuint32 Length = Data.Num() * 8 - 1;
 					for (vuint8 Mask = 0x80; !(LastByte & Mask); Mask >>= 1)
 					{
@@ -614,7 +614,7 @@
 void VNetConnection::SetUpFatPVS()
 {
 	guard(VNetConnection::SetUpFatPVS);
-	float	dummy_bbox[6] = {-99999, -99999, -99999, 99999, 99999, 99999};
+	float	dummy_bbox[6] = { -99999, -99999, -99999, 99999, 99999, 99999 };
 	VLevel*	Level = Context->GetLevel();
 
 	LeafPvs = Level->LeafPVS(Owner->MO->SubSector);
@@ -652,15 +652,14 @@
 	{
 		return;
 	}
-	if (!Clipper.ClipIsBBoxVisible(BBox))
+	if (!Clipper.ClipIsBBoxVisible(BBox, false))
 	{
 		return;
 	}
 
-	// Found a subsector?
-	if (BspNum & NF_SUBSECTOR)
+	if (BspNum == -1)
 	{
-		int SubNum = BspNum == -1 ? 0 : BspNum & ~NF_SUBSECTOR;
+		int SubNum = 0;
 		subsector_t* Sub = &Level->Subsectors[SubNum];
 		if (!Sub->sector->linecount)
 		{
@@ -672,15 +671,18 @@
 			return;
 		}
 
-		if (!Clipper.ClipCheckSubsector(Sub))
+		if (!Clipper.ClipCheckSubsector(Sub, false))
 		{
 			return;
 		}
-		Clipper.ClipAddSubsectorSegs(Sub);
+		Clipper.ClipAddSubsectorSegs(Sub, false);
 		UpdatePvs[SubNum >> 3] |= 1 << (SubNum & 7);
 		return;
 	}
 
+	// Found a subsector?
+	if (!(BspNum & NF_SUBSECTOR))
+	{
 	node_t* Bsp = &Level->Nodes[BspNum];
 
 	// Decide which side the view point is on.
@@ -689,8 +691,34 @@
 	// Recursively divide front space.
 	SetUpPvsNode(Bsp->children[Side], Bsp->bbox[Side]);
 
-	// Divide back space.
+	// Possibly divide back space.
+	if (!Clipper.ClipIsBBoxVisible(Bsp->bbox[Side ^ 1], false))
+	{
+		return;
+	}
 	SetUpPvsNode(Bsp->children[Side ^ 1], Bsp->bbox[Side ^ 1]);
+
+		return;
+	}
+
+	int SubNum = BspNum & ~NF_SUBSECTOR;
+	subsector_t* Sub = &Level->Subsectors[SubNum];
+	if (!Sub->sector->linecount)
+	{
+		//	Skip sectors containing original polyobjs
+		return;
+	}
+	if (!(LeafPvs[SubNum >> 3] & (1 << (SubNum & 7))))
+	{
+		return;
+	}
+
+	if (!Clipper.ClipCheckSubsector(Sub, false))
+	{
+		return;
+	}
+	Clipper.ClipAddSubsectorSegs(Sub, false);
+	UpdatePvs[SubNum >> 3] |= 1 << (SubNum & 7);
 	unguard;
 }
 
diff -Nur orig/source/net_context.cpp mod/source/net_context.cpp
--- orig/source/net_context.cpp	2008-11-29 21:11:02.000000000 +0100
+++ mod/source/net_context.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_context.cpp 3875 2008-11-29 20:14:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_datagram.cpp mod/source/net_datagram.cpp
--- orig/source/net_datagram.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/net_datagram.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_datagram.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -167,8 +167,8 @@
 
 // PRIVATE DATA DEFINITIONS ------------------------------------------------
 
-static VCvarI			UseMaster("use_master", "0", CVAR_Archive);
-static VCvarS			MasterSrv("master_srv", "127.0.0.1", CVAR_Archive);
+static VCvarI			UseMaster("use_master", "1", CVAR_Archive);
+static VCvarS			MasterSrv("master_srv", "altdeath.com", CVAR_Archive);
 
 static VDatagramDriver	Impl;
 
@@ -921,7 +921,7 @@
 		}
 		// send the query request
 		VBitStreamWriter MsgOut(256 << 3);
-		vuint8 TmpByte = MCREQ_LIST;
+		TmpByte = MCREQ_LIST;
 		MsgOut << TmpByte;
 		Drv->Write(Drv->MasterQuerySocket, MsgOut.GetData(),
 			MsgOut.GetNumBytes(), &sendaddr);
diff -Nur orig/source/net_demo.cpp mod/source/net_demo.cpp
--- orig/source/net_demo.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/net_demo.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_demo.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_local.h mod/source/net_local.h
--- orig/source/net_local.h	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/net_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_local.h 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_loopback.cpp mod/source/net_loopback.cpp
--- orig/source/net_loopback.cpp	2008-11-26 21:59:16.000000000 +0100
+++ mod/source/net_loopback.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_loopback.cpp 3874 2008-11-26 21:03:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_main.cpp mod/source/net_main.cpp
--- orig/source/net_main.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/net_main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_main.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_message.cpp mod/source/net_message.cpp
--- orig/source/net_message.cpp	2007-04-29 17:13:06.000000000 +0200
+++ mod/source/net_message.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_message.cpp 2220 2007-04-29 15:15:09Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_message.h mod/source/net_message.h
--- orig/source/net_message.h	2007-04-29 17:13:06.000000000 +0200
+++ mod/source/net_message.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_message.h 2220 2007-04-29 15:15:09Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_object_map.cpp mod/source/net_object_map.cpp
--- orig/source/net_object_map.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/net_object_map.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_object_map.cpp 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_udp.cpp mod/source/net_udp.cpp
--- orig/source/net_udp.cpp	2008-10-22 23:53:36.000000000 +0200
+++ mod/source/net_udp.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_udp.cpp 3845 2008-10-22 21:56:30Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/net_winsock.cpp mod/source/net_winsock.cpp
--- orig/source/net_winsock.cpp	2010-12-23 20:47:55.000000000 +0100
+++ mod/source/net_winsock.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: net_winsock.cpp 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -109,16 +109,15 @@
 int VWinSockDriver::Init()
 {
 	guard(VWinSockDriver::Init);
-	int		i;
 	char	buff[MAXHOSTNAMELEN];
 	char	*p;
-	int		r;
 
 	if (GArgs.CheckParm("-noudp"))
 		return -1;
 
 	if (winsock_initialised == 0)
 	{
+		int		r;
 		//MAKEWORD(2, 2)
 		r = WSAStartup(MAKEWORD(1, 1), &winsockdata);
 
@@ -150,6 +149,7 @@
 		// if it is a real name, strip off the domain; we only want the host
 		if (*p)
 		{
+			int i;
 			for (i = 0; i < 15; i++)
 				if (buff[i] == '.')
 					break;
diff -Nur orig/source/network.h mod/source/network.h
--- orig/source/network.h	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/network.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: network.h 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_acs.cpp mod/source/p_acs.cpp
--- orig/source/p_acs.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/p_acs.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_acs.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -641,9 +641,9 @@
 	{
 		int count = LittleLong(buffer[1]) / 4;
 		buffer += 2;
-		for (int i = 0; i < count; i++, buffer++)
+		for (i = 0; i < count; i++, buffer++)
 		{
-			VAcsInfo* info = FindScript(LittleShort(((word*)buffer)[0]));
+			info = FindScript(LittleShort(((word*)buffer)[0]));
 			if (info)
 			{
 				info->Flags = LittleShort(((word*)buffer)[1]);
@@ -659,7 +659,7 @@
 		buffer += 2;
 		for (i = 0; i < count; i++, buffer++)
 		{
-			VAcsInfo* info = FindScript(LittleShort(((word*)buffer)[0]));
+			info = FindScript(LittleShort(((word*)buffer)[0]));
 			if (info)
 			{
 				info->VarCount = LittleShort(((word*)buffer)[1]);
@@ -814,7 +814,7 @@
 	buffer = (int*)FindChunk("LOAD");
 	if (buffer)
 	{
-		const char* const parse = (char*)&buffer[2];
+		char* parse = (char*)&buffer[2];
 		for (i = 0; i < LittleLong(buffer[1]); i++)
 		{
 			if (parse[i])
@@ -887,7 +887,7 @@
 			buffer = (int*)FindChunk("MIMP");
 			if (buffer)
 			{
-				char* parse = (char*)&buffer[2];
+				parse = (char*)&buffer[2];
 				for (j = 0; j < LittleLong(buffer[1]); j++)
 				{
 					int varNum = LittleLong(*(int*)&parse[j]);
@@ -905,7 +905,7 @@
 			if (NumTotalArrays > NumArrays)
 			{
 				buffer = (int*)FindChunk("AIMP");
-				char* parse = (char*)&buffer[3];
+				parse = (char*)&buffer[3];
 				for (j = 0; j < LittleLong(buffer[2]); j++)
 				{
 					int varNum = LittleLong(*(int*)parse);
@@ -1506,7 +1506,7 @@
 	guard(VAcsLevel::Start);
 	if (MapNum)
 	{
-		VName Map = P_GetMapNameByLevelNum(MapNum);
+		VName Map = P_GetMapLumpNameByLevelNum(MapNum);
 		if (Map != NAME_None && Map != XLevel->MapName)
 		{
 			// Add to the script store
@@ -1551,7 +1551,7 @@
 	guard(VAcsLevel::Terminate);
 	if (MapNum)
 	{
-		VName Map = P_GetMapNameByLevelNum(MapNum);
+		VName Map = P_GetMapLumpNameByLevelNum(MapNum);
 		if (Map != NAME_None && Map != XLevel->MapName)
 		{
 			// Add to the script store
@@ -1588,7 +1588,7 @@
 	guard(VAcsLevel::Suspend);
 	if (MapNum)
 	{
-		VName Map = P_GetMapNameByLevelNum(MapNum);
+		VName Map = P_GetMapLumpNameByLevelNum(MapNum);
 		if (Map != NAME_None && Map != XLevel->MapName)
 		{
 			// Add to the script store
@@ -1963,7 +1963,9 @@
 	{
 		DelayTime -= DeltaTime;
 		if (DelayTime < 0)
+		{
 			DelayTime = 0;
+		}
 		return 1;
 	}
 
@@ -1975,7 +1977,7 @@
 
 	VStr PrintStr;
 	vint32 resultValue = 1;
-	vint32 stack[ACS_STACK_DEPTH];
+	vint32 *stack = (vint32 *)Z_Calloc(ACS_STACK_DEPTH);
 	vint32* optstart = NULL;
 	vint32* locals = LocalVars;
 	VAcsFunction* activeFunction = NULL;
@@ -3305,15 +3307,27 @@
 
 		ACSVM_CASE(PCD_SetThingSpecial)
 			{
-				for (VEntity* Ent = Level->FindMobjFromTID(sp[-7], NULL);
-					Ent; Ent = Level->FindMobjFromTID(sp[-7], Ent))
+				if (sp[-7] != 0)
+				{
+					for (VEntity* Ent = Level->FindMobjFromTID(sp[-7], NULL);
+						Ent; Ent = Level->FindMobjFromTID(sp[-7], Ent))
+					{
+						Ent->Special = sp[-6];
+						Ent->Args[0] = sp[-5];
+						Ent->Args[1] = sp[-4];
+						Ent->Args[2] = sp[-3];
+						Ent->Args[3] = sp[-2];
+						Ent->Args[4] = sp[-1];
+					}
+				}
+				else if (Activator)
 				{
-					Ent->Special = sp[-6];
-					Ent->Args[0] = sp[-5];
-					Ent->Args[1] = sp[-4];
-					Ent->Args[2] = sp[-3];
-					Ent->Args[3] = sp[-2];
-					Ent->Args[4] = sp[-1];
+					Activator->Special = sp[-6];
+					Activator->Args[0] = sp[-5];
+					Activator->Args[1] = sp[-4];
+					Activator->Args[2] = sp[-3];
+					Activator->Args[3] = sp[-2];
+					Activator->Args[4] = sp[-1];
 				}
 				sp -= 7;
 			}
@@ -5038,6 +5052,7 @@
 			Host_Error("Illegal ACS opcode %d", cmd);
 		}
 	} while  (action == SCRIPT_Continue);
+
 #if USE_COMPUTED_GOTO
 LblFuncStop:
 #endif
@@ -5050,6 +5065,8 @@
 		}
 		DestroyThinker();
 	}
+
+	Z_Free(stack);
 	return resultValue;
 	unguard;
 }
diff -Nur orig/source/p_acs.h mod/source/p_acs.h
--- orig/source/p_acs.h	2009-01-05 14:08:35.000000000 +0100
+++ mod/source/p_acs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_acs.h 3948 2009-01-05 13:12:18Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_clip.cpp mod/source/p_clip.cpp
--- orig/source/p_clip.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/p_clip.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_clip.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -51,6 +51,10 @@
 
 // PRIVATE DATA DEFINITIONS ------------------------------------------------
 
+#ifdef CLIENT
+extern VCvarF r_lights_radius;
+#endif
+
 // CODE --------------------------------------------------------------------
 
 //==========================================================================
@@ -80,9 +84,14 @@
 	while (Node)
 	{
 		VClipNode* Next = Node->Next;
+
 		delete Node;
 		Node = NULL;
-		Node = Next;
+
+		if (Next)
+		{
+			Node = Next;
+		}
 	}
 	unguard;
 }
@@ -97,6 +106,7 @@
 {
 	guard(VViewClipper::NewClipNode);
 	VClipNode* Ret = FreeClipNodes;
+
 	if (Ret)
 	{
 		FreeClipNodes = Ret->Next;
@@ -105,6 +115,7 @@
 	{
 		Ret = new VClipNode();
 	}
+
 	return Ret;
 	unguard;
 }
@@ -122,14 +133,17 @@
 	{
 		Node->Next->Prev = Node->Prev;
 	}
+
 	if (Node->Prev)
 	{
 		Node->Prev->Next = Node->Next;
 	}
+
 	if (Node == ClipHead)
 	{
 		ClipHead = Node->Next;
 	}
+
 	if (Node == ClipTail)
 	{
 		ClipTail = Node->Prev;
@@ -188,27 +202,33 @@
 	TVec clipforward = Normalise(TVec(viewforward.x, viewforward.y, 0.0));
 	float d1 = 0;
 	float d2 = 0;
+
 	for (int i = 0; i < 4; i++)
 	{
 		TransPts[i].x = Pts[i].y * viewright.x + Pts[i].z * viewup.x + Pts[i].x * viewforward.x;
 		TransPts[i].y = Pts[i].y * viewright.y + Pts[i].z * viewup.y + Pts[i].x * viewforward.y;
 		TransPts[i].z = Pts[i].y * viewright.z + Pts[i].z * viewup.z + Pts[i].x * viewforward.z;
+
 		if (DotProduct(TransPts[i], clipforward) <= 0)
 		{
 			//	Player can see behind.
 			return;
 		}
 		float a = matan(TransPts[i].y, TransPts[i].x);
-		if (a < 0)
+
+		if (a < 0.0)
 			a += 360.0;
 		float d = AngleMod180(a - viewangles.yaw);
+
 		if (d1 > d)
 			d1 = d;
+
 		if (d2 < d)
 			d2 = d;
 	}
 	float a1 = AngleMod(viewangles.yaw + d1);
 	float a2 = AngleMod(viewangles.yaw + d2);
+
 	if (a1 > a2)
 	{
 		ClipHead = NewClipNode();
@@ -255,6 +275,7 @@
 	{
 		DoAddClipRange(0.0, Range.ClipHead->From);
 	}
+
 	if (Range.ClipTail->To < 360.0)
 	{
 		DoAddClipRange(Range.ClipTail->To, 360.0);
@@ -285,6 +306,7 @@
 		ClipHead->To = To;
 		ClipHead->Prev = NULL;
 		ClipHead->Next = NULL;
+
 		return;
 	}
 
@@ -304,6 +326,7 @@
 			N->To = To;
 			N->Prev = Node->Prev;
 			N->Next = Node;
+
 			if (Node->Prev)
 			{
 				Node->Prev->Next = N;
@@ -313,6 +336,7 @@
 				ClipHead = N;
 			}
 			Node->Prev = N;
+
 			return;
 		}
 
@@ -327,6 +351,7 @@
 			//	Extend start of the current range.
 			Node->From = From;
 		}
+
 		if (To <= Node->To)
 		{
 			//	End is included, so we are done here.
@@ -339,11 +364,13 @@
 			Node->To = Node->Next->To;
 			RemoveClipNode(Node->Next);
 		}
+
 		if (To > Node->To)
 		{
 			//	Extend end.
 			Node->To = To;
 		}
+
 		//	We are done here.
 		return;
 	}
@@ -442,7 +469,8 @@
 float VViewClipper::PointToClipAngle(const TVec& Pt)
 {
 	float Ret = matan(Pt.y - Origin.y, Pt.x - Origin.x);
-	if (Ret < 0)
+
+	if (Ret < 0.0)
 		Ret += 360.0;
 	return Ret;
 }
@@ -453,7 +481,8 @@
 //
 //==========================================================================
 
-bool VViewClipper::ClipIsBBoxVisible(float* BBox)
+bool VViewClipper::ClipIsBBoxVisible(float* BBox, bool shadowslight, const TVec& CurrLightPos, 
+	float CurrLightRadius)
 {
 	guard(VViewClipper::ClipIsBBoxVisible);
 	if (!ClipHead)
@@ -461,6 +490,7 @@
 		//	No clip nodes yet.
 		return true;
 	}
+
 	if (BBox[0] <= Origin.x && BBox[3] >= Origin.x &&
 		BBox[1] <= Origin.y && BBox[4] >= Origin.y)
 	{
@@ -535,37 +565,587 @@
 			v2.y = BBox[4];
 		}
 	}
+
+	// Clip sectors that are behind rendered segs
+	TVec r1 = Origin - v1;
+	TVec r2 = Origin - v2;
+	float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), Origin);
+	float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), Origin);
+
+#ifdef CLIENT
+	if (shadowslight)
+	{
+		TVec rLight1 = CurrLightPos - v1;
+		TVec rLight2 = CurrLightPos - v2;
+		float DLight1 = DotProduct(Normalise(CrossProduct(rLight1, rLight2)), CurrLightPos);
+		float DLight2 = DotProduct(Normalise(CrossProduct(rLight2, rLight1)), CurrLightPos);
+
+		TVec rView1 = Origin - CurrLightPos;
+		TVec rView2 = Origin - CurrLightPos;
+		float DView1 = DotProduct(Normalise(CrossProduct(rView1, rView2)), Origin);
+		float DView2 = DotProduct(Normalise(CrossProduct(rView2, rView1)), Origin);
+
+		if (D1 < 0.0 && D2 < 0.0 &&
+			DView1 < -CurrLightRadius && DView2 < -CurrLightRadius)
+		{
+			return false;
+		}
+
+		if (D1 > r_lights_radius && D2 > r_lights_radius)
+		{
+			return false;
+		}
+
+		if (DLight1 > CurrLightRadius && DLight2 > CurrLightRadius ||
+			DLight1 < -CurrLightRadius && DLight2 < -CurrLightRadius)
+		{
+			return false;
+		}
+
+		// There might be a better method of doing this, but
+		// this one works for now...
+		if (DLight1 > 0.0 && DLight2 <= 0.0)
+		{
+			v2 += (v2 - v1) * D1 / (D1 - D2);
+		}
+		else if (DLight2 > 0.0 && DLight1 <= 0.0)
+		{
+			v1 += (v1 - v2) * D2 / (D2 - D1);
+		}
+	}
+	else
+#endif
+	{
+		if (D1 < 0.0 && D2 < 0.0)
+		{
+			return false;
+		}
+
+		// There might be a better method of doing this, but
+		// this one works for now...
+		if (D1 > 0.0 && D2 <= 0.0)
+		{
+			v2 += (v2 - v1) * D1 / (D1 - D2);
+		}
+		else if (D2 > 0.0 && D1 <= 0.0)
+		{
+			v1 += (v1 - v2) * D2 / (D2 - D1);
+		}
+	}
+
 	return IsRangeVisible(PointToClipAngle(v1), PointToClipAngle(v2));
 	unguard;
 }
 
 //==========================================================================
 //
+//	VViewClipper::ClipCheckRegion
+//
+//==========================================================================
+
+bool VViewClipper::ClipCheckRegion(subregion_t* region, subsector_t* sub, bool shadowslight, 
+	const TVec& CurrLightPos, float CurrLightRadius)
+{
+	guard(VViewClipper::ClipCheckRegion);
+	if (!ClipHead)
+	{
+		return true;
+	}
+	vint32 count = sub->numlines;
+	drawseg_t *ds = region->lines;
+
+	while (count--)
+	{
+		TVec v1 = *ds->seg->v1;
+		TVec v2 = *ds->seg->v2;
+
+		if (!ds->seg->linedef)
+		{
+			//	Miniseg.
+			if (!IsRangeVisible(PointToClipAngle(v2),
+				PointToClipAngle(v1)))
+			{
+				ds++;
+				continue;
+			}
+		}
+
+		if (ds->seg->PointOnSide(Origin))
+		{
+			//	Viewer is in back side or on plane
+			if (!IsRangeVisible(PointToClipAngle(v2),
+				PointToClipAngle(v1)))
+			{
+				ds++;
+				continue;
+			}
+		}
+
+		// Clip sectors that are behind rendered segs
+		TVec rLight1;
+		TVec rLight2;
+		float DLight1;
+		float DLight2;
+		TVec r1 = Origin - v1;
+		TVec r2 = Origin - v2;
+		float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), Origin);
+		float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), Origin);
+
+#ifdef CLIENT
+		if (shadowslight)
+		{
+			rLight1 = CurrLightPos - v1;
+			rLight2 = CurrLightPos - v2;
+			DLight1 = DotProduct(Normalise(CrossProduct(rLight1, rLight2)), CurrLightPos);
+			DLight2 = DotProduct(Normalise(CrossProduct(rLight2, rLight1)), CurrLightPos);
+
+			TVec rView1 = Origin - CurrLightPos;
+			TVec rView2 = Origin - CurrLightPos;
+			float DView1 = DotProduct(Normalise(CrossProduct(rView1, rView2)), Origin);
+			float DView2 = DotProduct(Normalise(CrossProduct(rView2, rView1)), Origin);
+
+			if (D1 <= 0.0 && D2 <= 0.0 &&
+				DView1 < -CurrLightRadius && DView2 < -CurrLightRadius)
+			{
+				ds++;
+				continue;
+			}
+
+			if (D1 > r_lights_radius && D2 > r_lights_radius)
+			{
+				ds++;
+				continue;
+			}
+
+			if (DLight1 > CurrLightRadius && DLight2 > CurrLightRadius ||
+				DLight1 < -CurrLightRadius && DLight2 < -CurrLightRadius)
+			{
+				ds++;
+				continue;
+			}
+		}
+		else
+#endif
+		{
+			if (D1 <= 0.0 && D2 <= 0.0)
+			{
+				ds++;
+				continue;
+			}
+		}
+
+		if(!ds->seg->backsector)
+		{
+#ifdef CLIENT
+			if (shadowslight)
+			{
+				// There might be a better method of doing this, but
+				// this one works for now...
+				if (DLight1 > CurrLightRadius && DLight2 <= -CurrLightRadius)
+				{
+					v2 += (v2 - v1) * DLight1 / (DLight1 - DLight2);
+				}
+				else if (DLight2 > CurrLightRadius && DLight1 <= -CurrLightRadius)
+				{
+					v1 += (v1 - v2) * DLight2 / (DLight2 - DLight1);
+				}
+			}
+			else
+#endif
+			{
+				if (D1 > 0.0 && D2 <= 0.0)
+				{
+					v2 += (v2 - v1) * D1 / (D1 - D2);
+				}
+				else if (D2 > 0.0 && D1 <= 0.0)
+				{
+					v1 += (v1 - v2) * D2 / (D2 - D1);
+				}
+			}
+
+			if (IsRangeVisible(PointToClipAngle(v2),
+				PointToClipAngle(v1)))
+			{
+				return true;
+			}
+		}
+		else if (ds->seg->linedef && ds->seg->backsector)
+		{
+			TVec v1 = *ds->seg->linedef->v1;
+			TVec v2 = *ds->seg->linedef->v2;
+
+			// 2-sided line, determine if it can be skipped
+			if (ds->seg->linedef->backsector)
+			{
+				// Just apply this to sectors without slopes
+				if (ds->seg->linedef->frontsector->floor.normal.z == 1.0 && ds->seg->linedef->backsector->floor.normal.z == 1.0 &&
+					ds->seg->linedef->frontsector->ceiling.normal.z == -1.0 && ds->seg->linedef->backsector->ceiling.normal.z == -1.0)
+				{
+					//
+					// Check for doors
+					//
+
+					// A line without top texture isn't a door
+					if (ds->seg->sidedef->TopTexture != -1)
+					{
+						float frontcz1 = ds->seg->linedef->frontsector->ceiling.GetPointZ(v1);
+						float frontcz2 = ds->seg->linedef->frontsector->ceiling.GetPointZ(v2);
+						float frontfz1 = ds->seg->linedef->frontsector->floor.GetPointZ(v1);
+						float frontfz2 = ds->seg->linedef->frontsector->floor.GetPointZ(v2);
+
+						float backcz1 = ds->seg->linedef->backsector->ceiling.GetPointZ(v1);
+						float backcz2 = ds->seg->linedef->backsector->ceiling.GetPointZ(v2);
+						float backfz1 = ds->seg->linedef->backsector->floor.GetPointZ(v1);
+						float backfz2 = ds->seg->linedef->backsector->floor.GetPointZ(v2);
+
+						if ((backcz2 <= frontfz2 && backcz2 <= frontfz1 && backcz1 <= frontfz2 && backcz1 <= frontfz1) &&
+							(frontcz2 <= backfz2 && frontcz2 <= backfz1 && frontcz1 <= backfz2 && frontcz1 <= backfz1))
+						{
+							// It's a closed door
+							ds++;
+							continue;
+						}
+					}
+
+					//
+					// Check for elevators/plats
+					//
+
+					// A line without bottom texture isn't an elevator/plat
+					if (ds->seg->sidedef->BottomTexture != -1)
+					{
+						float frontcz1 = ds->seg->linedef->frontsector->ceiling.GetPointZ(v1);
+						float frontcz2 = ds->seg->linedef->frontsector->ceiling.GetPointZ(v2);
+						float frontfz1 = ds->seg->linedef->frontsector->floor.GetPointZ(v1);
+						float frontfz2 = ds->seg->linedef->frontsector->floor.GetPointZ(v2);
+
+						float backcz1 = ds->seg->linedef->backsector->ceiling.GetPointZ(v1);
+						float backcz2 = ds->seg->linedef->backsector->ceiling.GetPointZ(v2);
+						float backfz1 = ds->seg->linedef->backsector->floor.GetPointZ(v1);
+						float backfz2 = ds->seg->linedef->backsector->floor.GetPointZ(v2);
+
+						if ((backcz2 <= frontfz2 && backcz2 <= frontfz1 && backcz1 <= frontfz2 && backcz1 <= frontfz1) &&
+							(frontcz2 <= backfz2 && frontcz2 <= backfz1 && frontcz1 <= backfz2 && frontcz1 <= backfz1))
+						{
+							// It's an enclosed elevator/plat
+							ds++;
+							continue;
+						}
+					}
+
+					//
+					// Check for polyobjs
+					//
+
+					// A line without mid texture isn't a polyobj door
+					if (ds->seg->sidedef->MidTexture != -1)
+					{
+						float frontcz1 = ds->seg->linedef->frontsector->ceiling.GetPointZ(v1);
+						float frontcz2 = ds->seg->linedef->frontsector->ceiling.GetPointZ(v2);
+						float frontfz1 = ds->seg->linedef->frontsector->floor.GetPointZ(v1);
+						float frontfz2 = ds->seg->linedef->frontsector->floor.GetPointZ(v2);
+
+						float backcz1 = ds->seg->linedef->backsector->ceiling.GetPointZ(v1);
+						float backcz2 = ds->seg->linedef->backsector->ceiling.GetPointZ(v2);
+						float backfz1 = ds->seg->linedef->backsector->floor.GetPointZ(v1);
+						float backfz2 = ds->seg->linedef->backsector->floor.GetPointZ(v2);
+
+						if ((backcz2 <= frontfz2 && backcz2 <= frontfz1 && backcz1 <= frontfz2 && backcz1 <= frontfz1) &&
+							(frontcz2 <= backfz2 && frontcz2 <= backfz1 && frontcz1 <= backfz2 && frontcz1 <= backfz1))
+						{
+							// It's a closed polyobj door
+							ds++;
+							continue;
+						}
+					}
+				}
+				else
+				{
+					if (ds->seg->linedef->backsector->floor.minz <= ds->seg->linedef->frontsector->ceiling.maxz &&
+						ds->seg->linedef->backsector->floor.maxz > ds->seg->linedef->frontsector->ceiling.minz)
+					{
+						ds++;
+						continue;
+					}
+				}
+			}
+
+#ifdef CLIENT
+			if (shadowslight)
+			{
+				// There might be a better method of doing this, but
+				// this one works for now...
+				if (DLight1 > CurrLightRadius && DLight2 <= -CurrLightRadius)
+				{
+					v2 += (v2 - v1) * DLight1 / (DLight1 - DLight2);
+				}
+				else if (DLight2 > CurrLightRadius && DLight1 <= -CurrLightRadius)
+				{
+					v1 += (v1 - v2) * DLight2 / (DLight2 - DLight1);
+				}
+			}
+			else
+#endif
+			{
+				if (D1 > 0.0 && D2 <= 0.0)
+				{
+					v2 += (v2 - v1) * D1 / (D1 - D2);
+				}
+				else if (D2 > 0.0 && D1 <= 0.0)
+				{
+					v1 += (v1 - v2) * D2 / (D2 - D1);
+				}
+			}
+
+			if (IsRangeVisible(PointToClipAngle(v2),
+				PointToClipAngle(v1)))
+			{
+				return true;
+			}
+		}
+		ds++;
+	}
+	return false;
+	unguard;
+}
+
+//==========================================================================
+//
 //	VViewClipper::ClipCheckSubsector
 //
 //==========================================================================
 
-bool VViewClipper::ClipCheckSubsector(subsector_t* Sub)
+bool VViewClipper::ClipCheckSubsector(subsector_t* Sub, bool shadowslight, const TVec& CurrLightPos,
+	float CurrLightRadius)
 {
 	guard(VViewClipper::ClipCheckSubsector);
 	if (!ClipHead)
 	{
 		return true;
 	}
+
 	for (int i = 0; i < Sub->numlines; i++)
 	{
 		seg_t* line = &Level->Segs[Sub->firstline + i];
 
-		float dist = DotProduct(Origin, line->normal) - line->dist;
-		if (dist <= 0)
+		TVec v1 = *line->v1;
+		TVec v2 = *line->v2;
+
+		if (!line->linedef)
+		{
+			//	Miniseg.
+			if (!IsRangeVisible(PointToClipAngle(v2),
+				PointToClipAngle(v1)))
+			{
+				continue;
+			}
+		}
+
+		if (line->PointOnSide(Origin))
 		{
 			//	Viewer is in back side or on plane
-			continue;
+			if (!IsRangeVisible(PointToClipAngle(v2),
+				PointToClipAngle(v1)))
+			{
+				continue;
+			}
 		}
 
-		if (IsRangeVisible(PointToClipAngle(*line->v2),
-			PointToClipAngle(*line->v1)))
+		// Clip sectors that are behind rendered segs
+		TVec rLight1;
+		TVec rLight2;
+		float DLight1;
+		float DLight2;
+
+		TVec r1 = Origin - v1;
+		TVec r2 = Origin - v2;
+		float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), Origin);
+		float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), Origin);
+
+#ifdef CLIENT
+		if (shadowslight)
+		{
+			rLight1 = CurrLightPos - v1;
+			rLight2 = CurrLightPos - v2;
+			DLight1 = DotProduct(Normalise(CrossProduct(rLight1, rLight2)), CurrLightPos);
+			DLight2 = DotProduct(Normalise(CrossProduct(rLight2, rLight1)), CurrLightPos);
+
+			TVec rView1 = Origin - CurrLightPos;
+			TVec rView2 = Origin - CurrLightPos;
+			float DView1 = DotProduct(Normalise(CrossProduct(rView1, rView2)), Origin);
+			float DView2 = DotProduct(Normalise(CrossProduct(rView2, rView1)), Origin);
+
+			if (D1 < 0.0 && D2 < 0.0 &&
+				DView1 < -CurrLightRadius && DView2 < -CurrLightRadius)
+			{
+				continue;
+			}
+
+			if (D1 > r_lights_radius && D2 > r_lights_radius)
+			{
+				continue;
+			}
+
+			if (DLight1 > CurrLightRadius && DLight2 > CurrLightRadius ||
+				DLight1 < -CurrLightRadius && DLight2 < -CurrLightRadius)
+			{
+				continue;
+			}
+		}
+		else
+#endif
 		{
+			if (D1 < 0.0 && D2 < 0.0)
+			{
+				continue;
+			}
+		}
+
+		if(!line->backsector)
+		{
+			if (shadowslight)
+			{
+				// There might be a better method of doing this, but
+				// this one works for now...
+				if (DLight1 > CurrLightRadius && DLight2 < -CurrLightRadius)
+				{
+					v2 += (v2 - v1) * DLight1 / (DLight1 - DLight2);
+				}
+				else if (DLight2 > CurrLightRadius && DLight1 < -CurrLightRadius)
+				{
+					v1 += (v1 - v2) * DLight2 / (DLight2 - DLight1);
+				}
+			}
+			else
+			{
+				if (D1 > 0.0 && D2 < 0.0)
+				{
+					v2 += (v2 - v1) * D1 / (D1 - D2);
+				}
+				else if (D2 > 0.0 && D1 < 0.0)
+				{
+					v1 += (v1 - v2) * D2 / (D2 - D1);
+				}
+			}
+
+			if (IsRangeVisible(PointToClipAngle(v2),
+				PointToClipAngle(v1)))
+			{
+				return true;
+			}
+		}
+		else if (line->linedef && line->backsector)
+		{
+			// 2-sided line, determine if it can be skipped
+			TVec v1 = *line->linedef->v1;
+			TVec v2 = *line->linedef->v2;
+
+			// Clip sectors that are behind rendered segs
+			TVec rLight1;
+			TVec rLight2;
+			float DLight1;
+			float DLight2;
+
+			TVec r1 = Origin - v1;
+			TVec r2 = Origin - v2;
+			float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), Origin);
+			float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), Origin);
+
+#ifdef CLIENT
+			if (shadowslight)
+			{
+				rLight1 = CurrLightPos - v1;
+				rLight2 = CurrLightPos - v2;
+				DLight1 = DotProduct(Normalise(CrossProduct(rLight1, rLight2)), CurrLightPos);
+				DLight2 = DotProduct(Normalise(CrossProduct(rLight2, rLight1)), CurrLightPos);
+
+				TVec rView1 = Origin - CurrLightPos;
+				TVec rView2 = Origin - CurrLightPos;
+				float DView1 = DotProduct(Normalise(CrossProduct(rView1, rView2)), Origin);
+				float DView2 = DotProduct(Normalise(CrossProduct(rView2, rView1)), Origin);
+			}
+#endif
+
+			// Just apply this to sectors without slopes
+			if (line->frontsector->floor.normal.z == 1.0 && line->backsector->floor.normal.z == 1.0 &&
+				line->frontsector->ceiling.normal.z == -1.0 && line->backsector->ceiling.normal.z == -1.0)
+			{
+				//
+				// Check for doors
+				//
+
+				// A line without top texture isn't a door
+				if (line->sidedef->TopTexture != -1)
+				{
+					float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+					float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+					float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+					float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+					float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+					float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+					float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+					float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+					if ((backcz2 <= frontfz2 && backcz2 <= frontfz1 && backcz1 <= frontfz2 && backcz1 <= frontfz1) &&
+						(frontcz2 <= backfz2 && frontcz2 <= backfz1 && frontcz1 <= backfz2 && frontcz1 <= backfz1))
+					{
+						// It's a closed door
+						continue;
+					}
+				}
+
+				//
+				// Check for elevators/plats
+				//
+
+				// A line without bottom texture isn't an elevator/plat
+				if (line->sidedef->BottomTexture != -1)
+				{
+					float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+					float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+					float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+					float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+					float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+					float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+					float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+					float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+					if ((backcz2 <= frontfz2 && backcz2 <= frontfz1 && backcz1 <= frontfz2 && backcz1 <= frontfz1) &&
+						(frontcz2 <= backfz2 && frontcz2 <= backfz1 && frontcz1 <= backfz2 && frontcz1 <= backfz1))
+					{
+						// It's an enclosed elevator/plat
+						continue;
+					}
+				}
+
+				//
+				// Check for polyobjs
+				//
+
+				// A line without mid texture isn't a polyobj door
+				if (line->sidedef->MidTexture != -1)
+				{
+					float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+					float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+					float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+					float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+					float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+					float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+					float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+					float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+					if ((backcz2 <= frontfz2 && backcz2 <= frontfz1 && backcz1 <= frontfz2 && backcz1 <= frontfz1) &&
+						(frontcz2 <= backfz2 && frontcz2 <= backfz1 && frontcz1 <= backfz2 && frontcz1 <= backfz1))
+					{
+						// It's a closed polyobj door
+						continue;
+					}
+				}
+			}
+
 			return true;
 		}
 	}
@@ -579,63 +1159,209 @@
 //
 //==========================================================================
 
-void VViewClipper::ClipAddSubsectorSegs(subsector_t* Sub, TPlane* Mirror)
+void VViewClipper::ClipAddSubsectorSegs(subsector_t* Sub, bool shadowslight, TPlane* Mirror,
+	const TVec& CurrLightPos, float CurrLightRadius)
 {
 	guard(VViewClipper::ClipAddSubsectorSegs);
 	for (int i = 0; i < Sub->numlines; i++)
 	{
 		seg_t* line = &Level->Segs[Sub->firstline + i];
-		if (line->backsector || !line->linedef)
+
+		TVec v1 = *line->v1;
+		TVec v2 = *line->v2;
+
+		if (!line->linedef)
 		{
-			//	Miniseg or two-sided line.
+			//	Miniseg.
 			continue;
 		}
 
-		float dist = DotProduct(Origin, line->normal) - line->dist;
-		if (dist <= 0)
+		if (line->PointOnSide(Origin))
 		{
 			//	Viewer is in back side or on plane
 			continue;
 		}
 
-		TVec v1 = *line->v1;
-		TVec v2 = *line->v2;
+		TVec r1 = Origin - v1;
+		TVec r2 = Origin - v2;
+		float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), Origin);
+		float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), Origin);
+
+#ifdef CLIENT
+		if (shadowslight)
+		{
+			TVec rLight1 = CurrLightPos - v1;
+			TVec rLight2 = CurrLightPos - v2;
+			float DLight1 = DotProduct(Normalise(CrossProduct(rLight1, rLight2)), CurrLightPos);
+			float DLight2 = DotProduct(Normalise(CrossProduct(rLight2, rLight1)), CurrLightPos);
+
+			TVec rView1 = Origin - CurrLightPos;
+			TVec rView2 = Origin - CurrLightPos;
+			float DView1 = DotProduct(Normalise(CrossProduct(rView1, rView2)), Origin);
+			float DView2 = DotProduct(Normalise(CrossProduct(rView2, rView1)), Origin);
+
+			if (D1 <= 0.0 && D2 <= 0.0 &&
+				DView1 < -CurrLightRadius && DView2 < -CurrLightRadius)
+			{
+				continue;
+			}
+
+			if (D1 > r_lights_radius && D2 > r_lights_radius)
+			{
+				continue;
+			}
+
+			if (DLight1 > CurrLightRadius && DLight2 > CurrLightRadius ||
+				DLight1 < -CurrLightRadius && DLight2 < -CurrLightRadius)
+			{
+				continue;
+			}
+		}
+		else
+#endif
+		{
+			if (D1 <= 0.0 && D2 <= 0.0)
+			{
+				continue;
+			}
+		}
+
 		if (Mirror)
 		{
 			//	Clip seg with mirror plane.
 			float Dist1 = DotProduct(v1, Mirror->normal) - Mirror->dist;
 			float Dist2 = DotProduct(v2, Mirror->normal) - Mirror->dist;
-			if (Dist1 <= 0 && Dist2 <= 0)
+
+			if (Dist1 <= 0.0 && Dist2 <= 0.0)
 			{
 				continue;
 			}
-			if (Dist1 > 0 && Dist2 < 0)
+		}
+
+		// 2-sided line, determine if it can be skipped
+		if (line->backsector)
+		{
+			TVec v1 = *line->linedef->v1;
+			TVec v2 = *line->linedef->v2;
+
+			// Just apply this to sectors without slopes
+			if (line->linedef->frontsector->floor.normal.z == 1.0 && line->linedef->backsector->floor.normal.z == 1.0 &&
+				line->linedef->frontsector->ceiling.normal.z == -1.0 && line->linedef->backsector->ceiling.normal.z == -1.0)
+			{
+				//
+				// Check for doors
+				//
+
+				// A line without top texture isn't a door
+				if (line->sidedef->TopTexture != -1)
+				{
+					float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+					float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+					float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+					float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+					float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+					float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+					float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+					float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+					if ((backcz2 > frontfz2 && backcz2 > frontfz1 && backcz1 > frontfz2 && backcz1 > frontfz1) &&
+						(frontcz2 > backfz2 && frontcz2 > backfz1 && frontcz1 > backfz2 && frontcz1 > backfz1))
+					{
+						// It's an opened door
+						continue;
+					}
+				}
+
+				//
+				// Check for elevators/plats
+				//
+
+				// A line without bottom texture isn't an elevator/plat
+				if (line->sidedef->BottomTexture != -1)
+				{
+					float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+					float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+					float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+					float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+					float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+					float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+					float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+					float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+					if ((backcz2 > frontfz2 && backcz2 > frontfz1 && backcz1 > frontfz2 && backcz1 > frontfz1) &&
+						(frontcz2 > backfz2 && frontcz2 > backfz1 && frontcz1 > backfz2 && frontcz1 > backfz1))
+					{
+						// It's a lowered elevator/plat
+						continue;
+					}
+				}
+
+				//
+				// Check for polyobjs
+				//
+
+				// A line without mid texture isn't a polyobj door
+				if (line->sidedef->MidTexture != -1)
+				{
+					float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+					float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+					float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+					float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+					float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+					float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+					float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+					float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+					if ((backcz2 > frontfz2 && backcz2 > frontfz1 && backcz1 > frontfz2 && backcz1 > frontfz1) &&
+						(frontcz2 > backfz2 && frontcz2 > backfz1 && frontcz1 > backfz2 && frontcz1 > backfz1))
+					{
+						// It's an opened polyobj door
+						continue;
+					}
+				}
+			}
+			else
+			{
+				continue;
+			}
+		}
+
+		if (Mirror)
+		{
+			//	Clip seg with mirror plane.
+			float Dist1 = DotProduct(v1, Mirror->normal) - Mirror->dist;
+			float Dist2 = DotProduct(v2, Mirror->normal) - Mirror->dist;
+
+			if (Dist1 > 0.0 && Dist2 <= 0.0)
 			{
 				v2 = v1 + (v2 - v1) * Dist1 / (Dist1 - Dist2);
 			}
-			else if (Dist2 > 0 && Dist1 < 0)
+			else if (Dist2 > 0.0 && Dist1 <= 0.0)
 			{
 				v1 = v2 + (v1 - v2) * Dist2 / (Dist2 - Dist1);
 			}
 		}
-
 		AddClipRange(PointToClipAngle(v2), PointToClipAngle(v1));
 	}
 
 	if (Sub->poly)
 	{
 		seg_t** polySeg = Sub->poly->segs;
+
 		for (int polyCount = Sub->poly->numsegs; polyCount--; polySeg++)
 		{
 			seg_t* line = *polySeg;
-			if (line->backsector || !line->linedef)
+
+			if (!line->linedef)
 			{
-				//	Miniseg or two-sided line.
+				//	Miniseg.
 				continue;
 			}
 
-			float dist = DotProduct(Origin, line->normal) - line->dist;
-			if (dist <= 0)
+			if (line->PointOnSide(Origin))
 			{
 				//	Viewer is in back side or on plane
 				continue;
@@ -644,6 +1370,145 @@
 			TVec v1 = *line->v1;
 			TVec v2 = *line->v2;
 
+			// Just apply this to sectors without slopes
+			if (line->frontsector->floor.normal.z == 1.0 && line->frontsector->ceiling.normal.z == -1.0)
+			{
+				TVec r1 = Origin - v1;
+				TVec r2 = Origin - v2;
+				float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), Origin);
+				float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), Origin);
+
+#ifdef CLIENT
+				if (shadowslight)
+				{
+					TVec rLight1 = CurrLightPos - v1;
+					TVec rLight2 = CurrLightPos - v2;
+					float DLight1 = DotProduct(Normalise(CrossProduct(rLight1, rLight2)), CurrLightPos);
+					float DLight2 = DotProduct(Normalise(CrossProduct(rLight2, rLight1)), CurrLightPos);
+
+					TVec rView1 = Origin - CurrLightPos;
+					TVec rView2 = Origin - CurrLightPos;
+					float DView1 = DotProduct(Normalise(CrossProduct(rView1, rView2)), Origin);
+					float DView2 = DotProduct(Normalise(CrossProduct(rView2, rView1)), Origin);
+
+					if (D1 <= 0.0 && D2 <= 0.0 &&
+						DView1 < -CurrLightRadius && DView2 < -CurrLightRadius)
+					{
+						continue;
+					}
+
+					if (D1 > r_lights_radius && D2 > r_lights_radius)
+					{
+						continue;
+					}
+
+					if (DLight1 > CurrLightRadius && DLight2 > CurrLightRadius ||
+						DLight1 < -CurrLightRadius && DLight2 < -CurrLightRadius)
+					{
+						continue;
+					}
+				}
+				else
+#endif
+				{
+					if (D1 <= 0.0 && D2 <= 0.0)
+					{
+						continue;
+					}
+				}
+			}
+
+			// 2-sided line, determine if it can be skipped
+			if (line->backsector)
+			{
+				TVec v1 = *line->linedef->v1;
+				TVec v2 = *line->linedef->v2;
+
+				// Just apply this to sectors without slopes
+				if (line->linedef->frontsector->floor.normal.z == 1.0 && line->linedef->backsector->floor.normal.z == 1.0 &&
+					line->linedef->frontsector->ceiling.normal.z == -1.0 && line->linedef->backsector->ceiling.normal.z == -1.0)
+				{
+					//
+					// Check for doors
+					//
+
+					// A line without top texture isn't a door
+					if (line->sidedef->TopTexture != -1)
+					{
+						float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+						float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+						float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+						float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+						float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+						float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+						float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+						float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+						if ((backcz2 > frontfz2 && backcz2 > frontfz1 && backcz1 > frontfz2 && backcz1 > frontfz1) &&
+							(frontcz2 > backfz2 && frontcz2 > backfz1 && frontcz1 > backfz2 && frontcz1 > backfz1))
+						{
+							// It's an opened door
+							continue;
+						}
+					}
+
+					//
+					// Check for elevators/plats
+					//
+
+					// A line without bottom texture isn't an elevator/plat
+					if (line->sidedef->BottomTexture != -1)
+					{
+						float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+						float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+						float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+						float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+						float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+						float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+						float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+						float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+						if ((backcz2 > frontfz2 && backcz2 > frontfz1 && backcz1 > frontfz2 && backcz1 > frontfz1) &&
+							(frontcz2 > backfz2 && frontcz2 > backfz1 && frontcz1 > backfz2 && frontcz1 > backfz1))
+						{
+							// It's a lowered elevator
+							continue;
+						}
+					}
+
+					//
+					// Check for polyobjs
+					//
+
+					// A line without mid texture isn't a polyobj door
+					if (line->sidedef->MidTexture != -1)
+					{
+						float frontcz1 = line->linedef->frontsector->ceiling.GetPointZ(v1);
+						float frontcz2 = line->linedef->frontsector->ceiling.GetPointZ(v2);
+						float frontfz1 = line->linedef->frontsector->floor.GetPointZ(v1);
+						float frontfz2 = line->linedef->frontsector->floor.GetPointZ(v2);
+
+						float backcz1 = line->linedef->backsector->ceiling.GetPointZ(v1);
+						float backcz2 = line->linedef->backsector->ceiling.GetPointZ(v2);
+						float backfz1 = line->linedef->backsector->floor.GetPointZ(v1);
+						float backfz2 = line->linedef->backsector->floor.GetPointZ(v2);
+
+						if ((backcz2 > frontfz2 && backcz2 > frontfz1 && backcz1 > frontfz2 && backcz1 > frontfz1) &&
+							(frontcz2 > backfz2 && frontcz2 > backfz1 && frontcz1 > backfz2 && frontcz1 > backfz1))
+						{
+							// It's an opened polyobj door
+							continue;
+						}
+					}
+				}
+				else
+				{
+					continue;
+				}
+			}
+
 			AddClipRange(PointToClipAngle(v2), PointToClipAngle(v1));
 		}
 	}
diff -Nur orig/source/p_clip.h mod/source/p_clip.h
--- orig/source/p_clip.h	2008-04-17 22:30:08.000000000 +0200
+++ mod/source/p_clip.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_clip.h 3546 2008-04-17 20:32:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -50,7 +50,8 @@
 	bool IsRangeVisible(float, float);
 	bool ClipIsFull();
 	float PointToClipAngle(const TVec&);
-	bool ClipIsBBoxVisible(float*);
-	bool ClipCheckSubsector(subsector_t*);
-	void ClipAddSubsectorSegs(subsector_t*, TPlane* = NULL);
+	bool ClipIsBBoxVisible(float*, bool, const TVec& = TVec(0, 0, 0), float = 0);
+	bool ClipCheckRegion(subregion_t*, subsector_t*, bool, const TVec& = TVec(0, 0, 0), float = 0);
+	bool ClipCheckSubsector(subsector_t*, bool, const TVec& = TVec(0, 0, 0), float = 0);
+	void ClipAddSubsectorSegs(subsector_t*, bool, TPlane* = NULL, const TVec& = TVec(0, 0, 0), float = 0);
 };
diff -Nur orig/source/p_entity.cpp mod/source/p_entity.cpp
--- orig/source/p_entity.cpp	2009-03-03 21:18:53.000000000 +0100
+++ mod/source/p_entity.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_entity.cpp 4001 2009-03-03 20:22:11Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -386,7 +386,7 @@
 {
 	guard(VEntity::HasSpecialStates);
 	VStateLabel* Lbl = GetClass()->FindStateLabel(StateName);
-	return Lbl && Lbl->SubLabels.Num() > 0;
+	return Lbl != NULL && Lbl->SubLabels.Num() > 0;
 	unguard;
 }
 
@@ -512,6 +512,10 @@
 	float Attenuation, bool Loop)
 {
 	guard(VEntity::StartSound);
+	if (!Sector)
+	{
+		return;
+	}
 	if (Sector->SectorFlags & sector_t::SF_Silent)
 	{
 		return;
diff -Nur orig/source/p_entity.h mod/source/p_entity.h
--- orig/source/p_entity.h	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/p_entity.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_entity.h 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -156,6 +156,7 @@
 	VName			FixedSpriteName;
 	VStr			FixedModelName;
 	vuint8			ModelVersion;
+	int				NumTouchingLights;
 
 	vuint8			RenderStyle;
 	float			Alpha;
@@ -227,7 +228,7 @@
 		EF_Missile				= 0x01000000,	// don't hit same species, explode on block
 		EF_DontOverlap			= 0x02000000,	// Prevent some things from overlapping.
 		EF_UseDispState			= 0x04000000,	// Use DispState for rendering
-		EF_ActLikeBridge		= 0x08000000,	// Always allow obkects to pass.
+		EF_ActLikeBridge		= 0x08000000,	// Always allow objects to pass.
 		EF_NoDropOff			= 0x10000000,	// Can't drop off under any circumstances
 		EF_Bright				= 0x20000000,	// Always render full bright
 		EF_CanJump				= 0x40000000,	// This entity can jump to high places
diff -Nur orig/source/p_entity_sight.cpp mod/source/p_entity_sight.cpp
--- orig/source/p_entity_sight.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/p_entity_sight.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_entity_sight.cpp 4323 2010-07-05 23:04:58Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -140,31 +140,34 @@
 
 	sec_region_t* StartReg = SV_PointInRegion(Sec, Trace.LineStart);
 
-	for (sec_region_t* Reg = StartReg; Reg; Reg = Reg->next)
+	if (StartReg != NULL)
 	{
-		if (!SightCheckPlane(Trace, Reg->floor))
+		for (sec_region_t* Reg = StartReg; Reg; Reg = Reg->next)
 		{
-			//	Hit floor
-			return false;
-		}
-		if (!SightCheckPlane(Trace, Reg->ceiling))
-		{
-			//	Hit ceiling
-			return false;
+			if (!SightCheckPlane(Trace, Reg->floor))
+			{
+				//	Hit floor
+				return false;
+			}
+			if (!SightCheckPlane(Trace, Reg->ceiling))
+			{
+				//	Hit ceiling
+				return false;
+			}
 		}
-	}
 
-	for (sec_region_t* Reg = StartReg->prev; Reg; Reg = Reg->prev)
-	{
-		if (!SightCheckPlane(Trace, Reg->floor))
-		{
-			//	Hit floor
-			return false;
-		}
-		if (!SightCheckPlane(Trace, Reg->ceiling))
+		for (sec_region_t* Reg = StartReg->prev; Reg != NULL; Reg = Reg->prev)
 		{
-			//	Hit ceiling
-			return false;
+			if (!SightCheckPlane(Trace, Reg->floor))
+			{
+				//	Hit floor
+				return false;
+			}
+			if (!SightCheckPlane(Trace, Reg->ceiling))
+			{
+				//	Hit ceiling
+				return false;
+			}
 		}
 	}
 
@@ -311,7 +314,7 @@
 	}
 
 	// try to early out the check
-	if (!ld->backsector || !(ld->flags & ML_TWOSIDED))
+	if (!ld->backsector || !(ld->flags & ML_TWOSIDED) || (ld->flags & ML_BLOCKEVERYTHING))
 	{
 		return false;	// stop checking
 	}
@@ -591,9 +594,7 @@
 bool VEntity::CanSee(VEntity* Other)
 {
 	guard(VEntity::CanSee);
-	int				s1;
 	int				s2;
-	int				pnum;
 #ifdef USE_BSP
 	linetrace_t		Trace;
 #else
@@ -621,6 +622,8 @@
 
 	if (XLevel->RejectMatrix)
 	{
+		int				s1;
+		int				pnum;
 		//	Determine subsector entries in REJECT table.
 		//	We must do this because REJECT can have some special effects like
 		// "safe sectors"
@@ -688,7 +691,7 @@
 		return true;
 	}
 
-	//	Check feats
+	//	Check feet
 	Trace.End = Other->Origin;
 	Trace.End.z -= Other->FloorClip;
 #ifdef USE_BSP
diff -Nur orig/source/p_entity_world.cpp mod/source/p_entity_world.cpp
--- orig/source/p_entity_world.cpp	2010-12-31 14:06:29.000000000 +0100
+++ mod/source/p_entity_world.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_entity_world.cpp 4361 2010-12-31 00:59:19Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -321,7 +321,7 @@
 			if (blockx >= 0 && blockx < XLevel->BlockMapWidth &&
 				blocky >= 0 && blocky < XLevel->BlockMapHeight)
 			{
-//				check(XLevel->BlockLinks[blocky * XLevel->BlockMapWidth + blockx] == this);
+				check(XLevel->BlockLinks[blocky * XLevel->BlockMapWidth + blockx] == this);
 				if (XLevel->BlockLinks[blocky * XLevel->BlockMapWidth + blockx] == this)
 				{
 					XLevel->BlockLinks[blocky * XLevel->BlockMapWidth + blockx] =
@@ -479,6 +479,15 @@
 					WaterLevel = 3;
 				}
 			}
+			else
+			{
+				point.z = Origin.z + Height * 0.75;
+				cont = SV_PointContents(Sector, point);
+				if (cont > 0)
+				{
+					WaterLevel = 3;
+				}
+			}
 		}
 	}
 	return WaterLevel > 1;
@@ -517,6 +526,7 @@
 	sec_region_t *gap;
 	sec_region_t *reg;
 	cptrace_t cptrace;
+	bool good = true;
 
 	cptrace.Pos = Pos;
 
@@ -591,13 +601,15 @@
 				line_t*		ld;
 				for (VBlockLinesIterator It(XLevel, bx, by, &ld); It.GetNext(); )
 				{
-					if (!CheckLine(cptrace, ld))
-					{
-						return false;
-					}
+					good &= CheckLine(cptrace, ld);
 				}
 			}
 		}
+
+		if (!good)
+		{
+			return false;
+		}
 	}
 
 	return true;
@@ -613,14 +625,17 @@
 bool VEntity::CheckThing(cptrace_t& cptrace, VEntity *Other)
 {
 	guardSlow(VEntity::CheckThing);
+	// don't clip against self
+	if (Other == this)
+	{
+		return true;
+	}
 	// can't hit thing
-	if (!(Other->EntityFlags & EF_Solid))
+	if (!(Other->EntityFlags & EF_ColideWithThings))
 	{
 		return true;
 	}
-
-	// don't clip against self
-	if (Other == this)
+	if (!(Other->EntityFlags & EF_Solid))
 	{
 		return true;
 	}
@@ -647,7 +662,7 @@
 		{
 			return true;
 		}
-		if (cptrace.Pos.z + Height < Other->Origin.z)
+		if (cptrace.Pos.z + Height <= Other->Origin.z)
 		{
 			// under thing
 			return true;
@@ -814,7 +829,8 @@
 	int by;
 	subsector_t *newsubsec;
 	VEntity* thingblocker;
-	VEntity* fakedblocker;
+//	VEntity* fakedblocker;
+	bool good = true;
 
 	tmtrace.End = Pos;
 
@@ -830,10 +846,10 @@
 	// that contains the point.
 	// Any contacted lines the step closer together
 	// will adjust them.
-	if (newsubsec->sector->SectorFlags && sector_t::SF_HasExtrafloors)
+	if (newsubsec->sector->SectorFlags & sector_t::SF_HasExtrafloors)
 	{
 		sec_region_t* gap = SV_FindThingGap(newsubsec->sector->botregion,
-			tmtrace.End, tmtrace.End.z, tmtrace.End.z + Height);
+			tmtrace.End, tmtrace.End.z, tmtrace.End.z + (Height ? 1.0 : Height));
 		sec_region_t* reg = gap;
 		while (reg->prev && reg->floor->flags & SPF_NOBLOCKING)
 		{
@@ -866,7 +882,7 @@
 	tmtrace.BlockingMobj = NULL;
 	tmtrace.StepThing = NULL;
 	thingblocker = NULL;
-	fakedblocker = NULL;
+//	fakedblocker = NULL;
 
 	// Check things first, possibly picking things up.
 	// The bounding box is extended by MAXRADIUS
@@ -898,7 +914,7 @@
 						else if (!tmtrace.BlockingMobj->Player &&
 							!(EntityFlags & VEntity::EF_Float) &&
 							!(EntityFlags & VEntity::EF_Missile) &&
-							tmtrace.BlockingMobj->Origin.z + tmtrace.BlockingMobj->Height - Origin.z <= MaxStepHeight)
+							tmtrace.BlockingMobj->Origin.z + tmtrace.BlockingMobj->Height - tmtrace.End.z <= MaxStepHeight)
 						{
 							if (!thingblocker || tmtrace.BlockingMobj->Origin.z > thingblocker->Origin.z)
 							{
@@ -906,7 +922,7 @@
 							}
 							tmtrace.BlockingMobj = NULL;
 						}
-						else if (Player && Origin.z + Height - tmtrace.BlockingMobj->Origin.z <= MaxStepHeight)
+						else if (Player && tmtrace.End.z + Height - tmtrace.BlockingMobj->Origin.z <= MaxStepHeight)
 						{
 							if (thingblocker)
 							{ // something to step up on, set it as
@@ -915,7 +931,7 @@
 							}
 							// nothing is blocking, but this object potentially could
 							// if there is something else to step on
-							fakedblocker = tmtrace.BlockingMobj;
+							//fakedblocker = tmtrace.BlockingMobj;
 							tmtrace.BlockingMobj = NULL;
 						}
 						else
@@ -928,11 +944,12 @@
 		}
 	}
 
+	// check lines
+	validcount++;
+
 	float thingdropoffz = tmtrace.FloorZ;
 	tmtrace.FloorZ = tmtrace.DropOffZ;
 	tmtrace.BlockingMobj = NULL;
-	// check lines
-	validcount++;
 
 	if (EntityFlags & EF_ColideWithWorld)
 	{
@@ -948,21 +965,23 @@
 				line_t*		ld;
 				for (VBlockLinesIterator It(XLevel, bx, by, &ld); It.GetNext(); )
 				{
-					if (!CheckRelLine(tmtrace, ld))
-					{
-						return false;
-					}
+					good &= CheckRelLine(tmtrace, ld);
 				}
 			}
 		}
 
+		if (!good)
+		{
+			return false;
+		}
+
 		if (tmtrace.CeilingZ - tmtrace.FloorZ < Height)
 		{
 			return false;
 		}
 	}
 
-	if (tmtrace.StepThing != NULL)
+	if (tmtrace.StepThing)
 	{
 		tmtrace.DropOffZ = thingdropoffz;
 	}
@@ -991,6 +1010,11 @@
 	{
 		return true;
 	}
+	// can't hit thing
+	if (!(Other->EntityFlags & EF_ColideWithThings))
+	{
+		return true;
+	}
 
 	float blockdist = Other->Radius + Radius;
 
@@ -1009,13 +1033,17 @@
 		!(EntityFlags & EF_NoGravity)) &&
 		(Other->EntityFlags & EF_Solid) &&
 		(Other->EntityFlags & EF_ActLikeBridge))
-	{
+ 	{
 		// allow actors to walk on other actors as well as floors
-		if (Other->Origin.z + Other->Height >= tmtrace.FloorZ &&
-			Other->Origin.z + Other->Height <= Origin.z + MaxStepHeight)
+		if (fabs(Other->Origin.x - tmtrace.End.x) < Other->Radius ||
+			fabs(Other->Origin.y - tmtrace.End.y) < Other->Radius)
 		{
-			tmtrace.StepThing = Other;
-			tmtrace.FloorZ = Other->Origin.z + Other->Height;
+			if (Other->Origin.z + Other->Height >= tmtrace.FloorZ &&
+				Other->Origin.z + Other->Height <= tmtrace.End.z + MaxStepHeight)
+			{
+				tmtrace.StepThing = Other;
+				tmtrace.FloorZ = Other->Origin.z + Other->Height;
+			}
 		}
 	}
 	//if (!(tmtrace.Thing->EntityFlags & VEntity::EF_NoPassMobj) || Actor(Other).bSpecial)
@@ -1030,11 +1058,11 @@
 			return false;
 		}
 		// check if a mobj passed over/under another object
-		if (tmtrace.End.z + 0.00001 >= Other->Origin.z + Other->Height)
+		if (tmtrace.End.z >= Other->Origin.z + Other->Height)
 		{
 			return true;	// overhead
 		}
-		if (tmtrace.End.z + Height <= Other->Origin.z + 0.00001)
+		if (tmtrace.End.z + Height <= Other->Origin.z)
 		{
 			return true;	// underneath
 		}
@@ -1212,8 +1240,6 @@
 	guard(VEntity::TryMove);
 	bool check;
 	TVec oldorg;
-	int side;
-	int oldside;
 	line_t *ld;
 	sector_t* OldSec = Sector;
 
@@ -1297,11 +1323,11 @@
 			if (tmtrace.FloorZ - Origin.z > MaxStepHeight)
 			{
 				// Too big a step up
-				if (EntityFlags & EF_CanJump)
+				if (EntityFlags & EF_CanJump && Health > 0.0)
 				{
 					// Check to make sure there's nothing in the way for the step up
-					if ((tmtrace.BlockingMobj && (tmtrace.BlockingMobj->CheckOnmobj() &&
-						tmtrace.BlockingMobj->CheckOnmobj() == this)) ||
+					if (!Velocity.z || tmtrace.FloorZ - Origin.z > 48.0 ||
+						(tmtrace.BlockingMobj && tmtrace.BlockingMobj->CheckOnmobj()) ||
 						TestMobjZ(TVec(newPos.x, newPos.y, tmtrace.FloorZ)))
 					{
 						PushLine(tmtrace);
@@ -1322,6 +1348,15 @@
 			}
 			if (Origin.z < tmtrace.FloorZ)
 			{
+				if (EntityFlags & EF_StepMissile)
+				{
+					Origin.z = tmtrace.FloorZ;
+					// If moving down, cancel vertical component of velocity
+					if (Velocity.z < 0)
+					{
+						Velocity.z = 0.0;
+					}
+				}
 				// Check to make sure there's nothing in the way for the step up
 				if (TestMobjZ(TVec(newPos.x, newPos.y, tmtrace.FloorZ)))
 				{
@@ -1411,6 +1446,9 @@
 	{
 		while (tmtrace.SpecHit.Num() > 0)
 		{
+			int side;
+			int oldside;
+
 			// see if the line was crossed
 			ld = tmtrace.SpecHit[tmtrace.SpecHit.Num() - 1];
 			tmtrace.SpecHit.SetNum(tmtrace.SpecHit.Num() - 1, false);
@@ -1721,6 +1759,7 @@
 {
 	guard(VEntity::BounceWall);
 	TVec SlideOrg;
+
 	if (Velocity.x > 0.0)
 	{
 		SlideOrg.x = Origin.x + Radius;
@@ -1741,6 +1780,7 @@
 	TVec SlideDir = Velocity * host_frametime;
 	line_t* BestSlideLine = NULL;
 	intercept_t* in;
+
 	for (VPathTraverse It(this, &in, SlideOrg.x, SlideOrg.y, SlideOrg.x +
 		SlideDir.x, SlideOrg.y + SlideDir.y, PT_ADDLINES); It.GetNext(); )
 	{
@@ -1748,15 +1788,16 @@
 		{
 			Host_Error("PTR_BounceTraverse: not a line?");
 		}
-
 		line_t* li = in->line;
+		TVec hit_point = SlideOrg + in->frac * SlideDir;
+
 		if (li->flags & ML_TWOSIDED)
 		{
-			TVec hit_point = SlideOrg + in->frac * SlideDir;
 			// set openrange, opentop, openbottom
 			opening_t* open = SV_LineOpenings(li, hit_point, SPF_NOBLOCKING);
 			open = SV_FindOpening(open, Origin.z, Origin.z + Height);
-			if (open && open->range >= Height &&	// fits
+
+			if (open != NULL && open->range >= Height &&	// fits
 				Origin.z + Height <= open->top &&
 				Origin.z >= open->bottom)	// mobj is not too high
 			{
@@ -1774,12 +1815,32 @@
 		BestSlideLine = li;
 		break;	// don't bother going farther
 	}
+
 	if (BestSlideLine)
 	{
-//		Velocity.x *= bouncefactor;
-//		Velocity.y *= bouncefactor;
-//		Velocity.z *= bouncefactor;
-		Velocity = ClipVelocity(Velocity * bouncefactor, BestSlideLine->normal, overbounce * bouncefactor);
+		TAVec	delta_ang;
+		TAVec	lineang;
+		TVec	delta;
+
+		// Convert BesSlideLine normal to an angle
+		VectorAngles(BestSlideLine->normal, lineang);
+		if (BestSlideLine->PointOnSide(Origin) == 1)
+		{
+			lineang.yaw += 180.0;
+		}
+
+		// Convert the line angle back to a vector, so that
+		// we can use it to calculate the delta against
+		// the Velocity vector
+		AngleVector(lineang, delta);
+		delta = (delta * 2.0) - Velocity;
+
+		// Finally get the delta angle to use
+		VectorAngles(delta, delta_ang);
+
+		Velocity.x = (Velocity.x * bouncefactor) * cos(delta_ang.yaw);
+		Velocity.y = (Velocity.y * bouncefactor) * sin(delta_ang.yaw);
+		Velocity = ClipVelocity(Velocity, BestSlideLine->normal, overbounce);
 	}
 	unguard;
 }
@@ -1793,8 +1854,6 @@
 void VEntity::UpdateVelocity()
 {
 	guard(VEntity::UpdateVelocity);
-	float startvelz, sinkspeed;
-
 /*	if (Origin.z <= FloorZ && !Velocity.x && !Velocity.y &&
 		!Velocity.z && !bCountKill && !(EntityFlags & EF_IsPlayer))
 	{
@@ -1815,6 +1874,8 @@
 		}
 		else if (!(EntityFlags & EF_IsPlayer) || Health <= 0)
 		{
+			float startvelz, sinkspeed;
+
 			// Water Gravity
 			Velocity.z -= Gravity * Level->Gravity * Sector->Gravity / 10.0 *
 				host_frametime;
@@ -1867,11 +1928,16 @@
 	guard(VEntity::TestMobjZ);
 	int xl, xh, yl, yh, bx, by;
 
-	// Can't hit thing
+	// can't hit thing
 	if (!(EntityFlags & EF_ColideWithThings))
 	{
 		return NULL;
 	}
+	// Not Solid
+	if (!(EntityFlags & EF_Solid))
+	{
+		return NULL;
+	}
 
 	//
 	// the bounding box is extended by MAXRADIUS because mobj_ts are grouped
@@ -1890,14 +1956,19 @@
 		{
 			for (VBlockThingsIterator Other(XLevel, bx, by); Other; ++Other)
 			{
-				if (!(Other->EntityFlags & EF_Solid))
+				if (*Other == this)
+				{
+					// Don't clip against self
+					continue;
+				}
+				if (!(Other->EntityFlags & EF_ColideWithThings))
 				{
 					// Can't hit thing
 					continue;
 				}
-				if (*Other == this)
+				if (!(Other->EntityFlags & EF_Solid))
 				{
-					// Don't clip against self
+					// Not solid
 					continue;
 				}
 				if (TryOrg.z > Other->Origin.z + Other->Height)
@@ -2134,13 +2205,13 @@
 						front < Origin.z - MaxDropoffHeight)
 					{
 						// front side dropoff
-						Dir = -line->normal;
+						Dir = line->normal;
 					}
 					else if (front == Origin.z &&
 						back < Origin.z - MaxDropoffHeight)
 					{
 						// back side dropoff
-						Dir = line->normal;
+						Dir = -line->normal;
 					}
 					else
 					{
diff -Nur orig/source/p_gameinfo.cpp mod/source/p_gameinfo.cpp
--- orig/source/p_gameinfo.cpp	2009-11-13 21:28:36.000000000 +0100
+++ mod/source/p_gameinfo.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_gameinfo.cpp 4109 2009-11-13 20:30:09Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_gameinfo.h mod/source/p_gameinfo.h
--- orig/source/p_gameinfo.h	2009-11-13 22:52:42.000000000 +0100
+++ mod/source/p_gameinfo.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_gameinfo.h 4110 2009-11-13 21:54:07Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_gameobject.cpp mod/source/p_gameobject.cpp
--- orig/source/p_gameobject.cpp	2009-11-13 22:52:42.000000000 +0100
+++ mod/source/p_gameobject.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_gameobject.cpp 4110 2009-11-13 21:54:07Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_gameobject.h mod/source/p_gameobject.h
--- orig/source/p_gameobject.h	2010-06-13 21:30:25.000000000 +0200
+++ mod/source/p_gameobject.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_gameobject.h 4305 2010-06-12 22:08:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -39,7 +39,10 @@
 struct seg_t;
 struct subsector_t;
 struct node_t;
+struct surface_t;
+struct segpart_t;
 struct drawseg_t;
+struct sec_surface_t;
 struct subregion_t;
 
 class	VThinker;
@@ -79,6 +82,27 @@
 
 //==========================================================================
 //
+//	DrawSeg
+//
+//==========================================================================
+
+struct drawseg_t
+{
+	seg_t*			seg;
+	drawseg_t*		next;
+
+	segpart_t*		top;
+	segpart_t*		mid;
+	segpart_t*		bot;
+	segpart_t*		topsky;
+	segpart_t*		extra;
+
+	surface_t*		HorizonTop;
+	surface_t*		HorizonBot;
+};
+
+//==========================================================================
+//
 //	LineDef
 //
 //==========================================================================
@@ -499,6 +523,24 @@
 };
 
 //==========================================================================
+//
+//	SubRegion
+//
+//==========================================================================
+
+struct subregion_t
+{
+	sec_region_t*	secregion;
+	subregion_t*	next;
+	sec_plane_t*	floorplane;
+	sec_plane_t*	ceilplane;
+	sec_surface_t*	floor;
+	sec_surface_t*	ceil;
+	int				count;
+	drawseg_t*		lines;
+};
+
+//==========================================================================
 //
 //	Subsector
 //
diff -Nur orig/source/p_levelinfo.cpp mod/source/p_levelinfo.cpp
--- orig/source/p_levelinfo.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/p_levelinfo.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_levelinfo.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -349,7 +349,7 @@
 		Map = 1;
 		Position = 0;
 	}
-	NextMap = P_GetMapNameByLevelNum(Map);
+	NextMap = P_GetMapLumpNameByLevelNum(Map);
 
 	LeavePosition = Position;
 	completed = true;
diff -Nur orig/source/p_levelinfo.h mod/source/p_levelinfo.h
--- orig/source/p_levelinfo.h	2009-01-05 19:07:05.000000000 +0100
+++ mod/source/p_levelinfo.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_levelinfo.h 3953 2009-01-05 18:10:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -27,7 +27,7 @@
 {
 	DECLARE_CLASS(VLevelInfo, VThinker, 0)
 
-	enum { TID_HASH_SIZE = 64 };
+	enum { TID_HASH_SIZE = 128 };
 
 	VGameInfo*		Game;
 	VWorldInfo*		World;
@@ -111,6 +111,7 @@
 		LIF2_HaveMonsterActivation		= 0x00008000,
 		LIF2_ClusterHub					= 0x00010000,
 		LIF2_BegunPlay					= 0x00020000,
+		LIF2_Frozen						= 0x00040000,
 	};
 	vuint32			LevelInfoFlags2;
 
@@ -206,6 +207,13 @@
 		P_PASS_PTR(po);
 		EV_RET_VOID(NAME_PolyThrustMobj);
 	}
+	void eventPolyCrushMobj(VEntity* A, polyobj_t* po)
+	{
+		P_PASS_SELF;
+		P_PASS_REF(A);
+		P_PASS_PTR(po);
+		EV_RET_VOID(NAME_PolyCrushMobj);
+	}
 	bool eventTagBusy(int tag)
 	{
 		P_PASS_SELF;
diff -Nur orig/source/p_level_think.cpp mod/source/p_level_think.cpp
--- orig/source/p_level_think.cpp	2008-12-28 11:14:35.000000000 +0100
+++ mod/source/p_level_think.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_level_think.cpp 3911 2008-12-28 10:18:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -142,7 +142,11 @@
 		}
 	}
 
-	LevelInfo->eventUpdateSpecials();
+	// Don't update specials if the level is frozen
+	if (!(LevelInfo->LevelInfoFlags2 & VLevelInfo::LIF2_Frozen))
+	{
+		LevelInfo->eventUpdateSpecials();
+	}
 
 	for (int i = 0; i < MAXPLAYERS; i++)
 	{
@@ -168,6 +172,7 @@
 	const TAVec& AAngles, mthing_t* mthing, bool AllowReplace)
 {
 	guard(VLevel::SpawnThinker);
+	check(AClass);
 	VClass* Class = AllowReplace ? AClass->GetReplacement() : AClass;
 	VThinker* Ret = (VThinker*)StaticSpawnObject(Class);
 	AddThinker(Ret);
diff -Nur orig/source/p_nodebuild.cpp mod/source/p_nodebuild.cpp
--- orig/source/p_nodebuild.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/p_nodebuild.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: p_nodebuild.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -248,6 +248,10 @@
 	for (int i = 0; i < Level->NumLines; i++, pSrc++)
 	{
 		linedef_t* Line = NewLinedef();
+		if (Line == NULL)
+		{
+			continue;
+		}
 		Line->start = LookupVertex(pSrc->v1 - Level->Vertexes);
 		Line->end = LookupVertex(pSrc->v2 - Level->Vertexes);
 		Line->start->ref_count++;
@@ -259,17 +263,17 @@
 		Line->two_sided = (Line->flags & LINEFLAG_TWO_SIDED) ? TRUE : FALSE;
 		Line->right = pSrc->sidenum[0] < 0 ? NULL : LookupSidedef(pSrc->sidenum[0]);
 		Line->left = pSrc->sidenum[1] < 0 ? NULL : LookupSidedef(pSrc->sidenum[1]);
-		if (Line->right)
+		if (Line->right != NULL)
 		{
 			Line->right->ref_count++;
 			Line->right->on_special |= (Line->type > 0) ? 1 : 0;
 		}
-		if (Line->left)
+		if (Line->left != NULL)
 		{
 			Line->left->ref_count++;
 			Line->left->on_special |= (Line->type > 0) ? 1 : 0;
 		}
-		Line->self_ref = (Line->left && Line->right &&
+		Line->self_ref = (Line->left != NULL && Line->right != NULL &&
 			(Line->left->sector == Line->right->sector));
 		Line->index = i;
 	}
diff -Nur orig/source/p_player.cpp mod/source/p_player.cpp
--- orig/source/p_player.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/p_player.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_player.cpp 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -123,7 +123,7 @@
 	}
 
 	//	Clean up parameters
-	guard(CleanUp);
+	guard(VBasePlayer::ExecuteNetMethod::CleanUp);
 	VStack* Param = pr_stackPtr - Func->ParamsSize + 1;	//	Skip self
 	for (int i = 0; i < Func->NumParams; i++)
 	{
@@ -159,7 +159,7 @@
 	unguard;
 
 	//	Push null return value
-	guard(RetVal);
+	guard(VBasePlayer::ExecuteNetMethod::RetVal);
 	switch (Func->ReturnType.Type)
 	{
 	case TYPE_Void:
@@ -386,6 +386,12 @@
 			if (St.StateTime != -1.0)
 			{
 				St.StateTime -= deltaTime;
+				if (eventCheckDoubleFiringSpeed())
+				{
+					// [BC] Apply double firing speed.
+					St.StateTime -= deltaTime;
+				}
+
 				if (St.StateTime <= 0.0)
 				{
 					St.StateTime = 0.0;
diff -Nur orig/source/p_player.h mod/source/p_player.h
--- orig/source/p_player.h	2010-11-30 12:36:12.000000000 +0100
+++ mod/source/p_player.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_player.h 4336 2010-09-17 21:54:34Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -318,6 +318,11 @@
 		P_PASS_STR(Inv);
 		EV_RET_VOID(NAME_UseInventory);
 	}
+	bool eventCheckDoubleFiringSpeed()
+	{
+		P_PASS_SELF;
+		EV_RET_BOOL(NAME_CheckDoubleFiringSpeed);
+	}
 
 	//	Cheats.
 	void eventCheat_God()
@@ -370,6 +375,11 @@
 		P_PASS_SELF;
 		EV_RET_VOID(NAME_Cheat_Anubis);
 	}
+	void eventCheat_Freeze()
+	{
+		P_PASS_SELF;
+		EV_RET_VOID(NAME_Cheat_Freeze);
+	}
 
 	//	Server to client events.
 	void eventClientStartSound(int SoundId, TVec Org, int OriginId,
diff -Nur orig/source/p_player_input.cpp mod/source/p_player_input.cpp
--- orig/source/p_player_input.cpp	2010-12-13 22:09:47.000000000 +0100
+++ mod/source/p_player_input.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_player_input.cpp 4338 2010-12-13 21:09:47Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_playerreplicationinfo.cpp mod/source/p_playerreplicationinfo.cpp
--- orig/source/p_playerreplicationinfo.cpp	2007-04-19 23:14:11.000000000 +0200
+++ mod/source/p_playerreplicationinfo.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_playerreplicationinfo.cpp 2163 2007-04-19 21:15:06Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_playerreplicationinfo.h mod/source/p_playerreplicationinfo.h
--- orig/source/p_playerreplicationinfo.h	2008-01-03 09:36:55.000000000 +0100
+++ mod/source/p_playerreplicationinfo.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_playerreplicationinfo.h 2974 2008-01-03 08:36:51Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_polyobj.cpp mod/source/p_polyobj.cpp
--- orig/source/p_polyobj.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/p_polyobj.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_polyobj.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -92,7 +92,8 @@
 			*(PolyObjs[index].segs) = &Segs[i]; // insert the first seg
 			//	Set sector's line count to 0 to force it not to be
 			// rendered even if we do a no-clip into it.
-			Segs[i].frontsector->linecount = 0;
+			// -- FB -- I'm disabling this behavior
+//			Segs[i].frontsector->linecount = 0;
 			IterFindPolySegs(*Segs[i].v2, PolyObjs[index].segs + 1,
 				PolySegCount, PolyStart);
 			if (crush)
@@ -147,7 +148,8 @@
 						polySegList[psIndex] = &Segs[i];
 						//	Set sector's line count to 0 to force it not to be
 						// rendered even if we do a no-clip into it.
-						Segs[i].frontsector->linecount = 0;
+						// -- FB -- I'm disabling this behavior
+//						Segs[i].frontsector->linecount = 0;
 						PolyObjs[index].numsegs++;
 						psIndex++;
 						check(psIndex <= PO_MAXPOLYSEGS);
@@ -245,7 +247,8 @@
 				*segList++ = &Segs[i];
 				//	Set sector's line count to 0 to force it not to be
 				// rendered even if we do a no-clip into it.
-				Segs[i].frontsector->linecount = 0;
+				// -- FB -- I'm disabling this behavior
+//				Segs[i].frontsector->linecount = 0;
 			}
 			IterFindPolySegs(*Segs[i].v2, segList, PolySegCount, PolyStart);
 			return;
@@ -824,27 +827,44 @@
 		{
 			for (mobj = BlockLinks[j + i]; mobj; mobj = mobj->BlockMapNext)
 			{
-				if ((mobj->EntityFlags & VEntity::EF_Solid) ||
-					(mobj->EntityFlags & VEntity::EF_IsPlayer))
+				if (mobj->EntityFlags & VEntity::EF_ColideWithWorld)
 				{
-					tmbbox[BOXTOP] = mobj->Origin.y + mobj->Radius;
-					tmbbox[BOXBOTTOM] = mobj->Origin.y - mobj->Radius;
-					tmbbox[BOXLEFT] = mobj->Origin.x - mobj->Radius;
-					tmbbox[BOXRIGHT] = mobj->Origin.x + mobj->Radius;
-
-					if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT] ||
-						tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT] ||
-						tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM] ||
-						tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP])
+					if (mobj->EntityFlags & VEntity::EF_Solid)
 					{
-						continue;
+						tmbbox[BOXTOP] = mobj->Origin.y + mobj->Radius;
+						tmbbox[BOXBOTTOM] = mobj->Origin.y - mobj->Radius;
+						tmbbox[BOXLEFT] = mobj->Origin.x - mobj->Radius;
+						tmbbox[BOXRIGHT] = mobj->Origin.x + mobj->Radius;
+
+						if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT] ||
+							tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT] ||
+							tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM] ||
+							tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP])
+						{
+							continue;
+						}
+						if (P_BoxOnLineSide(tmbbox, ld) != -1)
+						{
+							continue;
+						}
+						mobj->Level->eventPolyThrustMobj(mobj, seg->normal, po);
+						blocked = true;
 					}
-					if (P_BoxOnLineSide(tmbbox, ld) != -1)
+					if (mobj->EntityFlags & VEntity::EF_Corpse)
 					{
-						continue;
+						if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT] ||
+							tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT] ||
+							tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM] ||
+							tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP])
+						{
+							continue;
+						}
+						if (P_BoxOnLineSide(tmbbox, ld) != -1)
+						{
+							continue;
+						}
+						mobj->Level->eventPolyCrushMobj(mobj, po);
 					}
-					mobj->Level->eventPolyThrustMobj(mobj, seg->normal, po);
-					blocked = true;
 				}
 			}
 		}
diff -Nur orig/source/pr_cmds.cpp mod/source/pr_cmds.cpp
--- orig/source/pr_cmds.cpp	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/pr_cmds.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: pr_cmds.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -33,6 +33,7 @@
 #include "network.h"
 #include "sv_local.h"
 #include "cl_local.h"
+#include "snd_local.h"
 #include "drawer.h"
 
 // MACROS ------------------------------------------------------------------
@@ -292,6 +293,19 @@
 
 //==========================================================================
 //
+//	PF_StopAllSounds
+//
+//==========================================================================
+
+IMPLEMENT_FUNCTION(VObject, StopAllSounds)
+{
+#ifdef CLIENT
+	GAudio->StopAllSound();
+#endif
+}
+
+//==========================================================================
+//
 //  PF_SetSeqTrans
 //
 //==========================================================================
@@ -350,7 +364,7 @@
 IMPLEMENT_FUNCTION(VObject, SB_Start)
 {
 #ifdef CLIENT
-//	SB_Start();
+	SB_Start();
 #endif
 }
 
@@ -610,6 +624,12 @@
 	RET_STR(P_GetMapName(map));
 }
 
+IMPLEMENT_FUNCTION(VObject, P_GetMapIndexByLevelNum)
+{
+	P_GET_INT(map);
+	RET_INT(P_GetMapIndexByLevelNum(map));
+}
+
 IMPLEMENT_FUNCTION(VObject, P_GetMapLumpName)
 {
 	P_GET_INT(map);
diff -Nur orig/source/pr_exec.cpp mod/source/pr_exec.cpp
--- orig/source/pr_exec.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/pr_exec.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: pr_exec.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/progdefs.h mod/source/progdefs.h
--- orig/source/progdefs.h	2010-12-30 20:22:28.000000000 +0100
+++ mod/source/progdefs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: progdefs.h 4360 2010-12-30 19:22:35Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/progs.h mod/source/progs.h
--- orig/source/progs.h	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/progs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: progs.h 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_setup.cpp mod/source/p_setup.cpp
--- orig/source/p_setup.cpp	2010-09-09 21:48:11.000000000 +0200
+++ mod/source/p_setup.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: p_setup.cpp 4331 2010-09-09 19:49:09Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -1427,7 +1427,7 @@
 	VStream* Strm = new VZipStreamReader(DataStrm);
 
 	//	Read extra vertex data
-	guard(Vertexes);
+	guard(VLevel::LoadCompressedGLNodes::Vertexes);
 	vuint32 OrgVerts;
 	vuint32 NewVerts;
 	*Strm << OrgVerts << NewVerts;
@@ -1461,7 +1461,7 @@
 	unguard;
 
 	//	Load subsectors
-	guard(Subsectors);
+	guard(VLevel::LoadCompressedGLNodes::Subsectors);
 	NumSubsectors = Streamer<vuint32>(*Strm);
 	Subsectors = new subsector_t[NumSubsectors];
 	memset(Subsectors, 0, sizeof(subsector_t) * NumSubsectors);
@@ -1478,7 +1478,7 @@
 	unguard;
 
 	//	Load segs
-	guard(Segs);
+	guard(VLevel::LoadCompressedGLNodes::Segs);
 	NumSegs = Streamer<vuint32>(*Strm);
 	Segs = new seg_t[NumSegs];
 	memset(Segs, 0, sizeof(seg_t) * NumSegs);
@@ -1538,7 +1538,7 @@
 	unguard;
 
 	//	Load nodes.
-	guard(Nodes);
+	guard(VLevel::LoadCompressedGLNodes::Nodes);
 	NumNodes = Streamer<vuint32>(*Strm);
 	Nodes = new node_t[NumNodes];
 	memset(Nodes, 0, sizeof(node_t) * NumNodes);
@@ -1569,7 +1569,7 @@
 	unguard;
 
 	//	Set v2 of the segs.
-	guard(Set up seg v2);
+	guard(VLevel::LoadCompressedGLNodes::Set up seg v2);
 	subsector_t* Sub = Subsectors;
 	for (int i = 0; i < NumSubsectors; i++, Sub++)
 	{
@@ -1582,7 +1582,7 @@
 	}
 	unguard;
 
-	guard(Calc segs);
+	guard(VLevel::LoadCompressedGLNodes::Calc segs);
 	seg_t* li = Segs;
 	for (int i = 0; i < NumSegs; i++, li++)
 	{
diff -Nur orig/source/p_setup_udmf.cpp mod/source/p_setup_udmf.cpp
--- orig/source/p_setup_udmf.cpp	2008-06-06 21:25:07.000000000 +0200
+++ mod/source/p_setup_udmf.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: p_setup_udmf.cpp 3681 2008-06-06 19:26:02Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_switch.cpp mod/source/p_switch.cpp
--- orig/source/p_switch.cpp	2009-11-09 22:08:47.000000000 +0100
+++ mod/source/p_switch.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_switch.cpp 4084 2009-11-09 22:14:10Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_terrain.cpp mod/source/p_terrain.cpp
--- orig/source/p_terrain.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/p_terrain.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_terrain.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -211,19 +211,19 @@
 				{
 					sc->ExpectNumber();
 					SInfo->ChunkXVelMul = sc->Number < 0 ? 0.0 :
-						(1 << sc->Number) / 256.0;
+						float((1 << sc->Number) / 256);
 				}
 				else if (sc->Check("chunkyvelshift"))
 				{
 					sc->ExpectNumber();
 					SInfo->ChunkYVelMul = sc->Number < 0 ? 0.0 :
-						(1 << sc->Number) / 256.0;
+						float((1 << sc->Number) / 256);
 				}
 				else if (sc->Check("chunkzvelshift"))
 				{
 					sc->ExpectNumber();
 					SInfo->ChunkZVelMul = sc->Number < 0 ? 0.0 :
-						(1 << sc->Number) / 256.0;
+						float((1 << sc->Number) / 256);
 				}
 				else if (sc->Check("chunkbasezvel"))
 				{
diff -Nur orig/source/p_thinker.cpp mod/source/p_thinker.cpp
--- orig/source/p_thinker.cpp	2008-04-10 20:19:25.000000000 +0200
+++ mod/source/p_thinker.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_thinker.cpp 3396 2008-03-27 21:21:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_thinker.h mod/source/p_thinker.h
--- orig/source/p_thinker.h	2009-11-13 22:52:42.000000000 +0100
+++ mod/source/p_thinker.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_thinker.h 4110 2009-11-13 21:54:07Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_trace.cpp mod/source/p_trace.cpp
--- orig/source/p_trace.cpp	2008-12-27 11:32:18.000000000 +0100
+++ mod/source/p_trace.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_trace.cpp 3906 2008-12-27 10:43:11Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -101,31 +101,34 @@
 	guard(VLevel::CheckPlanes);
 	sec_region_t* StartReg = SV_PointInRegion(Sec, Trace.LineStart);
 
-	for (sec_region_t* Reg = StartReg; Reg; Reg = Reg->next)
+	if (StartReg != NULL)
 	{
-		if (!CheckPlane(Trace, Reg->floor))
+		for (sec_region_t* Reg = StartReg; Reg != NULL; Reg = Reg->next)
 		{
-			//	Hit floor
-			return false;
-		}
-		if (!CheckPlane(Trace, Reg->ceiling))
-		{
-			//	Hit ceiling
-			return false;
+			if (!CheckPlane(Trace, Reg->floor))
+			{
+				//	Hit floor
+				return false;
+			}
+			if (!CheckPlane(Trace, Reg->ceiling))
+			{
+				//	Hit ceiling
+				return false;
+			}
 		}
-	}
 
-	for (sec_region_t* Reg = StartReg->prev; Reg; Reg = Reg->prev)
-	{
-		if (!CheckPlane(Trace, Reg->floor))
-		{
-			//	Hit floor
-			return false;
-		}
-		if (!CheckPlane(Trace, Reg->ceiling))
+		for (sec_region_t* Reg = StartReg->prev; Reg != NULL; Reg = Reg->prev)
 		{
-			//	Hit ceiling
-			return false;
+			if (!CheckPlane(Trace, Reg->floor))
+			{
+				//	Hit floor
+				return false;
+			}
+			if (!CheckPlane(Trace, Reg->ceiling))
+			{
+				//	Hit ceiling
+				return false;
+			}
 		}
 	}
 
@@ -298,34 +301,40 @@
 bool VLevel::CrossBSPNode(linetrace_t& Trace, int BspNum) const
 {
 	guard(VLevel::CrossBSPNode);
-	if (BspNum & NF_SUBSECTOR)
+	if (BspNum == -1)
 	{
-		if (BspNum == -1)
-			return CrossSubsector(Trace, 0);
-		else
-			return CrossSubsector(Trace, BspNum & (~NF_SUBSECTOR));
+		return CrossSubsector(Trace, 0);
 	}
 
-	node_t* Bsp = &Nodes[BspNum];
+	if (!(BspNum & NF_SUBSECTOR))
+	{
+		node_t* Bsp = &Nodes[BspNum];
 	
-	// decide which side the start point is on
-	int Side = Bsp->PointOnSide2(Trace.Start);
-	if (Side == 2)
-		Side = 0;	// an "on" should cross both sides
+		// decide which side the start point is on
+		int Side = Bsp->PointOnSide2(Trace.Start);
+		if (Side == 2)
+		{
+			Side = 0;	// an "on" should cross both sides
+		}
 
-	// cross the starting side
-	if (!CrossBSPNode(Trace, Bsp->children[Side]))
-		return false;
+		// cross the starting side
+		if (!CrossBSPNode(Trace, Bsp->children[Side]))
+		{
+			return false;
+		}
 	
-	// the partition plane is crossed here
-	if (Side == Bsp->PointOnSide2(Trace.End))
-	{
-		// the line doesn't touch the other side
-		return true;
+		// the partition plane is crossed here
+		if (Side == Bsp->PointOnSide2(Trace.End))
+		{
+			// the line doesn't touch the other side
+			return true;
+		}
+
+		// cross the ending side		
+		return CrossBSPNode(Trace, Bsp->children[Side ^ 1]);
 	}
 
-	// cross the ending side		
-	return CrossBSPNode(Trace, Bsp->children[Side ^ 1]);
+	return CrossSubsector(Trace, BspNum & (~NF_SUBSECTOR));
 	unguard;
 }
 
diff -Nur orig/source/p_world.cpp mod/source/p_world.cpp
--- orig/source/p_world.cpp	2009-01-01 14:15:06.000000000 +0100
+++ mod/source/p_world.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_world.cpp 3924 2009-01-01 13:20:02Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -262,8 +262,8 @@
 	float y2, int flags)
 {
 	guard(VPathTraverse::Init);
-	float x1 = InX1;
-	float y1 = InY1;
+	float		x1 = InX1;
+	float		y1 = InY1;
 	int			xt1;
 	int			yt1;
 	int			xt2;
@@ -373,8 +373,8 @@
 		}
 		if (partialx == partialy)
 		{
-			xintercept = xt1;
-			yintercept = yt1;
+			xintercept = float(xt1);
+			yintercept = float(yt1);
 		}
 	}
 
@@ -405,17 +405,17 @@
 		}
 
 		// [RH] Handle corner cases properly instead of pretending they don't exist.
-		if ((int)yintercept == mapy)
+		if (int(yintercept) == mapy)
 		{
 			yintercept += ystep;
 			mapx += mapxstep;
 		}
-		else if ((int)xintercept == mapx)
+		else if (int(xintercept) == mapx)
 		{
 			xintercept += xstep;
 			mapy += mapystep;
 		}
-		else if (((int)yintercept == mapy) && ((int)xintercept == mapx))
+		else if ((int(fabs(yintercept)) == mapy) && (int(fabs(xintercept)) == mapx))
 		{
 			// The trace is exiting a block through its corner. Not only does the block
 			// being entered need to be checked (which will happen when this loop
@@ -492,9 +492,9 @@
 		num = ld->dist - DotProduct(trace_org, ld->normal);
 		frac = num / den;
 
-		if (frac < 0)
+		if (frac < 0 || frac > 1.0)
 		{
-			continue;	// behind source
+			continue;	// behind source or beyond end point
 		}
 
 		// try to early out the check
@@ -522,7 +522,7 @@
 void VPathTraverse::AddThingIntercepts(VThinker* Self, int mapx, int mapy)
 {
 	guard(VPathTraverse::AddThingIntercepts);
-	for (VBlockThingsIterator It(Self->XLevel, mapx, mapy); It; ++It)
+	for (VBlockThingsIterator It(Self->XLevel, mapx, mapy); Self && It; ++It)
 	{
 		float dot = DotProduct(It->Origin, trace_plane.normal) -
 			trace_plane.dist;
diff -Nur orig/source/p_world.h mod/source/p_world.h
--- orig/source/p_world.h	2009-01-01 14:15:06.000000000 +0100
+++ mod/source/p_world.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_world.h 3924 2009-01-01 13:20:02Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_worldinfo.cpp mod/source/p_worldinfo.cpp
--- orig/source/p_worldinfo.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/p_worldinfo.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_worldinfo.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/p_worldinfo.h mod/source/p_worldinfo.h
--- orig/source/p_worldinfo.h	2009-11-13 22:52:42.000000000 +0100
+++ mod/source/p_worldinfo.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: p_worldinfo.h 4110 2009-11-13 21:54:07Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_adv_light.cpp mod/source/r_adv_light.cpp
--- orig/source/r_adv_light.cpp	2010-12-14 12:22:15.000000000 +0100
+++ mod/source/r_adv_light.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -1,948 +1,1061 @@
-//**************************************************************************
-//**
-//**	##   ##    ##    ##   ##   ####     ####   ###     ###
-//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
-//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
-//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
-//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
-//**	   #    ##    ##    #      ####     ####   ##       ##
-//**
-//**	$Id: r_light.cpp 4220 2010-04-24 15:24:35Z dj_jl $
-//**
-//**	Copyright (C) 1999-2006 Jānis Legzdiņš
-//**
-//**	This program is free software; you can redistribute it and/or
-//**  modify it under the terms of the GNU General Public License
-//**  as published by the Free Software Foundation; either version 2
-//**  of the License, or (at your option) any later version.
-//**
-//**	This program is distributed in the hope that it will be useful,
-//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//**  GNU General Public License for more details.
-//**
-//**************************************************************************
-
-// HEADER FILES ------------------------------------------------------------
-
-#include "gamedefs.h"
-#include "r_local.h"
-
-// MACROS ------------------------------------------------------------------
-
-// TYPES -------------------------------------------------------------------
-
-// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------
-
-// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------
-
-// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------
-
-// EXTERNAL DATA DECLARATIONS ----------------------------------------------
-
-// PUBLIC DATA DEFINITIONS -------------------------------------------------
-
-extern VCvarI				r_darken;
-
-// PRIVATE DATA DEFINITIONS ------------------------------------------------
-
-static subsector_t*		r_sub;
-static sec_region_t*	r_region;
-static VCvarF			r_lights_radius("r_lights_radius", "4096", CVAR_Archive);
-
-// CODE --------------------------------------------------------------------
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::PushDlights
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::PushDlights()
-{
-	r_dlightframecount = 1;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::LightPoint
-//
-//==========================================================================
-
-vuint32 VAdvancedRenderLevel::LightPoint(const TVec &p)
-{
-	guard(VAdvancedRenderLevel::LightPoint);
-	subsector_t		*sub;
-	subregion_t		*reg;
-	float			l, lr, lg, lb, d, add;
-	int				i;
-	int				leafnum;
-	linetrace_t		Trace;
-
-	if (FixedLight)
-	{
-		return FixedLight | (FixedLight << 8) | (FixedLight << 16) | (FixedLight << 24);
-	}
-
-	sub = Level->PointInSubsector(p);
-	vuint8* dyn_facevis = Level->LeafPVS(sub);
-	reg = sub->regions;
-	while (reg->next)
-	{
-		d = DotProduct(p, reg->floor->secplane->normal) - reg->floor->secplane->dist;
-
-		if (d >= 0.0)
-		{
-			break;
-		}
-
-		reg = reg->next;
-	}
-
-	//	Region's base light
-	l = reg->secregion->params->lightlevel + ExtraLight;
-	if (r_darken)
-	{
-		l = light_remap[MIN(255, (int)l)];
-	}
-	l = MIN(255, l);
-	int SecLightColour = reg->secregion->params->LightColour;
-	lr = ((SecLightColour >> 16) & 255) * l / 255.0;
-	lg = ((SecLightColour >> 8) & 255) * l / 255.0;
-	lb = (SecLightColour & 255) * l / 255.0;
-
-	//	Add static lights
-	for (i = 0; i < Lights.Num(); i++)
-	{
-/*		leafnum = Level->PointInSubsector(Lights[i].origin) -
-			Level->Subsectors;*/
-
-		if (!Lights[i].radius)
-		{
-			continue;
-		}
-
-		// Check potential visibility
-		if (!(dyn_facevis[Lights[i].leafnum >> 3] & (1 << (Lights[i].leafnum & 7))))
-		{
-			continue;
-		}
-
-		if (!Level->TraceLine(Trace, Lights[i].origin, p, SPF_NOBLOCKSIGHT))
-		{
-			// ray was blocked
-			continue;
-		}
-
-		add = Lights[i].radius - Length(p - Lights[i].origin);
-		if (add > 0)
-		{
-			l += add;
-			lr += add * ((Lights[i].colour >> 16) & 0xff) / 255.0;
-			lg += add * ((Lights[i].colour >> 8) & 0xff) / 255.0;
-			lb += add * (Lights[i].colour & 0xff) / 255.0;
-		}
-	}
-
-	//	Add dynamic lights
-	for (i = 0; i < MAX_DLIGHTS; i++)
-	{
-		if (DLights[i].die < Level->Time || !DLights[i].radius)
-			continue;
-
-		leafnum = Level->PointInSubsector(DLights[i].origin) -
-			Level->Subsectors;
-
-		// Check potential visibility
-		if (!(dyn_facevis[leafnum >> 3] & (1 << (leafnum & 7))))
-		{
-			continue;
-		}
-
-		add = (DLights[i].radius - DLights[i].minlight) - Length(p - DLights[i].origin);
-		if (add > 0)
-		{
-			l += add;
-			lr += add * ((DLights[i].colour >> 16) & 0xff) / 255.0;
-			lg += add * ((DLights[i].colour >> 8) & 0xff) / 255.0;
-			lb += add * (DLights[i].colour & 0xff) / 255.0;
-		}
-	}
-
-	if (l > 255)
-		l = 255;
-	if (lr > 255)
-		lr = 255;
-	if (lg > 255)
-		lg = 255;
-	if (lb > 255)
-		lb = 255;
-
-	return ((int)l << 24) | ((int)lr << 16) | ((int)lg << 8) | ((int)lb);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::LightPointAmbient
-//
-//==========================================================================
-
-vuint32 VAdvancedRenderLevel::LightPointAmbient(const TVec &p)
-{
-	guard(VAdvancedRenderLevel::LightPointAmbient);
-	subsector_t		*sub;
-	subregion_t		*reg;
-	float			l, lr, lg, lb, d;
-	linetrace_t		Trace;
-
-	if (FixedLight)
-	{
-		return FixedLight | (FixedLight << 8) | (FixedLight << 16) | (FixedLight << 24);
-	}
-
-	sub = Level->PointInSubsector(p);
-	reg = sub->regions;
-	while (reg->next)
-	{
-		d = DotProduct(p, reg->floor->secplane->normal) - reg->floor->secplane->dist;
-
-		if (d >= 0.0)
-		{
-			break;
-		}
-
-		reg = reg->next;
-	}
-
-	//	Region's base light
-	l = reg->secregion->params->lightlevel + ExtraLight;
-	if (r_darken)
-	{
-		l = light_remap[MIN(255, (int)l)];
-	}
-	l = MIN(255, l);
-	int SecLightColour = reg->secregion->params->LightColour;
-	lr = ((SecLightColour >> 16) & 255) * l / 255.0;
-	lg = ((SecLightColour >> 8) & 255) * l / 255.0;
-	lb = (SecLightColour & 255) * l / 255.0;
-
-	return ((int)l << 24) | ((int)lr << 16) | ((int)lg << 8) | ((int)lb);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::BuildLightMap
-//
-//==========================================================================
-
-bool VAdvancedRenderLevel::BuildLightMap(surface_t *surf, int shift)
-{
-	return true;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::BuildLightVis
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::BuildLightVis(int bspnum, float* bbox)
-{
-	guard(VAdvancedRenderLevel::BuildLightVis);
-	if (LightClip.ClipIsFull())
-	{
-		return;
-	}
-
-	if (!LightClip.ClipIsBBoxVisible(bbox))
-	{
-		return;
-	}
-
-	// Found a subsector?
-	if (bspnum & NF_SUBSECTOR)
-	{
-		int SubNum = bspnum == -1 ? 0 : bspnum & (~NF_SUBSECTOR);
-		subsector_t* Sub = &Level->Subsectors[SubNum];
-		if (!Sub->sector->linecount)
-		{
-			//	Skip sectors containing original polyobjs
-			return;
-		}
-
-		if (!LightClip.ClipCheckSubsector(Sub))
-		{
-			return;
-		}
-
-		LightVis[SubNum >> 3] |= 1 << (SubNum & 7);
-		LightClip.ClipAddSubsectorSegs(Sub);
-		return;
-	}
-
-	node_t* bsp = &Level->Nodes[bspnum];
-
-	// Decide which side the view point is on.
-	float Dist = DotProduct(CurrLightPos, bsp->normal) - bsp->dist;
-	if (Dist >= CurrLightRadius)
-	{
-		//	Light is completely on front side.
-		BuildLightVis(bsp->children[0], bsp->bbox[0]);
-	}
-	else if (Dist <= -CurrLightRadius)
-	{
-		//	Light is completely on back side.
-		BuildLightVis(bsp->children[1], bsp->bbox[1]);
-	}
-	else
-	{
-		int side = Dist < 0;
-
-		// Recursively divide front space.
-		BuildLightVis(bsp->children[side], bsp->bbox[side]);
-
-		// Divide back space.
-		BuildLightVis(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
-	}
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::DrawShadowSurfaces
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::DrawShadowSurfaces(surface_t* InSurfs, texinfo_t *texinfo,
-	bool CheckSkyBoxAlways)
-{
-	guard(VAdvancedRenderLevel::DrawShadowSurfaces);
-	surface_t* surfs = InSurfs;
-	if (!surfs)
-	{
-		return;
-	}
-
-	if (texinfo->Tex->Type == TEXTYPE_Null)
-	{
-		return;
-	}
-	if (texinfo->Alpha < 1.0)
-	{
-		return;
-	}
-
-	do
-	{
-		Drawer->RenderSurfaceShadowVolume(surfs, CurrLightPos, CurrLightRadius);
-		surfs = surfs->next;
-	} while (surfs);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderShadowLine
-//
-// 	Clips the given segment and adds any visible pieces to the line list.
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderShadowLine(drawseg_t* dseg)
-{
-	guard(VAdvancedRenderLevel::RenderShadowLine);
-	seg_t *line = dseg->seg;
-
-	if (!line->linedef)
-	{
-		//	Miniseg
-		return;
-	}
-
-	float dist = DotProduct(CurrLightPos, line->normal) - line->dist;
-	if (dist <= 0)
-	{
-		//	Light is in back side or on plane
-		return;
-	}
-
-	float a1 = LightClip.PointToClipAngle(*line->v2);
-	float a2 = LightClip.PointToClipAngle(*line->v1);
-	if (!LightClip.IsRangeVisible(a1, a2))
-	{
-		return;
-	}
-
-	line_t *linedef = line->linedef;
-	side_t *sidedef = line->sidedef;
-
-	if (!line->backsector)
-	{
-		// single sided line
-		DrawShadowSurfaces(dseg->mid->surfs, &dseg->mid->texinfo, false);
-		DrawShadowSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo, false);
-	}
-	else
-	{
-		// two sided line
-		DrawShadowSurfaces(dseg->top->surfs, &dseg->top->texinfo, false);
-		DrawShadowSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo, false);
-		DrawShadowSurfaces(dseg->bot->surfs, &dseg->bot->texinfo, false);
-		DrawShadowSurfaces(dseg->mid->surfs, &dseg->mid->texinfo, false);
-		for (segpart_t *sp = dseg->extra; sp; sp = sp->next)
-		{
-			DrawShadowSurfaces(sp->surfs, &sp->texinfo, false);
-		}
-	}
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderShadowSecSurface
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderShadowSecSurface(sec_surface_t* ssurf, VEntity* SkyBox)
-{
-	guard(VAdvancedRenderLevel::RenderShadowSecSurface);
-	sec_plane_t& plane = *ssurf->secplane;
-
-	if (!plane.pic)
-	{
-		return;
-	}
-
-	float dist = DotProduct(CurrLightPos, plane.normal) - plane.dist;
-	if (dist <= 0)
-	{
-		//	Light is in back side or on plane
-		return;
-	}
-
-	DrawShadowSurfaces(ssurf->surfs, &ssurf->texinfo, true);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderShadowSubRegion
-//
-// 	Determine floor/ceiling planes.
-// 	Draw one or more line segments.
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderShadowSubRegion(subregion_t* region)
-{
-	guard(VAdvancedRenderLevel::RenderShadowSubRegion);
-	int				count;
-	int 			polyCount;
-	seg_t**			polySeg;
-	float			d;
-
-	d = DotProduct(CurrLightPos, region->floor->secplane->normal) -
-		region->floor->secplane->dist;
-	if (region->next && d <= 0.0)
-	{
-		RenderShadowSubRegion(region->next);
-	}
-
-	r_region = region->secregion;
-
-	if (r_sub->poly)
-	{
-		//	Render the polyobj in the subsector first
-		polyCount = r_sub->poly->numsegs;
-		polySeg = r_sub->poly->segs;
-		while (polyCount--)
-		{
-			RenderShadowLine((*polySeg)->drawsegs);
-			polySeg++;
-		}
-	}
-
-	count = r_sub->numlines;
-	drawseg_t *ds = region->lines;
-	while (count--)
-	{
-		RenderShadowLine(ds);
-		ds++;
-	}
-
-	RenderShadowSecSurface(region->floor, r_region->floor->SkyBox);
-	RenderShadowSecSurface(region->ceil, r_region->ceiling->SkyBox);
-
-	if (region->next && d > 0.0)
-	{
-		RenderShadowSubRegion(region->next);
-	}
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderShadowSubsector
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderShadowSubsector(int num)
-{
-	guard(VAdvancedRenderLevel::RenderShadowSubsector);
-	subsector_t* Sub = &Level->Subsectors[num];
-	r_sub = Sub;
-
-	if (!(LightVis[num >> 3] & (1 << (num & 7))))
-	{
-		return;
-	}
-
-	if (!Sub->sector->linecount)
-	{
-		//	Skip sectors containing original polyobjs
-		return;
-	}
-
-	RenderShadowSubRegion(Sub->regions);
-
-	//	Add subsector's segs to the clipper. Clipping against mirror
-	// is done only for vertical mirror planes.
-	LightClip.ClipAddSubsectorSegs(Sub);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderShadowBSPNode
-//
-//	Renders all subsectors below a given node, traversing subtree
-// recursively. Just call with BSP root.
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderShadowBSPNode(int bspnum, float* bbox)
-{
-	guard(VAdvancedRenderLevel::RenderShadowBSPNode);
-	if (LightClip.ClipIsFull())
-	{
-		return;
-	}
-
-	if (!LightClip.ClipIsBBoxVisible(bbox))
-	{
-		return;
-	}
-
-	// Found a subsector?
-	if (bspnum & NF_SUBSECTOR)
-	{
-		if (bspnum == -1)
-		{
-			RenderShadowSubsector(0);
-		}
-		else
-		{
-			RenderShadowSubsector(bspnum & (~NF_SUBSECTOR));
-		}
-		return;
-	}
-
-	node_t* bsp = &Level->Nodes[bspnum];
-
-	/*if (bsp->VisFrame != r_visframecount)
-	{
-		return;
-	}*/
-
-	// Decide which side the light is on.
-	float Dist = DotProduct(CurrLightPos, bsp->normal) - bsp->dist;
-	if (Dist >= CurrLightRadius)
-	{
-		//	Light is completely on front side.
-		RenderShadowBSPNode(bsp->children[0], bsp->bbox[0]);
-	}
-	else if (Dist <= -CurrLightRadius)
-	{
-		//	Light is completely on back side.
-		RenderShadowBSPNode(bsp->children[1], bsp->bbox[1]);
-	}
-	else
-	{
-		int side = Dist < 0;
-
-		// Recursively divide front space.
-		RenderShadowBSPNode(bsp->children[side], bsp->bbox[side]);
-
-		// Divide back space.
-		RenderShadowBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
-	}
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::DrawLightSurfaces
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::DrawLightSurfaces(surface_t* InSurfs, texinfo_t *texinfo,
-	VEntity* SkyBox, bool CheckSkyBoxAlways)
-{
-	guard(VAdvancedRenderLevel::DrawLightSurfaces);
-	surface_t* surfs = InSurfs;
-	if (!surfs)
-	{
-		return;
-	}
-
-	if (texinfo->Tex->Type == TEXTYPE_Null)
-	{
-		return;
-	}
-	if (texinfo->Alpha < 1.0)
-	{
-		return;
-	}
-
-	if (SkyBox && (SkyBox->EntityFlags & VEntity::EF_FixedModel))
-	{
-		SkyBox = NULL;
-	}
-	bool IsStack = SkyBox && SkyBox->eventSkyBoxGetAlways();
-	if (texinfo->Tex == GTextureManager[skyflatnum] ||
-		(IsStack && CheckSkyBoxAlways))
-	{
-		return;
-	}
-
-	do
-	{
-		Drawer->DrawSurfaceLight(surfs);
-		surfs = surfs->next;
-	} while (surfs);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderLightLine
-//
-// 	Clips the given segment and adds any visible pieces to the line list.
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderLightLine(drawseg_t* dseg)
-{
-	guard(VAdvancedRenderLevel::RenderLightLine);
-	seg_t *line = dseg->seg;
-
-	if (!line->linedef)
-	{
-		//	Miniseg
-		return;
-	}
-
-	float dist = DotProduct(vieworg, line->normal) - line->dist;
-	if (dist <= 0)
-	{
-		//	Viewer is in back side or on plane
-		return;
-	}
-	dist = DotProduct(CurrLightPos, line->normal) - line->dist;
-	if (dist < 0 || dist >= CurrLightRadius)
-	{
-		//	Light is in back side or on plane or too far away
-		return;
-	}
-
-	float a1 = LightClip.PointToClipAngle(*line->v2);
-	float a2 = LightClip.PointToClipAngle(*line->v1);
-	if (!LightClip.IsRangeVisible(a1, a2))
-	{
-		return;
-	}
-
-	line_t *linedef = line->linedef;
-	side_t *sidedef = line->sidedef;
-
-	if (!line->backsector)
-	{
-		// single sided line
-		DrawLightSurfaces(dseg->mid->surfs, &dseg->mid->texinfo,
-			r_region->ceiling->SkyBox, false);
-		DrawLightSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo,
-			r_region->ceiling->SkyBox, false);
-	}
-	else
-	{
-		// two sided line
-		DrawLightSurfaces(dseg->top->surfs, &dseg->top->texinfo,
-			r_region->ceiling->SkyBox, false);
-		DrawLightSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo,
-			r_region->ceiling->SkyBox, false);
-		DrawLightSurfaces(dseg->bot->surfs, &dseg->bot->texinfo,
-			r_region->ceiling->SkyBox, false);
-		DrawLightSurfaces(dseg->mid->surfs, &dseg->mid->texinfo,
-			r_region->ceiling->SkyBox, false);
-		for (segpart_t *sp = dseg->extra; sp; sp = sp->next)
-		{
-			DrawLightSurfaces(sp->surfs, &sp->texinfo,
-				r_region->ceiling->SkyBox, false);
-		}
-	}
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderLightSecSurface
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderLightSecSurface(sec_surface_t* ssurf, VEntity* SkyBox)
-{
-	guard(VAdvancedRenderLevel::RenderLightSecSurface);
-	sec_plane_t& plane = *ssurf->secplane;
-
-	if (!plane.pic)
-	{
-		return;
-	}
-
-	float dist = DotProduct(vieworg, plane.normal) - plane.dist;
-	if (dist <= 0)
-	{
-		//	Viewer is in back side or on plane
-		return;
-	}
-	dist = DotProduct(CurrLightPos, plane.normal) - plane.dist;
-	if (dist < 0 || dist >= CurrLightRadius)
-	{
-		//	Light is in back side or on plane or too far away
-		return;
-	}
-
-	DrawLightSurfaces(ssurf->surfs, &ssurf->texinfo, SkyBox, true);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderLightSubRegion
-//
-// 	Determine floor/ceiling planes.
-// 	Draw one or more line segments.
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderLightSubRegion(subregion_t* region)
-{
-	guard(VAdvancedRenderLevel::RenderLightSubRegion);
-	int				count;
-	int 			polyCount;
-	seg_t**			polySeg;
-	float			d;
-
-	d = DotProduct(vieworg, region->floor->secplane->normal) -
-		region->floor->secplane->dist;
-	if (region->next && d <= 0.0)
-	{
-		RenderLightSubRegion(region->next);
-	}
-
-	r_region = region->secregion;
-
-	if (r_sub->poly)
-	{
-		//	Render the polyobj in the subsector first
-		polyCount = r_sub->poly->numsegs;
-		polySeg = r_sub->poly->segs;
-		while (polyCount--)
-		{
-			RenderLightLine((*polySeg)->drawsegs);
-			polySeg++;
-		}
-	}
-
-	count = r_sub->numlines;
-	drawseg_t *ds = region->lines;
-	while (count--)
-	{
-		RenderLightLine(ds);
-		ds++;
-	}
-
-	RenderLightSecSurface(region->floor, r_region->floor->SkyBox);
-	RenderLightSecSurface(region->ceil, r_region->ceiling->SkyBox);
-
-	if (region->next && d > 0.0)
-	{
-		RenderLightSubRegion(region->next);
-	}
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderLightSubsector
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderLightSubsector(int num)
-{
-	guard(VAdvancedRenderLevel::RenderLightSubsector);
-	subsector_t* Sub = &Level->Subsectors[num];
-	r_sub = Sub;
-
-	if (!(LightBspVis[num >> 3] & (1 << (num & 7))))
-	{
-		return;
-	}
-
-	if (!Sub->sector->linecount)
-	{
-		//	Skip sectors containing original polyobjs
-		return;
-	}
-
-	RenderLightSubRegion(Sub->regions);
-
-	//	Add subsector's segs to the clipper. Clipping against mirror
-	// is done only for vertical mirror planes.
-	LightClip.ClipAddSubsectorSegs(Sub);
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderLightBSPNode
-//
-//	Renders all subsectors below a given node, traversing subtree
-// recursively. Just call with BSP root.
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderLightBSPNode(int bspnum, float* bbox)
-{
-	guard(VAdvancedRenderLevel::RenderLightBSPNode);
-	if (LightClip.ClipIsFull())
-	{
-		return;
-	}
-
-	if (!LightClip.ClipIsBBoxVisible(bbox))
-	{
-		return;
-	}
-
-	// Found a subsector?
-	if (bspnum & NF_SUBSECTOR)
-	{
-		if (bspnum == -1)
-		{
-			RenderLightSubsector(0);
-		}
-		else
-		{
-			RenderLightSubsector(bspnum & (~NF_SUBSECTOR));
-		}
-		return;
-	}
-
-	node_t* bsp = &Level->Nodes[bspnum];
-
-	// Decide which side the light is on.
-	float Dist = DotProduct(CurrLightPos, bsp->normal) - bsp->dist;
-	if (Dist >= CurrLightRadius)
-	{
-		//	Light is completely on front side.
-		RenderLightBSPNode(bsp->children[0], bsp->bbox[0]);
-	}
-	else if (Dist <= -CurrLightRadius)
-	{
-		//	Light is completely on back side.
-		RenderLightBSPNode(bsp->children[1], bsp->bbox[1]);
-	}
-	else
-	{
-		int side = Dist < 0;
-
-		// Recursively divide front space.
-		RenderLightBSPNode(bsp->children[side], bsp->bbox[side]);
-
-		// Divide back space.
-		RenderLightBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
-	}
-	unguard;
-}
-
-//==========================================================================
-//
-//	VAdvancedRenderLevel::RenderLightShadows
-//
-//==========================================================================
-
-void VAdvancedRenderLevel::RenderLightShadows(const refdef_t* RD,
-	const VViewClipper* Range, TVec& Pos, float Radius, vuint32 Colour)
-{
-	guard(VAdvancedRenderLevel::RenderLightShadows);
-	//	Don't do lights that are too far away.
-	if ((Pos - vieworg).Length() > r_lights_radius + Radius)
-	{
-		return;
-	}
-
-	float	dummy_bbox[6] = {-99999, -99999, -99999, 99999, 99999, 99999};
-
-	//	Clip against frustrum.
-	for (int i = 0; i < (MirrorClip ? 5 : 4); i++)
-	{
-		float d = DotProduct(Pos, view_clipplanes[i].normal);
-		d -= view_clipplanes[i].dist;
-		if (d <= -Radius)
-		{
-			return;
-		}
-	}
-
-	CurrLightPos = Pos;
-	CurrLightRadius = Radius;
-	CurrLightColour = Colour;
-
-	//	Build vis data for light.
-	LightClip.ClearClipNodes(CurrLightPos, Level);
-	memset(LightVis, 0, VisSize);
-	BuildLightVis(Level->NumNodes - 1, dummy_bbox);
-
-	//	Create combined light and view visibility.
-	bool HaveIntersect = false;
-	for (int i = 0; i < VisSize; i++)
-	{
-		LightBspVis[i] = BspVis[i] & LightVis[i];
-		if (LightBspVis[i])
-		{
-			HaveIntersect = true;
-		}
-	}
-	if (!HaveIntersect)
-	{
-		return;
-	}
-
-	//	Do shadow volumes.
-	Drawer->BeginLightShadowVolumes();
-	LightClip.ClearClipNodes(CurrLightPos, Level);
-	RenderShadowBSPNode(Level->NumNodes - 1, dummy_bbox);
-	Drawer->BeginModelsShadowsPass(CurrLightPos, CurrLightRadius);
-	RenderMobjsShadow();
-
-	//	Draw light.
-	Drawer->BeginLightPass(CurrLightPos, CurrLightRadius, Colour);
-	LightClip.ClearClipNodes(CurrLightPos, Level);
-	RenderLightBSPNode(Level->NumNodes - 1, dummy_bbox);
-	Drawer->BeginModelsLightPass(CurrLightPos, CurrLightRadius, Colour);
-	RenderMobjsLight();
-	unguard;
-}
+//**************************************************************************
+//**
+//**	##   ##    ##    ##   ##   ####     ####   ###     ###
+//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**	   #    ##    ##    #      ####     ####   ##       ##
+//**
+//**	$Id: r_light.cpp 4220 2010-04-24 15:24:35Z dj_jl $
+//**
+//**	Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**	This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**	This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+// HEADER FILES ------------------------------------------------------------
+
+#include "gamedefs.h"
+#include "r_local.h"
+
+// MACROS ------------------------------------------------------------------
+
+// TYPES -------------------------------------------------------------------
+
+// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------
+
+// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------
+
+// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------
+
+// EXTERNAL DATA DECLARATIONS ----------------------------------------------
+
+// PUBLIC DATA DEFINITIONS -------------------------------------------------
+
+extern VCvarI				r_darken;
+
+// PRIVATE DATA DEFINITIONS ------------------------------------------------
+
+static subsector_t*		r_sub;
+static sec_region_t*	r_region;
+VCvarF					r_lights_radius("r_lights_radius", "4096", CVAR_Archive);
+VCvarI                  r_max_model_lights("r_max_model_lights", "32", CVAR_Archive);
+VCvarI                  r_max_model_shadows("r_max_model_shadows", "2", CVAR_Archive);
+VCvarI                  r_max_lights("r_max_lights", "64", CVAR_Archive);
+VCvarI                  r_max_shadows("r_max_shadows", "64", CVAR_Archive);
+
+// CODE --------------------------------------------------------------------
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::PushDlights
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::PushDlights()
+{
+	r_dlightframecount = 1;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::LightPoint
+//
+//==========================================================================
+
+vuint32 VAdvancedRenderLevel::LightPoint(const TVec &p)
+{
+	guard(VAdvancedRenderLevel::LightPoint);
+	subsector_t		*sub;
+	subregion_t		*reg;
+	float			l, lr, lg, lb, add;
+	int				leafnum;
+	linetrace_t		Trace;
+
+	if (FixedLight)
+	{
+		return FixedLight | (FixedLight << 8) | (FixedLight << 16) | (FixedLight << 24);
+	}
+
+	sub = Level->PointInSubsector(p);
+	reg = sub->regions;
+	if (reg)
+	{
+		while (reg->next)
+		{
+			float d = DotProduct(p, reg->floor->secplane->normal) - reg->floor->secplane->dist;
+
+			if (d >= 0.0)
+			{
+				break;
+			}
+
+			reg = reg->next;
+		}
+
+		//	Region's base light
+		l = reg->secregion->params->lightlevel + ExtraLight;
+		if (r_darken)
+		{
+			l = light_remap[MIN(255, (int)l)];
+		}
+		l = MIN(255, l);
+		int SecLightColour = reg->secregion->params->LightColour;
+		lr = ((SecLightColour >> 16) & 255) * l / 255.0;
+		lg = ((SecLightColour >> 8) & 255) * l / 255.0;
+		lb = (SecLightColour & 255) * l / 255.0;
+	}
+
+	//	Add static lights
+	if (r_static_lights)
+	{
+		vuint8* dyn_facevis = Level->LeafPVS(sub);
+		for (int i = 0; i < Lights.Num(); i++)
+		{
+			if (!Lights[i].radius)
+			{
+				continue;
+			}
+
+			// Check potential visibility
+			if (!(dyn_facevis[Lights[i].leafnum >> 3] & (1 << (Lights[i].leafnum & 7))))
+			{
+				continue;
+			}
+
+			add = Lights[i].radius - Length(p - Lights[i].origin);
+			if (add > 0)
+			{
+				l += add;
+				lr += add * ((Lights[i].colour >> 16) & 255) / 255.0;
+				lg += add * ((Lights[i].colour >> 8) & 255) / 255.0;
+				lb += add * (Lights[i].colour & 255) / 255.0;
+			}
+		}
+	}
+
+	//	Add dynamic lights
+	if (r_dynamic)
+	{
+		vuint8* dyn_facevis = Level->LeafPVS(sub);
+		for (int i = 0; i < MAX_DLIGHTS; i++)
+		{
+			if (!DLights[i].radius || DLights[i].die < Level->Time)
+				continue;
+
+			leafnum = Level->PointInSubsector(DLights[i].origin) -
+				Level->Subsectors;
+
+			// Check potential visibility
+			if (!(dyn_facevis[leafnum >> 3] & (1 << (leafnum & 7))))
+			{
+				continue;
+			}
+
+			add = (DLights[i].radius - DLights[i].minlight) - Length(p - DLights[i].origin);
+			if (add > 0)
+			{
+				l += add;
+				lr += add * ((DLights[i].colour >> 16) & 255) / 255.0;
+				lg += add * ((DLights[i].colour >> 8) & 255) / 255.0;
+				lb += add * (DLights[i].colour & 255) / 255.0;
+			}
+		}
+	}
+
+	if (l > 255)
+		l = 255;
+	if (lr > 255)
+		lr = 255;
+	if (lg > 255)
+		lg = 255;
+	if (lb > 255)
+		lb = 255;
+
+	return ((int)l << 24) | ((int)lr << 16) | ((int)lg << 8) | ((int)lb);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::LightPointAmbient
+//
+//==========================================================================
+
+vuint32 VAdvancedRenderLevel::LightPointAmbient(const TVec &p)
+{
+	guard(VAdvancedRenderLevel::LightPointAmbient);
+	subsector_t		*sub;
+	subregion_t		*reg;
+	float			l, lr, lg, lb;
+
+	if (FixedLight)
+	{
+		return FixedLight | (FixedLight << 8) | (FixedLight << 16) | (FixedLight << 24);
+	}
+
+	sub = Level->PointInSubsector(p);
+	reg = sub->regions;
+	while (reg->next)
+	{
+		float d = DotProduct(p, reg->floor->secplane->normal) - reg->floor->secplane->dist;
+
+		if (d >= 0.0)
+		{
+			break;
+		}
+
+		reg = reg->next;
+	}
+
+	//	Region's base light
+	l = reg->secregion->params->lightlevel + ExtraLight;
+	if (r_darken)
+	{
+		l = light_remap[MIN(255, (int)l)];
+	}
+	l = MIN(255, l);
+	int SecLightColour = reg->secregion->params->LightColour;
+	lr = ((SecLightColour >> 16) & 255) * l / 255.0;
+	lg = ((SecLightColour >> 8) & 255) * l / 255.0;
+	lb = (SecLightColour & 255) * l / 255.0;
+
+	return ((int)l << 24) | ((int)lr << 16) | ((int)lg << 8) | ((int)lb);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::BuildLightMap
+//
+//==========================================================================
+
+bool VAdvancedRenderLevel::BuildLightMap(surface_t *surf, int shift)
+{
+	return true;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::BuildLightVis
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::BuildLightVis(int bspnum, float* bbox)
+{
+	guard(VAdvancedRenderLevel::BuildLightVis);
+	if (LightClip.ClipIsFull())
+	{
+		return;
+	}
+
+	if (!LightClip.ClipIsBBoxVisible(bbox, true, CurrLightPos, CurrLightRadius))
+	{
+		return;
+	}
+
+	if (bspnum == -1)
+	{
+		int SubNum = 0;
+		subsector_t* Sub = &Level->Subsectors[SubNum];
+		if (!Sub->sector->linecount)
+		{
+			//	Skip sectors containing original polyobjs
+			return;
+		}
+
+		if (!LightClip.ClipCheckSubsector(Sub, true, CurrLightPos, CurrLightRadius))
+		{
+			return;
+		}
+
+		LightVis[SubNum >> 3] |= 1 << (SubNum & 7);
+		LightClip.ClipAddSubsectorSegs(Sub, true, NULL, CurrLightPos, CurrLightRadius);
+		return;
+	}
+
+	// Found a subsector?
+	if (!(bspnum & NF_SUBSECTOR))
+	{
+		node_t* bsp = &Level->Nodes[bspnum];
+
+		// Decide which side the view point is on.
+		float Dist = DotProduct(CurrLightPos, bsp->normal) - bsp->dist;
+		if (Dist > CurrLightRadius)
+		{
+			//	Light is completely on front side.
+			BuildLightVis(bsp->children[0], bsp->bbox[0]);
+		}
+		else if (Dist < -CurrLightRadius)
+		{
+			//	Light is completely on back side.
+			BuildLightVis(bsp->children[1], bsp->bbox[1]);
+		}
+		else
+		{
+			int side = bsp->PointOnSide(CurrLightPos);
+
+			// Recursively divide front space.
+			BuildLightVis(bsp->children[side], bsp->bbox[side]);
+
+			// Possibly divide back space.
+			if (!LightClip.ClipIsBBoxVisible(bsp->bbox[side ^ 1], true, CurrLightPos, CurrLightRadius))
+			{
+				return;
+			}
+
+			BuildLightVis(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
+		}
+		return;
+	}
+
+	int SubNum = bspnum & (~NF_SUBSECTOR);
+	subsector_t* Sub = &Level->Subsectors[SubNum];
+	if (!Sub->sector->linecount)
+	{
+		//	Skip sectors containing original polyobjs
+		return;
+	}
+
+	if (!LightClip.ClipCheckSubsector(Sub, true, CurrLightPos, CurrLightRadius))
+	{
+		return;
+	}
+
+	LightVis[SubNum >> 3] |= 1 << (SubNum & 7);
+	LightClip.ClipAddSubsectorSegs(Sub, true, NULL, CurrLightPos, CurrLightRadius);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::DrawShadowSurfaces
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::DrawShadowSurfaces(surface_t* InSurfs, texinfo_t *texinfo,
+	bool CheckSkyBoxAlways, bool LightCanCross)
+{
+	guard(VAdvancedRenderLevel::DrawShadowSurfaces);
+	surface_t* surfs = InSurfs;
+	if (!surfs)
+	{
+		return;
+	}
+
+	if (texinfo->Tex->Type == TEXTYPE_Null)
+	{
+		return;
+	}
+
+	if (texinfo->Alpha < 1.0)
+	{
+		return;
+	}
+
+	do
+	{
+		Drawer->RenderSurfaceShadowVolume(surfs, CurrLightPos, CurrLightRadius, LightCanCross);
+		surfs = surfs->next;
+	} while (surfs);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderShadowLine
+//
+// 	Clips the given segment and adds any visible pieces to the line list.
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderShadowLine(drawseg_t* dseg)
+{
+	guard(VAdvancedRenderLevel::RenderShadowLine);
+	seg_t *line = dseg->seg;
+
+	if (!line->linedef)
+	{
+		//	Miniseg
+		return;
+	}
+
+	// Clip sectors that are behind rendered segs
+	TVec v1 = *line->v1;
+	TVec v2 = *line->v2;
+	TVec r1 = CurrLightPos - v1;
+	TVec r2 = CurrLightPos - v2;
+	float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), CurrLightPos);
+	float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), CurrLightPos);
+
+	// There might be a better method of doing this, but
+	// this one works for now...
+	if (D1 > CurrLightRadius && D2 < -CurrLightRadius)
+	{
+		v2 += ((v2 - v1) * D1 / (D1 - D2));
+	}
+	else if (D2 > CurrLightRadius && D1 < -CurrLightRadius)
+	{
+		v1 += ((v1 - v2) * D2 / (D2 - D1));
+	}
+
+	if (!LightClip.IsRangeVisible(LightClip.PointToClipAngle(v2),
+		LightClip.PointToClipAngle(v1)))
+	{
+		return;
+	}
+
+    // NOTE: We don't want to filter out shadows that are behind...
+	float dist = DotProduct(CurrLightPos, line->normal) - line->dist;
+	if (dist < -CurrLightRadius || dist > CurrLightRadius)
+	{
+		//	Light is too far away
+		return;
+	}
+
+	line_t *linedef = line->linedef;
+	side_t *sidedef = line->sidedef;
+
+	if (!line->backsector)
+	{
+		// single sided line
+		DrawShadowSurfaces(dseg->mid->surfs, &dseg->mid->texinfo, false, false);
+		DrawShadowSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo, false, false);
+	}
+	else
+	{
+		// two sided line
+		DrawShadowSurfaces(dseg->top->surfs, &dseg->top->texinfo, false, false);
+		DrawShadowSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo, false, true);
+		DrawShadowSurfaces(dseg->bot->surfs, &dseg->bot->texinfo, false, false);
+		DrawShadowSurfaces(dseg->mid->surfs, &dseg->mid->texinfo, false, true);
+
+		for (segpart_t *sp = dseg->extra; sp; sp = sp->next)
+		{
+			DrawShadowSurfaces(sp->surfs, &sp->texinfo, false, false);
+		}
+	}
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderShadowSecSurface
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderShadowSecSurface(sec_surface_t* ssurf, VEntity* SkyBox)
+{
+	guard(VAdvancedRenderLevel::RenderShadowSecSurface);
+	sec_plane_t& plane = *ssurf->secplane;
+
+	if (!plane.pic)
+	{
+		return;
+	}
+
+	// NOTE: We don't want to filter out shadows that are behind
+	float dist = DotProduct(CurrLightPos, plane.normal) - plane.dist;
+	if (dist < -CurrLightRadius || dist > CurrLightRadius)
+	{
+		//	Light is too far away
+		return;
+	}
+
+	DrawShadowSurfaces(ssurf->surfs, &ssurf->texinfo, true, false);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderShadowSubRegion
+//
+// 	Determine floor/ceiling planes.
+// 	Draw one or more line segments.
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderShadowSubRegion(subregion_t* region)
+{
+	guard(VAdvancedRenderLevel::RenderShadowSubRegion);
+	int				count;
+	int 			polyCount;
+	seg_t**			polySeg;
+	float			d;
+
+	d = DotProduct(CurrLightPos, region->floor->secplane->normal) -
+		region->floor->secplane->dist;
+	if (region->next && d <= -CurrLightRadius)
+	{
+		if (!LightClip.ClipCheckRegion(region->next, r_sub, true, CurrLightPos, CurrLightRadius))
+		{
+			return;
+		}
+		RenderShadowSubRegion(region->next);
+	}
+
+	r_region = region->secregion;
+
+	if (r_sub->poly)
+	{
+		//	Render the polyobj in the subsector first
+		polyCount = r_sub->poly->numsegs;
+		polySeg = r_sub->poly->segs;
+		while (polyCount--)
+		{
+			RenderShadowLine((*polySeg)->drawsegs);
+			polySeg++;
+		}
+	}
+
+	count = r_sub->numlines;
+	drawseg_t *ds = region->lines;
+	while (count--)
+	{
+		RenderShadowLine(ds);
+		ds++;
+	}
+
+	RenderShadowSecSurface(region->floor, r_region->floor->SkyBox);
+	RenderShadowSecSurface(region->ceil, r_region->ceiling->SkyBox);
+
+	if (region->next && d > CurrLightRadius)
+	{
+		if (!LightClip.ClipCheckRegion(region->next, r_sub, true, CurrLightPos, CurrLightRadius))
+		{
+			return;
+		}
+		RenderShadowSubRegion(region->next);
+	}
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderShadowSubsector
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderShadowSubsector(int num)
+{
+	guard(VAdvancedRenderLevel::RenderShadowSubsector);
+	subsector_t* Sub = &Level->Subsectors[num];
+	r_sub = Sub;
+
+	// Don't do this check for shadows
+	/*if (!(LightBspVis[num >> 3] & (1 << (num & 7))) ||
+		!(BspVis[num >> 3] & (1 << (num & 7))))
+	{
+		return;
+	}*/
+
+	if (!Sub->sector->linecount)
+	{
+		//	Skip sectors containing original polyobjs
+		return;
+	}
+
+	if (!LightClip.ClipCheckSubsector(Sub, true, CurrLightPos, CurrLightRadius))
+	{
+		return;
+	}
+
+	RenderShadowSubRegion(Sub->regions);
+
+	//	Add subsector's segs to the clipper. Clipping against mirror
+	// is done only for vertical mirror planes.
+	LightClip.ClipAddSubsectorSegs(Sub, true, NULL, CurrLightPos, CurrLightRadius);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderShadowBSPNode
+//
+//	Renders all subsectors below a given node, traversing subtree
+// recursively. Just call with BSP root.
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderShadowBSPNode(int bspnum, float* bbox, bool LimitLights)
+{
+	guard(VAdvancedRenderLevel::RenderShadowBSPNode);
+	if (LimitLights && CurrShadowsNumber > r_max_shadows)
+	{
+		return;
+	}
+
+	if (LightClip.ClipIsFull())
+	{
+		return;
+	}
+
+	if (!LightClip.ClipIsBBoxVisible(bbox, true, CurrLightPos, CurrLightRadius))
+	{
+		return;
+	}
+
+	if (bspnum == -1)
+	{
+		RenderShadowSubsector(0);
+		if (LimitLights)
+		{
+			CurrShadowsNumber += 1;
+		}
+		return;
+	}
+
+	// Found a subsector?
+	if (!(bspnum & NF_SUBSECTOR))
+	{
+		node_t* bsp = &Level->Nodes[bspnum];
+
+		// Decide which side the light is on.
+		float Dist = DotProduct(CurrLightPos, bsp->normal) - bsp->dist;
+		if (Dist > CurrLightRadius)
+		{
+			//	Light is completely on front side.
+			RenderShadowBSPNode(bsp->children[0], bsp->bbox[0], LimitLights ? true : false);
+		}
+		else if (Dist < -CurrLightRadius)
+		{
+			//	Light is completely on back side.
+			RenderShadowBSPNode(bsp->children[1], bsp->bbox[1], LimitLights ? true : false);
+		}
+		else
+		{
+			int side = bsp->PointOnSide(CurrLightPos);
+
+			// Recursively divide front space.
+			RenderShadowBSPNode(bsp->children[side], bsp->bbox[side], false);
+
+			// Always divide back space for shadows
+			RenderShadowBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1], false);
+		}
+
+		if (LimitLights)
+		{
+			CurrShadowsNumber += 1;
+		}
+		return;
+	}
+
+	RenderShadowSubsector(bspnum & (~NF_SUBSECTOR));
+
+	/*if (LimitLights)
+	{
+		CurrShadowsNumber += 1;
+	}*/
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::DrawLightSurfaces
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::DrawLightSurfaces(surface_t* InSurfs, texinfo_t *texinfo,
+	VEntity* SkyBox, bool CheckSkyBoxAlways, bool LightCanCross)
+{
+	guard(VAdvancedRenderLevel::DrawLightSurfaces);
+	surface_t* surfs = InSurfs;
+	if (!surfs)
+	{
+		return;
+	}
+
+	if (texinfo->Tex->Type == TEXTYPE_Null)
+	{
+		return;
+	}
+
+	if (texinfo->Alpha < 1.0)
+	{
+		return;
+	}
+
+	if (SkyBox && (SkyBox->EntityFlags & VEntity::EF_FixedModel))
+	{
+		SkyBox = NULL;
+	}
+	bool IsStack = SkyBox && SkyBox->eventSkyBoxGetAlways();
+	if (texinfo->Tex == GTextureManager[skyflatnum] ||
+		(IsStack && CheckSkyBoxAlways))
+	{
+		return;
+	}
+
+	do
+	{
+		Drawer->DrawSurfaceLight(surfs, CurrLightPos, CurrLightRadius, LightCanCross);
+		surfs = surfs->next;
+	} while (surfs);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderLightLine
+//
+// 	Clips the given segment and adds any visible pieces to the line list.
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderLightLine(drawseg_t* dseg)
+{
+	guard(VAdvancedRenderLevel::RenderLightLine);
+	seg_t *line = dseg->seg;
+
+	if (!line->linedef)
+	{
+		//	Miniseg
+		return;
+	}
+
+	// Clip sectors that are behind rendered segs
+	TVec v1 = *line->v1;
+	TVec v2 = *line->v2;
+	TVec r1 = CurrLightPos - v1;
+	TVec r2 = CurrLightPos - v2;
+	float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), CurrLightPos);
+	float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), CurrLightPos);
+
+	// There might be a better method of doing this, but
+	// this one works for now...
+	if (D1 > CurrLightRadius && D2 < -CurrLightRadius)
+	{
+		v2 += ((v2 - v1) * D1 / (D1 - D2));
+	}
+	else if (D2 > CurrLightRadius && D1 < -CurrLightRadius)
+	{
+		v1 += ((v1 - v2) * D2 / (D2 - D1));
+	}
+
+	if (!LightClip.IsRangeVisible(LightClip.PointToClipAngle(v2),
+		LightClip.PointToClipAngle(v1)))
+	{
+		return;
+	}
+
+	float dist = DotProduct(CurrLightPos, line->normal) - line->dist;
+	if (dist <= -CurrLightRadius || dist > CurrLightRadius)
+	{
+		//	Light is in back side or on plane
+		return;
+	}
+
+	line_t *linedef = line->linedef;
+	side_t *sidedef = line->sidedef;
+
+	if (!line->backsector)
+	{
+		// single sided line
+		DrawLightSurfaces(dseg->mid->surfs, &dseg->mid->texinfo,
+			r_region->ceiling->SkyBox, false, false);
+		DrawLightSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo,
+			r_region->ceiling->SkyBox, false, false);
+	}
+	else
+	{
+		// two sided line
+		DrawLightSurfaces(dseg->top->surfs, &dseg->top->texinfo,
+			r_region->ceiling->SkyBox, false, false);
+		DrawLightSurfaces(dseg->topsky->surfs, &dseg->topsky->texinfo,
+			r_region->ceiling->SkyBox, false, true);
+		DrawLightSurfaces(dseg->bot->surfs, &dseg->bot->texinfo,
+			r_region->ceiling->SkyBox, false, false);
+		DrawLightSurfaces(dseg->mid->surfs, &dseg->mid->texinfo,
+			r_region->ceiling->SkyBox, false, true);
+
+		for (segpart_t *sp = dseg->extra; sp; sp = sp->next)
+		{
+			DrawLightSurfaces(sp->surfs, &sp->texinfo,
+				r_region->ceiling->SkyBox, false, false);
+		}
+	}
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderLightSecSurface
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderLightSecSurface(sec_surface_t* ssurf, VEntity* SkyBox)
+{
+	guard(VAdvancedRenderLevel::RenderLightSecSurface);
+	sec_plane_t& plane = *ssurf->secplane;
+
+	if (!plane.pic)
+	{
+		return;
+	}
+
+	float dist = DotProduct(CurrLightPos, plane.normal) - plane.dist;
+	if (dist <= -CurrLightRadius || dist > CurrLightRadius)
+	{
+		//	Light is in back side or on plane
+		return;
+	}
+
+	DrawLightSurfaces(ssurf->surfs, &ssurf->texinfo, SkyBox, true, false);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderLightSubRegion
+//
+// 	Determine floor/ceiling planes.
+// 	Draw one or more line segments.
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderLightSubRegion(subregion_t* region)
+{
+	guard(VAdvancedRenderLevel::RenderLightSubRegion);
+	int				count;
+	int 			polyCount;
+	seg_t**			polySeg;
+	float			d;
+
+	d = DotProduct(CurrLightPos, region->floor->secplane->normal) -
+		region->floor->secplane->dist;
+	if (region->next && d <= -CurrLightRadius)
+	{
+		if (!LightClip.ClipCheckRegion(region->next, r_sub, true, CurrLightPos, CurrLightRadius))
+		{
+			return;
+		}
+		RenderLightSubRegion(region->next);
+	}
+
+	r_region = region->secregion;
+
+	if (r_sub->poly)
+	{
+		//	Render the polyobj in the subsector first
+		polyCount = r_sub->poly->numsegs;
+		polySeg = r_sub->poly->segs;
+		while (polyCount--)
+		{
+			RenderLightLine((*polySeg)->drawsegs);
+			polySeg++;
+		}
+	}
+
+	count = r_sub->numlines;
+	drawseg_t *ds = region->lines;
+	while (count--)
+	{
+		RenderLightLine(ds);
+		ds++;
+	}
+
+	RenderLightSecSurface(region->floor, r_region->floor->SkyBox);
+	RenderLightSecSurface(region->ceil, r_region->ceiling->SkyBox);
+
+	if (region->next && d > CurrLightRadius)
+	{
+		if (!LightClip.ClipCheckRegion(region->next, r_sub, true, CurrLightPos, CurrLightRadius))
+		{
+			return;
+		}
+		RenderLightSubRegion(region->next);
+	}
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderLightSubsector
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderLightSubsector(int num)
+{
+	guard(VAdvancedRenderLevel::RenderLightSubsector);
+	subsector_t* Sub = &Level->Subsectors[num];
+	r_sub = Sub;
+
+	if (!(LightBspVis[num >> 3] & (1 << (num & 7))) ||
+		!(BspVis[num >> 3] & (1 << (num & 7))))
+	{
+		return;
+	}
+
+	if (!Sub->sector->linecount)
+	{
+		//	Skip sectors containing original polyobjs
+		return;
+	}
+
+	if (!LightClip.ClipCheckSubsector(Sub, true, CurrLightPos, CurrLightRadius))
+	{
+		return;
+	}
+
+	RenderLightSubRegion(Sub->regions);
+
+	//	Add subsector's segs to the clipper. Clipping against mirror
+	// is done only for vertical mirror planes.
+	LightClip.ClipAddSubsectorSegs(Sub, true, NULL, CurrLightPos, CurrLightRadius);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderLightBSPNode
+//
+//	Renders all subsectors below a given node, traversing subtree
+// recursively. Just call with BSP root.
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderLightBSPNode(int bspnum, float* bbox, bool LimitLights)
+{
+	guard(VAdvancedRenderLevel::RenderLightBSPNode);
+	if (LimitLights && CurrLightsNumber > r_max_lights)
+	{
+		return;
+	}
+
+	if (LightClip.ClipIsFull())
+	{
+		return;
+	}
+
+	if (!LightClip.ClipIsBBoxVisible(bbox, true, CurrLightPos, CurrLightRadius))
+	{
+		return;
+	}
+
+	if (bspnum == -1)
+	{
+		RenderLightSubsector(0);
+		if (LimitLights)
+		{
+			CurrLightsNumber += 1;
+		}
+		return;
+	}
+
+	// Found a subsector?
+	if (!(bspnum & NF_SUBSECTOR))
+	{
+		node_t* bsp = &Level->Nodes[bspnum];
+
+		// Decide which side the light is on.
+		float Dist = DotProduct(CurrLightPos, bsp->normal) - bsp->dist;
+		if (Dist > CurrLightRadius)
+		{
+			//	Light is completely on front side.
+			RenderLightBSPNode(bsp->children[0], bsp->bbox[0], LimitLights ? true : false);
+		}
+		else if (Dist < -CurrLightRadius)
+		{
+			//	Light is completely on back side.
+			RenderLightBSPNode(bsp->children[1], bsp->bbox[1], LimitLights ? true : false);
+		}
+		else
+		{
+			int side = bsp->PointOnSide(CurrLightPos);
+
+			// Recursively divide front space.
+			RenderLightBSPNode(bsp->children[side], bsp->bbox[side], false);
+
+			// Possibly divide back space
+			if (!LightClip.ClipIsBBoxVisible(bsp->bbox[side ^ 1], true, CurrLightPos, CurrLightRadius))
+			{
+				if (LimitLights)
+				{
+					CurrLightsNumber += 1;
+				}
+				return;
+			}
+			RenderLightBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1], false);
+		}
+
+		if (LimitLights)
+		{
+			CurrLightsNumber += 1;
+		}
+		return;
+	}
+
+	RenderLightSubsector(bspnum & (~NF_SUBSECTOR));
+
+	/*if (LimitLights)
+	{
+		CurrLightsNumber += 1;
+	}*/
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::RenderLightShadows
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::RenderLightShadows(const refdef_t* RD,
+	const VViewClipper* Range, TVec& Pos, float Radius, vuint32 Colour, bool LimitLights)
+{
+	guard(VAdvancedRenderLevel::RenderLightShadows);
+	CurrLightPos = Pos;
+	CurrLightRadius = Radius;
+	CurrLightColour = Colour;
+
+	float	dummy_bbox[6] = { -99999, -99999, -99999, 99999, 99999, 99999 };
+
+	//	Build vis data for light.
+	LightClip.ClearClipNodes(CurrLightPos, Level);
+	memset(LightVis, 0, VisSize);
+	BuildLightVis(Level->NumNodes - 1, dummy_bbox);
+
+	//	Create combined light and view visibility.
+	bool HaveIntersect = false;
+	for (int i = 0; i < VisSize; i++)
+	{
+		LightBspVis[i] = BspVis[i] & LightVis[i];
+		if (LightBspVis[i])
+		{
+			HaveIntersect = true;
+		}
+	}
+	if (!HaveIntersect)
+	{
+		return;
+	}
+
+	ResetMobjsLightCount();
+
+	//	Do shadow volumes.
+	Drawer->BeginLightShadowVolumes();
+	LightClip.ClearClipNodes(CurrLightPos, Level);
+	RenderShadowBSPNode(Level->NumNodes - 1, dummy_bbox, LimitLights);
+	Drawer->BeginModelsShadowsPass(CurrLightPos, CurrLightRadius);
+	RenderMobjsShadow();
+
+	ResetMobjsLightCount();
+
+	//	Draw light.
+	Drawer->BeginLightPass(CurrLightPos, CurrLightRadius, Colour);
+	LightClip.ClearClipNodes(CurrLightPos, Level);
+	RenderLightBSPNode(Level->NumNodes - 1, dummy_bbox, LimitLights);
+	Drawer->BeginModelsLightPass(CurrLightPos, CurrLightRadius, Colour);
+	RenderMobjsLight();
+	unguard;
+}
diff -Nur orig/source/r_adv_things.cpp mod/source/r_adv_things.cpp
--- orig/source/r_adv_things.cpp	2010-09-27 21:19:57.000000000 +0200
+++ mod/source/r_adv_things.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -80,6 +80,9 @@
 extern VCvarF			transsouls;
 extern VCvarI			croshair;
 extern VCvarF			croshair_alpha;
+extern VCvarI           r_max_model_lights;
+extern VCvarI           r_max_model_shadows;
+
 
 // CODE --------------------------------------------------------------------
 
@@ -92,30 +95,9 @@
 void VAdvancedRenderLevel::RenderThingAmbient(VEntity* mobj)
 {
 	guard(VAdvancedRenderLevel::RenderThingAmbient);
-	//	Skip things in subsectors that are not visible.
-	int SubIdx = mobj->SubSector - Level->Subsectors;
-	if (!(BspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
-	{
-		return;
-	}
-	if (mobj == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
-	{
-		//	Don't draw camera actor.
-		return;
-	}
-
-	if ((mobj->EntityFlags & VEntity::EF_NoSector) ||
-		(mobj->EntityFlags & VEntity::EF_Invisible))
-	{
-		return;
-	}
-	if (!mobj->State)
-	{
-		return;
-	}
-
 	int RendStyle = mobj->RenderStyle;
 	float Alpha = mobj->Alpha;
+	bool Additive = false;
 
 	if (RendStyle == STYLE_SoulTrans)
 	{
@@ -137,28 +119,41 @@
 		break;
 
 	case STYLE_Fuzzy:
-		return;
+		Alpha = 0.1;
+		break;
 
 	case STYLE_Add:
-		return;
+		if (Alpha == 1.0)
+		{
+			Alpha -= 0.00001;
+		}
+		Additive = true;
+		break;
 	}
 	Alpha = MID(0.0, Alpha, 1.0);
 
-	if (Alpha < 1.0)
-	{
-		return;
-	}
-
 	//	Setup lighting
 	vuint32 light;
-	if ((mobj->State->Frame & VState::FF_FULLBRIGHT) ||
+	if (RendStyle == STYLE_Fuzzy)
+	{
+		light = 0;
+	}
+	else if ((mobj->State->Frame & VState::FF_FULLBRIGHT) ||
 		(mobj->EntityFlags & (VEntity::EF_FullBright | VEntity::EF_Bright)))
 	{
 		light = 0xffffffff;
 	}
 	else
 	{
-		light = LightPointAmbient(mobj->Origin);
+		if (!r_model_light)
+		{
+			// Use old way of lighting
+			light = LightPoint(mobj->Origin);
+		}
+		else
+		{
+			light = LightPointAmbient(mobj->Origin);
+		}
 	}
 
 	float TimeFrac = 0;
@@ -168,7 +163,7 @@
 		TimeFrac = MID(0.0, TimeFrac, 1.0);
 	}
 
-	DrawEntityModel(mobj, light, 0, 1, false, TimeFrac, RPASS_Ambient);
+	DrawEntityModel(mobj, light, 0, Alpha, Additive, TimeFrac, RPASS_Ambient);
 	unguard;
 }
 
@@ -188,6 +183,30 @@
 
 	for (TThinkerIterator<VEntity> Ent(Level); Ent; ++Ent)
 	{
+		if (*Ent == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
+		{
+			//	Don't draw camera actor.
+			continue;
+		}
+
+		if ((Ent->EntityFlags & VEntity::EF_NoSector) ||
+			(Ent->EntityFlags & VEntity::EF_Invisible))
+		{
+			continue;
+		}
+
+		if (!Ent->State)
+		{
+			continue;
+		}
+
+		//	Skip things in subsectors that are not visible.
+		int SubIdx = Ent->SubSector - Level->Subsectors;
+		if (!(BspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
+		{
+			continue;
+		}
+
 		RenderThingAmbient(*Ent);
 	}
 	unguard;
@@ -202,30 +221,9 @@
 void VAdvancedRenderLevel::RenderThingTextures(VEntity* mobj)
 {
 	guard(VAdvancedRenderLevel::RenderThingAmbient);
-	//	Skip things in subsectors that are not visible.
-	int SubIdx = mobj->SubSector - Level->Subsectors;
-	if (!(BspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
-	{
-		return;
-	}
-	if (mobj == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
-	{
-		//	Don't draw camera actor.
-		return;
-	}
-
-	if ((mobj->EntityFlags & VEntity::EF_NoSector) ||
-		(mobj->EntityFlags & VEntity::EF_Invisible))
-	{
-		return;
-	}
-	if (!mobj->State)
-	{
-		return;
-	}
-
 	int RendStyle = mobj->RenderStyle;
 	float Alpha = mobj->Alpha;
+	bool Additive = false;
 
 	if (RendStyle == STYLE_SoulTrans)
 	{
@@ -246,19 +244,24 @@
 		Alpha = 1.0;
 		break;
 
+	case STYLE_Translucent:
+		Alpha = mobj->Alpha;
+		break;
+
 	case STYLE_Fuzzy:
-		return;
+		Alpha = 0.1;
+		break;
 
 	case STYLE_Add:
-		return;
+		if (Alpha == 1.0)
+		{
+			Alpha -= 0.00001;
+		}
+		Additive = true;
+		break;
 	}
 	Alpha = MID(0.0, Alpha, 1.0);
 
-	if (Alpha < 1.0)
-	{
-		return;
-	}
-
 	float TimeFrac = 0;
 	if (mobj->State->Time > 0)
 	{
@@ -266,7 +269,7 @@
 		TimeFrac = MID(0.0, TimeFrac, 1.0);
 	}
 
-	DrawEntityModel(mobj, 0xffffffff, 0, 1, false, TimeFrac, RPASS_Textures);
+	DrawEntityModel(mobj, 0xffffffff, 0, Alpha, Additive, TimeFrac, RPASS_Textures);
 	unguard;
 }
 
@@ -286,6 +289,30 @@
 
 	for (TThinkerIterator<VEntity> Ent(Level); Ent; ++Ent)
 	{
+		if (*Ent == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
+		{
+			//	Don't draw camera actor.
+			continue;
+		}
+
+		if ((Ent->EntityFlags & VEntity::EF_NoSector) ||
+			(Ent->EntityFlags & VEntity::EF_Invisible))
+		{
+			continue;
+		}
+
+		if (!Ent->State)
+		{
+			continue;
+		}
+
+		//	Skip things in subsectors that are not visible.
+		int SubIdx = Ent->SubSector - Level->Subsectors;
+		if (!(BspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
+		{
+			continue;
+		}
+
 		RenderThingTextures(*Ent);
 	}
 	unguard;
@@ -297,12 +324,12 @@
 //
 //==========================================================================
 
-bool VAdvancedRenderLevel::IsTouchedByLight(VEntity* Ent)
+bool VAdvancedRenderLevel::IsTouchedByLight(VEntity* Ent, bool Count)
 {
 	guard(VAdvancedRenderLevel::IsTouchedByLight);
 	TVec Delta = Ent->Origin - CurrLightPos;
 	float Dist = Ent->Radius + CurrLightRadius;
-	if (fabs(Delta.x) > Dist || Delta.y > Dist)
+	if (Delta.x > Dist || Delta.y > Dist)
 	{
 		return false;
 	}
@@ -319,6 +346,11 @@
 	{
 		return false;
 	}
+	if (Count)
+	{
+		Ent->NumTouchingLights += 1;
+	}
+
 	return true;
 	unguard;
 }
@@ -332,35 +364,10 @@
 void VAdvancedRenderLevel::RenderThingLight(VEntity* mobj)
 {
 	guard(VAdvancedRenderLevel::RenderThingLight);
-	//	Skip things in subsectors that are not visible.
-	int SubIdx = mobj->SubSector - Level->Subsectors;
-	if (!(LightBspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
-	{
-		return;
-	}
-	if (mobj == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
-	{
-		//	Don't draw camera actor.
-		return;
-	}
-
-	if ((mobj->EntityFlags & VEntity::EF_NoSector) ||
-		(mobj->EntityFlags & VEntity::EF_Invisible))
-	{
-		return;
-	}
-	if (!mobj->State)
-	{
-		return;
-	}
-
-	if (!IsTouchedByLight(mobj))
-	{
-		return;
-	}
-
+	// Use advanced lighting style
 	int RendStyle = mobj->RenderStyle;
 	float Alpha = mobj->Alpha;
+	bool Additive = false;
 
 	if (RendStyle == STYLE_SoulTrans)
 	{
@@ -382,14 +389,20 @@
 		break;
 
 	case STYLE_Fuzzy:
-		return;
+		Alpha = 0.1;
+		break;
 
 	case STYLE_Add:
-		return;
+		if (Alpha == 1.0)
+		{
+			Alpha -= 0.00001;
+		}
+		Additive = true;
+		break;
 	}
 	Alpha = MID(0.0, Alpha, 1.0);
 
-	if (Alpha < 1.0)
+	if (Alpha < 1.0 && RendStyle == STYLE_Fuzzy)
 	{
 		return;
 	}
@@ -401,7 +414,50 @@
 		TimeFrac = MID(0.0, TimeFrac, 1.0);
 	}
 
-	DrawEntityModel(mobj, 0xffffffff, 0, 1, false, TimeFrac, RPASS_Light);
+	DrawEntityModel(mobj, 0xffffffff, 0, Alpha, Additive, TimeFrac, RPASS_Light);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VAdvancedRenderLevel::ResetMobjsLightCount
+//
+//==========================================================================
+
+void VAdvancedRenderLevel::ResetMobjsLightCount()
+{
+	guard(VAdvancedRenderLevel::RenderMobjsLight);
+	if (!r_draw_mobjs || !r_models)
+	{
+		return;
+	}
+
+	for (TThinkerIterator<VEntity> Ent(Level); Ent; ++Ent)
+	{
+		if (Ent->NumTouchingLights == 0)
+		{
+			// No need to do anything
+			continue;
+		}
+
+		if ((Ent->EntityFlags & VEntity::EF_NoSector) ||
+			(Ent->EntityFlags & VEntity::EF_Invisible))
+		{
+			continue;
+		}
+
+		if (!Ent->State)
+		{
+			continue;
+		}
+
+		if (!IsTouchedByLight(*Ent, false))
+		{
+			continue;
+		}
+
+		Ent->NumTouchingLights = 0;
+	}
 	unguard;
 }
 
@@ -421,6 +477,41 @@
 
 	for (TThinkerIterator<VEntity> Ent(Level); Ent; ++Ent)
 	{
+		if (Ent->NumTouchingLights > r_max_model_lights)
+		{
+			// Limit maximum lights for this Entity
+			continue;
+		}
+
+		if (*Ent == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
+		{
+			//	Don't draw camera actor.
+			continue;
+		}
+
+		if ((Ent->EntityFlags & VEntity::EF_NoSector) ||
+			(Ent->EntityFlags & VEntity::EF_Invisible))
+		{
+			continue;
+		}
+
+		if (!Ent->State)
+		{
+			continue;
+		}
+
+		//	Skip things in subsectors that are not visible.
+		int SubIdx = Ent->SubSector - Level->Subsectors;
+		if (!(LightBspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
+		{
+			continue;
+		}
+
+		if (!IsTouchedByLight(*Ent, true))
+		{
+			continue;
+		}
+
 		RenderThingLight(*Ent);
 	}
 	unguard;
@@ -435,33 +526,9 @@
 void VAdvancedRenderLevel::RenderThingShadow(VEntity* mobj)
 {
 	guard(VAdvancedRenderLevel::RenderThingShadow);
-	//	Skip things in subsectors that are not visible.
-	int SubIdx = mobj->SubSector - Level->Subsectors;
-	if (!(LightVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
-	{
-		return;
-	}
-	if (mobj == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
-	{
-		//	Don't draw camera actor.
-		return;
-	}
-	if ((mobj->EntityFlags & VEntity::EF_NoSector) ||
-		(mobj->EntityFlags & VEntity::EF_Invisible))
-	{
-		return;
-	}
-	if (!mobj->State)
-	{
-		return;
-	}
-	if (!IsTouchedByLight(mobj))
-	{
-		return;
-	}
-
 	int RendStyle = mobj->RenderStyle;
 	float Alpha = mobj->Alpha;
+	bool Additive = false;
 
 	if (RendStyle == STYLE_SoulTrans)
 	{
@@ -483,18 +550,19 @@
 		break;
 
 	case STYLE_Fuzzy:
-		return;
+		Alpha = 0.1;
+		break;
 
 	case STYLE_Add:
-		return;
+		if (Alpha == 1.0)
+		{
+			Alpha -= 0.00001;
+		}
+		Additive = true;
+		break;
 	}
 	Alpha = MID(0.0, Alpha, 1.0);
 
-	if (Alpha < 1.0)
-	{
-		return;
-	}
-
 	float TimeFrac = 0;
 	if (mobj->State->Time > 0)
 	{
@@ -502,7 +570,7 @@
 		TimeFrac = MID(0.0, TimeFrac, 1.0);
 	}
 
-	DrawEntityModel(mobj, 0xffffffff, 0, 1, false, TimeFrac, RPASS_ShadowVolumes);
+	DrawEntityModel(mobj, 0xffffffff, 0, Alpha, Additive, TimeFrac, RPASS_ShadowVolumes);
 	unguard;
 }
 
@@ -522,6 +590,35 @@
 
 	for (TThinkerIterator<VEntity> Ent(Level); Ent; ++Ent)
 	{
+		if (Ent->NumTouchingLights > r_max_model_shadows)
+		{
+			// Limit maximum shadows for this Entity
+			continue;
+		}
+
+		if ((Ent->EntityFlags & VEntity::EF_NoSector) ||
+			(Ent->EntityFlags & VEntity::EF_Invisible))
+		{
+			continue;
+		}
+
+		if (!Ent->State)
+		{
+			continue;
+		}
+
+		//	Skip things in subsectors that are not visible.
+		int SubIdx = Ent->SubSector - Level->Subsectors;
+		if (!(LightVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
+		{
+			continue;
+		}
+
+		if (!IsTouchedByLight(*Ent, true))
+		{
+			continue;
+		}
+
 		RenderThingShadow(*Ent);
 	}
 	unguard;
@@ -536,31 +633,9 @@
 void VAdvancedRenderLevel::RenderThingFog(VEntity* mobj)
 {
 	guard(VAdvancedRenderLevel::RenderThingFog);
-	//	Skip things in subsectors that are not visible.
-	int SubIdx = mobj->SubSector - Level->Subsectors;
-	if (!(BspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
-	{
-		return;
-	}
-
-	if (mobj == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
-	{
-		//	Don't draw camera actor.
-		return;
-	}
-
-	if ((mobj->EntityFlags & VEntity::EF_NoSector) ||
-		(mobj->EntityFlags & VEntity::EF_Invisible))
-	{
-		return;
-	}
-	if (!mobj->State)
-	{
-		return;
-	}
-
 	int RendStyle = mobj->RenderStyle;
 	float Alpha = mobj->Alpha;
+	bool Additive = false;
 
 	if (RendStyle == STYLE_SoulTrans)
 	{
@@ -582,17 +657,19 @@
 		break;
 
 	case STYLE_Fuzzy:
-		return;
+		Alpha = 0.1;
+		break;
 
 	case STYLE_Add:
-		return;
+		if (Alpha == 1.0)
+		{
+			Alpha -= 0.00001;
+		}
+		Additive = true;
+		break;
 	}
 	Alpha = MID(0.0, Alpha, 1.0);
 
-	if (Alpha < 1.0)
-	{
-		return;
-	}
 	vuint32 Fade = GetFade(SV_PointInRegion(mobj->Sector, mobj->Origin));
 	if (!Fade)
 	{
@@ -606,7 +683,7 @@
 		TimeFrac = MID(0.0, TimeFrac, 1.0);
 	}
 
-	DrawEntityModel(mobj, 0xffffffff, Fade, 1, false, TimeFrac, RPASS_Fog);
+	DrawEntityModel(mobj, 0xffffffff, Fade, Alpha, Additive, TimeFrac, RPASS_Fog);
 	unguard;
 }
 
@@ -626,6 +703,30 @@
 
 	for (TThinkerIterator<VEntity> Ent(Level); Ent; ++Ent)
 	{
+		if (*Ent == ViewEnt && (!r_chasecam || ViewEnt != cl->MO))
+		{
+			//	Don't draw camera actor.
+			continue;
+		}
+
+		if ((Ent->EntityFlags & VEntity::EF_NoSector) ||
+			(Ent->EntityFlags & VEntity::EF_Invisible))
+		{
+			continue;
+		}
+
+		if (!Ent->State)
+		{
+			continue;
+		}
+
+		//	Skip things in subsectors that are not visible.
+		int SubIdx = Ent->SubSector - Level->Subsectors;
+		if (!(BspVis[SubIdx >> 3] & (1 << (SubIdx & 7))))
+		{
+			continue;
+		}
+
 		RenderThingFog(*Ent);
 	}
 	unguard;
diff -Nur orig/source/r_bsp.cpp mod/source/r_bsp.cpp
--- orig/source/r_bsp.cpp	2010-12-17 16:36:07.000000000 +0100
+++ mod/source/r_bsp.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_bsp.cpp 4350 2010-12-17 15:36:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -128,7 +128,7 @@
 
 //==========================================================================
 //
-//	VRenderLevelShared::DrawSurfaces
+//	VRenderLevelShared::QueueSimpleSurf
 //
 //==========================================================================
 
@@ -322,6 +322,12 @@
 		}
 		do
 		{
+			if (surfs->plane->PointOnSide(vieworg))
+			{
+				//	Viewer is in back side or on plane
+				continue;
+			}
+
 			Portal->Surfs.Append(surfs);
 			if (IsStack && CheckSkyBoxAlways &&
 				SkyBox->eventSkyBoxGetPlaneAlpha())
@@ -356,6 +362,12 @@
 
 	do
 	{
+		if (surfs->plane->PointOnSide(vieworg))
+		{
+			//	Viewer is in back side or on plane
+			continue;
+		}
+
 		surfs->Light = (lLev << 24) | LightParams->LightColour;
 		surfs->Fade = Fade;
 		surfs->dlightframe = r_sub->dlightframe;
@@ -582,34 +594,82 @@
 		return;
 	}
 
-	float dist = DotProduct(vieworg, line->normal) - line->dist;
-	if (dist <= 0)
+	if (line->PointOnSide(vieworg))
 	{
 		//	Viewer is in back side or on plane
 		return;
 	}
 
-	float a1 = ViewClip.PointToClipAngle(*line->v2);
-	float a2 = ViewClip.PointToClipAngle(*line->v1);
-	if (!ViewClip.IsRangeVisible(a1, a2))
-	{
-		return;
-	}
-
 	if (MirrorClipSegs)
 	{
 		//	Clip away segs that are behind mirror.
-		float Dist1 = DotProduct(*line->v1, view_clipplanes[4].normal) -
-			view_clipplanes[4].dist;
-		float Dist2 = DotProduct(*line->v2, view_clipplanes[4].normal) -
-			view_clipplanes[4].dist;
-		if (Dist1 <= 0 && Dist2 <= 0)
+		if (view_clipplanes[4].PointOnSide(*line->v1) && view_clipplanes[4].PointOnSide(*line->v2))
 		{
 			//	Behind mirror.
 			return;
 		}
 	}
 
+	if (line->backsector)
+	{
+		// Just apply this to sectors without slopes
+		if (line->frontsector->floor.normal.z == 1.0 && line->backsector->floor.normal.z == 1.0 &&
+			line->frontsector->ceiling.normal.z == -1.0 && line->backsector->ceiling.normal.z == -1.0)
+		{
+			// Clip sectors that are behind rendered segs
+			TVec v1 = *line->v1;
+			TVec v2 = *line->v2;
+			TVec r1 = vieworg - v1;
+			TVec r2 = vieworg - v2;
+			float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), vieworg);
+			float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), vieworg);
+
+			// There might be a better method of doing this, but
+			// this one works for now...
+			if (D1 > 0.0 && D2 < 0.0)
+			{
+				v2 += ((v2 - v1) * D1) / (D1 - D2);
+			}
+			else if (D2 > 0.0 && D1 < 0.0)
+			{
+				v1 += ((v2 - v1) * D1) / (D2 - D1);
+			}
+
+			if (!ViewClip.IsRangeVisible(ViewClip.PointToClipAngle(v2),
+				ViewClip.PointToClipAngle(v1)))
+			{
+				return;
+			}
+		}
+	}
+	else
+	{
+		// Clip sectors that are behind rendered segs
+		TVec v1 = *line->v1;
+		TVec v2 = *line->v2;
+		TVec r1 = vieworg - v1;
+		TVec r2 = vieworg - v2;
+		float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), vieworg);
+		float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), vieworg);
+
+		// There might be a better method of doing this, but
+		// this one works for now...
+		if (D1 > 0.0 && D2 < 0.0)
+		{
+			v2 += ((v2 - v1) * D1) / (D1 - D2);
+		}
+		else if (D2 > 0.0 && D1 < 0.0)
+		{
+			v1 += ((v2 - v1) * D1) / (D2 - D1);
+		}
+
+		if (!ViewClip.IsRangeVisible(ViewClip.PointToClipAngle(v2),
+			ViewClip.PointToClipAngle(v1)))
+		{
+			return;
+		}
+	}
+
 	line_t *linedef = line->linedef;
 	side_t *sidedef = line->sidedef;
 
@@ -655,7 +715,7 @@
 			!!(sidedef->Flags & SDF_ABSLIGHT), false);
 		for (segpart_t *sp = dseg->extra; sp; sp = sp->next)
 		{
-			DrawSurfaces(sp->surfs, &sp->texinfo,r_region->ceiling->SkyBox,
+			DrawSurfaces(sp->surfs, &sp->texinfo, r_region->ceiling->SkyBox,
 				-1, sidedef->Light, !!(sidedef->Flags & SDF_ABSLIGHT), false);
 		}
 	}
@@ -679,8 +739,7 @@
 		return;
 	}
 
-	float dist = DotProduct(vieworg, plane.normal) - plane.dist;
-	if (dist <= 0)
+	if (plane.PointOnSide(vieworg))
 	{
 		//	Viewer is in back side or on plane
 		return;
@@ -744,9 +803,15 @@
 		region->floor->secplane->dist;
 	if (region->next && d <= 0.0)
 	{
+		if (!ViewClip.ClipCheckRegion(region->next, r_sub, false))
+		{
+			return;
+		}
 		RenderSubRegion(region->next);
 	}
 
+	check(r_sub->sector != NULL);
+
 	r_subregion = region;
 	r_region = region->secregion;
 
@@ -775,6 +840,10 @@
 
 	if (region->next && d > 0.0)
 	{
+		if (!ViewClip.ClipCheckRegion(region->next, r_sub, false))
+		{
+			return;
+		}
 		RenderSubRegion(region->next);
 	}
 	unguard;
@@ -803,7 +872,7 @@
 		return;
 	}
 
-	if (!ViewClip.ClipCheckSubsector(Sub))
+	if (!ViewClip.ClipCheckSubsector(Sub, false))
 	{
 		return;
 	}
@@ -814,7 +883,7 @@
 
 	//	Add subsector's segs to the clipper. Clipping against mirror
 	// is done only for vertical mirror planes.
-	ViewClip.ClipAddSubsectorSegs(Sub, MirrorClipSegs ? &view_clipplanes[4] :
+	ViewClip.ClipAddSubsectorSegs(Sub, false, MirrorClipSegs ? &view_clipplanes[4] :
 		NULL);
 	unguard;
 }
@@ -845,9 +914,12 @@
 			{
 				continue;	// don't need to clip against it
 			}
+			if (view_clipplanes[i].PointOnSide(vieworg))
+			{
+				continue;
+			}
 
 			// generate accept and reject points
-
 			int *pindex = FrustumIndexes[i];
 
 			TVec rejectpt;
@@ -856,13 +928,9 @@
 			rejectpt[1] = bbox[pindex[1]];
 			rejectpt[2] = bbox[pindex[2]];
 
-			float d;
-
-			d = DotProduct(rejectpt, view_clipplanes[i].normal);
-			d -= view_clipplanes[i].dist;
-			if (d <= 0)
+			if (view_clipplanes[i].PointOnSide(rejectpt))
 			{
-				return;
+				continue;
 			}
 
 			TVec acceptpt;
@@ -871,50 +939,51 @@
 			acceptpt[1] = bbox[pindex[3+1]];
 			acceptpt[2] = bbox[pindex[3+2]];
 
-			d = DotProduct(acceptpt, view_clipplanes[i].normal);
-			d -= view_clipplanes[i].dist;
-
-			if (d >= 0)
+			if (!view_clipplanes[i].PointOnSide(acceptpt))
 			{
 				clipflags ^= view_clipplanes[i].clipflag;	// node is entirely on screen
 			}
 		}
 	}
 
-	if (!ViewClip.ClipIsBBoxVisible(bbox))
+	if (!ViewClip.ClipIsBBoxVisible(bbox, false))
 	{
 		return;
 	}
 
+	if (bspnum == -1)
+	{
+		RenderSubsector(0);
+		return;
+	}
+
 	// Found a subsector?
-	if (bspnum & NF_SUBSECTOR)
+	if (!(bspnum & NF_SUBSECTOR))
 	{
-		if (bspnum == -1)
+		node_t* bsp = &Level->Nodes[bspnum];
+
+		if (bsp->VisFrame != r_visframecount)
 		{
-			RenderSubsector(0);
+			return;
 		}
-		else
+
+		// Decide which side the view point is on.
+		int side = bsp->PointOnSide(vieworg);
+
+		// Recursively divide front space (toward the viewer).
+		RenderBSPNode(bsp->children[side], bsp->bbox[side], clipflags);
+
+		// Possibly divide back space (away from the viewer).
+		if (!ViewClip.ClipIsBBoxVisible(bsp->bbox[side ^ 1], false))
 		{
-			RenderSubsector(bspnum & (~NF_SUBSECTOR));
+			return;
 		}
-		return;
-	}
 
-	node_t* bsp = &Level->Nodes[bspnum];
-
-	if (bsp->VisFrame != r_visframecount)
-	{
+		RenderBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1], clipflags);
 		return;
 	}
 
-	// Decide which side the view point is on.
-	int side = bsp->PointOnSide(vieworg);
-
-	// Recursively divide front space.
-	RenderBSPNode(bsp->children[side], bsp->bbox[side], clipflags);
-
-	// Divide back space.
-	RenderBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1], clipflags);
+	RenderSubsector(bspnum & (~NF_SUBSECTOR));
 	unguard;
 }
 
@@ -927,7 +996,7 @@
 void VRenderLevelShared::RenderBspWorld(const refdef_t* rd, const VViewClipper* Range)
 {
 	guard(VRenderLevelShared::RenderBspWorld);
-	float	dummy_bbox[6] = {-99999, -99999, -99999, 99999, 99999, 99999};
+	float	dummy_bbox[6] = { -99999, -99999, -99999, 99999, 99999, 99999 };
 
 	SetUpFrustumIndexes();
 	ViewClip.ClearClipNodes(vieworg, Level);
@@ -950,7 +1019,7 @@
 
 	if (PortalLevel == 0)
 	{
-		guard(Best sky);
+		guard(VRenderLevelShared::RenderBspWorld::Best sky);
 		//	Draw the most complex sky portal behind the scene first, without
 		// the need to use stencil buffer.
 		VPortal* BestSky = NULL;
@@ -975,7 +1044,7 @@
 		}
 		unguard;
 
-		guard(World surfaces);
+		guard(VRenderLevelShared::RenderBspWorld::World surfaces);
 		for (int i = 0; i < WorldSurfs.Num(); i++)
 		{
 			switch (WorldSurfs[i].Type)
diff -Nur orig/source/r_data.cpp mod/source/r_data.cpp
--- orig/source/r_data.cpp	2010-12-15 22:48:26.000000000 +0100
+++ mod/source/r_data.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_data.cpp 4340 2010-12-15 21:48:23Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -441,7 +441,7 @@
 
 	maxframe++;
 
-	for (int frame = 0 ; frame < maxframe ; frame++)
+	for (int frame = 0; frame < maxframe; frame++)
 	{
 		switch ((int)sprtemp[frame].rotate)
 		{
@@ -684,9 +684,9 @@
 {
 	guard(VTextureTranslation::BuildPlayerTrans);
 	int Count = End - Start + 1;
-	vuint8 r = (Col >> 16) & 0xff;
-	vuint8 g = (Col >> 8) & 0xff;
-	vuint8 b = Col & 0xff;
+	vuint8 r = (Col >> 16) & 255;
+	vuint8 g = (Col >> 8) & 255;
+	vuint8 b = Col & 255;
 	vuint8 h, s, v;
 	M_RgbToHsv(r, g, b, h, s, v);
 	for (int i = 0; i < Count; i++)
@@ -847,9 +847,9 @@
 void VTextureTranslation::BuildBloodTrans(int Col)
 {
 	guard(VTextureTranslation::BuildBloodTrans);
-	vuint8 r = (Col >> 16) & 0xff;
-	vuint8 g = (Col >> 8) & 0xff;
-	vuint8 b = Col & 0xff;
+	vuint8 r = (Col >> 16) & 255;
+	vuint8 g = (Col >> 8) & 255;
+	vuint8 b = Col & 255;
 	//	Don't remap colour 0.
 	for (int i = 1; i < 256; i++)
 	{
@@ -1650,6 +1650,12 @@
 		}
 		else if (sc->Check("skybox"))
 		{
+			sc->GetString();
+			sc->Expect("{");
+			while (!sc->Check("}"))
+			{
+				sc->GetString();
+			}
 			sc->Message("Skybox parsing isn't implemented yet.");
 		}
 		else if (sc->Check("brightmap"))
diff -Nur orig/source/r_light.cpp mod/source/r_light.cpp
--- orig/source/r_light.cpp	2010-12-23 20:48:32.000000000 +0100
+++ mod/source/r_light.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_light.cpp 4354 2010-12-23 19:48:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -220,7 +220,9 @@
 
 	// calculate texorg on the texture plane
 	for (i = 0; i < 3; i++)
+	{
 		texorg[i] = -tex->soffs * textoworld[0][i] - tex->toffs * textoworld[1][i];
+	}
 
 	// project back to the face plane
 	dist = DotProduct(texorg, surf->plane->normal) - surf->plane->dist - 1;
@@ -359,7 +361,9 @@
 
 	// Check potential visibility
 	if (!(facevis[light->leafnum >> 3] & (1 << (light->leafnum & 7))))
+	{
 		return;
+	}
 
 	// Check bounding box
 	if (light->origin.x + light->radius < smins.x ||
@@ -376,7 +380,9 @@
 	
 	// don't bother with lights behind the surface
 	if (dist <= -0.1)
+	{
 		return;
+	}
 		
 	// don't bother with light too far away
 	if (dist > light->radius)
@@ -402,14 +408,16 @@
 	//
 	spt = surfpt;
 	squaredist = light->radius * light->radius;
-	rmul = ((light->colour >> 16) & 0xff) / 255.0;
-	gmul = ((light->colour >> 8) & 0xff) / 255.0;
-	bmul = (light->colour & 0xff) / 255.0;
+	rmul = ((light->colour >> 16) & 255) / 255.0;
+	gmul = ((light->colour >> 8) & 255) / 255.0;
+	bmul = (light->colour & 255) / 255.0;
 	for (c = 0; c < numsurfpt; c++, spt++)
 	{
 		dist = CastRay(light->origin, *spt, squaredist);
 		if (dist < 0)
+		{
 			continue;	// light doesn't reach
+		}
 
 		incoming = Normalise(light->origin - *spt);
 		angle = DotProduct(incoming, surf->plane->normal);
@@ -418,7 +426,9 @@
 		add = light->radius - dist;
 		add *= angle;
 		if (add < 0)
+		{
 			continue;
+		}
 		lightmap[c] += add;
 		lightmapr[c] += add * rmul;
 		lightmapg[c] += add * gmul;
@@ -427,7 +437,9 @@
 		{
 			light_hit = true;
 			if (light->colour != 0xffffffff)
+			{
 				is_coloured = true;
+			}
 		}
 	}
 	unguard;
@@ -507,11 +519,17 @@
 					total *= 0.25;
 				}
 				else
+				{
 					total = lightmapr[i];
+				}
 				if (total > 255)
+				{
 					total = 255;
+				}
 				if (total < 0)
+				{
 					Sys_Error("light < 0");
+				}
 				surf->lightmap_rgb[i].r = byte(total);
 
 				if (r_extrasamples)
@@ -524,11 +542,17 @@
 					total *= 0.25;
 				}
 				else
+				{
 					total = lightmapg[i];
+				}
 				if (total > 255)
+				{
 					total = 255;
+				}
 				if (total < 0)
+				{
 					Sys_Error("light < 0");
+				}
 				surf->lightmap_rgb[i].g = byte(total);
 
 				if (r_extrasamples)
@@ -541,11 +565,17 @@
 					total *= 0.25;
 				}
 				else
+				{
 					total = lightmapb[i];
+				}
 				if (total > 255)
+				{
 					total = 255;
+				}
 				if (total < 0)
+				{
 					Sys_Error("light < 0");
+				}
 				surf->lightmap_rgb[i].b = byte(total);
 			}
 		}
@@ -581,11 +611,17 @@
 				total *= 0.25;
 			}
 			else
+			{
 				total = lightmap[i];
+			}
 			if (total > 255)
+			{
 				total = 255;
+			}
 			if (total < 0)
+			{
 				Sys_Error("light < 0");
+			}
 			surf->lightmap[i] = byte(total);
 		}
 	}
@@ -639,6 +675,7 @@
 
 	int bestnum = 0;
 	float bestdist = 0.0;
+	dl = DLights;
 	for (i = 0; i < MAX_DLIGHTS; i++, dl++)
 	{
 		float dist = Length(dl->origin - cl->ViewOrg);
@@ -667,12 +704,16 @@
 	dlight_t* dl = DLights;
 	for (int i = 0; i < MAX_DLIGHTS; i++, dl++)
 	{
-		if (dl->die < Level->Time || !dl->radius)
+		if (!dl->radius || dl->die < Level->Time)
+		{
 			continue;
+		}
 
 		dl->radius -= time * dl->decay;
 		if (dl->radius < 0)
+		{
 			dl->radius = 0;
+		}
 	}
 	unguard;
 }
@@ -686,27 +727,31 @@
 void VRenderLevel::MarkLights(dlight_t *light, int bit, int bspnum)
 {
 	guard(VRenderLevel::MarkLights);
-	int leafnum;
-
     if (bspnum & NF_SUBSECTOR)
     {
 		int num;
 
 		if (bspnum == -1)
+		{
 		    num = 0;
+		}
 		else
+		{
 		    num = bspnum & (~NF_SUBSECTOR);
+		}
 		subsector_t *ss = &Level->Subsectors[num];
 
 		if (r_dynamic_clip)
 		{
 			vuint8* dyn_facevis = Level->LeafPVS(ss);
-			leafnum = Level->PointInSubsector(light->origin) -
+			int leafnum = Level->PointInSubsector(light->origin) -
 				Level->Subsectors;
 
 			// Check potential visibility
 			if (!(dyn_facevis[leafnum >> 3] & (1 << (leafnum & 7))))
+			{
 				return;
+			}
 		}
 
 		if (ss->dlightframe != r_dlightframecount)
@@ -742,7 +787,8 @@
 void VRenderLevel::PushDlights()
 {
 	guard(VRenderLevel::PushDlights);
-	if (GGameInfo->IsPaused())
+	if (GGameInfo->IsPaused() ||
+		(Level->LevelInfo->LevelInfoFlags2 & VLevelInfo::LIF2_Frozen))
 	{
 		return;
 	}
@@ -756,8 +802,10 @@
 	dlight_t* l = DLights;
 	for (int i = 0; i < MAX_DLIGHTS; i++, l++)
 	{
-		if (l->die < Level->Time || !l->radius)
+		if (!l->radius || l->die < Level->Time)
+		{
 			continue;
+		}
 		MarkLights(l, 1 << i, Level->NumNodes - 1);
 	}
 	unguard;
@@ -774,13 +822,9 @@
 	guard(VRenderLevel::LightPoint);
 	subsector_t		*sub;
 	subregion_t		*reg;
-	float			l, lr, lg, lb, d, add;
-	int				i, s, t, ds, dt;
+	float			l, lr, lg, lb;
 	surface_t		*surf;
-	int				ltmp;
 	rgb_t			*rgbtmp;
-	int				leafnum;
-
 
 	if (FixedLight)
 	{
@@ -789,109 +833,125 @@
 
 	sub = Level->PointInSubsector(p);
 	reg = sub->regions;
-	while (reg->next)
+	if (reg)
 	{
-		d = DotProduct(p, reg->floor->secplane->normal) - reg->floor->secplane->dist;
-
-		if (d >= 0.0)
+		while (reg->next)
 		{
-			break;
-		}
+			float d = DotProduct(p, reg->floor->secplane->normal) - reg->floor->secplane->dist;
 
-		reg = reg->next;
-	}
+			if (d >= 0.0)
+			{
+				break;
+			}
 
-	//	Region's base light
-	l = reg->secregion->params->lightlevel + ExtraLight;
-	if (r_darken)
-	{
-		l = light_remap[MIN(255, (int)l)];
-	}
-	l = MIN(255, l);
-	int SecLightColour = reg->secregion->params->LightColour;
-	lr = ((SecLightColour >> 16) & 255) * l / 255.0;
-	lg = ((SecLightColour >> 8) & 255) * l / 255.0;
-	lb = (SecLightColour & 255) * l / 255.0;
+			reg = reg->next;
+		}
 
-	//	Light from floor's lightmap
-	s = (int)(DotProduct(p, reg->floor->texinfo.saxis) + reg->floor->texinfo.soffs);
-	t = (int)(DotProduct(p, reg->floor->texinfo.taxis) + reg->floor->texinfo.toffs);
-	for (surf = reg->floor->surfs; surf; surf = surf->next)
-	{
-		if (!surf->lightmap)
+		//	Region's base light
+		l = reg->secregion->params->lightlevel + ExtraLight;
+		if (r_darken)
 		{
-			continue;
+			l = light_remap[MIN(255, (int)l)];
 		}
-		if (s < surf->texturemins[0] ||	t < surf->texturemins[1])
+		l = MIN(255, l);
+		int SecLightColour = reg->secregion->params->LightColour;
+		lr = ((SecLightColour >> 16) & 255) * l / 255.0;
+		lg = ((SecLightColour >> 8) & 255) * l / 255.0;
+		lb = (SecLightColour & 255) * l / 255.0;
+
+		//	Light from floor's lightmap
+		int s = (int)(DotProduct(p, reg->floor->texinfo.saxis) + reg->floor->texinfo.soffs);
+		int t = (int)(DotProduct(p, reg->floor->texinfo.taxis) + reg->floor->texinfo.toffs);
+		int ds, dt;
+		for (surf = reg->floor->surfs; surf; surf = surf->next)
 		{
-			continue;
-		}
+			if (!surf->lightmap)
+			{
+				continue;
+			}
+			if (s < surf->texturemins[0] ||	t < surf->texturemins[1])
+			{
+				continue;
+			}
 
-		ds = s - surf->texturemins[0];
-		dt = t - surf->texturemins[1];
+			ds = s - surf->texturemins[0];
+			dt = t - surf->texturemins[1];
 
-		if (ds > surf->extents[0] || dt > surf->extents[1])
-		{
-			continue;
-		}
+			if (ds > surf->extents[0] || dt > surf->extents[1])
+			{
+				continue;
+			}
 
-		if (surf->lightmap_rgb)
-		{
-			l += surf->lightmap[(ds >> 4) + (dt >> 4) * ((surf->extents[0] >> 4) + 1)];
-			rgbtmp = &surf->lightmap_rgb[(ds >> 4) + (dt >> 4) * ((surf->extents[0] >> 4) + 1)];
-			lr += rgbtmp->r;
-			lg += rgbtmp->g;
-			lb += rgbtmp->b;
-		}
-		else
-		{
-			ltmp = surf->lightmap[(ds >> 4) + (dt >> 4) * ((surf->extents[0] >> 4) + 1)];
-			l += ltmp;
-			lr += ltmp;
-			lg += ltmp;
-			lb += ltmp;
+			if (surf->lightmap_rgb)
+			{
+				l += surf->lightmap[(ds >> 4) + (dt >> 4) * ((surf->extents[0] >> 4) + 1)];
+				rgbtmp = &surf->lightmap_rgb[(ds >> 4) + (dt >> 4) * ((surf->extents[0] >> 4) + 1)];
+				lr += rgbtmp->r;
+				lg += rgbtmp->g;
+				lb += rgbtmp->b;
+			}
+			else
+			{
+				int ltmp = surf->lightmap[(ds >> 4) + (dt >> 4) * ((surf->extents[0] >> 4) + 1)];
+				l += ltmp;
+				lr += ltmp;
+				lg += ltmp;
+				lb += ltmp;
+			}
+			break;
 		}
-		break;
 	}
 
 	//	Add dynamic lights
 	if (sub->dlightframe == r_dlightframecount)
 	{
-		for (i = 0; i < MAX_DLIGHTS; i++)
+		for (int i = 0; i < MAX_DLIGHTS; i++)
 		{
 			if (!(sub->dlightbits & (1 << i)))
+			{
 				continue;
+			}
 			if (r_dynamic_clip)
 			{
 				vuint8* dyn_facevis = Level->LeafPVS(sub);
-				leafnum = Level->PointInSubsector(DLights[i].origin) -
+				int leafnum = Level->PointInSubsector(DLights[i].origin) -
 					Level->Subsectors;
 
 				// Check potential visibility
 				if (!(dyn_facevis[leafnum >> 3] & (1 << (leafnum & 7))))
-						continue;
+				{
+					continue;
+				}
 			}
 
-			add = (DLights[i].radius - DLights[i].minlight) - Length(p - DLights[i].origin);
+			float add = (DLights[i].radius - DLights[i].minlight) - Length(p - DLights[i].origin);
 	
 			if (add > 0)
 			{
 				l += add;
-				lr += add * ((DLights[i].colour >> 16) & 0xff) / 255.0;
-				lg += add * ((DLights[i].colour >> 8) & 0xff) / 255.0;
-				lb += add * (DLights[i].colour & 0xff) / 255.0;
+				lr += add * ((DLights[i].colour >> 16) & 255) / 255.0;
+				lg += add * ((DLights[i].colour >> 8) & 255) / 255.0;
+				lb += add * (DLights[i].colour & 255) / 255.0;
 			}
 		}
 	}
 
 	if (l > 255)
+	{
 		l = 255;
+	}
 	if (lr > 255)
+	{
 		lr = 255;
+	}
 	if (lg > 255)
+	{
 		lg = 255;
+	}
 	if (lb > 255)
+	{
 		lb = 255;
+	}
 
 	return ((int)l << 24) | ((int)lr << 16) | ((int)lg << 8) | ((int)lb);
 	unguard;
@@ -916,15 +976,16 @@
 	subsector_t *sub;
 	int			leafnum;
 
-
 	smax = (surf->extents[0] >> 4) + 1;
 	tmax = (surf->extents[1] >> 4) + 1;
 	tex = surf->texinfo;
 
 	for (lnum = 0; lnum < MAX_DLIGHTS; lnum++)
 	{
-		if (!(surf->dlightbits & (1<<lnum)))
+		if (!(surf->dlightbits & (1 << lnum)))
+		{
 			continue;		// not lit by this light
+		}
 
 		rad = DLights[lnum].radius;
 		dist = DotProduct(DLights[lnum].origin, surf->plane->normal) -
@@ -932,32 +993,38 @@
 		if (r_dynamic_clip)
 		{
 			if (dist <= -0.1)
+			{
 				continue;
+			}
 		}
 		
 		rad -= fabs(dist);
 		minlight = DLights[lnum].minlight;
 		if (rad < minlight)
+		{
 			continue;
+		}
 		minlight = rad - minlight;
 
 		impact = DLights[lnum].origin - surf->plane->normal * dist;
 
 		if (r_dynamic_clip)
 		{
-			sub = Level->PointInSubsector(*surf->verts);
+			sub = Level->PointInSubsector(impact);
 			vuint8* dyn_facevis = Level->LeafPVS(sub);
 			leafnum = Level->PointInSubsector(DLights[lnum].origin) -
 				Level->Subsectors;
 
 			// Check potential visibility
 			if (!(dyn_facevis[leafnum >> 3] & (1 << (leafnum & 7))))
+			{
 				continue;
+			}
 		}
 
-		rmul = (DLights[lnum].colour >> 16) & 0xff;
-		gmul = (DLights[lnum].colour >> 8) & 0xff;
-		bmul = DLights[lnum].colour & 0xff;
+		rmul = (DLights[lnum].colour >> 16) & 255;
+		gmul = (DLights[lnum].colour >> 8) & 255;
+		bmul = DLights[lnum].colour & 255;
 
 		local.x = DotProduct(impact, tex->saxis) + tex->soffs;
 		local.y = DotProduct(impact, tex->taxis) + tex->toffs;
@@ -969,26 +1036,36 @@
 		{
 			td = (int)local.y - t * 16;
 			if (td < 0)
+			{
 				td = -td;
+			}
 			for (s = 0; s < smax; s++)
 			{
 				sd = (int)local.x - s * 16;
 				if (sd < 0)
+				{
 					sd = -sd;
+				}
 				if (sd > td)
+				{
 					dist = sd + (td >> 1);
+				}
 				else
+				{
 					dist = td + (sd >> 1);
+				}
 
 				if (dist < minlight)
 				{
 					i = t * smax + s;
-					blocklights[i] += (vuint32)((rad - dist) * 256);
+					blocklights[i] += (vuint32)((rad - dist) * 256.0);
 					blocklightsr[i] += (vuint32)((rad - dist) * rmul);
 					blocklightsg[i] += (vuint32)((rad - dist) * gmul);
 					blocklightsb[i] += (vuint32)((rad - dist) * bmul);
 					if (DLights[lnum].colour != 0xffffffff)
+					{
 						is_coloured = true;
+					}
 				}
 			}
 		}
@@ -1029,7 +1106,9 @@
 	int tG = ((surf->Light >> 8) & 255) * t / 255;
 	int tB = (surf->Light & 255) * t / 255;
 	if (tR != tG || tR != tB)
+	{
 		is_coloured = true;
+	}
 	for (i = 0; i < size; i++)
 	{
 		blocklights[i] = t;
@@ -1058,11 +1137,17 @@
 			if (!r_static_add)
 			{
 				if (blocklightsr[i] > 0xffff)
+				{
 					blocklightsr[i] = 0xffff;
+				}
 				if (blocklightsg[i] > 0xffff)
+				{
 					blocklightsg[i] = 0xffff;
+				}
 				if (blocklightsb[i] > 0xffff)
+				{
 					blocklightsb[i] = 0xffff;
+				}
 			}
 		}
 	}
@@ -1078,18 +1163,26 @@
 			if (!r_static_add)
 			{
 				if (blocklightsr[i] > 0xffff)
+				{
 					blocklightsr[i] = 0xffff;
+				}
 				if (blocklightsg[i] > 0xffff)
+				{
 					blocklightsg[i] = 0xffff;
+				}
 				if (blocklightsb[i] > 0xffff)
+				{
 					blocklightsb[i] = 0xffff;
+				}
 			}
 		}
 	}
 
 	// add all the dynamic lights
 	if (surf->dlightframe == r_dlightframecount)
+	{
 		AddDynamicLights(surf);
+	}
 
 	//  Calc additive light. This must be done before lightmap procesing
 	// because it will clamp all lights
@@ -1102,7 +1195,9 @@
 			{
 				t = int(r_specular * t);
 				if (t > 0xffff)
+				{
 					t = 0xffff;
+				}
 				blockaddlightsr[i] = t;
 				r_light_add = true;
 			}
@@ -1112,7 +1207,9 @@
 			{
 				t = int(r_specular * t);
 				if (t > 0xffff)
+				{
 					t = 0xffff;
+				}
 				blockaddlightsg[i] = t;
 				r_light_add = true;
 			}
@@ -1122,7 +1219,9 @@
 			{
 				t = int(r_specular * t);
 				if (t > 0xffff)
+				{
 					t = 0xffff;
+				}
 				blockaddlightsb[i] = t;
 				r_light_add = true;
 			}
@@ -1135,22 +1234,30 @@
 	{
 		t = (255 * 256 - (int)blocklights[i]) >> shift;
 		if (t < minlight)
+		{
 			t = minlight;
+		}
 		blocklights[i] = t;
 
 		t = (255 * 256 - (int)blocklightsr[i]) >> shift;
 		if (t < minlight)
+		{
 			t = minlight;
+		}
 		blocklightsr[i] = t;
 
 		t = (255 * 256 - (int)blocklightsg[i]) >> shift;
 		if (t < minlight)
+		{
 			t = minlight;
+		}
 		blocklightsg[i] = t;
 
 		t = (255 * 256 - (int)blocklightsb[i]) >> shift;
 		if (t < minlight)
+		{
 			t = minlight;
+		}
 		blocklightsb[i] = t;
 	}
 
@@ -1493,9 +1600,13 @@
 	}
 
 	if (surface->dlightframe == r_dlightframecount)
+	{
 		cache->dlight = 1;
+	}
 	else
+	{
 		cache->dlight = 0;
+	}
 	cache->Light = surface->Light;
 
 	// calculate the lightings
diff -Nur orig/source/r_local.h mod/source/r_local.h
--- orig/source/r_local.h	2010-12-23 20:48:32.000000000 +0100
+++ mod/source/r_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_local.h 4354 2010-12-23 19:48:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -89,21 +89,6 @@
 	float			RowOffset;
 };
 
-struct drawseg_t
-{
-	seg_t*			seg;
-	drawseg_t*		next;
-
-	segpart_t*		top;
-	segpart_t*		mid;
-	segpart_t*		bot;
-	segpart_t*		topsky;
-	segpart_t*		extra;
-
-	surface_t*		HorizonTop;
-	surface_t*		HorizonBot;
-};
-
 struct sec_surface_t
 {
 	sec_plane_t*	secplane;
@@ -115,18 +100,6 @@
 	surface_t*		surfs;
 };
 
-struct subregion_t
-{
-	sec_region_t*	secregion;
-	subregion_t*	next;
-	sec_plane_t*	floorplane;
-	sec_plane_t*	ceilplane;
-	sec_surface_t*	floor;
-	sec_surface_t*	ceil;
-	int				count;
-	drawseg_t*		lines;
-};
-
 struct fakefloor_t
 {
 	sec_plane_t		floorplane;
@@ -361,6 +334,8 @@
 	//	Moved here so that model rendering methods can be merged.
 	TVec			CurrLightPos;
 	float			CurrLightRadius;
+	int             CurrLightsNumber;
+	int             CurrShadowsNumber;
 
 	VRenderLevelShared(VLevel* ALevel);
 	~VRenderLevelShared();
@@ -543,7 +518,7 @@
 	surface_t* SubdivideSeg(surface_t*, const TVec&, const TVec*);
 	void UpdateSubsector(int, float*);
 	void UpdateBSPNode(int, float*);
-	void UpdateWorld();
+	void UpdateWorld(const refdef_t*, const VViewClipper*);
 
 	//	Light methods
 	void PushDlights();
@@ -555,28 +530,29 @@
 
 	void BuildLightVis(int bspnum, float* bbox);
 	void DrawShadowSurfaces(surface_t* InSurfs, texinfo_t *texinfo,
-		bool CheckSkyBoxAlways);
+		bool CheckSkyBoxAlways, bool LightCanCross);
 	void RenderShadowLine(drawseg_t* dseg);
 	void RenderShadowSecSurface(sec_surface_t* ssurf, VEntity* SkyBox);
 	void RenderShadowSubRegion(subregion_t* region);
 	void RenderShadowSubsector(int num);
-	void RenderShadowBSPNode(int bspnum, float* bbox);
+	void RenderShadowBSPNode(int bspnum, float* bbox, bool LimitLights);
 	void DrawLightSurfaces(surface_t* InSurfs, texinfo_t *texinfo,
-		VEntity* SkyBox, bool CheckSkyBoxAlways);
+		VEntity* SkyBox, bool CheckSkyBoxAlways, bool LightCanCross);
 	void RenderLightLine(drawseg_t* dseg);
 	void RenderLightSecSurface(sec_surface_t* ssurf, VEntity* SkyBox);
 	void RenderLightSubRegion(subregion_t* region);
 	void RenderLightSubsector(int num);
-	void RenderLightBSPNode(int bspnum, float* bbox);
+	void RenderLightBSPNode(int bspnum, float* bbox, bool LimitLights);
 	void RenderLightShadows(const refdef_t* RD, const VViewClipper* Range,
-		TVec& Pos, float Radius, vuint32 Colour);
+		TVec& Pos, float Radius, vuint32 Colour, bool LimitLights);
 
 	//	Things
+	void ResetMobjsLightCount();
 	void RenderThingAmbient(VEntity*);
 	void RenderMobjsAmbient();
 	void RenderThingTextures(VEntity*);
 	void RenderMobjsTextures();
-	bool IsTouchedByLight(VEntity*);
+	bool IsTouchedByLight(VEntity*, bool);
 	void RenderThingLight(VEntity*);
 	void RenderMobjsLight();
 	void RenderThingShadow(VEntity*);
diff -Nur orig/source/r_main.cpp mod/source/r_main.cpp
--- orig/source/r_main.cpp	2010-12-24 17:10:48.000000000 +0100
+++ mod/source/r_main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_main.cpp 4355 2010-12-24 01:29:15Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -77,6 +77,8 @@
 VCvarF					r_fade_factor("r_fade_factor", "4.0", CVAR_Archive);
 VCvarF					r_sky_bright_factor("r_sky_bright_factor", "1.0", CVAR_Archive);
 
+extern VCvarF			r_lights_radius;
+
 VDrawer					*Drawer;
 
 refdef_t				refdef;
@@ -315,14 +317,20 @@
 
 	for (int i = 0; i < Level->NumSubsectors; i++)
 	{
-		for (subregion_t* r = Level->Subsectors[i].regions; r; r = r->next)
+		for (subregion_t* r = Level->Subsectors[i].regions; r != NULL; r = r->next)
 		{
-			FreeSurfaces(r->floor->surfs);
-			delete r->floor;
-			r->floor = NULL;
-			FreeSurfaces(r->ceil->surfs);
-			delete r->ceil;
-			r->ceil = NULL;
+			if (r->floor != NULL)
+			{
+				FreeSurfaces(r->floor->surfs);
+				delete r->floor;
+				r->floor = NULL;
+			}
+			if (r->ceil != NULL)
+			{
+				FreeSurfaces(r->ceil->surfs);
+				delete r->ceil;
+				r->ceil = NULL;
+			}
 		}
 	}
 
@@ -837,33 +845,93 @@
 
 	MarkLeaves();
 
-	UpdateWorld();
+	UpdateWorld(RD, Range);
 
 	RenderWorld(RD, Range);
 	RenderMobjsAmbient();
 
 	Drawer->BeginShadowVolumesPass();
-	if (!FixedLight && r_dynamic)
+
+	subsector_t		*sub;
+	int				leafnum;
+	vuint8*         dyn_facevis;
+	linetrace_t		Trace;
+	TVec			Delta;
+
+	CurrLightsNumber = 0;
+	CurrShadowsNumber = 0;
+
+	if (!FixedLight && r_static_lights)
 	{
-		dlight_t* l = DLights;
-		for (int i = 0; i < MAX_DLIGHTS; i++, l++)
+		for (int i = 0; i < Lights.Num(); i++)
 		{
-			if (l->die < Level->Time || !l->radius)
+			if (!Lights[i].radius)
 			{
 				continue;
 			}
-			RenderLightShadows(RD, Range, l->origin, l->radius, l->colour);
+
+			sub = Level->PointInSubsector(Lights[i].origin);
+			dyn_facevis = Level->LeafPVS(sub);
+
+			// Check potential visibility
+			if (!(dyn_facevis[Lights[i].leafnum >> 3] & (1 << (Lights[i].leafnum & 7))))
+			{
+				continue;
+			}
+
+			Delta = Lights[i].origin - vieworg;
+			Delta.z = 0;
+			//	Don't do lights that are too far away.
+			if ((Delta.Length() > r_lights_radius / 4.0) && !Level->TraceLine(Trace, Lights[i].origin, vieworg, SPF_NOBLOCKSIGHT))
+			{
+				continue;
+			}
+
+			if (Delta.Length() > r_lights_radius)
+			{
+				continue;
+			}
+
+			RenderLightShadows(RD, Range, Lights[i].origin, Lights[i].radius, Lights[i].colour, true);
 		}
 	}
-	if (!FixedLight && r_static_lights)
+
+	if (!FixedLight && r_dynamic)
 	{
-		for (int i = 0; i < Lights.Num(); i++)
+		dlight_t* l = DLights;
+
+		for (int i = 0; i < MAX_DLIGHTS; i++, l++)
 		{
-			if (!Lights[i].radius)
+			if (!l->radius || l->die < Level->Time)
+			{
+				continue;
+			}
+
+			sub = Level->PointInSubsector(l->origin);
+			dyn_facevis = Level->LeafPVS(sub);
+
+			leafnum = Level->PointInSubsector(l->origin) - Level->Subsectors;
+
+			// Check potential visibility
+			if (!(dyn_facevis[leafnum >> 3] & (1 << (leafnum & 7))))
+			{
+				continue;
+			}
+
+			Delta = l->origin - vieworg;
+			Delta.z = 0;
+			//	Don't do lights that are too far away.
+			if ((Delta.Length() > r_lights_radius / 4.0) && !Level->TraceLine(Trace, l->origin, vieworg, SPF_NOBLOCKSIGHT))
 			{
 				continue;
 			}
-			RenderLightShadows(RD, Range, Lights[i].origin, Lights[i].radius, Lights[i].colour);
+
+			if (Delta.Length() > r_lights_radius)
+			{
+				continue;
+			}
+
+			RenderLightShadows(RD, Range, l->origin, l->radius, l->colour, true);
 		}
 	}
 
@@ -916,7 +984,6 @@
 	AnimateSky(host_frametime);
 
 	UpdateParticles(host_frametime);
-
 	PushDlights();
 
 	//	Update camera textures that were visible in last frame.
@@ -1181,7 +1248,7 @@
 
 	if (!Tr)
 	{
-		Tr = new VTextureTranslation;
+		Tr = new VTextureTranslation();
 		PlayerTranslations[MAXPLAYERS] = Tr;
 	}
 	if (Tr->TranslStart != Start || Tr->TranslEnd == End)
diff -Nur orig/source/r_model.cpp mod/source/r_model.cpp
--- orig/source/r_model.cpp	2010-12-16 21:24:24.000000000 +0100
+++ mod/source/r_model.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_model.cpp 4342 2010-12-16 20:24:23Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -58,6 +58,8 @@
 	TArray<VName>		Skins;
 	bool				FullBright;
 	bool				NoShadow;
+	bool                UseDepth;
+	bool                AllowTransparency;
 };
 
 struct VScriptModel
@@ -345,6 +347,22 @@
 				Md2.NoShadow = !SN->GetAttribute("noshadow").ICmp("true");
 			}
 
+			//	Force depth test flag.
+			//  For things like monsters with alpha transaparency
+			Md2.UseDepth = false;
+			if (SN->HasAttribute("usedepth"))
+			{
+				Md2.UseDepth = !SN->GetAttribute("usedepth").ICmp("true");
+			}
+
+			//	Allow transparency in skin files.
+			//  For skins that are transparent in solid models (Alpha = 1.0)
+			Md2.AllowTransparency = false;
+			if (SN->HasAttribute("allowtransparency"))
+			{
+				Md2.AllowTransparency = !SN->GetAttribute("allowtransparency").ICmp("true");
+			}
+
 			//	Process frames.
 			for (VXmlNode* FN = SN->FindChild("frame"); FN; FN = FN->FindNext())
 			{
@@ -798,6 +816,7 @@
 
 	if (LittleLong(*(vuint32*)mod->Data) != IDPOLY2HEADER)
 	{
+		Z_Free(mod->Data);
 		Sys_Error("model %s is not a md2 model", *mod->Name);
 	}
 
@@ -1033,14 +1052,32 @@
 		switch (Pass)
 		{
 		case RPASS_Normal:
+		case RPASS_Ambient:
 			break;
 
-		case RPASS_Ambient:
 		case RPASS_ShadowVolumes:
-		case RPASS_Light:
+			if (Md2Alpha < 1.0 || SubMdl.NoShadow)
+			{
+				continue;
+			}
+			break;
+
 		case RPASS_Textures:
+			if (Md2Alpha <= 0.333)
+			{
+				continue;
+			}
+			break;
+
+		case RPASS_Light:
+			if (Md2Alpha <= 0.333 || SubMdl.NoShadow)
+			{
+				continue;
+			}
+			break;
+
 		case RPASS_Fog:
-			if (Md2Alpha < 1 || SubMdl.NoShadow)
+			if (Md2Alpha <= 0.666 || SubMdl.NoShadow)
 			{
 				continue;
 			}
@@ -1102,13 +1139,15 @@
 			Drawer->DrawAliasModel(Md2Org, Md2Angle, Offset, Scale,
 				SubMdl.Model, Md2Frame, Md2NextFrame, GTextureManager(SkinID),
 				Trans, ColourMap, Md2Light, Fade, Md2Alpha, Additive,
-				IsViewModel, smooth_inter, Interpolate);
+				IsViewModel, smooth_inter, Interpolate, SubMdl.UseDepth,
+				SubMdl.AllowTransparency);
 			break;
 
 		case RPASS_Ambient:
 			Drawer->DrawAliasModelAmbient(Md2Org, Md2Angle, Offset, Scale,
 				SubMdl.Model, Md2Frame, Md2NextFrame, GTextureManager(SkinID),
-				Md2Light, smooth_inter, Interpolate);
+				Md2Light, Md2Alpha, smooth_inter, Interpolate, SubMdl.UseDepth,
+				SubMdl.AllowTransparency);
 			break;
 
 		case RPASS_ShadowVolumes:
@@ -1120,19 +1159,20 @@
 		case RPASS_Light:
 			Drawer->DrawAliasModelLight(Md2Org, Md2Angle, Offset, Scale,
 				SubMdl.Model, Md2Frame, Md2NextFrame, GTextureManager(SkinID),
-				smooth_inter, Interpolate);
+				Md2Alpha, smooth_inter, Interpolate, SubMdl.AllowTransparency);
 			break;
 
 		case RPASS_Textures:
 			Drawer->DrawAliasModelTextures(Md2Org, Md2Angle, Offset, Scale,
 				SubMdl.Model, Md2Frame, Md2NextFrame, GTextureManager(SkinID),
-				Trans, ColourMap, smooth_inter, Interpolate);
+				Trans, ColourMap, Md2Alpha, smooth_inter, Interpolate, SubMdl.UseDepth,
+				SubMdl.AllowTransparency);
 			break;
 
 		case RPASS_Fog:
 			Drawer->DrawAliasModelFog(Md2Org, Md2Angle, Offset, Scale,
 				SubMdl.Model, Md2Frame, Md2NextFrame, GTextureManager(SkinID),
-				Fade, smooth_inter, Interpolate);
+				Fade, Md2Alpha, smooth_inter, Interpolate, SubMdl.AllowTransparency);
 			break;
 		}
 	}
diff -Nur orig/source/r_particle.cpp mod/source/r_particle.cpp
--- orig/source/r_particle.cpp	2010-06-04 23:21:12.000000000 +0200
+++ mod/source/r_particle.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_particle.cpp 4298 2010-06-04 21:27:57Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -133,7 +133,8 @@
 	guard(VRenderLevelShared::UpdateParticles);
 	particle_t		*p, *kill;
 
-	if (GGameInfo->IsPaused())
+	if (GGameInfo->IsPaused() ||
+		(Level->LevelInfo->LevelInfoFlags2 & VLevelInfo::LIF2_Frozen))
 	{
 		return;
 	}
@@ -184,7 +185,7 @@
 		{
 			vuint32 Col = p->colour;
 			rgba_t TmpCol = ColourMaps[ColourMap].GetPalette()[R_LookupRGB(
-				(Col >> 16) & 0xff, (Col >> 8) & 0xff, Col & 0xff)];
+				(Col >> 16) & 255, (Col >> 8) & 255, Col & 255)];
 			p->colour = (Col & 0xff000000) | (TmpCol.r << 16) |
 				(TmpCol.g << 8) | TmpCol.b;
 			Drawer->DrawParticle(p);
diff -Nur orig/source/r_portal.cpp mod/source/r_portal.cpp
--- orig/source/r_portal.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/r_portal.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_portal.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -157,7 +157,8 @@
 	TClipPlane SavedClip = view_clipplanes[4];
 	TClipPlane* SavedClipLink = view_clipplanes[3].next;
 
-	VRenderLevel::trans_sprite_t TransSprites[VRenderLevel::MAX_TRANS_SPRITES];
+	VRenderLevel::trans_sprite_t *TransSprites =
+		(VRenderLevel::trans_sprite_t *)Z_Calloc(sizeof(VRenderLevel::trans_sprite_t) * VRenderLevel::MAX_TRANS_SPRITES);
 
 	if (NeedsDepthBuffer())
 	{
@@ -165,7 +166,7 @@
 		// be done only for portals that do rendering of view.
 		RLev->BspVis = new vuint8[RLev->VisSize];
 
-		memset(TransSprites, 0, sizeof(TransSprites));
+		memset(TransSprites, 0, sizeof(VRenderLevel::trans_sprite_t) * VRenderLevel::MAX_TRANS_SPRITES);
 		RLev->trans_sprites = TransSprites;
 	}
 
@@ -194,6 +195,8 @@
 	Drawer->SetupViewOrg();
 
 	Drawer->EndPortal(this, UseStencil);
+
+	Z_Free(TransSprites);
 	unguard;
 }
 
@@ -411,7 +414,7 @@
 
 //==========================================================================
 //
-//	VMirrorPortal::MatchSkyBox
+//	VMirrorPortal::MatchMirror
 //
 //==========================================================================
 
diff -Nur orig/source/r_public.h mod/source/r_public.h
--- orig/source/r_public.h	2010-12-15 23:20:47.000000000 +0100
+++ mod/source/r_public.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_public.h 4341 2010-12-15 22:20:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -245,7 +245,7 @@
 
 	static void AdjustGamma(rgba_t*, int);
 	static void SmoothEdges(vuint8*, int, int, vuint8*);
-	static void ResampleTexture(int, int, const vuint8*, int, int, vuint8*);
+	static void ResampleTexture(int, int, const vuint8*, int, int, vuint8*, int);
 	static void MipMap(int, int, vuint8*);
 
 protected:
@@ -269,6 +269,7 @@
 		bool bCheckAny = false);
 	int FindTextureByLumpNum(int);
 	VName GetTextureName(int TexNum);
+	float TextureWidth(int TexNum);
 	float TextureHeight(int TexNum);
 	int TextureAnimation(int InTex);
 	void SetFrontSkyLayer(int tex);
diff -Nur orig/source/r_shared.h mod/source/r_shared.h
--- orig/source/r_shared.h	2010-12-16 21:24:24.000000000 +0100
+++ mod/source/r_shared.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_shared.h 4342 2010-12-16 20:24:23Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -34,6 +34,8 @@
 
 #include "fmd2defs.h"
 #include "drawer.h"
+#include "avir/avir.h"
+#include "avir/avir_float4_sse.h"
 
 // MACROS ------------------------------------------------------------------
 
diff -Nur orig/source/r_sky.cpp mod/source/r_sky.cpp
--- orig/source/r_sky.cpp	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/r_sky.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_sky.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -71,13 +71,13 @@
 
 //==========================================================================
 //
-//	R_InitSkyBoxes
+//	ParseSkyBoxesScript
 //
 //==========================================================================
 
 static void ParseSkyBoxesScript(VScriptParser* sc)
 {
-	guard(R_InitSkyBoxes);
+	guard(ParseSkyBoxesScript);
 	while (!sc->AtEnd())
 	{
 		skyboxinfo_t& info = skyboxinfo.Alloc();
@@ -110,6 +110,7 @@
 
 void R_InitSkyBoxes()
 {
+	guard(R_InitSkyBoxes);
 	for (int Lump = W_IterateNS(-1, WADNS_Global); Lump >= 0;
 		Lump = W_IterateNS(Lump, WADNS_Global))
 	{
@@ -125,6 +126,7 @@
 		ParseSkyBoxesScript(new VScriptParser("scripts/skyboxes.txt",
 			FL_OpenFileRead("scripts/skyboxes.txt")));
 	}
+	unguard;
 }
 
 //==========================================================================
@@ -136,7 +138,7 @@
 static int CheckSkyboxNumForName(VName Name)
 {
 	guard(CheckSkyboxNumForName);
-	for (int num = skyboxinfo.Num() - 1; num >= 0 ; num--)
+	for (int num = skyboxinfo.Num() - 1; num >= 0; num--)
 	{
 		if (skyboxinfo[num].Name == Name)
 		{
@@ -179,7 +181,7 @@
 		skyheight = 256;
 	}
 	float skytop;
-	float skybot;
+//	float skybot;
 	int j;
 
 	if (skyheight <= 128)
@@ -190,7 +192,7 @@
 	{
 		skytop = 190;
 	}
-	skybot = skytop - skyheight;
+//	skybot = skytop - skyheight;
 	int skyh = (int)skytop;
 
 	for (j = 0; j < VDIVS; j++)
@@ -329,7 +331,7 @@
 			Host_Error("No such skybox %s", *Name2);
 		}
 	}
-	skyboxinfo_t& s2info = skyboxinfo[num];
+//	skyboxinfo_t& s2info = skyboxinfo[num];
 
 	memset(sky, 0, sizeof(sky));
 
@@ -530,11 +532,14 @@
 	guard(VRenderLevelShared::AnimateSky);
 	InitSky();
 
-	//	Update sky column offsets
-	for (int i = 0; i < BaseSky.NumSkySurfs; i++)
+	if (!(Level->LevelInfo->LevelInfoFlags2 & VLevelInfo::LIF2_Frozen))
 	{
-		BaseSky.sky[i].columnOffset1 += BaseSky.sky[i].scrollDelta1 * frametime;
-		BaseSky.sky[i].columnOffset2 += BaseSky.sky[i].scrollDelta2 * frametime;
+		//	Update sky column offsets
+		for (int i = 0; i < BaseSky.NumSkySurfs; i++)
+		{
+			BaseSky.sky[i].columnOffset1 += BaseSky.sky[i].scrollDelta1 * frametime;
+			BaseSky.sky[i].columnOffset2 += BaseSky.sky[i].scrollDelta2 * frametime;
+		}
 	}
 	unguard;
 }
diff -Nur orig/source/r_surf.cpp mod/source/r_surf.cpp
--- orig/source/r_surf.cpp	2010-12-15 22:48:26.000000000 +0100
+++ mod/source/r_surf.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_surf.cpp 4340 2010-12-15 21:48:23Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -245,7 +245,7 @@
 //==========================================================================
 
 void VAdvancedRenderLevel::InitSurfs(surface_t* surfs, texinfo_t *texinfo,
-	TPlane *plane, subsector_t*)
+	TPlane *plane, subsector_t* sub)
 {
 	guard(VAdvancedRenderLevel::InitSurfs);
 	//	It's always one surface.
@@ -481,7 +481,7 @@
 
 	surf->count = sub->numlines;
 	seg_t *line = &Level->Segs[sub->firstline];
-	int vlindex = (splane->normal.z < 0);
+	bool vlindex = (splane->normal.z < 0);
 	for (int i = 0; i < surf->count; i++)
 	{
 		TVec &v = *line[vlindex ? surf->count - i - 1 : i].v1;
@@ -600,7 +600,7 @@
 				(sub->numlines - 1) * sizeof(TVec));
 			surf->count = sub->numlines;
 			seg_t* line = &Level->Segs[sub->firstline];
-			int vlindex = (plane->normal.z < 0);
+			bool vlindex = (plane->normal.z < 0);
 			for (int i = 0; i < surf->count; i++)
 			{
 				TVec &v = *line[vlindex ? surf->count - i - 1 : i].v1;
@@ -645,11 +645,11 @@
 	if (!free_wsurfs)
 	{
 		//	Allocate some more surfs
-		byte* tmp = (byte*)Z_Malloc(WSURFSIZE * 32 + sizeof(void*));
+		vuint8* tmp = (vuint8*)Z_Malloc(WSURFSIZE * 128 + sizeof(void*));
 		*(void**)tmp = AllocatedWSurfBlocks;
 		AllocatedWSurfBlocks = tmp;
 		tmp += sizeof(void*);
-		for (int i = 0; i < 32; i++)
+		for (int i = 0; i < 128; i++)
 		{
 			((surface_t*)tmp)->next = free_wsurfs;
 			free_wsurfs = (surface_t*)tmp;
@@ -854,7 +854,7 @@
 	surface_t *surf = NewWSurf();
 	surf->next = NULL;
 	surf->count = 4;
-	memcpy(surf->verts, wv, 4 * sizeof(TVec));
+	memcpy(surf->verts, wv, surf->count * sizeof(TVec));
 
 	if (texinfo->Tex == GTextureManager[skyflatnum])
 	{
@@ -1012,7 +1012,6 @@
 	else
 	{
 		// two sided line
-
 		sec_plane_t* back_floor = &seg->backsector->floor;
 		sec_plane_t* back_ceiling = &seg->backsector->ceiling;
 		if (seg->backsector->fakefloors)
@@ -1232,10 +1231,14 @@
 
 			if (linedef->flags & ML_WRAP_MIDTEX)
 			{
-				wv[0].z = midbotz1;
+				wv[0].z = MAX(midbotz1, z_org - texh);
+				wv[1].z = MIN(midtopz1, z_org);
+				wv[2].z = MIN(midtopz2, z_org);
+				wv[3].z = MAX(midbotz2, z_org - texh);
+/*				wv[0].z = midbotz1;
 				wv[1].z = midtopz1;
 				wv[2].z = midtopz2;
-				wv[3].z = midbotz2;
+				wv[3].z = midbotz2;*/
 			}
 			else
 			{
@@ -1363,19 +1366,37 @@
 		return;
 	}
 
-	side_t* sidedef = seg->sidedef;
-	line_t* linedef = seg->linedef;
-
 	if (ShouldClip)
 	{
-		float a1 = ViewClip.PointToClipAngle(*seg->v2);
-		float a2 = ViewClip.PointToClipAngle(*seg->v1);
-		if (!ViewClip.IsRangeVisible(a1, a2))
+		// Clip sectors that are behind rendered segs
+		TVec v1 = *seg->v1;
+		TVec v2 = *seg->v2;
+		TVec r1 = vieworg - v1;
+		TVec r2 = vieworg - v2;
+		float D1 = DotProduct(Normalise(CrossProduct(r1, r2)), vieworg);
+		float D2 = DotProduct(Normalise(CrossProduct(r2, r1)), vieworg);
+
+		// There might be a better method of doing this, but
+		// this one works for now...
+		if (D1 > 0.0 && D2 < 0.0)
+		{
+			v2 += (v2 - v1) * D1 / (D1 - D2);
+		}
+		else if (D2 > 0.0 && D1 < 0.0)
+		{
+			v1 += (v1 - v2) * D2 / (D2 - D1);
+		}
+
+		if (!ViewClip.IsRangeVisible(ViewClip.PointToClipAngle(v2),
+			ViewClip.PointToClipAngle(v1)))
 		{
 			return;
 		}
 	}
 
+	side_t* sidedef = seg->sidedef;
+	line_t* linedef = seg->linedef;
+
 	if (!seg->backsector)
 	{
 		sp = dseg->mid;
@@ -1755,10 +1776,14 @@
 
 				if (linedef->flags & ML_WRAP_MIDTEX)
 				{
-					wv[0].z = midbotz1;
+					wv[0].z = MAX(midbotz1, z_org - texh);
+					wv[1].z = MIN(midtopz1, z_org);
+					wv[2].z = MIN(midtopz2, z_org);
+					wv[3].z = MAX(midbotz2, z_org - texh);
+/*					wv[0].z = midbotz1;
 					wv[1].z = midtopz1;
 					wv[2].z = midtopz2;
-					wv[3].z = midbotz2;
+					wv[3].z = midbotz2;*/
 				}
 				else
 				{
@@ -1967,7 +1992,7 @@
 			//	Skip sectors containing original polyobjs
 			continue;
 		}
-		for (reg = sub->sector->botregion; reg; reg = reg->next)		
+		for (reg = sub->sector->botregion; reg; reg = reg->next)
 		{
 			count++;
 			dscount += sub->numlines;
@@ -2083,7 +2108,6 @@
 {
 	guard(VRenderLevelShared::UpdateSubRegion);
 	int				count;
-	int 			polyCount;
 	seg_t**			polySeg;
 
 	r_floor = region->floorplane;
@@ -2114,7 +2138,7 @@
 	if (r_sub->poly)
 	{
 		//	Update the polyobj
-		polyCount = r_sub->poly->numsegs;
+		int polyCount = r_sub->poly->numsegs;
 		polySeg = r_sub->poly->segs;
 		while (polyCount--)
 		{
@@ -2125,6 +2149,13 @@
 
 	if (region->next)
 	{
+		if (ClipSegs)
+		{
+			if (!ViewClip.ClipCheckRegion(region->next, r_sub, false))
+			{
+				return;
+			}
+		}
 		UpdateSubRegion(region->next, ClipSegs);
 	}
 	unguard;
@@ -2152,7 +2183,7 @@
 		return;
 	}
 
-	if (!ViewClip.ClipCheckSubsector(r_sub))
+	if (!ViewClip.ClipCheckSubsector(r_sub, false))
 	{
 		return;
 	}
@@ -2169,7 +2200,7 @@
 
 	UpdateSubRegion(r_sub->regions, true);
 
-	ViewClip.ClipAddSubsectorSegs(r_sub);
+	ViewClip.ClipAddSubsectorSegs(r_sub, false);
 	unguard;
 }
 
@@ -2190,6 +2221,11 @@
 		return;
 	}
 
+	if (!ViewClip.ClipCheckSubsector(r_sub, false))
+	{
+		return;
+	}
+
 	bbox[2] = r_sub->sector->floor.minz;
 	if (IsSky(&r_sub->sector->ceiling))
 	{
@@ -2200,7 +2236,9 @@
 		bbox[5] = r_sub->sector->ceiling.maxz;
 	}
 
-	UpdateSubRegion(r_sub->regions, false);
+	UpdateSubRegion(r_sub->regions, true);
+
+	ViewClip.ClipAddSubsectorSegs(r_sub, false);
 	unguard;
 }
 
@@ -2218,39 +2256,42 @@
 		return;
 	}
 
-	if (!ViewClip.ClipIsBBoxVisible(bbox))
+	if (!ViewClip.ClipIsBBoxVisible(bbox, false))
+	{
+		return;
+	}
+
+	if (bspnum == -1)
 	{
+		UpdateSubsector(0, bbox);
 		return;
 	}
 
 	// Found a subsector?
-	if (bspnum & NF_SUBSECTOR)
+	if (!(bspnum & NF_SUBSECTOR))
 	{
-		if (bspnum == -1)
-		{
-			UpdateSubsector(0, bbox);
-		}
-		else
+		node_t* bsp = &Level->Nodes[bspnum];
+
+		if (bsp->VisFrame != r_visframecount)
 		{
-			UpdateSubsector(bspnum & (~NF_SUBSECTOR), bbox);
+			return;
 		}
-		return;
-	}
 
-	node_t* bsp = &Level->Nodes[bspnum];
+		// Decide which side the view point is on.
+		int side = bsp->PointOnSide(vieworg);
 
-	if (bsp->VisFrame != r_visframecount)
-	{
+		UpdateBSPNode(bsp->children[side], bsp->bbox[side]);
+		bbox[2] = MIN(bsp->bbox[0][2], bsp->bbox[1][2]);
+		bbox[5] = MAX(bsp->bbox[0][5], bsp->bbox[1][5]);
+		if (!ViewClip.ClipIsBBoxVisible(bsp->bbox[side ^ 1], false))
+		{
+			return;
+		}
+		UpdateBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
 		return;
 	}
 
-	// Decide which side the view point is on.
-	int side = bsp->PointOnSide(vieworg);
-
-	UpdateBSPNode(bsp->children[side], bsp->bbox[side]);
-	UpdateBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
-	bbox[2] = MIN(bsp->bbox[0][2], bsp->bbox[1][2]);
-	bbox[5] = MAX(bsp->bbox[0][5], bsp->bbox[1][5]);
+	UpdateSubsector(bspnum & (~NF_SUBSECTOR), bbox);
 	unguard;
 }
 
@@ -2263,29 +2304,42 @@
 void VAdvancedRenderLevel::UpdateBSPNode(int bspnum, float* bbox)
 {
 	guard(VAdvancedRenderLevel::UpdateBSPNode);
+	if (ViewClip.ClipIsFull())
+	{
+		return;
+	}
+
+	if (!ViewClip.ClipIsBBoxVisible(bbox, false))
+	{
+		return;
+	}
+
+	if (bspnum == -1)
+	{
+		UpdateSubsector(0, bbox);
+		return;
+	}
+
 	// Found a subsector?
-	if (bspnum & NF_SUBSECTOR)
+	if (!(bspnum & NF_SUBSECTOR))
 	{
-		if (bspnum == -1)
-		{
-			UpdateSubsector(0, bbox);
-		}
-		else
+		node_t* bsp = &Level->Nodes[bspnum];
+
+		// Decide which side the view point is on.
+		int side = bsp->PointOnSide(vieworg);
+
+		UpdateBSPNode(bsp->children[side], bsp->bbox[side]);
+		bbox[2] = MIN(bsp->bbox[0][2], bsp->bbox[1][2]);
+		bbox[5] = MAX(bsp->bbox[0][5], bsp->bbox[1][5]);
+		if (!ViewClip.ClipIsBBoxVisible(bsp->bbox[side ^ 1], false))
 		{
-			UpdateSubsector(bspnum & (~NF_SUBSECTOR), bbox);
+			return;
 		}
+		UpdateBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
 		return;
 	}
 
-	node_t* bsp = &Level->Nodes[bspnum];
-
-	// Decide which side the view point is on.
-	int side = bsp->PointOnSide(vieworg);
-
-	UpdateBSPNode(bsp->children[side], bsp->bbox[side]);
-	UpdateBSPNode(bsp->children[side ^ 1], bsp->bbox[side ^ 1]);
-	bbox[2] = MIN(bsp->bbox[0][2], bsp->bbox[1][2]);
-	bbox[5] = MAX(bsp->bbox[0][5], bsp->bbox[1][5]);
+	UpdateSubsector(bspnum & (~NF_SUBSECTOR), bbox);
 	unguard;
 }
 
@@ -2309,12 +2363,12 @@
 	}
 	else if (opp->normal != -dest->normal)
 	{
-		if (source->dist > dest->dist)
+		if (source->dist < dest->dist)
 		{
 			copy = true;
 		}
 	}
-	else if (source->dist > dest->dist && source->dist < -opp->dist)
+	else if (source->dist < dest->dist && source->dist > -opp->dist)
 	{
 		copy = true;
 	}
@@ -2354,7 +2408,7 @@
 		//(heightsec && vieworg.z <= heightsec->floor.GetPointZ(vieworg));
 		(s && vieworg.z <= s->floor.GetPointZ(vieworg));
 	bool doorunderwater = false;
-	int diffTex = !!(s->SectorFlags & sector_t::SF_ClipFakePlanes);
+	bool diffTex = !!(s && s->SectorFlags & sector_t::SF_ClipFakePlanes);
 
 	// Replace sector being drawn with a copy to be hacked
 	fakefloor_t* ff = sec->fakefloors;
@@ -2369,7 +2423,7 @@
 		{
 			ff->floorplane.pic = s->floor.pic;
 		}
-		else if (s->SectorFlags & sector_t::SF_FakeFloorOnly)
+		else if (s && s->SectorFlags & sector_t::SF_FakeFloorOnly)
 		{
 			if (underwater)
 			{
@@ -2397,11 +2451,14 @@
 	}
 	else
 	{
-		ff->floorplane.normal = s->floor.normal;
-		ff->floorplane.dist = s->floor.dist;
+		if (s)
+		{
+			ff->floorplane.normal = s->floor.normal;
+			ff->floorplane.dist = s->floor.dist;
+		}
 	}
 
-	if (!(s->SectorFlags & sector_t::SF_FakeFloorOnly))
+	if (s && !(s->SectorFlags & sector_t::SF_FakeFloorOnly))
 	{
 		if (diffTex)
 		{
@@ -2418,46 +2475,58 @@
 	}
 
 //	float refflorz = s->floor.GetPointZ(viewx, viewy);
-	float refceilz = s->ceiling.GetPointZ(vieworg);
+	float refceilz = s ? s->ceiling.GetPointZ(vieworg) : NULL;
 //	float orgflorz = sec->floor.GetPointZ(viewx, viewy);
 	float orgceilz = sec->ceiling.GetPointZ(vieworg);
 
-#if 0//1
+#if 1
 	// [RH] Allow viewing underwater areas through doors/windows that
 	// are underwater but not in a water sector themselves.
 	// Only works if you cannot see the top surface of any deep water
 	// sectors at the same time.
-	if (back && !r_fakingunderwater && curline->frontsector->heightsec == NULL)
+	if (s)
 	{
-		if (rw_frontcz1 <= s->floorplane.ZatPoint (curline->v1->x, curline->v1->y) &&
-			rw_frontcz2 <= s->floorplane.ZatPoint (curline->v2->x, curline->v2->y))
+		for (int i = 0; i < sec->linecount; i++)
 		{
-			// Check that the window is actually visible
-			for (int z = WallSX1; z < WallSX2; ++z)
+			float rw_frontcz1 = sec->ceiling.GetPointZ (sec->lines[i]->v1->x, sec->lines[i]->v1->y);
+			float rw_frontcz2 = sec->ceiling.GetPointZ (sec->lines[i]->v2->x, sec->lines[i]->v2->y);
+
+			if (/*back && !r_fakingunderwater &&*/ !s->lines[i]->frontsector->heightsec)
 			{
-				if (floorclip[z] > ceilingclip[z])
+				if (rw_frontcz1 <= s->floor.GetPointZ (sec->lines[i]->v1->x, sec->lines[i]->v1->y) &&
+					rw_frontcz2 <= s->floor.GetPointZ (sec->lines[i]->v2->x, sec->lines[i]->v2->y))
 				{
-					doorunderwater = true;
-					r_fakingunderwater = true;
-					break;
+					// Check that the window is actually visible
+/*					for (int z = WallSX1; z < WallSX2; ++z)
+					{
+						if (floorclip[z] > ceilingclip[z])
+						bool val = (heightsec && ((vieworg.z <= heightsec->floor.GetPointZ(sec->lines[i]->v1->x, sec->lines[i]->v1->y) &&
+							vieworg.z <= heightsec->floor.GetPointZ(sec->lines[i]->v2->x, sec->lines[i]->v2->y))));
+
+						doorunderwater &= val;
+					}*/
 				}
 			}
 		}
 	}
 #endif
 
-	if (underwater || doorunderwater)
+	if (underwater || doorunderwater /*||
+		(heightsec && vieworg.z <= heightsec->floor.GetPointZ(vieworg))*/
+	   )
 	{
 		ff->floorplane.normal = sec->floor.normal;
 		ff->floorplane.dist = sec->floor.dist;
 		ff->ceilplane.normal = -s->floor.normal;
-		ff->ceilplane.dist = -s->floor.dist/* + 1*/;
+		ff->ceilplane.dist = -s->floor.dist/* - -s->floor.normal.z*/;
 //		ff->ColourMap = s->ColourMap;
 		ff->params.Fade = s->params.Fade;
 	}
 
 	// killough 11/98: prevent sudden light changes from non-water sectors:
-	if ((underwater/* && !back*/) || doorunderwater)
+	if ((underwater /*&& !back*/) || doorunderwater ||
+		(heightsec && vieworg.z <= heightsec->floor.GetPointZ(vieworg))
+		)
 	{
 		// head-below-floor hack
 		ff->floorplane.pic			= diffTex ? sec->floor.pic : s->floor.pic;
@@ -2470,11 +2539,11 @@
 		ff->floorplane.BaseYOffs	= s->floor.BaseYOffs;
 
 		ff->ceilplane.normal		= -s->floor.normal;
-		ff->ceilplane.dist			= -s->floor.dist/* + 1*/;
+		ff->ceilplane.dist			= -s->floor.dist/* - -s->floor.normal.z*/;
 		if (s->ceiling.pic == skyflatnum)
 		{
 			ff->floorplane.normal	= -ff->ceilplane.normal;
-			ff->floorplane.dist		= -ff->ceilplane.dist/* + 1*/;
+			ff->floorplane.dist		= -ff->ceilplane.dist/* - ff->ceilplane.normal.z*/;
 			ff->ceilplane.pic		= ff->floorplane.pic;
 			ff->ceilplane.xoffs		= ff->floorplane.xoffs;
 			ff->ceilplane.yoffs		= ff->floorplane.yoffs;
@@ -2512,25 +2581,25 @@
 			}*/
 		}
 	}
-	else if (heightsec && orgceilz > refceilz &&
-		!(s->SectorFlags & sector_t::SF_FakeFloorOnly) &&
-		vieworg.z >= heightsec->ceiling.GetPointZ(vieworg))
+	else if (((s && vieworg.z > s->floor.GetPointZ(vieworg)) ||
+			 (heightsec && vieworg.z > heightsec->ceiling.GetPointZ(vieworg))) &&
+			 orgceilz > refceilz &&	!(s->SectorFlags & sector_t::SF_FakeFloorOnly))
 	{
 		// Above-ceiling hack
-		ff->ceilplane.normal	= s->ceiling.normal;
-		ff->ceilplane.dist		= s->ceiling.dist;
-		ff->floorplane.normal	= -s->ceiling.normal;
-		ff->floorplane.dist		= -s->ceiling.dist/* + 1*/;
-		ff->params.Fade 		= s->params.Fade;
-//		ff->params.ColourMap	= s->params.ColourMap;
-
-		ff->ceilplane.pic = diffTex ? sec->ceiling.pic : s->ceiling.pic;
-		ff->floorplane.pic									= s->ceiling.pic;
-		ff->floorplane.xoffs	= ff->ceilplane.xoffs		= s->ceiling.xoffs;
-		ff->floorplane.yoffs	= ff->ceilplane.yoffs		= s->ceiling.yoffs;
-		ff->floorplane.XScale	= ff->ceilplane.XScale		= s->ceiling.XScale;
-		ff->floorplane.YScale	= ff->ceilplane.YScale		= s->ceiling.YScale;
-		ff->floorplane.Angle	= ff->ceilplane.Angle		= s->ceiling.Angle;
+		ff->ceilplane.normal		= s->ceiling.normal;
+		ff->ceilplane.dist			= s->ceiling.dist;
+		ff->floorplane.normal		= -s->ceiling.normal;
+		ff->floorplane.dist			= -s->ceiling.dist/* - s->ceiling.normal.z*/;
+		ff->params.Fade 			= s->params.Fade;
+//		ff->params.ColourMap		= s->params.ColourMap;
+
+		ff->ceilplane.pic			= diffTex ? sec->ceiling.pic : s->ceiling.pic;
+		ff->floorplane.pic										= s->ceiling.pic;
+		ff->floorplane.xoffs		= ff->ceilplane.xoffs		= s->ceiling.xoffs;
+		ff->floorplane.yoffs		= ff->ceilplane.yoffs		= s->ceiling.yoffs;
+		ff->floorplane.XScale		= ff->ceilplane.XScale		= s->ceiling.XScale;
+		ff->floorplane.YScale		= ff->ceilplane.YScale		= s->ceiling.YScale;
+		ff->floorplane.Angle		= ff->ceilplane.Angle		= s->ceiling.Angle;
 		ff->floorplane.BaseAngle	= ff->ceilplane.BaseAngle	= s->ceiling.BaseAngle;
 		ff->floorplane.BaseYOffs	= ff->ceilplane.BaseYOffs	= s->ceiling.BaseYOffs;
 
@@ -2574,7 +2643,7 @@
 void VRenderLevel::UpdateWorld(const refdef_t* rd, const VViewClipper* Range)
 {
 	guard(VRenderLevel::UpdateWorld);
-	float	dummy_bbox[6] = {-99999, -99999, -99999, 99999, 99999, 99999};
+	float	dummy_bbox[6] = { -99999, -99999, -99999, 99999, 99999, 99999 };
 
 	ViewClip.ClearClipNodes(vieworg, Level);
 	ViewClip.ClipInitFrustrumRange(viewangles, viewforward, viewright, viewup,
@@ -2605,10 +2674,19 @@
 //
 //==========================================================================
 
-void VAdvancedRenderLevel::UpdateWorld()
+void VAdvancedRenderLevel::UpdateWorld(const refdef_t* rd, const VViewClipper* Range)
 {
 	guard(VAdvancedRenderLevel::UpdateWorld);
-	float	dummy_bbox[6] = {-99999, -99999, -99999, 99999, 99999, 99999};
+	float	dummy_bbox[6] = { -99999, -99999, -99999, 99999, 99999, 99999 };
+
+	ViewClip.ClearClipNodes(vieworg, Level);
+	ViewClip.ClipInitFrustrumRange(viewangles, viewforward, viewright, viewup,
+		rd->fovx, rd->fovy);
+	if (Range)
+	{
+		//	Range contains a valid range, so we must clip away holes in it.
+		ViewClip.ClipToRanges(*Range);
+	}
 
 	//	Update fake sectors.
 	for (int i = 0; i < Level->NumSectors; i++)
diff -Nur orig/source/r_tex_automap.cpp mod/source/r_tex_automap.cpp
--- orig/source/r_tex_automap.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/r_tex_automap.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_automap.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_base.cpp mod/source/r_tex_base.cpp
--- orig/source/r_tex_base.cpp	2010-12-15 23:20:47.000000000 +0100
+++ mod/source/r_tex_base.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_base.cpp 4341 2010-12-15 22:20:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -432,7 +432,7 @@
 	}
 	l1 += 4;
 
-	for(x = 1; x < w - 1; x++, l1 += 4)
+	for (x = 1; x < w - 1; x++, l1 += 4)
 	{
 		if (l1[MSB] == 0 && !CHKPIX(-1) && !CHKPIX(1))
 		{
@@ -445,7 +445,7 @@
 	}
 	l1 += 4;
 
-	for(y = 1; y < h - 1; y++)
+	for (y = 1; y < h - 1; y++)
 	{
 		if (l1[MSB] == 0 && !CHKPIX(-w) && !CHKPIX(1))
 		{
@@ -453,9 +453,9 @@
 		}
 		l1 += 4;
 
-		for(x = 1; x < w - 1; x++, l1 += 4)
+		for (x = 1; x < w - 1; x++, l1 += 4)
 		{
-			if (l1[MSB] == 0 && !CHKPIX(-w) && !CHKPIX(-1) && !CHKPIX(1))
+			if (l1[MSB] == 0 && !CHKPIX(-w) && !CHKPIX(-1) && !CHKPIX(1) && !CHKPIX(-w - 1) && !CHKPIX(-w + 1) && !CHKPIX(w - 1) && !CHKPIX(w + 1))
 			{
 				CHKPIX(w);
 			}
@@ -472,7 +472,7 @@
 		CHKPIX(1);
 	}
 	l1 += 4;
-	for(x = 1;x < w - 1; x++, l1 += 4)
+	for (x = 1; x < w - 1; x++, l1 += 4)
 	{
 		if (l1[MSB] == 0 && !CHKPIX(-w) && !CHKPIX(-1))
 		{
@@ -498,7 +498,7 @@
 //==========================================================================
 
 void VTexture::ResampleTexture(int widthin, int heightin,
-	const vuint8* datain, int widthout, int heightout, vuint8* dataout)
+	const vuint8* datain, int widthout, int heightout, vuint8* dataout, int sampling_type)
 {
 	guard(VTexture::ResampleTexture);
 	int i, j, k;
@@ -521,104 +521,120 @@
 		sy = float(heightin - 1);
 	}
 
-//#define POINT_SAMPLE
-#ifdef POINT_SAMPLE
-	for (i = 0; i < heightout; i++)
+	if (sampling_type == 1)
 	{
-		int ii = int(i * sy);
-		for (j = 0; j < widthout; j++)
-		{
-			int jj = int(j * sx);
-
-			const vuint8* src = datain + (ii * widthin + jj) * 4;
-			vuint8* dst = dataout + (i * widthout + j) * 4;
-
-			for (k = 0; k < 4; k++)
-			{
-				*dst++ = *src++;
-			}
-		}
-	}
-#else
-	if (sx <= 1.0 && sy <= 1.0)
-	{
-		/* magnify both width and height:  use weighted sample of 4 pixels */
-		int i0, i1, j0, j1;
-		float alpha, beta;
-		const vuint8 *src00, *src01, *src10, *src11;
-		float s1, s2;
-		vuint8* dst;
-
+		// Use point sample
 		for (i = 0; i < heightout; i++)
 		{
-			i0 = int(i * sy);
-			i1 = i0 + 1;
-			if (i1 >= heightin) i1 = heightin-1;
-			alpha = i * sy - i0;
+			int ii = int(i * sy);
 			for (j = 0; j < widthout; j++)
 			{
-				j0 = int(j * sx);
-				j1 = j0 + 1;
-				if (j1 >= widthin) j1 = widthin-1;
-				beta = j * sx - j0;
-
-				/* compute weighted average of pixels in rect (i0,j0)-(i1,j1) */
-				src00 = datain + (i0 * widthin + j0) * 4;
-				src01 = datain + (i0 * widthin + j1) * 4;
-				src10 = datain + (i1 * widthin + j0) * 4;
-				src11 = datain + (i1 * widthin + j1) * 4;
+				int jj = int(j * sx);
 
-				dst = dataout + (i * widthout + j) * 4;
+				const vuint8* src = datain + (ii * widthin + jj) * 4;
+				vuint8* dst = dataout + (i * widthout + j) * 4;
 
 				for (k = 0; k < 4; k++)
 				{
-					s1 = *src00++ * (1.0-beta) + *src01++ * beta;
-					s2 = *src10++ * (1.0-beta) + *src11++ * beta;
-					*dst++ = vuint8(s1 * (1.0-alpha) + s2 * alpha);
+					*dst++ = *src++;
 				}
 			}
 		}
 	}
 	else
 	{
-		/* shrink width and/or height:  use an unweighted box filter */
-		int i0, i1;
-		int j0, j1;
-		int ii, jj;
-		int sum;
-		vuint8* dst;
-
-		for (i = 0; i < heightout; i++)
+		// Use weighted sample
+		if (sx <= 1.0 && sy <= 1.0)
 		{
-			i0 = int(i * sy);
-			i1 = i0 + 1;
-			if (i1 >= heightin) i1 = heightin-1;
-			for (j = 0; j < widthout; j++)
+			/* magnify both width and height:  use weighted sample of 4 pixels */
+			int i0, i1, j0, j1;
+			float alpha, beta;
+			const vuint8 *src00, *src01, *src10, *src11;
+			float s1, s2;
+			vuint8* dst;
+
+			for (i = 0; i < heightout; i++)
 			{
-				j0 = int(j * sx);
-				j1 = j0 + 1;
-				if (j1 >= widthin) j1 = widthin-1;
+				i0 = int(i * sy);
+				i1 = i0 + 1;
+				if (i1 >= heightin)
+				{
+					i1 = heightin - 1;
+				}
+				alpha = i * sy - i0;
+				for (j = 0; j < widthout; j++)
+				{
+					j0 = int(j * sx);
+					j1 = j0 + 1;
+					if (j1 >= widthin)
+					{
+						j1 = widthin - 1;
+					}
+					beta = j * sx - j0;
 
-				dst = dataout + (i * widthout + j) * 4;
+					/* compute weighted average of pixels in rect (i0,j0)-(i1,j1) */
+					src00 = datain + (i0 * widthin + j0) * 4;
+					src01 = datain + (i0 * widthin + j1) * 4;
+					src10 = datain + (i1 * widthin + j0) * 4;
+					src11 = datain + (i1 * widthin + j1) * 4;
 
-				/* compute average of pixels in the rectangle (i0,j0)-(i1,j1) */
-				for (k = 0; k < 4; k++)
+					dst = dataout + (i * widthout + j) * 4;
+
+					for (k = 0; k < 4; k++)
+					{
+						s1 = *src00++ * (1.0 - beta) + *src01++ * beta;
+						s2 = *src10++ * (1.0 - beta) + *src11++ * beta;
+						*dst++ = vuint8(s1 * (1.0 - alpha) + s2 * alpha);
+					}
+				}
+			}
+		}
+		else
+		{
+			/* shrink width and/or height:  use an unweighted box filter */
+			int i0, i1;
+			int j0, j1;
+			int ii, jj;
+			int sum;
+			vuint8* dst;
+
+			for (i = 0; i < heightout; i++)
+			{
+				i0 = int(i * sy);
+				i1 = i0 + 1;
+				if (i1 >= heightin)
+				{
+					i1 = heightin - 1;
+				}
+				for (j = 0; j < widthout; j++)
 				{
-					sum = 0;
-					for (ii = i0; ii <= i1; ii++)
+					j0 = int(j * sx);
+					j1 = j0 + 1;
+					if (j1 >= widthin)
+					{
+						j1 = widthin - 1;
+					}
+
+					dst = dataout + (i * widthout + j) * 4;
+
+					/* compute average of pixels in the rectangle (i0,j0)-(i1,j1) */
+					for (k = 0; k < 4; k++)
 					{
-						for (jj = j0; jj <= j1; jj++)
+						sum = 0;
+						for (ii = i0; ii <= i1; ii++)
 						{
-							sum += *(datain + (ii * widthin + jj) * 4 + k);
+							for (jj = j0; jj <= j1; jj++)
+							{
+								sum += *(datain + (ii * widthin + jj) * 4 + k);
+							}
 						}
+						sum /= (j1 - j0 + 1) * (i1 - i0 + 1);
+						*dst++ = vuint8(sum);
 					}
-					sum /= (j1 - j0 + 1) * (i1 - i0 + 1);
-					*dst++ = vuint8(sum);
 				}
 			}
 		}
 	}
-#endif
 	unguard;
 }
 
diff -Nur orig/source/r_tex_camera.cpp mod/source/r_tex_camera.cpp
--- orig/source/r_tex_camera.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/r_tex_camera.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_camera.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex.cpp mod/source/r_tex.cpp
--- orig/source/r_tex.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/r_tex.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -370,7 +370,7 @@
 
 //==========================================================================
 //
-//	VTextureManager::TextureHeight
+//	VTextureManager::GetTextureName
 //
 //==========================================================================
 
@@ -387,6 +387,19 @@
 
 //==========================================================================
 //
+//	VTextureManager::TextureWidth
+//
+//==========================================================================
+
+float VTextureManager::TextureWidth(int TexNum)
+{
+	guard(VTextureManager::TextureWidth);
+	return Textures[TexNum]->GetWidth() / Textures[TexNum]->SScale;
+	unguard;
+}
+
+//==========================================================================
+//
 //	VTextureManager::TextureHeight
 //
 //==========================================================================
@@ -1831,7 +1844,7 @@
 		}
 		else
 		{
-			for (int i = 0; i < ad.NumFrames; i++)
+			for (i = 0; i < ad.NumFrames; i++)
 			{
 				GTextureManager[ad.Index + i]->TextureTranslation =
 					ad.Index + (ad.CurrentFrame + i) % ad.NumFrames;
diff -Nur orig/source/r_tex_flat.cpp mod/source/r_tex_flat.cpp
--- orig/source/r_tex_flat.cpp	2010-06-04 23:20:23.000000000 +0200
+++ mod/source/r_tex_flat.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_flat.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex.h mod/source/r_tex.h
--- orig/source/r_tex.h	2009-02-02 21:09:49.000000000 +0100
+++ mod/source/r_tex.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex.h 3983 2009-02-02 20:22:06Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_imgz.cpp mod/source/r_tex_imgz.cpp
--- orig/source/r_tex_imgz.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/r_tex_imgz.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_imgz.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_jpeg.cpp mod/source/r_tex_jpeg.cpp
--- orig/source/r_tex_jpeg.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/r_tex_jpeg.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_jpeg.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_multipatch.cpp mod/source/r_tex_multipatch.cpp
--- orig/source/r_tex_multipatch.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/r_tex_multipatch.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_multipatch.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_patch.cpp mod/source/r_tex_patch.cpp
--- orig/source/r_tex_patch.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/r_tex_patch.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_patch.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_pcx.cpp mod/source/r_tex_pcx.cpp
--- orig/source/r_tex_pcx.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/r_tex_pcx.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_pcx.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_png.cpp mod/source/r_tex_png.cpp
--- orig/source/r_tex_png.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/r_tex_png.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_png.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_raw.cpp mod/source/r_tex_raw.cpp
--- orig/source/r_tex_raw.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/r_tex_raw.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_raw.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_tga.cpp mod/source/r_tex_tga.cpp
--- orig/source/r_tex_tga.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/r_tex_tga.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_tga.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_tex_warp.cpp mod/source/r_tex_warp.cpp
--- orig/source/r_tex_warp.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/r_tex_warp.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_tex_warp.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/r_things.cpp mod/source/r_things.cpp
--- orig/source/r_things.cpp	2010-12-24 17:10:48.000000000 +0100
+++ mod/source/r_things.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: r_things.cpp 4355 2010-12-24 01:29:15Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -351,17 +351,19 @@
 	{
 		// choose a different rotation based on player view
 		//FIXME must use sprforward here?
-		float ang = matan(thing->Origin.y - vieworg.y,
-			thing->Origin.x - vieworg.x);
+		float ang = matan(sprorigin.y - vieworg.y,
+			sprorigin.x - vieworg.x);
 		if (sprframe->lump[0] == sprframe->lump[1])
 		{
 			ang = AngleMod(ang - thing->Angles.yaw + 180.0 + 45.0 / 2.0);
 		}
 		else
 		{
+			ang = matan(sprforward.y + viewforward.y,
+				sprforward.x + viewforward.x);
 			ang = AngleMod(ang - thing->Angles.yaw + 180.0 + 45.0 / 4.0);
 		}
-		vuint32 rot = (vuint32)(ang * 16 / 360.0) & 15;
+		vuint32 rot = (vuint32)(ang * 16.0 / 360.0) & 15;
 		lump = sprframe->lump[rot];
 		flip = sprframe->flip[rot];
 	}
@@ -554,6 +556,7 @@
 	{
 		return;
 	}
+
 	if (!mobj->State)
 	{
 		return;
diff -Nur orig/source/save.h mod/source/save.h
--- orig/source/save.h	2009-11-11 22:29:45.000000000 +0100
+++ mod/source/save.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: save.h 4100 2009-11-11 21:31:19Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/sbar.cpp mod/source/sbar.cpp
--- orig/source/sbar.cpp	2010-12-14 13:07:20.000000000 +0100
+++ mod/source/sbar.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sbar.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -81,7 +81,7 @@
 
 void SB_Ticker()
 {
-	if (cls.signon)
+	if (cl && cls.signon && cl->MO)
 	{
 	    GClGame->eventStatusBarUpdateWidgets(host_frametime);
 	}
diff -Nur orig/source/sbar.h mod/source/sbar.h
--- orig/source/sbar.h	2006-12-05 18:51:21.000000000 +0100
+++ mod/source/sbar.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sbar.h 1878 2006-12-05 09:25:14Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/sc_man.cpp mod/source/sc_man.cpp
--- orig/source/sc_man.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/sc_man.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sc_man.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/screen.cpp mod/source/screen.cpp
--- orig/source/screen.cpp	2010-12-16 21:25:04.000000000 +0100
+++ mod/source/screen.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: screen.cpp 4343 2010-12-16 20:25:03Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -278,11 +278,9 @@
 static void DrawFPS()
 {
 	guard(DrawFPS);
-	double		time;
-
 	if (draw_fps)
 	{
-		time = Sys_Time();
+		double time = Sys_Time();
 		fps_frames++;
 
 		if (time - fps_start > 1.0)
diff -Nur orig/source/screen.h mod/source/screen.h
--- orig/source/screen.h	2010-12-16 21:25:04.000000000 +0100
+++ mod/source/screen.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: screen.h 4343 2010-12-16 20:25:03Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/scripts.h mod/source/scripts.h
--- orig/source/scripts.h	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/scripts.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: scripts.h 4324 2010-07-09 19:19:37Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/server.h mod/source/server.h
--- orig/source/server.h	2008-12-03 20:52:30.000000000 +0100
+++ mod/source/server.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: server.h 3889 2008-12-03 19:57:05Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_al.cpp mod/source/snd_al.cpp
--- orig/source/snd_al.cpp	2008-11-17 19:55:37.000000000 +0100
+++ mod/source/snd_al.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_al.cpp 3866 2008-11-17 18:58:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -100,12 +100,12 @@
 IMPLEMENT_SOUND_DEVICE(VOpenALDevice, SNDDRV_OpenAL, "OpenAL",
 	"OpenAL sound device", "-openal");
 
-VCvarF VOpenALDevice::doppler_factor("al_doppler_factor", "1.0", CVAR_Archive);
-VCvarF VOpenALDevice::doppler_velocity("al_doppler_velocity", "10000.0", CVAR_Archive);
-VCvarF VOpenALDevice::rolloff_factor("al_rolloff_factor", "1.0", CVAR_Archive);
-VCvarF VOpenALDevice::reference_distance("al_reference_distance", "64.0", CVAR_Archive);
-VCvarF VOpenALDevice::max_distance("al_max_distance", "2024.0", CVAR_Archive);
-VCvarI VOpenALDevice::eax_environment("al_eax_environment", "0");
+VCvarF VOpenALDevice::doppler_factor("snd_al_doppler_factor", "1.0", CVAR_Archive);
+VCvarF VOpenALDevice::doppler_velocity("snd_al_doppler_velocity", "10000.0", CVAR_Archive);
+VCvarF VOpenALDevice::rolloff_factor("snd_al_rolloff_factor", "1.0", CVAR_Archive);
+VCvarF VOpenALDevice::reference_distance("snd_al_reference_distance", "64.0", CVAR_Archive);
+VCvarF VOpenALDevice::max_distance("snd_al_max_distance", "2024.0", CVAR_Archive);
+VCvarI VOpenALDevice::eax_environment("snd_al_eax_environment", "0");
 
 //==========================================================================
 //
@@ -183,7 +183,11 @@
 	//	Allocate array for buffers.
 	Buffers = new ALuint[GSoundManager->S_sfx.Num()];
 	memset(Buffers, 0, sizeof(ALuint) * GSoundManager->S_sfx.Num());
-	Sound3D = true;
+	if (GArgs.CheckParm("-3dsound"))
+	{
+		Sound3D = true;
+		GCon->Log(NAME_Init, "3D sound on");
+	}
 	return true;
 	unguard;
 }
@@ -585,7 +589,7 @@
 
 //==========================================================================
 //
-//	VOpenALDevice::SetStreamData
+//	VOpenALDevice::GetStreamBuffer
 //
 //==========================================================================
 
@@ -615,7 +619,10 @@
 	alGetSourcei(StrmSource, AL_SOURCE_STATE, &State);
 	if (State != AL_PLAYING)
 	{
-		alSourcePlay(StrmSource);
+		if (StrmSource)
+		{
+			alSourcePlay(StrmSource);
+		}
 	}
 	unguard;
 }
diff -Nur orig/source/snd_allegro.cpp mod/source/snd_allegro.cpp
--- orig/source/snd_allegro.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/snd_allegro.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_allegro.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_allegromusic.cpp mod/source/snd_allegromusic.cpp
--- orig/source/snd_allegromusic.cpp	2008-11-17 19:55:37.000000000 +0100
+++ mod/source/snd_allegromusic.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_allegromusic.cpp 3866 2008-11-17 18:58:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_audiocd_bsd.cpp mod/source/snd_audiocd_bsd.cpp
--- orig/source/snd_audiocd_bsd.cpp	2008-11-17 19:55:38.000000000 +0100
+++ mod/source/snd_audiocd_bsd.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_audiocd_bsd.cpp 3866 2008-11-17 18:58:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_audiocd_linux.cpp mod/source/snd_audiocd_linux.cpp
--- orig/source/snd_audiocd_linux.cpp	2008-11-17 19:55:38.000000000 +0100
+++ mod/source/snd_audiocd_linux.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_audiocd_linux.cpp 3866 2008-11-17 18:58:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_audiocd_win32.cpp mod/source/snd_audiocd_win32.cpp
--- orig/source/snd_audiocd_win32.cpp	2008-11-17 19:55:38.000000000 +0100
+++ mod/source/snd_audiocd_win32.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_audiocd_win32.cpp 3866 2008-11-17 18:58:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_data.cpp mod/source/snd_data.cpp
--- orig/source/snd_data.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/snd_data.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_data.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -172,7 +172,7 @@
 
 	//	Load script SNDSEQ
 	memset(SeqTrans, -1, sizeof(SeqTrans));
-	for (int Lump = W_IterateNS(-1, WADNS_Global); Lump >= 0;
+	for (Lump = W_IterateNS(-1, WADNS_Global); Lump >= 0;
 		Lump = W_IterateNS(Lump, WADNS_Global))
 	{
 		if (W_LumpName(Lump) == NAME_sndseq)
@@ -881,7 +881,7 @@
 bool VSoundManager::LoadSound(int sound_id)
 {
 	guard(VSoundManager::LoadSound);
-	static const char* Exts[] = { "flac", "wav", "raw", NULL };
+	static const char* Exts[] = { "flac", "wav", "raw", "ogg", "mp3", NULL };
 
 	if (!S_sfx[sound_id].Data)
 	{
diff -Nur orig/source/snd_flac.cpp mod/source/snd_flac.cpp
--- orig/source/snd_flac.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/snd_flac.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_flac.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_gme.cpp mod/source/snd_gme.cpp
--- orig/source/snd_gme.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/snd_gme.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,239 @@
+﻿//**************************************************************************
+//**
+//**	##   ##    ##    ##   ##   ####     ####   ###     ###
+//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**	   #    ##    ##    #      ####     ####   ##       ##
+//**
+//**	$Id$
+//**
+//**	Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**	This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**	This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+// HEADER FILES ------------------------------------------------------------
+
+#ifdef _WIN32
+#include "winlocal.h"
+#endif
+#include "gme/src/Music_Emu.h"
+
+#include "gamedefs.h"
+#include "snd_local.h"
+
+// MACROS ------------------------------------------------------------------
+
+// TYPES -------------------------------------------------------------------
+
+class VGMEAudioCodec : public VAudioCodec
+{
+public:
+	Music_Emu*		emu;
+	gme_info_t*		info;
+	long			length;
+	bool			playing;
+
+	VGMEAudioCodec(void* Data, int Size, gme_type_t in_file);
+	~VGMEAudioCodec();
+	int Decode(short* Data, int NumSamples);
+	bool Finished();
+	void Restart();
+
+	static VAudioCodec* Create(VStream* InStrm);
+};
+
+// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------
+
+// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------
+
+// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------
+
+// EXTERNAL DATA DECLARATIONS ----------------------------------------------
+
+// PUBLIC DATA DEFINITIONS -------------------------------------------------
+
+// PRIVATE DATA DEFINITIONS ------------------------------------------------
+
+IMPLEMENT_AUDIO_CODEC(VGMEAudioCodec, "Game Music Emu");
+
+// CODE --------------------------------------------------------------------
+
+//==========================================================================
+//
+//	VGMEAudioCodec::VGMEAudioCodec
+//
+//==========================================================================
+
+VGMEAudioCodec::VGMEAudioCodec(void* Data, int Size, gme_type_t in_file)
+: emu(in_file->new_emu()), playing(false)
+{
+	// Create emulator and set up playback parameters
+	if (emu == NULL)
+	{
+		GCon->Log("Couldn't create Emulator, Out of memory.");
+	}
+//	emu->set_gain(3.0);
+	emu->set_sample_rate(44100);
+	
+	// Load music file into emulator
+	gme_load_data(emu, Data, Size);
+	
+	// Start track (0 is first track)
+	gme_err_t err = gme_start_track(emu, 0);
+	if (err)
+	{
+		Z_Free(Data);
+	}
+
+	// Set Play length here
+	err = gme_track_info(emu, &info, 0);
+	if (!err && !info->length && !info->loop_length)
+	{
+		// Look for length inside of track info
+		if (info->length > 0)
+		{
+			length = info->length;
+		}
+		if (info->loop_length > 0)
+		{
+			length = info->intro_length + info->loop_length * 2;
+		}
+		if (!length)
+		{
+			length = 150000;
+		}
+	}
+	else
+	{
+		// Or set a default length of 2.5 mins
+		length = 150000;
+	}
+	// Fade sound before finishing
+	gme_set_fade(emu, length - 2500);
+}
+
+//==========================================================================
+//
+//	VGMEAudioCodec::~VGMEAudioCodec
+//
+//==========================================================================
+
+VGMEAudioCodec::~VGMEAudioCodec()
+{
+	guard(VGMEAudioCodec::~VGMEAudioCodec);
+	// Delete emulator and track info
+	playing = false;
+
+	gme_free_info(info);
+	info = NULL;
+
+	gme_delete(emu);
+	emu = NULL;
+	unguard;
+}
+
+//==========================================================================
+//
+//	VGMEAudioCodec::Decode
+//
+//==========================================================================
+
+int VGMEAudioCodec::Decode(short* Data, int NumSamples)
+{
+	guard(VGMEAudioCodec::Decode);
+	// Are we done yet?
+	if (!gme_play(emu, (NumSamples * 2), Data))
+	{
+		if (!gme_track_ended(emu))
+		{
+			playing = true;
+		}
+		else
+		{
+			playing = false;
+		}
+	}
+	else
+	{
+		Z_Free(Data);
+	}
+
+	// This function converts current time in msec to
+	// number of samples played
+	return emu->msec_to_samples(gme_tell(emu));
+	unguard;
+}
+
+//==========================================================================
+//
+//	VGMEAudioCodec::Finished
+//
+//==========================================================================
+
+bool VGMEAudioCodec::Finished()
+{
+	// Finish if we aren't looping and have finished playing
+	return !playing;
+}
+
+//==========================================================================
+//
+//	VGMEAudioCodec::Restart
+//
+//==========================================================================
+
+void VGMEAudioCodec::Restart()
+{
+	guard(VGMEAudioCodec::Restart);
+	// If music is looping, restart playback by simply
+	// starting track 0 again and setting playing state
+	gme_start_track(emu, 0);
+	playing = true;
+	unguard;
+}
+
+//==========================================================================
+//
+//	VGMEAudioCodec::Create
+//
+//==========================================================================
+
+VAudioCodec* VGMEAudioCodec::Create(VStream* InStrm)
+{
+	guard(VGMEAudioCodec::Create);
+	// Scan file's header to determine it's a playable type
+	byte Header[4];
+	InStrm->Seek(0);
+	InStrm->Serialise(Header, 4);
+	gme_type_t file = gme_identify_extension(gme_identify_header(Header));
+	if (!file)
+	{
+		// Incorrect header or incompatible file
+		return NULL;
+	}
+
+	//	Start playback.
+	int Size = InStrm->TotalSize();
+	void* Data = Z_Malloc(Size);
+	InStrm->Seek(0);
+	InStrm->Serialise(Data, Size);
+
+	InStrm->Close();
+	delete InStrm;
+	InStrm = NULL;
+
+	return new VGMEAudioCodec(Data, Size, file);
+	unguard;
+}
diff -Nur orig/source/snd_local.h mod/source/snd_local.h
--- orig/source/snd_local.h	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/snd_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_local.h 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_main.cpp mod/source/snd_main.cpp
--- orig/source/snd_main.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/snd_main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_main.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -163,13 +163,13 @@
 	VCDAudioDevice*		CDAudioDevice;
 
 	//	Console variables
-	static VCvarF		sfx_volume;
-	static VCvarF		music_volume;
-	static VCvarI		swap_stereo;
-	static VCvarI		s_channels;
-	static VCvarI		cd_music;
-	static VCvarI		s_external_music;
-	static VCvarF		eax_distance_unit;
+	static VCvarF		snd_sfx_volume;
+	static VCvarF		snd_music_volume;
+	static VCvarI		snd_swap_stereo;
+	static VCvarI		snd_channels;
+	static VCvarI		snd_cd_music;
+	static VCvarI		snd_external_music;
+	static VCvarF		snd_eax_distance_unit;
 
 	//	Friends
 	friend class TCmdMusic;
@@ -205,13 +205,21 @@
 
 // PRIVATE DATA DEFINITIONS ------------------------------------------------
 
-VCvarF				VAudio::sfx_volume("sfx_volume", "0.5", CVAR_Archive);
-VCvarF				VAudio::music_volume("music_volume", "0.5", CVAR_Archive);
-VCvarI				VAudio::swap_stereo("swap_stereo", "0", CVAR_Archive);
-VCvarI				VAudio::s_channels("s_channels", "16", CVAR_Archive);
-VCvarI				VAudio::cd_music("use_cd_music", "0", CVAR_Archive);
-VCvarI				VAudio::s_external_music("s_external_music", "1", CVAR_Archive);
-VCvarF				VAudio::eax_distance_unit("eax_distance_unit", "32.0", CVAR_Archive);
+VCvarF				VAudio::snd_sfx_volume("snd_sfx_volume", "0.5", CVAR_Archive);
+VCvarF				VAudio::snd_music_volume("snd_music_volume", "0.5", CVAR_Archive);
+VCvarI				VAudio::snd_swap_stereo("snd_swap_stereo", "0", CVAR_Archive);
+VCvarI				VAudio::snd_channels("snd_channels", "128", CVAR_Archive);
+VCvarI				VAudio::snd_cd_music("snd_use_cd_music", "0", CVAR_Archive);
+VCvarI				VAudio::snd_external_music("snd_external_music", "1", CVAR_Archive);
+VCvarF				VAudio::snd_eax_distance_unit("snd_eax_distance_unit", "32.0", CVAR_Archive);
+
+//  Public CVars
+#if defined(DJGPP) || defined(_WIN32)
+VCvarI				snd_mid_player("snd_mid_player", "0", CVAR_Archive);
+#else
+VCvarI				snd_mid_player("snd_mid_player", "1", CVAR_Archive);
+#endif
+VCvarI				snd_mod_player("snd_mod_player", "1", CVAR_Archive);
 
 FAudioCodecDesc*	FAudioCodecDesc::List;
 
@@ -399,7 +407,7 @@
 
 	//	Free all channels for use.
 	memset(Channel, 0, sizeof(Channel));
-	NumChannels = SoundDevice ? SoundDevice->SetChannels(s_channels) : 0;
+	NumChannels = SoundDevice ? SoundDevice->SetChannels(snd_channels) : 0;
 	unguard;
 }
 
@@ -528,9 +536,9 @@
 	else if (!SoundDevice->Sound3D)
 	{
 		float vol = SoundCurve[dist] / 127.0 * volume;
-		float sep = DotProduct(origin - cl->ViewOrg, ListenerRight) /
+		float sep = DotProduct(origin - (cl ? cl->ViewOrg : TVec(0.0, 0.0, 0.0)), ListenerRight) /
 			MaxSoundDist;
-		if (swap_stereo)
+		if (snd_swap_stereo)
 		{
 			sep = -sep;
 		}
@@ -609,7 +617,7 @@
 	}
 
 	//	Mobjs can have only one sound
-	if (origin_id && channel)
+/*	if (origin_id && channel)
     {
 		for (i = 0; i < NumChannels; i++)
 		{
@@ -621,7 +629,7 @@
 				return i;
 			}
 		}
-	}
+	}*/
 
 	//	Look for a free channel
 	for (i = 0; i < NumChannels; i++)
@@ -806,9 +814,10 @@
 void VAudio::UpdateActiveSequences(float DeltaTime)
 {
 	guard(VAudio::UpdateActiveSequences);
-	if (!ActiveSequences || GGameInfo->IsPaused())
+	if (!ActiveSequences || GGameInfo->IsPaused() || !cl)
 	{
 		//	No sequences currently playing/game is paused
+		//  or there's no player in the map
 		return;
 	}
 	for (VSoundSeqNode* node = SequenceListHead; node; node = node->Next)
@@ -887,9 +896,9 @@
 		return;
 	}
 
-	if (sfx_volume != MaxVolume)
+	if (snd_sfx_volume != MaxVolume)
     {
-	    MaxVolume = sfx_volume;
+	    MaxVolume = snd_sfx_volume;
 		if (!MaxVolume)
 		{
 			StopAllSound();
@@ -955,7 +964,7 @@
 			float vol = SoundCurve[dist] / 127.0 * Channel[i].volume;
 			float sep = DotProduct(Channel[i].origin - cl->ViewOrg,
 				ListenerRight) / MaxSoundDist;
-			if (swap_stereo)
+			if (snd_swap_stereo)
 			{
 				sep = -sep;
 			}
@@ -1103,33 +1112,33 @@
 {
 	guard(VAudio::UpdateSounds);
 	//	Check sound volume.
-	if (sfx_volume < 0.0)
+	if (snd_sfx_volume < 0.0)
 	{
-		sfx_volume = 0.0;
+		snd_sfx_volume = 0.0;
 	}
-	if (sfx_volume > 1.0)
+	if (snd_sfx_volume > 1.0)
 	{
-		sfx_volume = 1.0;
+		snd_sfx_volume = 1.0;
 	}
 
 	//	Check music volume.
-	if (music_volume < 0.0)
+	if (snd_music_volume < 0.0)
 	{
-		music_volume = 0.0;
+		snd_music_volume = 0.0;
 	}
-	if (music_volume > 1.0)
+	if (snd_music_volume > 1.0)
 	{
-		music_volume = 1.0;
+		snd_music_volume = 1.0;
 	}
 
 	//	Check for CD music change.
-	if (cd_music && !CDMusic)
+	if (snd_cd_music && !CDMusic)
 	{
 		GCmdBuf << "Music Stop\n";
 		CDMusic = true;
 		StartMusic();
 	}
-	if (!cd_music && CDMusic)
+	if (!snd_cd_music && CDMusic)
 	{
 		GCmdBuf << "CD Stop\n";
 		CDMusic = false;
@@ -1142,12 +1151,12 @@
 	UpdateSfx();
 	if (StreamMusicPlayer)
 	{
-		SoundDevice->SetStreamVolume(music_volume * MusicVolumeFactor);
+		SoundDevice->SetStreamVolume(snd_music_volume * MusicVolumeFactor);
 		StreamMusicPlayer->Tick(host_frametime);
 	}
 	if (MidiDevice)
 	{
-		MidiDevice->SetVolume(music_volume * MusicVolumeFactor);
+		MidiDevice->SetVolume(snd_music_volume * MusicVolumeFactor);
 		MidiDevice->Tick(host_frametime);
 	}
 	if (CDAudioDevice)
@@ -1168,7 +1177,8 @@
 	guard(VAudio::PlaySong);
 	static const char* Exts[] = { "ogg", "mp3", "wav", "mid", "mus", "669",
 		"amf", "dsm", "far", "gdm", "imf", "it", "m15", "med", "mod", "mtm",
-		"okt", "s3m", "stm", "stx", "ult", "uni", "xm", "flac", NULL };
+		"okt", "s3m", "stm", "stx", "ult", "uni", "xm", "flac", "ay", "gbs",
+		"gym", "hes", "kss", "nsf", "nsfe", "sap", "sgc", "spc", "vgm", NULL };
 	static const char* ExtraExts[] = { "ogg", "mp3", NULL };
 
 	if (!Song || !Song[0])
@@ -1190,16 +1200,16 @@
 	MusicVolumeFactor = GSoundManager->GetMusicVolume(Song);
 	if (StreamMusicPlayer)
 	{
-		SoundDevice->SetStreamVolume(music_volume * MusicVolumeFactor);
+		SoundDevice->SetStreamVolume(snd_music_volume * MusicVolumeFactor);
 	}
 	if (MidiDevice)
 	{
-		MidiDevice->SetVolume(music_volume * MusicVolumeFactor);
+		MidiDevice->SetVolume(snd_music_volume * MusicVolumeFactor);
 	}
 
 	//	Find the song.
 	int Lump = -1;
-	if (s_external_music)
+	if (snd_external_music)
 	{
 		//	Check external music definition file.
 		VStream* XmlStrm = FL_OpenFileRead("extras/music/remap.xml");
@@ -1259,7 +1269,7 @@
 	Strm->Serialise(Hdr, 4);
 	if (!memcmp(Hdr, MUSMAGIC, 4))
 	{
-		// convert mus to mid with a wanderfull function
+		// convert mus to mid with a wonderfull function
 		// thanks to S.Bacquet for the source of qmus2mid
 		Strm->Seek(0);
 		VMemoryStream* MidStrm = new VMemoryStream();
@@ -1283,6 +1293,7 @@
 	VAudioCodec* Codec = NULL;
 	for (FAudioCodecDesc* Desc = FAudioCodecDesc::List; Desc && !Codec; Desc = Desc->Next)
 	{
+//		GCon->Logf(va("Using %s to open the stream", Desc->Description));
 		Codec = Desc->Creator(Strm);
 	}
 
@@ -1644,7 +1655,7 @@
 	float len = Length(Trace.LineEnd - cl->ViewOrg);
 	GClLevel->TraceLine(Trace, cl->ViewOrg, cl->ViewOrg - dir, SPF_NOBLOCKSIGHT);
 	len += Length(Trace.LineEnd - cl->ViewOrg);
-	len /= eax_distance_unit;
+	len /= snd_eax_distance_unit;
 	if (len > 100)
 		len = 100;
 	if (len < 1)
@@ -1811,7 +1822,7 @@
 		break;
 
 	case SSCMD_DelayOnce:
-		if (!DidDelayOnce & (1 << SequencePtr[2]))
+		if (!(DidDelayOnce & (1 << SequencePtr[2])))
 		{
 			DidDelayOnce |= 1 << SequencePtr[2];
 			DelayTime = SequencePtr[1] / 35.0;
diff -Nur orig/source/snd_mikmod.cpp mod/source/snd_mikmod.cpp
--- orig/source/snd_mikmod.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/snd_mikmod.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_mikmod.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -129,7 +129,12 @@
 	VC_VoiceRealVolume
 };
 
-static VCvarI	s_mikmod_hqmixer("s_mikmod_hqmixer", "0", CVAR_Archive);
+static VCvarI	s_mikmod_hqmixer("snd_mikmod_hqmixer", "0", CVAR_Archive);
+static VCvarI	s_mikmod_float("snd_mikmod_float", "0", CVAR_Archive);
+static VCvarI	s_mikmod_surround("snd_mikmod_surround", "0", CVAR_Archive);
+static VCvarI	s_mikmod_interpolation("snd_mikmod_interpolation", "0", CVAR_Archive);
+static VCvarI	s_mikmod_reverse_stereo("snd_mikmod_reverse_stereo", "0", CVAR_Archive);
+static VCvarI	s_mikmod_lowpass("snd_mikmod_lowpass", "0", CVAR_Archive);
 
 // CODE --------------------------------------------------------------------
 
@@ -343,6 +348,10 @@
 VAudioCodec* VMikModAudioCodec::Create(VStream* InStrm)
 {
 	guard(VMikModAudioCodec::Create);
+	if (snd_mod_player != 0)
+	{
+		return NULL;
+	}
 	if (!MikModInitialised)
 	{
 		//	Register our driver and all the loaders.
@@ -356,7 +365,57 @@
 	md_mixfreq = 44100;
 	md_mode = DMODE_16BITS | DMODE_SOFT_MUSIC | DMODE_STEREO;
 	if (s_mikmod_hqmixer)
+	{
 		md_mode |= DMODE_HQMIXER;
+	}
+	else
+	{
+		md_mode &= ~DMODE_HQMIXER;
+	}
+#ifdef DMODE_FLOAT
+	if (s_mikmod_float)
+	{
+		md_mode |= DMODE_FLOAT;
+	}
+	else
+	{
+		md_mode &= ~DMODE_FLOAT;
+	}
+#endif
+	if (s_mikmod_surround)
+	{
+		md_mode |= DMODE_SURROUND;
+	}
+	else
+	{
+		md_mode &= ~DMODE_SURROUND;
+	}
+	if (s_mikmod_interpolation)
+	{
+		md_mode |= DMODE_INTERP;
+	}
+	else
+	{
+		md_mode &= ~DMODE_INTERP;
+	}
+	if (s_mikmod_reverse_stereo)
+	{
+		md_mode |= DMODE_REVERSE;
+	}
+	else
+	{
+		md_mode &= ~DMODE_REVERSE;
+	}
+#ifdef DMODE_NOISEREDUCTION
+	if (s_mikmod_lowpass)
+	{
+		md_mode |= DMODE_NOISEREDUCTION;
+	}
+	else
+	{
+		md_mode &= ~DMODE_NOISEREDUCTION;
+	}
+#endif
 
 	//	Initialise MikMod.
 	if (MikMod_Init((CHAR*)""))
diff -Nur orig/source/snd_modplug.cpp mod/source/snd_modplug.cpp
--- orig/source/snd_modplug.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mod/source/snd_modplug.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -0,0 +1,284 @@
+//**************************************************************************
+//**
+//**	##   ##    ##    ##   ##   ####     ####   ###     ###
+//**	##   ##  ##  ##  ##   ##  ##  ##   ##  ##  ####   ####
+//**	 ## ##  ##    ##  ## ##  ##    ## ##    ## ## ## ## ##
+//**	 ## ##  ########  ## ##  ##    ## ##    ## ##  ###  ##
+//**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
+//**	   #    ##    ##    #      ####     ####   ##       ##
+//**
+//**	$Id: snd_modplug.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**
+//**	Copyright (C) 1999-2006 Jānis Legzdiņš
+//**
+//**	This program is free software; you can redistribute it and/or
+//**  modify it under the terms of the GNU General Public License
+//**  as published by the Free Software Foundation; either version 2
+//**  of the License, or (at your option) any later version.
+//**
+//**	This program is distributed in the hope that it will be useful,
+//**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//**  GNU General Public License for more details.
+//**
+//**************************************************************************
+
+// HEADER FILES ------------------------------------------------------------
+
+#ifdef _WIN32
+#include "winlocal.h"
+#include <modplug.h>
+#else
+#include <libmodplug/modplug.h>
+#endif
+
+#include "gamedefs.h"
+#include "snd_local.h"
+
+// MACROS ------------------------------------------------------------------
+
+// TYPES -------------------------------------------------------------------
+
+class VModPlugAudioCodec : public VAudioCodec
+{
+public:
+	ModPlugFile*		file;
+	bool			playing;
+
+	//	VAudioCodec interface.
+	VModPlugAudioCodec(ModPlugFile* InFile);
+	~VModPlugAudioCodec();
+	int Decode(short* Data, int NumSamples);
+	bool Finished();
+	void Restart();
+
+	static VAudioCodec* Create(VStream* InStrm);
+};
+
+// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------
+
+// PUBLIC FUNCTION PROTOTYPES ----------------------------------------------
+
+// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------
+
+// EXTERNAL DATA DECLARATIONS ----------------------------------------------
+
+// PUBLIC DATA DEFINITIONS -------------------------------------------------
+
+// PRIVATE DATA DEFINITIONS ------------------------------------------------
+
+IMPLEMENT_AUDIO_CODEC(VModPlugAudioCodec, "ModPlug");
+
+static VCvarI	s_modplug_hqmixer("snd_modplug_hqmixer", "0", CVAR_Archive);
+static VCvarI	s_modplug_oversampling("snd_modplug_oversampling", "1", CVAR_Archive);
+static VCvarI	s_modplug_noise_reduction("snd_modplug_noise_reduction", "0", CVAR_Archive);
+static VCvarI	s_modplug_reverb("snd_modplug_reverb", "0", CVAR_Archive);
+static VCvarI	s_modplug_megabass("snd_modplug_megabass", "0", CVAR_Archive);
+static VCvarI	s_modplug_surround("snd_modplug_surround", "1", CVAR_Archive);
+
+// CODE --------------------------------------------------------------------
+
+//==========================================================================
+//
+//	VModPlugAudioCodec::VModPlugAudioCodec
+//
+//==========================================================================
+
+VModPlugAudioCodec::VModPlugAudioCodec(ModPlugFile* InFile)
+: file(InFile), playing(true)
+{
+}
+
+//==========================================================================
+//
+//	VModPlugAudioCodec::~VModPlugAudioCodec
+//
+//==========================================================================
+
+VModPlugAudioCodec::~VModPlugAudioCodec()
+{
+	guard(VModPlugAudioCodec::~VModPlugAudioCodec);
+	ModPlug_Unload(file);
+	unguard;
+}
+
+//==========================================================================
+//
+//	VModPlugAudioCodec::Decode
+//
+//==========================================================================
+
+int VModPlugAudioCodec::Decode(short* Data, int NumSamples)
+{
+	guard(VModPlugAudioCodec::Decode);
+	int count = ModPlug_Read(file, Data, NumSamples * 4);
+	if (count < NumSamples * 4)
+	{
+		memset(Data+count, 0, NumSamples*4-count);
+		playing = false;
+	}
+	return count/4;
+	unguard;
+}
+
+//==========================================================================
+//
+//	VModPlugAudioCodec::Finished
+//
+//==========================================================================
+
+bool VModPlugAudioCodec::Finished()
+{
+	guard(VModPlugAudioCodec::Finished);
+	return !playing;
+	unguard;
+}
+
+//==========================================================================
+//
+//	VModPlugAudioCodec::Restart
+//
+//==========================================================================
+
+void VModPlugAudioCodec::Restart()
+{
+	guard(VModPlugAudioCodec::Restart);
+	ModPlug_Seek(file, 0);
+	playing = true;
+	unguard;
+}
+
+//==========================================================================
+//
+//	VModPlugAudioCodec::Create
+//
+//==========================================================================
+
+VAudioCodec* VModPlugAudioCodec::Create(VStream* InStrm)
+{
+	guard(VModPlugAudioCodec::Create);
+	if (snd_mod_player != 1)
+	{
+		return NULL;
+	}
+	//	Set up playback parameters.
+	ModPlug_Settings settings;
+	ModPlug_GetSettings(&settings);
+
+	//  Check desired user settings and set them using flags
+	if (s_modplug_oversampling)
+	{
+		settings.mFlags |= MODPLUG_ENABLE_OVERSAMPLING;
+	}
+	else
+	{
+		settings.mFlags &= ~MODPLUG_ENABLE_OVERSAMPLING;
+	}
+	if (s_modplug_noise_reduction)
+	{
+		settings.mFlags |= MODPLUG_ENABLE_NOISE_REDUCTION;
+	}
+	else
+	{
+		settings.mFlags &= ~MODPLUG_ENABLE_NOISE_REDUCTION;
+	}
+	if (s_modplug_reverb)
+	{
+		settings.mFlags |= MODPLUG_ENABLE_REVERB;
+	}
+	else
+	{
+		settings.mFlags &= ~MODPLUG_ENABLE_REVERB;
+	}
+	if (s_modplug_megabass)
+	{
+		settings.mFlags |= MODPLUG_ENABLE_MEGABASS;
+	}
+	else
+	{
+		settings.mFlags &= ~MODPLUG_ENABLE_MEGABASS;
+	}
+	if (s_modplug_surround)
+	{
+		settings.mFlags |= MODPLUG_ENABLE_SURROUND;
+	}
+	else
+	{
+		settings.mFlags &= ~MODPLUG_ENABLE_SURROUND;
+	}
+	if (s_modplug_hqmixer == 3)
+	{
+	    settings.mResamplingMode = MODPLUG_RESAMPLE_FIR;
+	}
+	else if (s_modplug_hqmixer == 2)
+	{
+	    settings.mResamplingMode = MODPLUG_RESAMPLE_SPLINE;
+	}
+	else if (s_modplug_hqmixer == 1)
+	{
+	    settings.mResamplingMode = MODPLUG_RESAMPLE_LINEAR;
+	}
+	else
+	{
+	    settings.mResamplingMode = MODPLUG_RESAMPLE_NEAREST;
+	}
+
+	ModPlug_SetSettings(&settings);
+
+	//	Start playback.
+	int Size = InStrm->TotalSize();
+	void* Data = Z_Malloc(Size);
+	InStrm->Seek(0);
+	InStrm->Serialise(Data, Size);
+	ModPlugFile* file = ModPlug_Load(Data, Size);
+	Z_Free(Data);
+	if (!file)
+	{
+		return NULL;
+	}
+
+	// Check the file type, we don't want to use ModPlug for
+	// MIDI files, so if we have a MIDI file or an invalid
+	//  file, we'll reject the Codec
+	if (ModPlug_GetModuleType(file) == 0x00 /*MOD_TYPE_NONE*/ ||
+		ModPlug_GetModuleType(file) == 0x10000 /*MOD_TYPE_MID*/)
+	{
+		return NULL;
+	}
+
+	if (ModPlug_GetModuleType(file) == 0x01 /*MOD_TYPE_MOD*/)
+	{
+		// The file is a MOD file, I've seen problems with some
+		// GME type files being detected as MOD files by ModPlug,
+		// so we have to make sure that it is really a MOD_TYPE
+		// file by checking some of it's internal data here
+
+		byte Hdr[4];
+		InStrm->Seek(0);
+		InStrm->Serialise(Hdr, 4);
+
+		// Ignore files that aren't MOD_TYPE files
+		if (memcmp(Hdr, "ZXAY", 4) || memcmp(Hdr, "GBS ", 4) ||
+			memcmp(Hdr, "GYMX", 4) || memcmp(Hdr, "HESM", 4) ||
+			memcmp(Hdr, "KSCC", 4) || memcmp(Hdr, "KSSX", 4) ||
+			memcmp(Hdr, "NESM", 4) || memcmp(Hdr, "NSFE", 4) ||
+			memcmp(Hdr, "SAP ", 4) || memcmp(Hdr, "SGC ", 4) ||
+			memcmp(Hdr, "SNES", 4) || memcmp(Hdr, "Vgm ", 4))
+		{
+			// Incompatible file
+			file = NULL;
+			return NULL;
+		}
+	}
+
+	//  Set master volume here, we'll set it to the maximum
+	//  value (or near to it), it will be adjusted by the
+	//  music volume settings
+	ModPlug_SetMasterVolume(file, 512);
+	InStrm->Close();
+	delete InStrm;
+	InStrm = NULL;
+
+	return new VModPlugAudioCodec(file);
+	unguard;
+}
diff -Nur orig/source/snd_mp3.cpp mod/source/snd_mp3.cpp
--- orig/source/snd_mp3.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/snd_mp3.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_mp3.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -368,7 +368,7 @@
 
 //==========================================================================
 //
-//	VMp3SampleLoader::Create
+//	VMp3SampleLoader::Load
 //
 //==========================================================================
 
diff -Nur orig/source/snd_qmus2mid.cpp mod/source/snd_qmus2mid.cpp
--- orig/source/snd_qmus2mid.cpp	2008-11-17 19:55:38.000000000 +0100
+++ mod/source/snd_qmus2mid.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_qmus2mid.cpp 3866 2008-11-17 18:58:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_reverbs.cpp mod/source/snd_reverbs.cpp
--- orig/source/snd_reverbs.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/snd_reverbs.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_reverbs.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_sdl.cpp mod/source/snd_sdl.cpp
--- orig/source/snd_sdl.cpp	2010-04-21 15:15:39.000000000 +0200
+++ mod/source/snd_sdl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_sdl.cpp 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -94,11 +94,11 @@
 
 bool							sdl_mixer_initialised;
 
-static VCvarI mix_frequency		("mix_frequency", "44100", CVAR_Archive);
-static VCvarI mix_bits			("mix_bits",      "16",    CVAR_Archive);
-static VCvarI mix_channels		("mix_channels",  "2",     CVAR_Archive);
+static VCvarI mix_frequency		("snd_sdl_mix_frequency", "44100", CVAR_Archive);
+static VCvarI mix_bits			("snd_sdl_mix_bits",      "16",    CVAR_Archive);
+static VCvarI mix_channels		("snd_sdl_mix_channels",  "2",     CVAR_Archive);
 
-static VCvarI mix_chunksize		("mix_chunksize", "4096",  CVAR_Archive);
+static VCvarI mix_chunksize		("snd_sdl_mix_chunksize", "4096",  CVAR_Archive);
 
 // PRIVATE DATA DEFINITIONS ------------------------------------------------
 
@@ -303,7 +303,7 @@
 	//	Run the audio converter.
 	if (SDL_ConvertAudio(&cvt) < 0)
 	{
-		free(cvt.buf);
+		Z_Free(cvt.buf);
 		cvt.buf = NULL;
 		return NULL;
 	}
diff -Nur orig/source/snd_sdlmusic.cpp mod/source/snd_sdlmusic.cpp
--- orig/source/snd_sdlmusic.cpp	2010-03-04 23:35:54.000000000 +0100
+++ mod/source/snd_sdlmusic.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_sdlmusic.cpp 4137 2010-03-04 22:39:17Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_streamplayer.cpp mod/source/snd_streamplayer.cpp
--- orig/source/snd_streamplayer.cpp	2008-11-17 19:55:38.000000000 +0100
+++ mod/source/snd_streamplayer.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_streamplayer.cpp 3866 2008-11-17 18:58:49Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_timidity.cpp mod/source/snd_timidity.cpp
--- orig/source/snd_timidity.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/snd_timidity.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_timidity.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -75,15 +75,13 @@
 };
 
 #if defined(DJGPP) || defined(_WIN32)
-static VCvarI	s_timidity("s_timidity", "0", CVAR_Archive);
-static VCvarS	s_timidity_patches("s_timidity_patches", "\\TIMIDITY", CVAR_Archive);
+static VCvarS	s_timidity_patches("snd_timidity_patches", "\\TIMIDITY", CVAR_Archive);
 #else
-static VCvarI	s_timidity("s_timidity", "1", CVAR_Archive);
-static VCvarS	s_timidity_patches("s_timidity_patches", "/usr/share/timidity", CVAR_Archive);
+static VCvarS	s_timidity_patches("snd_timidity_patches", "/usr/share/timidity", CVAR_Archive);
 #endif
-static VCvarI	s_timidity_test_dls("s_timidity_test_dls", "0", CVAR_Archive);
-static VCvarI	s_timidity_test_sf2("s_timidity_test_sf2", "0", CVAR_Archive);
-static VCvarI	s_timidity_verbosity("s_timidity_verbosity", "0", CVAR_Archive);
+static VCvarI	s_timidity_test_dls("snd_timidity_test_dls", "0", CVAR_Archive);
+static VCvarI	s_timidity_test_sf2("snd_timidity_test_sf2", "0", CVAR_Archive);
+static VCvarI	s_timidity_verbosity("snd_timidity_verbosity", "0", CVAR_Archive);
 
 // CODE --------------------------------------------------------------------
 
@@ -191,10 +189,10 @@
 VAudioCodec* VTimidityAudioCodec::Create(VStream* InStrm)
 {
 	guard(VTimidityAudioCodec::Create);
-	//	Handle only if enabled.
-	if (!s_timidity)
+	if (snd_mid_player != 1)
+	{
 		return NULL;
-
+	}
 	//	Check if it's a MIDI file.
 	char Header[4];
 	InStrm->Seek(0);
diff -Nur orig/source/snd_vorbis.cpp mod/source/snd_vorbis.cpp
--- orig/source/snd_vorbis.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/snd_vorbis.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_vorbis.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_wav.cpp mod/source/snd_wav.cpp
--- orig/source/snd_wav.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/snd_wav.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_wav.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/snd_win32.cpp mod/source/snd_win32.cpp
--- orig/source/snd_win32.cpp	2010-03-02 18:51:43.000000000 +0100
+++ mod/source/snd_win32.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_win32.cpp 4129 2010-03-01 13:09:25Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -109,13 +109,20 @@
 
 // PRIVATE DATA DEFINITIONS ------------------------------------------------
 
-static VCvarF		s3d_distance_unit("s3d_distance_unit", "32.0", CVAR_Archive);
-static VCvarF		s3d_doppler_factor("s3d_doppler_factor", "1.0", CVAR_Archive);
-static VCvarF		s3d_rolloff_factor("s3d_rolloff_factor", "1.0", CVAR_Archive);
-static VCvarF		s3d_min_distance("s3d_min_distance", "64.0", CVAR_Archive);
-static VCvarF		s3d_max_distance("s3d_max_distance", "2024.0", CVAR_Archive);
+static VCvarF		snd_3d_distance_unit("snd_3d_distance_unit", "32.0", CVAR_Archive);
+static VCvarF		snd_3d_doppler_factor("snd_3d_doppler_factor", "1.0", CVAR_Archive);
+static VCvarF		snd_3d_rolloff_factor("snd_3d_rolloff_factor", "1.0", CVAR_Archive);
+static VCvarF		snd_3d_min_distance("snd_3d_min_distance", "64.0", CVAR_Archive);
+static VCvarF		snd_3d_max_distance("snd_3d_max_distance", "2024.0", CVAR_Archive);
+static VCvarI		snd_speaker_type("snd_speaker_type", "2", CVAR_Archive);
+static VCvarI		snd_mix_frequency("snd_mix_frequency", "2", CVAR_Archive);
 static VCvarI		eax_environment("eax_environment", "0");
 
+static const DWORD	speaker_type[] = { DSSPEAKER_HEADPHONE, DSSPEAKER_MONO, DSSPEAKER_STEREO, 
+                                       DSSPEAKER_SURROUND, DSSPEAKER_5POINT1_BACK, DSSPEAKER_7POINT1_WIDE };
+
+static const int	frequency[] = { 11025, 22050, 44100, 48000 };
+
 // CODE --------------------------------------------------------------------
 
 //==========================================================================
@@ -170,6 +177,13 @@
 	if (result != DS_OK)
 		Sys_Error("Failed to set sound cooperative level\n%s", DS_Error(result));
 
+	//  Set speaker type
+	if (snd_speaker_type > 5)
+	{
+		snd_speaker_type = 5;
+	}
+	DSound->SetSpeakerConfig(speaker_type[snd_speaker_type]);
+
 	//	Check for 3D sound hardware
 	memset(&caps, 0, sizeof(caps));
 	caps.dwSize = sizeof(caps);
@@ -202,7 +216,11 @@
 	wfx.wBitsPerSample	= WORD(caps.dwFlags & DSCAPS_PRIMARY16BIT ? 16 : 8);
 	wfx.nChannels		= caps.dwFlags & DSCAPS_PRIMARYSTEREO ? 2 : 1;
 	//wfx.nSamplesPerSec	= 11025;
-	wfx.nSamplesPerSec	= 44100;
+	if (snd_mix_frequency > 3)
+	{
+		snd_mix_frequency = 3;
+	}
+	wfx.nSamplesPerSec	= frequency[snd_mix_frequency]; //44100;
 	wfx.nBlockAlign		= WORD(wfx.wBitsPerSample / 8 * wfx.nChannels);
 	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;
 	wfx.cbSize			= 0;
@@ -227,7 +245,7 @@
 		memset(&pcmwf, 0, sizeof(WAVEFORMATEX));
 		pcmwf.wFormatTag      = WAVE_FORMAT_PCM;      
 		pcmwf.nChannels       = 1;
-		pcmwf.nSamplesPerSec  = 44100;
+		pcmwf.nSamplesPerSec  = frequency[snd_mix_frequency]; //44100;
 		pcmwf.wBitsPerSample  = WORD(8);
 		pcmwf.nBlockAlign     = WORD(pcmwf.wBitsPerSample / 8 * pcmwf.nChannels);
 		pcmwf.nAvgBytesPerSec = pcmwf.nSamplesPerSec * pcmwf.nBlockAlign;
@@ -238,7 +256,7 @@
 		dsbdesc.dwFlags       = DSBCAPS_CTRLVOLUME | 
 			DSBCAPS_CTRLFREQUENCY | DSBCAPS_STATIC | 
 			DSBCAPS_CTRL3D | DSBCAPS_LOCHARDWARE;
-		dsbdesc.dwBufferBytes = 44100;
+		dsbdesc.dwBufferBytes = frequency[snd_mix_frequency]; //44100;
 		dsbdesc.lpwfxFormat   = &pcmwf;
 
 		if (SUCCEEDED(DSound->CreateSoundBuffer(&dsbdesc, &tempBuffer, NULL)))
@@ -273,9 +291,9 @@
 			tempBuffer->Release();
 		}
 
-		Listener->SetDistanceFactor(1.0 / s3d_distance_unit, DS3D_IMMEDIATE);
-		Listener->SetDopplerFactor(s3d_doppler_factor, DS3D_IMMEDIATE);
-		Listener->SetRolloffFactor(s3d_rolloff_factor, DS3D_IMMEDIATE);
+		Listener->SetDistanceFactor(1.0 / snd_3d_distance_unit, DS3D_IMMEDIATE);
+		Listener->SetDopplerFactor(snd_3d_doppler_factor, DS3D_IMMEDIATE);
+		Listener->SetRolloffFactor(snd_3d_rolloff_factor, DS3D_IMMEDIATE);
 	}
 	return true;
 	unguard;
@@ -302,7 +320,7 @@
 	if (!NumBuffers)
 	{
 		GCon->Log(NAME_Init, "No HW channels available");
-		NumBuffers = 8;
+		NumBuffers = InNumChannels; //8;
 	}
 	Buffers = new FBuffer[NumBuffers];
 	memset(Buffers, 0, sizeof(FBuffer) * NumBuffers);
@@ -575,8 +593,8 @@
 
 		Buf3D->SetMode(DS3DMODE_HEADRELATIVE, DS3D_IMMEDIATE);
 		Buf3D->SetPosition(0.0, -16.0, 0.0, DS3D_IMMEDIATE);
-		Buf3D->SetMinDistance(s3d_min_distance, DS3D_IMMEDIATE);
-		Buf3D->SetMaxDistance(s3d_max_distance, DS3D_IMMEDIATE);
+		Buf3D->SetMinDistance(snd_3d_min_distance, DS3D_IMMEDIATE);
+		Buf3D->SetMaxDistance(snd_3d_max_distance, DS3D_IMMEDIATE);
 		Buf3D->Release();
 	}
 	else
@@ -632,8 +650,8 @@
 
 	Buf3D->SetPosition(origin.x, origin.z, origin.y, DS3D_IMMEDIATE);
 	Buf3D->SetVelocity(velocity.x, velocity.z, velocity.y, DS3D_IMMEDIATE);
-	Buf3D->SetMinDistance(s3d_min_distance, DS3D_IMMEDIATE);
-	Buf3D->SetMaxDistance(s3d_max_distance, DS3D_IMMEDIATE);
+	Buf3D->SetMinDistance(snd_3d_min_distance, DS3D_IMMEDIATE);
+	Buf3D->SetMaxDistance(snd_3d_max_distance, DS3D_IMMEDIATE);
 	Buf3D->Release();
 
 	result = Buffers[Handle].Buffer->Play(0, 0, Loop ? DSBPLAY_LOOPING : 0);
@@ -767,9 +785,9 @@
 	Listener->SetOrientation(fwd.x, fwd.z, fwd.y, up.x, up.z, up.y, DS3D_DEFERRED);
 
 	//	Set factor values.
-	Listener->SetDistanceFactor(1.0 / s3d_distance_unit, DS3D_DEFERRED);
-	Listener->SetDopplerFactor(s3d_doppler_factor, DS3D_DEFERRED);
-	Listener->SetRolloffFactor(s3d_rolloff_factor, DS3D_DEFERRED);
+	Listener->SetDistanceFactor(1.0 / snd_3d_distance_unit, DS3D_DEFERRED);
+	Listener->SetDopplerFactor(snd_3d_doppler_factor, DS3D_DEFERRED);
+	Listener->SetRolloffFactor(snd_3d_rolloff_factor, DS3D_DEFERRED);
 
 	if (SupportEAX)
 	{
@@ -826,7 +844,6 @@
 	HRESULT					result;
 	DSBUFFERDESC			dsbdesc;
 	WAVEFORMATEX			pcmwf;
-	int						i;
 
 	// Set up wave format structure.
 	memset(&pcmwf, 0, sizeof(WAVEFORMATEX));
@@ -851,7 +868,7 @@
 		int		best = -1;
 		double	least_time = 999999999.0;
 
-		for (i = 0; i < NumBuffers; i++)
+		for (int i = 0; i < NumBuffers; i++)
 		{
 			if (Buffers[i].SoundID && !Buffers[i].Playing &&
 				Buffers[i].FreeTime < least_time)
@@ -931,7 +948,7 @@
 
 //==========================================================================
 //
-//	VDirectSoundDevice::SetStreamData
+//	VDirectSoundDevice::GetStreamBuffer
 //
 //==========================================================================
 
diff -Nur orig/source/snd_win32music.cpp mod/source/snd_win32music.cpp
--- orig/source/snd_win32music.cpp	2010-02-26 21:44:33.000000000 +0100
+++ mod/source/snd_win32music.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: snd_win32music.cpp 4122 2010-01-05 14:56:31Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/sound.h mod/source/sound.h
--- orig/source/sound.h	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/sound.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sound.h 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -177,6 +177,8 @@
 
 	static VAudioPublic* Create();
 };
+extern VCvarI				snd_mid_player;
+extern VCvarI				snd_mod_player;
 
 extern VSoundManager*		GSoundManager;
 extern VAudioPublic*		GAudio;
diff -Nur orig/source/sv_local.h mod/source/sv_local.h
--- orig/source/sv_local.h	2010-03-02 20:56:39.000000000 +0100
+++ mod/source/sv_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sv_local.h 4132 2010-03-02 19:59:53Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/sv_main.cpp mod/source/sv_main.cpp
--- orig/source/sv_main.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/sv_main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sv_main.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -118,7 +118,7 @@
 
 	ProcessDehackedFiles();
 
-	for (int i = 0; i < VClass::GSpriteNames.Num(); i++)
+	for (i = 0; i < VClass::GSpriteNames.Num(); i++)
 	{
 		R_InstallSprite(*VClass::GSpriteNames[i], i);
 	}
@@ -326,9 +326,13 @@
 	}
 	if (skip)
 	{
-		for (int i = 0; i < svs.max_clients; i++)
+		for (i = 0; i < svs.max_clients; i++)
+		{
 			if (GGameInfo->Players[i])
+			{
 				GGameInfo->Players[i]->eventClientSkipIntermission();
+			}
+		}
 	}
 }
 
@@ -438,12 +442,14 @@
 	if (!real_time)
 	{
 		// Rounded a little bit up to prevent "slow motion"
-		host_frametime = 0.028572f;//1.0 / 35.0;
+		host_frametime = 0.02857142857142857142857142857143f; //1.0 / 35.0;
 	}
 	else if (split_frame)
 	{
-		while (host_frametime / exec_times > 0.028572f/*1.0 / 35.0*/)
+		while (host_frametime / exec_times > 0.02857142857142857142857142857143f) //1.0 / 35.0)
+		{
 			exec_times++;
+		}
 	}
 
 	GGameInfo->frametime = host_frametime;
@@ -614,8 +620,12 @@
 		if (VStr(GLevelInfo->NextMap).StartsWith("EndGame"))
 		{
 			for (int i = 0; i < svs.max_clients; i++)
+			{
 				if (GGameInfo->Players[i])
+				{
 					GGameInfo->Players[i]->eventClientFinale(*GLevelInfo->NextMap);
+				}
+			}
 			sv.intermission = 2;
 			return;
 		}
@@ -627,6 +637,11 @@
 	RebornPosition = LeavePosition;
 	GGameInfo->RebornPosition = RebornPosition;
 	mapteleport_issued = true;
+	if (GGameInfo->NetMode == NM_Standalone)
+	{
+		// Copy the base slot to the reborn slot
+		SV_UpdateRebornSlot();
+	}
 	unguard;
 }
 
@@ -951,17 +966,20 @@
 //
 //==========================================================================
 
-void SV_DropClient(VBasePlayer* Player, bool)
+void SV_DropClient(VBasePlayer* Player, bool crash)
 {
 	guard(SV_DropClient);
-	if (GLevel && GLevel->Acs)
-	{
-		GLevel->Acs->StartTypedACScripts(SCRIPT_Disconnect,
-			SV_GetPlayerNum(Player), 0, 0, NULL, true, false);
-	}
-	if (Player->PlayerFlags & VBasePlayer::PF_Spawned)
+	if (!crash)
 	{
-		Player->eventDisconnectClient();
+		if (GLevel && GLevel->Acs)
+		{
+			GLevel->Acs->StartTypedACScripts(SCRIPT_Disconnect,
+				SV_GetPlayerNum(Player), 0, 0, NULL, true, false);
+		}
+		if (Player->PlayerFlags & VBasePlayer::PF_Spawned)
+		{
+			Player->eventDisconnectClient();
+		}
 	}
 	Player->PlayerFlags &= ~VBasePlayer::PF_Active;
 	GGameInfo->Players[SV_GetPlayerNum(Player)] = NULL;
diff -Nur orig/source/sv_save.cpp mod/source/sv_save.cpp
--- orig/source/sv_save.cpp	2010-12-30 20:22:28.000000000 +0100
+++ mod/source/sv_save.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sv_save.cpp 4360 2010-12-30 19:22:35Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -427,7 +427,7 @@
 	*Strm << STRM_INDEX(NumMaps);
 	for (int i = 0; i < Maps.Num(); i++)
 	{
-		VStr TmpName(Maps[i]->Name);
+		TmpName = VStr(Maps[i]->Name);
 		vint32 DataLen = Maps[i]->Data.Num();
 		*Strm << TmpName
 			<< Maps[i]->DecompressedSize
@@ -608,7 +608,7 @@
 	for (TThinkerIterator<VThinker> Th(GLevel); Th; ++Th)
 	{
 		VEntity *mobj = Cast<VEntity>(*Th);
-		if (mobj && mobj->EntityFlags & VEntity::EF_IsPlayer && !SavingPlayers)
+		if (mobj != NULL && mobj->EntityFlags & VEntity::EF_IsPlayer && !SavingPlayers)
 		{
 			// Skipping player mobjs
 			continue;
@@ -913,6 +913,12 @@
 		CL_SetUpLocalPlayer();
 	}
 #endif
+
+	// Launch waiting scripts
+	if (!deathmatch)
+	{
+		GLevel->Acs->CheckAcsStore();
+	}
 	unguard;
 }
 
@@ -993,7 +999,7 @@
 	for (VThinker* Th = GLevel->ThinkerHead; Th; Th = Th->Next)
 	{
 		VEntity *vent = Cast<VEntity>(Th);
-		if (vent && (//(vent->EntityFlags & VEntity::EF_IsPlayer) ||
+		if (vent != NULL && (//(vent->EntityFlags & VEntity::EF_IsPlayer) ||
 			(vent->Owner && (vent->Owner->EntityFlags & VEntity::EF_IsPlayer))))
 		{
 			TravelObjs.Append(vent);
diff -Nur orig/source/sv_world.cpp mod/source/sv_world.cpp
--- orig/source/sv_world.cpp	2009-10-01 15:24:44.000000000 +0200
+++ mod/source/sv_world.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sv_world.cpp 4076 2009-09-24 15:49:34Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -255,11 +255,11 @@
 	float nofit_mindist = 200000.0;
 
 	// check for trivial gaps...
-	if (!gaps)
+	if (gaps == NULL)
 	{
 		return NULL;
 	}
-	if (!gaps->next)
+	if (gaps->next == NULL)
 	{
 		return gaps;
 	}
@@ -268,15 +268,19 @@
 	sec_plane_t *ceil = NULL;
 
 	// There are 2 or more gaps. Now it gets interesting :-)
-	while (gaps)
+	while (gaps != NULL)
 	{
 		float	f;
 		float	c;
 
-		if (!gaps->floor->flags)
+		if (gaps->floor->flags == 0)
+		{
 			floor = gaps->floor;
-		if (!gaps->ceiling->flags)
+		}
+		if (gaps->ceiling->flags == 0)
+		{
 			ceil = gaps->ceiling;
+		}
 		if (gaps->ceiling->flags)
 		{
 			gaps = gaps->next;
@@ -314,9 +318,13 @@
 	}
 
 	if (fit_num == 1)
+	{
 		return fit_last;
+	}
 	if (fit_num > 1)
+	{
 		return fit_closest;
+	}
 	return nofit_closest;
 	unguard;
 }
@@ -448,7 +456,7 @@
 	check(sector);
 	if (sector->heightsec &&
 		(sector->heightsec->SectorFlags & sector_t::SF_UnderWater) &&
-		p.z < sector->heightsec->floor.GetPointZ(p))
+		p.z <= sector->heightsec->floor.GetPointZ(p))
 	{
 		return 9;
 	}
@@ -502,7 +510,6 @@
 bool VLevel::ChangeSector(sector_t* sector, int crunch)
 {
 	guard(VLevel::ChangeSector);
-	int i;
 	sector_t* sec2;
 	sec_region_t* reg;
 	msecnode_t* n;
@@ -554,7 +561,7 @@
 
 	if (sector->SectorFlags & sector_t::SF_ExtrafloorSource)
 	{
-		for (i = 0; i < NumSectors; i++)
+		for (int i = 0; i < NumSectors; i++)
 		{
 			sec2 = &Sectors[i];
 			if (sec2->SectorFlags & sector_t::SF_HasExtrafloors && sec2 != sector)
diff -Nur orig/source/sys_bsd.cpp mod/source/sys_bsd.cpp
--- orig/source/sys_bsd.cpp	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/sys_bsd.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sys_bsd.cpp 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -35,8 +35,9 @@
 #include <dirent.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <time.h>
 #include "gamedefs.h"
-#include "svnrev.h"
+#include "gitrev.h"
 
 #ifdef DJGPP
 #include <dpmi.h>
@@ -197,7 +198,9 @@
 
 void Sys_Sleep()
 {
-	usleep(1);
+//	usleep(1);
+	static const struct timespec sleepTime = {0, 28500000};
+	nanosleep(&sleepTime, NULL);
 }
 
 //==========================================================================
@@ -336,7 +339,7 @@
 {
 	try
 	{
-		printf("Vavoom dedicated server "VERSION_TEXT" (r" SVN_REVISION_STRING ")\n");
+		printf("Vavoom dedicated server " VERSION_TEXT " (r" GIT_HASH ")\n");
 
 		GArgs.Init(argc, argv);
 
diff -Nur orig/source/sys_lin.cpp mod/source/sys_lin.cpp
--- orig/source/sys_lin.cpp	2010-09-07 22:05:19.000000000 +0200
+++ mod/source/sys_lin.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sys_lin.cpp 4328 2010-09-07 20:05:38Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -26,6 +26,7 @@
 // HEADER FILES ------------------------------------------------------------
 
 #include <sys/time.h>
+#include <time.h>
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -187,7 +188,9 @@
 
 void Sys_Sleep()
 {
-	usleep(1);
+//	usleep(1);
+	static const struct timespec sleepTime = {0, 28500000};
+	nanosleep(&sleepTime, NULL);
 }
 
 //==========================================================================
diff -Nur orig/source/sys_sdl.cpp mod/source/sys_sdl.cpp
--- orig/source/sys_sdl.cpp	2010-09-07 22:05:19.000000000 +0200
+++ mod/source/sys_sdl.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sys_sdl.cpp 4328 2010-09-07 20:05:38Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -26,12 +26,14 @@
 // HEADER FILES ------------------------------------------------------------
 
 #include <sys/time.h>
+#include <time.h>
 #include <fcntl.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <signal.h>
 #include <dirent.h>
 #include <SDL.h>
+#include <execinfo.h>
 
 #include "gamedefs.h"
 
@@ -187,7 +189,9 @@
 
 void Sys_Sleep()
 {
-	usleep(1);
+//	usleep(1);
+	static const struct timespec sleepTime = {0, 28500000};
+	nanosleep(&sleepTime, NULL);
 }
 
 //==========================================================================
@@ -329,6 +333,14 @@
 	// can we still print entries on the calling stack or have we finished?
 	static bool		continue_stack_trace = true;
 
+	// get void*'s for all entries on the stack
+	void *array[10];
+	size_t size = backtrace(array, 10);
+
+	// print out all the frames to stderr
+	backtrace_symbols_fd(array, size, STDERR_FILENO);
+    
+
 	// clean the stack addresses if necessary
 	for (i = 0; i < MAX_STACK_ADDR; i++)
 	{
@@ -440,6 +452,7 @@
 {
 	// Ignore future instances of this signal.
 	signal(s, SIG_IGN);
+	stack_trace();
 
 	//	Exit with error message
 #ifdef USE_GUARD_SIGNAL_CONTEXT
@@ -530,11 +543,11 @@
 	catch (VavoomError &e)
 	{
 		Host_Shutdown();
-		stack_trace();
 
 		printf("\n%s\n", e.message);
 		dprintf("\n\nERROR: %s\n", e.message);
 
+		SDL_Quit();
 		exit(1);
 	}
 	catch (...)
diff -Nur orig/source/system.h mod/source/system.h
--- orig/source/system.h	2010-09-07 22:05:19.000000000 +0200
+++ mod/source/system.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: system.h 4328 2010-09-07 20:05:38Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/sys_win.cpp mod/source/sys_win.cpp
--- orig/source/sys_win.cpp	2010-09-07 22:05:19.000000000 +0200
+++ mod/source/sys_win.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sys_win.cpp 4328 2010-09-07 20:05:38Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -559,8 +559,8 @@
 
 		//	Create window
 		hwnd = CreateWindowEx(WS_EX_APPWINDOW, "VAVOOM", "VAVOOM for Windows",
-			WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0, 2, 2,
-			NULL, NULL, hInst, NULL);
+			(WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX) | WS_CLIPCHILDREN |
+			 WS_CLIPSIBLINGS, 0, 0, 2, 2, NULL, NULL, hInst, NULL);
 		if (!hwnd)
 		{
 			MessageBox(NULL, "Couldn't create window", "Error", MB_OK);
@@ -645,7 +645,7 @@
 			VStr::Length(Host_GetCoreDump()) + 4];
 		sprintf(tmp_msg, "%s\n\n%s", e.message, Host_GetCoreDump());
 		MessageBox(hwnd, tmp_msg, "Error", MB_OK);
-		delete tmp_msg;
+		delete[] tmp_msg;
 		tmp_msg = NULL;
 
 		SendMessage(hwnd, WM_CLOSE, 0, 0);
@@ -662,7 +662,7 @@
 		tmp_msg = new char[VStr::Length(Host_GetCoreDump()) + 32];
 		sprintf(tmp_msg, "Received external exception\n\n%s", Host_GetCoreDump());
 		MessageBox(hwnd, tmp_msg, "Error", MB_OK);
-		delete tmp_msg;
+		delete[] tmp_msg;
 		tmp_msg = NULL;
 
 //		throw;
diff -Nur orig/source/sys_wind.cpp mod/source/sys_wind.cpp
--- orig/source/sys_wind.cpp	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/sys_wind.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sys_wind.cpp 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -36,7 +36,7 @@
 #include <sys/stat.h>
 #include "winlocal.h"	
 #include "gamedefs.h"
-#include "svnrev.h"
+#include "gitrev.h"
 
 // MACROS ------------------------------------------------------------------
 
@@ -307,7 +307,7 @@
 {
 	try
 	{
-		printf("Vavoom dedicated server "VERSION_TEXT" (r" SVN_REVISION_STRING ")\n");
+		printf("Vavoom dedicated server " VERSION_TEXT " (r" GIT_HASH ")\n");
 
 		GArgs.Init(argc, argv);
 
diff -Nur orig/source/template.cpp mod/source/template.cpp
--- orig/source/template.cpp	2006-06-27 21:47:30.000000000 +0200
+++ mod/source/template.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: template.cpp 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/template.h mod/source/template.h
--- orig/source/template.h	2006-06-27 21:47:30.000000000 +0200
+++ mod/source/template.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: template.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/text.cpp mod/source/text.cpp
--- orig/source/text.cpp	2007-12-02 11:01:38.000000000 +0100
+++ mod/source/text.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: text.cpp 2927 2007-12-02 10:05:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/text.h mod/source/text.h
--- orig/source/text.h	2010-04-03 21:55:10.000000000 +0200
+++ mod/source/text.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: text.h 4211 2010-04-03 19:59:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/timidity/common.cpp mod/source/timidity/common.cpp
--- orig/source/timidity/common.cpp	2010-05-30 23:46:44.000000000 +0200
+++ mod/source/timidity/common.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -29,7 +29,6 @@
 
 namespace LibTimidity
 {
-
 char				current_filename[1024];
 
 /* The paths in this list will be tried whenever we're reading a file */
@@ -63,17 +62,19 @@
 		return 0;
 	}
 #endif
-
 	PathList* plp = pathlist;
+
 	if (name[0] != PATH_SEP)
 	{
 		while (plp)  /* Try along the path then */
 		{
 			*current_filename = 0;
 			int l = strlen(plp->path);
+
 			if (l)
 			{
 				strcpy(current_filename, plp->path);
+
 				if (current_filename[l - 1] != PATH_SEP)
 				{
 					strcat(current_filename, PATH_STRING);
@@ -82,6 +83,7 @@
 			strcat(current_filename, name);
 			ctl->cmsg(CMSG_INFO, VERB_DEBUG, "Trying to open %s", current_filename);
 			fp = fopen(current_filename, "rb");
+
 			if (fp)
 			{
 				return fp;
@@ -124,12 +126,17 @@
 void* safe_malloc(size_t count)
 {
 	void* p;
+
 	if ((p = malloc(count)))
+	{
 		return p;
+	}
 	else
+	{
 		ctl->cmsg(CMSG_FATAL, VERB_NORMAL, "Sorry. Couldn't malloc %d bytes.", count);
-
+	}
 	exit(10);
+
 	return NULL;
 }
 
@@ -146,6 +153,7 @@
 void free_pathlist()
 {
 	PathList* plp = pathlist;
+
 	while (plp)
 	{
 		if (plp->path)
diff -Nur orig/source/timidity/dls1.h mod/source/timidity/dls1.h
--- orig/source/timidity/dls1.h	2010-03-12 18:21:52.000000000 +0100
+++ mod/source/timidity/dls1.h	2022-08-12 08:34:35.000000000 +0200
@@ -129,20 +129,23 @@
 #define CONN_TRN_NONE              0x0000
 #define CONN_TRN_CONCAVE           0x0001
 
-typedef struct _DLSID {
+typedef struct _DLSID
+{
   ULONG    ulData1;
   USHORT   usData2;
   USHORT   usData3;
   BYTE     abData4[8];
 } DLSID, FAR *LPDLSID;
 
-typedef struct _DLSVERSION {
+typedef struct _DLSVERSION
+{
   DWORD    dwVersionMS;
   DWORD    dwVersionLS;
 } DLSVERSION, FAR *LPDLSVERSION;
                    
 
-typedef struct _CONNECTION {
+typedef struct _CONNECTION
+{
   USHORT   usSource;
   USHORT   usControl;
   USHORT   usDestination;
@@ -153,7 +156,8 @@
 
 /* Level 1 Articulation Data */
 
-typedef struct _CONNECTIONLIST {
+typedef struct _CONNECTIONLIST
+{
   ULONG    cbSize;            /* size of the connection list structure */
   ULONG    cConnections;      /* count of connections in the list */
 } CONNECTIONLIST, FAR *LPCONNECTIONLIST;
@@ -164,14 +168,16 @@
 // Generic type defines for regions and instruments
 /////////////////////////////////////////////////////////////////////////*/
 
-typedef struct _RGNRANGE {
+typedef struct _RGNRANGE
+{
   USHORT usLow;
   USHORT usHigh;
 } RGNRANGE, FAR * LPRGNRANGE;
 
 #define F_INSTRUMENT_DRUMS      0x80000000
 
-typedef struct _MIDILOCALE {
+typedef struct _MIDILOCALE
+{
   ULONG ulBank;
   ULONG ulInstrument;
 } MIDILOCALE, FAR *LPMIDILOCALE;
@@ -183,7 +189,8 @@
 
 #define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001
 
-typedef struct _RGNHEADER {
+typedef struct _RGNHEADER
+{
   RGNRANGE RangeKey;            /* Key range  */
   RGNRANGE RangeVelocity;       /* Velocity Range  */
   USHORT   fusOptions;          /* Synthesis options for this range */
@@ -192,12 +199,14 @@
                                 /* for Level 1 only groups 1-15 are allowed */
 } RGNHEADER, FAR *LPRGNHEADER;
 
-typedef struct _INSTHEADER {
+typedef struct _INSTHEADER
+{
   ULONG      cRegions;          /* Count of regions in this instrument */
   MIDILOCALE Locale;            /* Intended MIDI locale of this instrument */
 } INSTHEADER, FAR *LPINSTHEADER;
 
-typedef struct _DLSHEADER {
+typedef struct _DLSHEADER
+{
   ULONG      cInstruments;      /* Count of instruments in the collection */
 } DLSHEADER, FAR *LPDLSHEADER;
 
@@ -214,7 +223,8 @@
 
 #define F_WAVELINK_PHASE_MASTER  0x0001
 
-typedef struct _WAVELINK { /* any paths or links are stored right after struct */
+typedef struct _WAVELINK
+{ /* any paths or links are stored right after struct */
   USHORT   fusOptions;     /* options flags for this wave */
   USHORT   usPhaseGroup;   /* Phase grouping for locking channels */
   ULONG    ulChannel;      /* channel placement */
@@ -223,11 +233,13 @@
 
 #define POOL_CUE_NULL  0xffffffffl
 
-typedef struct _POOLCUE { 
+typedef struct _POOLCUE
+{ 
   ULONG    ulOffset;       /* Offset to the entry in the list */
 } POOLCUE, FAR *LPPOOLCUE;
 
-typedef struct _POOLTABLE {
+typedef struct _POOLTABLE
+{
   ULONG    cbSize;            /* size of the pool table structure */
   ULONG    cCues;             /* count of cues in the list */
 } POOLTABLE, FAR *LPPOOLTABLE;
@@ -240,7 +252,8 @@
 #define F_WSMP_NO_COMPRESSION    0x0002l
 
 
-typedef struct _rwsmp {
+typedef struct _rwsmp
+{
   ULONG   cbSize;
   USHORT  usUnityNote;         /* MIDI Unity Playback Note */
   SHORT   sFineTune;           /* Fine Tune in log tuning */
@@ -256,7 +269,8 @@
 
 #define WLOOP_TYPE_FORWARD   0
 
-typedef struct _rloop {
+typedef struct _rloop
+{
   ULONG cbSize;
   ULONG ulType;              /* Loop Type */
   ULONG ulStart;             /* Start of loop in samples */
diff -Nur orig/source/timidity/gf1.h mod/source/timidity/gf1.h
--- orig/source/timidity/gf1.h	2010-03-25 22:17:41.000000000 +0100
+++ mod/source/timidity/gf1.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: gf1.h 4190 2010-03-25 21:22:03Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/source/timidity/instrum.cpp mod/source/timidity/instrum.cpp
--- orig/source/timidity/instrum.cpp	2010-09-01 20:26:04.000000000 +0200
+++ mod/source/timidity/instrum.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -30,7 +30,6 @@
 
 namespace LibTimidity
 {
-
 #include "gf1.h"
 
 #ifdef FAST_DECAY
@@ -39,7 +38,6 @@
 int fast_decay=0;
 #endif
 
-
 static void free_instrument(Instrument* ip)
 {
 	if (!ip)
@@ -50,6 +48,7 @@
 	for (int i = 0; i < ip->samples; i++)
 	{
 		Sample* sp = &(ip->sample[i]);
+
 		if (sp->data)
 		{
 			free(sp->data);
@@ -65,6 +64,7 @@
 static void free_bank(MidiSong* song, int dr, int b)
 {
 	ToneBank* bank = ((dr) ? song->drumset[b] : song->tonebank[b]);
+
 	for (int i = 0; i < 128; i++)
 	{
 		if (bank->instrument[i])
@@ -76,6 +76,7 @@
 				bank->instrument[i] = NULL;
 			}
 		}
+
 		if (bank->tone[i].name)
 		{
 			free(bank->tone[i].name);
@@ -85,14 +86,14 @@
 }
 
 
-static int32 convert_envelope_rate(uint8 rate)
+static int32 convert_envelope_rate(MidiSong* song, uint8 rate)
 {
 	int32 r = 3 - ((rate >> 6) & 0x3);
 	r *= 3;
 	r = (int32)(rate & 0x3f) << r; /* 6.9 fixed point */
 
 	/* 15.15 fixed point. */
-	return ((r * 44100) / CONTROLS_PER_SECOND) << ((fast_decay) ? 10 : 9);
+	return ((r * 44100) / song->control_ratio) << ((fast_decay) ? 10 : 9);
 }
 
 static int32 convert_envelope_offset(uint8 offset)
@@ -104,13 +105,14 @@
 	return offset << (7 + 15);
 }
 
-static int32 convert_tremolo_sweep(uint8 sweep)
+static int32 convert_tremolo_sweep(MidiSong* song, uint8 sweep)
 {
 	if (!sweep)
 	{
 		return 0;
 	}
-	return (SWEEP_TUNING << SWEEP_SHIFT) / (CONTROLS_PER_SECOND * sweep);
+
+	return (SWEEP_TUNING << SWEEP_SHIFT) / (song->control_ratio * sweep);
 }
 
 static int32 convert_vibrato_sweep(uint8 sweep, int32 vib_control_ratio)
@@ -119,6 +121,7 @@
 	{
 		return 0;
 	}
+
 	return (int32) (FSCALE((double) (vib_control_ratio) * SWEEP_TUNING, SWEEP_SHIFT) /
 		(double)(OUTPUT_RATE * sweep));
 
@@ -128,10 +131,10 @@
 	(play_mode->rate * sweep); */
 }
 
-static int32 convert_tremolo_rate(uint8 rate)
+static int32 convert_tremolo_rate(MidiSong* song, uint8 rate)
 {
 	return ((SINE_CYCLE_LENGTH * rate) << RATE_SHIFT) /
-		(TREMOLO_RATE_TUNING * CONTROLS_PER_SECOND);
+		(TREMOLO_RATE_TUNING * song->control_ratio);
 }
 
 static int32 convert_vibrato_rate(uint8 rate)
@@ -147,6 +150,7 @@
 	sp += ls;
 	le -= ls;
 	le /= 2;
+
 	while (le--)
 	{
 		int16 s = *sp;
@@ -165,7 +169,7 @@
    undefined.
 
    TODO: do reverse loops right */
-static Instrument* load_instrument(const char *name, int percussion,
+static Instrument* load_instrument(MidiSong* song, const char *name, int percussion,
 	int panning, int amp, int note_to_use,
 	int strip_loop, int strip_envelope,
 	int strip_tail)
@@ -175,12 +179,15 @@
 	int i,j,noluck=0;
 
 	if (!name)
+	{
 		return 0;
+	}
 
 	/* Open patch file */
 	if ((fp=open_file(name, 1, OF_NORMAL)) == NULL)
 	{
 		noluck = 1;
+
 		if (strlen(name) + strlen(".pat") < 1024)
 		{
 			char path[1024];
@@ -259,7 +266,6 @@
 			free_instrument(ip);
 			return 0;
 		}
-
 		Sample* sp = &ip->sample[i];
 
 		sp->data_length = LE_LONG(SmplHdr.DataLength);
@@ -274,7 +280,7 @@
 
 		if (panning == -1)
 		{
-			sp->panning = (SmplHdr.Panning * 8 + 4) & 0x7f;
+			sp->panning = (SmplHdr.Panning * 8 + 4) & 0x7F;
 		}
 		else
 		{
@@ -290,9 +296,9 @@
 		else
 		{
 			sp->tremolo_sweep_increment =
-				convert_tremolo_sweep(SmplHdr.TremoloSweep);
+				convert_tremolo_sweep(song, SmplHdr.TremoloSweep);
 			sp->tremolo_phase_increment =
-				convert_tremolo_rate(SmplHdr.TremoloRate);
+				convert_tremolo_rate(song, SmplHdr.TremoloRate);
 			sp->tremolo_depth = SmplHdr.TremoloDepth;
 			ctl->cmsg(CMSG_INFO, VERB_DEBUG,
 				" * tremolo: sweep %d, phase %d, depth %d",
@@ -319,14 +325,17 @@
 				sp->vibrato_sweep_increment, sp->vibrato_control_ratio,
 				sp->vibrato_depth);
 		}
-
 		sp->modes = SmplHdr.Modes;
 
 		/* Mark this as a fixed-pitch instrument if such a deed is desired. */
 		if (note_to_use != -1)
+		{
 			sp->note_to_use = (uint8)(note_to_use);
+		}
 		else
+		{
 			sp->note_to_use = 0;
+		}
 
 		/* seashore.pat in the Midia patch set has no Sustain. I don't
 			understand why, and fixing it by adding the Sustain flag to
@@ -334,7 +343,9 @@
 			anyway. */
 
 		if (sp->modes & MODES_LOOPING) 
+		{
 			sp->modes |= MODES_SUSTAIN;
+		}
 
 		/* Strip any loops and envelopes we're permitted to */
 		if ((strip_loop==1) &&
@@ -387,25 +398,28 @@
 		for (j = 0; j < 6; j++)
 		{
 			sp->envelope_rate[j] =
-				convert_envelope_rate(SmplHdr.EnvelopeRate[j]);
+				convert_envelope_rate(song, SmplHdr.EnvelopeRate[j]);
 			sp->envelope_offset[j] =
 				convert_envelope_offset(SmplHdr.EnvelopeOffset[j]);
 		}
-
 		/* Then read the sample data */
 		sp->data = (sample_t*)safe_malloc(sp->data_length);
 
 		if (1 != fread(sp->data, sp->data_length, 1, fp))
+		{
 			goto fail;
+		}
 
 		if (!(sp->modes & MODES_16BIT)) /* convert to 16-bit data */
 		{
-			int32 i = sp->data_length;
+			int32 k = sp->data_length;
 			uint8 *cp = (uint8*)(sp->data);
 			uint16 *tmp,*newdta;
 			tmp = newdta = (uint16*)safe_malloc(sp->data_length * 2);
-			while (i--)
+			while (k--)
+			{
 				*tmp++ = (uint16)(*cp++) << 8;
+			}
 			cp = (uint8*)(sp->data);
 			sp->data = (sample_t*)newdta;
 			free(cp);
@@ -430,9 +444,9 @@
 
 		if (sp->modes & MODES_UNSIGNED) /* convert to signed data */
 		{
-			int32 i = sp->data_length / 2;
+			int32 k = sp->data_length / 2;
 			int16* tmp = (int16*)sp->data;
-			while (i--)
+			while (k--)
 				*tmp++ ^= 0x8000;
 		}
 
@@ -440,9 +454,9 @@
 		if (sp->modes & MODES_REVERSE)
 		{
 			int32 t;
+
 			/* The GUS apparently plays reverse loops by reversing the
 				whole sample. We do the same because the GUS does not SUCK. */
-
 			ctl->cmsg(CMSG_WARNING, VERB_NORMAL, "Reverse loop in %s", name);
 			reverse_data((int16*)sp->data, 0, sp->data_length / 2);
 
@@ -455,23 +469,30 @@
 		}
 
 		if (amp != -1)
+		{
 			sp->volume = (float)((amp) / 100.0);
+		}
 		else
 		{
 #ifdef ADJUST_SAMPLE_VOLUMES
 			/* Try to determine a volume scaling factor for the sample.
 				This is a very crude adjustment, but things sound more
 				balanced with it. Still, this should be a runtime option. */
-			int32 i = sp->data_length / 2;
+			int32 k = sp->data_length / 2;
 			int16 maxamp = 0, a;
 			int16* tmp = (int16*)sp->data;
-			while (i--)
+
+			while (k--)
 			{
 				a = *tmp++;
 				if (a < 0)
+				{
 					a = -a;
+				}
 				if (a > maxamp)
+				{
 					maxamp = a;
+				}
 			}
 			sp->volume=(float)(32768.0 / maxamp);
 			ctl->cmsg(CMSG_INFO, VERB_DEBUG, " * volume comp: %f", sp->volume);
@@ -479,7 +500,6 @@
 			sp->volume = 1.0;
 #endif
 		}
-
 		sp->data_length /= 2; /* These are in bytes. Convert into samples. */
 
 		sp->loop_start /= 2;
@@ -500,7 +520,9 @@
 		/* If this instrument will always be played on the same note,
 		and it's not looped, we can resample it now. */
 		if (sp->note_to_use && !(sp->modes & MODES_LOOPING))
+		{
 			pre_resample(sp);
+		}
 
 		if (strip_tail == 1)
 		{
@@ -509,9 +531,8 @@
 			sp->data_length = sp->loop_end;
 		}
 	}
-
-
 	close_file(fp);
+
 	return ip;
 }
 
@@ -519,6 +540,7 @@
 {
 	int i, errors = 0;
 	ToneBank* bank = ((dr) ? song->drumset[b] : song->tonebank[b]);
+
 	if (!bank)
 	{
 		ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
@@ -531,21 +553,25 @@
 		if (bank->instrument[i] == MAGIC_LOAD_INSTRUMENT)
 		{
 			bank->instrument[i] = load_instrument_sf2(song, b, i, dr ? true : false);
+
 			if (bank->instrument[i])
 			{
 				continue;
 			}
 			bank->instrument[i] = load_instrument_dls(song, dr, b, i);
+
 			if (bank->instrument[i])
 			{
 				continue;
 			}
+
 			if (!(bank->tone[i].name))
 			{
 				ctl->cmsg(CMSG_WARNING, (b != 0) ? VERB_VERBOSE : VERB_NORMAL,
 					"No instrument mapped to %s %d, program %d%s",
 					(dr)? "drum set" : "tone bank", b, i, 
 					(b != 0) ? "" : " - this instrument will not be heard");
+
 				if (b != 0)
 				{
 					/* Mark the corresponding instrument in the default
@@ -553,19 +579,23 @@
 					if (!dr)
 					{
 						if (!(song->tonebank[0]->instrument[i]))
+						{
 							song->tonebank[0]->instrument[i] = MAGIC_LOAD_INSTRUMENT;
+						}
 					}
 					else
 					{
 						if (!(song->drumset[0]->instrument[i]))
+						{
 							song->drumset[0]->instrument[i] = MAGIC_LOAD_INSTRUMENT;
+						}
 					}
 				}
 				bank->instrument[i] = 0;
 				errors++;
 			}
 			else if (!(bank->instrument[i] =
-				load_instrument(bank->tone[i].name, 
+				load_instrument(song, bank->tone[i].name, 
 					(dr) ? 1 : 0,
 					bank->tone[i].pan,
 					bank->tone[i].amp,
@@ -588,41 +618,58 @@
 			}
 		}
 	}
+
 	return errors;
 }
 
 int load_missing_instruments(MidiSong* song)
 {
 	int i = 128, errors = 0;
+
 	while (i--)
 	{
 		if (song->tonebank[i])
+		{
 			errors += fill_bank(song, 0, i);
+		}
+
 		if (song->drumset[i])
+		{
 			errors += fill_bank(song, 1, i);
+		}
 	}
+
 	return errors;
 }
 
 void free_instruments(MidiSong* song)
 {
 	int i = 128;
+
 	while(i--)
 	{
 		if (song->tonebank[i])
+		{
 			free_bank(song, 0, i);
+		}
 		if (song->drumset[i])
+		{
 			free_bank(song, 1, i);
+		}
 	}
 }
 
 int set_default_instrument(MidiSong* song, const char* name)
 {
 	Instrument* ip;
-	if (!(ip = load_instrument(name, 0, -1, -1, -1, 0, 0, 0)))
+
+	if (!(ip = load_instrument(song, name, 0, -1, -1, -1, 0, 0, 0)))
+	{
 		return -1;
+	}
 	song->default_instrument = ip;
 	song->default_program = SPECIAL_PROGRAM;
+
 	return 0;
 }
 
diff -Nur orig/source/timidity/instrum_dls.cpp mod/source/timidity/instrum_dls.cpp
--- orig/source/timidity/instrum_dls.cpp	2010-04-21 15:15:39.000000000 +0200
+++ mod/source/timidity/instrum_dls.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -57,13 +57,15 @@
 
 static RIFF_Chunk *AllocRIFFChunk()
 {
-	RIFF_Chunk *chunk = (RIFF_Chunk *)malloc(sizeof(*chunk));
+	RIFF_Chunk *chunk = (RIFF_Chunk *)safe_malloc(sizeof(*chunk));
+
 	if (!chunk)
 	{
 		__Sound_SetError(ERR_OUT_OF_MEMORY);
 		return NULL;
 	}
 	memset(chunk, 0, sizeof(*chunk));
+
 	return chunk;
 }
 
@@ -73,6 +75,7 @@
 	{
 		FreeRIFFChunk(chunk->child);
 	}
+
 	if (chunk->next)
 	{
 		FreeRIFFChunk(chunk->next);
@@ -83,29 +86,39 @@
 
 static int ChunkHasSubType(uint32 magic)
 {
-	static uint32 chunk_list[] = {
+	static uint32 chunk_list[] =
+	{
 		RIFF, LIST
 	};
 	int i;
-	for ( i = 0; i < sizeof(chunk_list) / sizeof(chunk_list[0]); ++i ) {
-		if ( magic == chunk_list[i] ) {
+
+	for (i = 0; i < sizeof(chunk_list) / sizeof(chunk_list[0]); ++i)
+	{
+		if (magic == chunk_list[i])
+		{
 			return 1;
 		}
 	}
+
 	return 0;
 }
 
 static int ChunkHasSubChunks(uint32 magic)
 {
-	static uint32 chunk_list[] = {
+	static uint32 chunk_list[] =
+	{
 		RIFF, LIST
 	};
 	int i;
-	for ( i = 0; i < sizeof(chunk_list) / sizeof(chunk_list[0]); ++i ) {
-		if ( magic == chunk_list[i] ) {
+
+	for (i = 0; i < sizeof(chunk_list) / sizeof(chunk_list[0]); ++i)
+	{
+		if (magic == chunk_list[i])
+		{
 			return 1;
 		}
 	}
+
 	return 0;
 }
 
@@ -114,50 +127,53 @@
 	uint8 *subchunkData;
 	uint32 subchunkDataLen;
 
-	while ( left > 8 ) {
+	while (left > 8)
+	{
 		RIFF_Chunk *child = AllocRIFFChunk();
 		RIFF_Chunk *next, *prev = NULL;
-		for ( next = chunk->child; next; next = next->next ) {
+
+		for (next = chunk->child; next; next = next->next)
+		{
 			prev = next;
 		}
-		if ( prev ) {
+
+		if (prev)
+		{
 			prev->next = child;
-		} else {
+		}
+		else
+		{
 			chunk->child = child;
 		}
-			
-		child->magic = (data[0] <<  0) |
-						(data[1] <<  8) |
-						(data[2] << 16) |
-						(data[3] << 24);
+		child->magic = (data[0] <<  0) | (data[1] <<  8) |
+						(data[2] << 16) | (data[3] << 24);
 		data += 4;
 		left -= 4;
-		child->length = (data[0] <<  0) |
-						(data[1] <<  8) |
-						(data[2] << 16) |
-						(data[3] << 24);
+		child->length = (data[0] <<  0) | (data[1] <<  8) |
+						(data[2] << 16) | (data[3] << 24);
 		data += 4;
 		left -= 4;
 		child->data = data;
 
-		if ( child->length > left ) {
+		if (child->length > left)
+		{
 			child->length = left;
 		}
-
 		subchunkData = child->data;
 		subchunkDataLen = child->length;
-		if ( ChunkHasSubType(child->magic) && subchunkDataLen >= 4 ) {
-			child->subtype = (subchunkData[0] <<  0) |
-						(subchunkData[1] <<  8) |
-						(subchunkData[2] << 16) |
-						(subchunkData[3] << 24);
+
+		if (ChunkHasSubType(child->magic) && subchunkDataLen >= 4)
+		{
+			child->subtype = (subchunkData[0] <<  0) | (subchunkData[1] <<  8) |
+						(subchunkData[2] << 16) | (subchunkData[3] << 24);
 			subchunkData += 4;
 			subchunkDataLen -= 4;
 		}
-		if ( ChunkHasSubChunks(child->magic) ) {
+
+		if (ChunkHasSubChunks(child->magic))
+		{
 			LoadSubChunks(child, subchunkData, subchunkDataLen);
 		}
-
 		data += (child->length + 1) & ~1;
 		left -= (child->length + 1) & ~1;
 	}
@@ -177,35 +193,47 @@
 	fread(&chunk->length, 4, 1, src);
 	chunk->magic = LE_LONG(chunk->magic);
 	chunk->length = LE_LONG(chunk->length);
-	if ( chunk->magic != RIFF ) {
+
+	if (chunk->magic != RIFF)
+	{
 		__Sound_SetError("Not a RIFF file");
 		FreeRIFFChunk(chunk);
+
 		return NULL;
 	}
-	chunk->data = (uint8 *)malloc(chunk->length);
-	if ( chunk->data == NULL ) {
+	chunk->data = (uint8 *)safe_malloc(chunk->length);
+
+	if (chunk->data == NULL)
+	{
 		__Sound_SetError(ERR_OUT_OF_MEMORY);
 		FreeRIFFChunk(chunk);
+
 		return NULL;
 	}
-	if ( fread(chunk->data, chunk->length, 1, src) != 1 ) {
+
+	if (fread(chunk->data, chunk->length, 1, src) != 1)
+	{
 		__Sound_SetError(ERR_IO_ERROR);
 		FreeRIFF(chunk);
+
 		return NULL;
 	}
 	subchunkData = chunk->data;
 	subchunkDataLen = chunk->length;
-	if ( ChunkHasSubType(chunk->magic) && subchunkDataLen >= 4 ) {
-		chunk->subtype = (subchunkData[0] <<  0) |
-					(subchunkData[1] <<  8) |
-					(subchunkData[2] << 16) |
-					(subchunkData[3] << 24);
+
+	if (ChunkHasSubType(chunk->magic) && subchunkDataLen >= 4)
+	{
+		chunk->subtype = (subchunkData[0] <<  0) | (subchunkData[1] <<  8) |
+					(subchunkData[2] << 16) | (subchunkData[3] << 24);
 		subchunkData += 4;
 		subchunkDataLen -= 4;
 	}
-	if ( ChunkHasSubChunks(chunk->magic) ) {
+
+	if (ChunkHasSubChunks(chunk->magic))
+	{
 		LoadSubChunks(chunk, subchunkData, subchunkDataLen);
 	}
+
 	return chunk;
 }
 
@@ -327,7 +355,8 @@
 
 static void FreeRegions(DLS_Instrument *instrument)
 {
-	if ( instrument->regions ) {
+	if (instrument->regions)
+	{
 		free(instrument->regions);
 		instrument->regions = NULL;
 	}
@@ -336,18 +365,24 @@
 static void AllocRegions(DLS_Instrument *instrument)
 {
 	int datalen = (instrument->header->cRegions * sizeof(DLS_Region));
+
 	FreeRegions(instrument);
-	instrument->regions = (DLS_Region *)malloc(datalen);
-	if ( instrument->regions ) {
+	instrument->regions = (DLS_Region *)safe_malloc(datalen);
+
+	if (instrument->regions)
+	{
 		memset(instrument->regions, 0, datalen);
 	}
 }
 
 static void FreeInstruments(DLS_Data *data)
 {
-	if ( data->instruments ) {
+	if (data->instruments)
+	{
 		uint32 i;
-		for ( i = 0; i < data->cInstruments; ++i ) {
+
+		for (i = 0; i < data->cInstruments; ++i)
+		{
 			FreeRegions(&data->instruments[i]);
 		}
 		free(data->instruments);
@@ -358,16 +393,19 @@
 static void AllocInstruments(DLS_Data *data)
 {
 	int datalen = (data->cInstruments * sizeof(DLS_Instrument));
+
 	FreeInstruments(data);
-	data->instruments = (DLS_Instrument *)malloc(datalen);
-	if ( data->instruments ) {
+	data->instruments = (DLS_Instrument *)safe_malloc(datalen);
+	if (data->instruments)
+	{
 		memset(data->instruments, 0, datalen);
 	}
 }
 
 static void FreeWaveList(DLS_Data *data)
 {
-	if ( data->waveList ) {
+	if (data->waveList)
+	{
 		free(data->waveList);
 		data->waveList = NULL;
 	}
@@ -376,9 +414,11 @@
 static void AllocWaveList(DLS_Data *data)
 {
 	int datalen = (data->ptbl->cCues * sizeof(DLS_Wave));
+
 	FreeWaveList(data);
-	data->waveList = (DLS_Wave *)malloc(datalen);
-	if ( data->waveList ) {
+	data->waveList = (DLS_Wave *)safe_malloc(datalen);
+	if (data->waveList)
+	{
 		memset(data->waveList, 0, datalen);
 	}
 }
@@ -435,7 +475,9 @@
 	loop = (WLOOP *)((uint8 *)chunk->data + wsmp->cbSize);
 	*wsmp_ptr = wsmp;
 	*wsmp_loop_ptr = loop;
-	for ( i = 0; i < wsmp->cSampleLoops; ++i ) {
+
+	for (i = 0; i < wsmp->cSampleLoops; ++i)
+	{
 		loop->cbSize = LE_LONG(loop->cbSize);
 		loop->ulType = LE_LONG(loop->ulType);
 		loop->ulStart = LE_LONG(loop->ulStart);
@@ -454,7 +496,9 @@
 	artList = (CONNECTION *)((uint8 *)chunk->data + art->cbSize);
 	*art_ptr = art;
 	*artList_ptr = artList;
-	for ( i = 0; i < art->cConnections; ++i ) {
+
+	for (i = 0; i < art->cConnections; ++i)
+	{
 		artList->usSource = LE_SHORT(artList->usSource);
 		artList->usControl = LE_SHORT(artList->usControl);
 		artList->usDestination = LE_SHORT(artList->usDestination);
@@ -467,22 +511,30 @@
 static void Parse_lart(DLS_Data *data, RIFF_Chunk *chunk, CONNECTIONLIST **conn_ptr, CONNECTION **connList_ptr)
 {
 	/* FIXME: This only supports one set of connections */
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_ART1:
 			case FOURCC_ART2:
+			{
 				Parse_art(data, chunk, conn_ptr, connList_ptr);
 				return;
+			}
 		}
 	}
 }
 
 static void Parse_rgn(DLS_Data *data, RIFF_Chunk *chunk, DLS_Region *region)
 {
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_RGNH:
 				Parse_rgnh(data, chunk, region);
 				break;
@@ -503,12 +555,17 @@
 static void Parse_lrgn(DLS_Data *data, RIFF_Chunk *chunk, DLS_Instrument *instrument)
 {
 	uint32 region = 0;
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_RGN:
 			case FOURCC_RGN2:
-				if ( region < instrument->header->cRegions ) {
+				if (region < instrument->header->cRegions)
+				{
 					Parse_rgn(data, chunk, &instrument->regions[region++]);
 				}
 				break;
@@ -518,9 +575,12 @@
 
 static void Parse_INFO_INS(DLS_Data *data, RIFF_Chunk *chunk, DLS_Instrument *instrument)
 {
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_INAM: /* Name */
 				instrument->name = (const char*)chunk->data;
 				break;
@@ -530,9 +590,12 @@
 
 static void Parse_ins(DLS_Data *data, RIFF_Chunk *chunk, DLS_Instrument *instrument)
 {
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_INSH:
 				Parse_insh(data, chunk, instrument);
 				break;
@@ -553,11 +616,16 @@
 static void Parse_lins(DLS_Data *data, RIFF_Chunk *chunk)
 {
 	uint32 instrument = 0;
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_INS:
-				if ( instrument < data->cInstruments ) {
+				if (instrument < data->cInstruments)
+				{
 					Parse_ins(data, chunk, &data->instruments[instrument++]);
 				}
 				break;
@@ -573,7 +641,9 @@
 	ptbl->cCues = LE_LONG(ptbl->cCues);
 	data->ptbl = ptbl;
 	data->ptblList = (POOLCUE *)((uint8 *)chunk->data + ptbl->cbSize);
-	for ( i = 0; i < ptbl->cCues; ++i ) {
+
+	for (i = 0; i < ptbl->cCues; ++i)
+	{
 		data->ptblList[i].ulOffset = LE_LONG(data->ptblList[i].ulOffset);
 	}
 	AllocWaveList(data);
@@ -599,9 +669,12 @@
 
 static void Parse_wave(DLS_Data *data, RIFF_Chunk *chunk, DLS_Wave *wave)
 {
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_FMT:
 				Parse_fmt(data, chunk, wave);
 				break;
@@ -618,11 +691,16 @@
 static void Parse_wvpl(DLS_Data *data, RIFF_Chunk *chunk)
 {
 	uint32 wave = 0;
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_wave:
-				if ( wave < data->ptbl->cCues ) {
+				if (wave < data->ptbl->cCues)
+				{
 					Parse_wave(data, chunk, &data->waveList[wave++]);
 				}
 				break;
@@ -632,9 +710,12 @@
 
 static void Parse_INFO_DLS(DLS_Data *data, RIFF_Chunk *chunk)
 {
-	for ( chunk = chunk->child; chunk; chunk = chunk->next ) {
+	for (chunk = chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_IARL: /* Archival Location */
 				break;
 			case FOURCC_IART: /* Artist */
@@ -680,22 +761,28 @@
 DLS_Data *LoadDLS(FILE *src)
 {
 	RIFF_Chunk *chunk;
-	DLS_Data *data = (DLS_Data *)malloc(sizeof(*data));
-	if ( !data ) {
+	DLS_Data *data = (DLS_Data *)safe_malloc(sizeof(*data));
+
+	if (!data)
+	{
 		__Sound_SetError(ERR_OUT_OF_MEMORY);
 		return NULL;
 	}
 	memset(data, 0, sizeof(*data));
-
 	data->chunk = LoadRIFF(src);
-	if ( !data->chunk ) {
+
+	if (!data->chunk)
+	{
 		FreeDLS(data);
 		return NULL;
 	}
 
-	for ( chunk = data->chunk->child; chunk; chunk = chunk->next ) {
+	for (chunk = data->chunk->child; chunk; chunk = chunk->next)
+	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
-		switch(magic) {
+
+		switch(magic)
+		{
 			case FOURCC_COLH:
 				Parse_colh(data, chunk);
 				break;
@@ -713,12 +800,14 @@
 				break;
 		}
 	}
+
 	return data;
 }
 
 void FreeDLS(DLS_Data *data)
 {
-	if ( data->chunk ) {
+	if (data->chunk)
+	{
 		FreeRIFF(data->chunk);
 	}
 	FreeInstruments(data);
@@ -734,9 +823,11 @@
 DLS_Data *Timidity_LoadDLS(FILE *src)
 {
 	DLS_Data *patches = LoadDLS(src);
-	//  if (!patches) {
-	//    SNDDBG(("%s", SDL_GetError()));
-	//  }
+	//if (!patches)
+	//{
+	//	SNDDBG(("%s", SDL_GetError()));
+	//}
+
 	return patches;
 }
 
@@ -745,11 +836,20 @@
 	FreeDLS(patches);
 }
 
+static double RelativeGainToLinear(int centibels)
+{
+	// v = 10^(cb/(200*65536)) * V
+	return 100.0 * pow(10.0, (double)(centibels / 65536) / 200.0);
+}
+
 /* convert timecents to sec */
 static double to_msec(int timecent)
 {
-	if (timecent == 0x80000000 || timecent == 0)
+	if (timecent == 0x80000000)
+	{
 		return 0.0;
+	}
+
 	return 1000.0 * pow(2.0, (double)(timecent / 65536) / 1200.0);
 }
 
@@ -768,16 +868,22 @@
 /* calculate ramp rate in fractional unit;
 * diff = 8bit, time = msec
 */
-static int32 calc_rate(int diff, int sample_rate, double msec)
+static int32 calc_rate(MidiSong* song, int diff, int sample_rate, double msec)
 {
 	double rate;
 
 	if(msec < 6)
+	{
 		msec = 6;
+	}
+
 	if(diff == 0)
+	{
 		diff = 255;
+	}
 	diff <<= (7+15);
-	rate = ((double)diff / CONTROLS_PER_SECOND) * 1000.0 / msec;
+	rate = ((double)diff / OUTPUT_RATE) * song->control_ratio * 1000.0 / msec;
+
 	return (int32)rate;
 }
 
@@ -785,9 +891,11 @@
 {
 	ULONG i;
 	int value = 0;
+
 	for (i = 0; i < cConnections; ++i)
 	{
 		CONNECTION *conn = &artList[i];
+
 		if(conn->usDestination == destination)
 		{
 			// The formula for the destination is:
@@ -797,13 +905,33 @@
 			if (conn->usSource == CONN_SRC_NONE &&
 				conn->usControl == CONN_SRC_NONE &&
 				conn->usTransform == CONN_TRN_NONE)
+			{
+				if (destination == CONN_DST_EG1_ATTACKTIME)
+				{
+					if (conn->lScale > 78743200)
+					{
+						conn->lScale -= 78743200; // maximum velocity
+					}
+				}
+
+				if (destination == CONN_DST_EG1_SUSTAINLEVEL)
+				{
+					conn->lScale /= (1000*512);
+				}
+
+				if (destination == CONN_DST_PAN)
+				{
+					conn->lScale /= (65536000/128);
+				}
 				value += conn->lScale;
+			}
 		}
 	}
+
 	return value;
 }
 
-static void load_region_dls(DLS_Data *patches, Sample *sample, DLS_Instrument *ins, uint32 index)
+static void load_region_dls(MidiSong* song, DLS_Data *patches, Sample *sample, DLS_Instrument *ins, uint32 index)
 {
 	DLS_Region *rgn = &ins->regions[index];
 	DLS_Wave *wave = &patches->waveList[rgn->wlnk->ulTableIndex];
@@ -819,6 +947,7 @@
 	sample->data_length = wave->length / 2;
 	sample->data = (sample_t *)safe_malloc(wave->length);
 	memcpy(sample->data, wave->data, wave->length);
+
 	if (rgn->wsmp->cSampleLoops)
 	{
 		sample->modes |= (MODES_LOOPING|MODES_SUSTAIN);
@@ -830,7 +959,8 @@
 	if (sample->modes & MODES_SUSTAIN)
 	{
 		int value;
-		double attack, hold, decay, release; int sustain;
+		double attack, hold, decay, release;
+		int sustain;
 		CONNECTIONLIST *art = NULL;
 		CONNECTION *artList = NULL;
 
@@ -847,32 +977,75 @@
 
 		value = load_connection(art->cConnections, artList, CONN_DST_EG1_ATTACKTIME);
 		attack = to_msec(value);
+		if (attack < 0)
+		{
+			attack = 0;
+		}
+		if (attack >= 20)
+		{
+			attack = attack / 20;
+		}
+
 		value = load_connection(art->cConnections, artList, CONN_DST_EG1_HOLDTIME);
 		hold = to_msec(value);
+		if (hold >= 20)
+		{
+			hold = hold / 20;
+		}
+
 		value = load_connection(art->cConnections, artList, CONN_DST_EG1_DECAYTIME);
 		decay = to_msec(value);
+		if (decay >= 20)
+		{
+			decay = decay / 20;
+		}
+
 		value = load_connection(art->cConnections, artList, CONN_DST_EG1_RELEASETIME);
 		release = to_msec(value);
-		value = load_connection(art->cConnections, artList, CONN_DST_EG1_SUSTAINLEVEL);
+		if (release >= 20)
+		{
+			release = release / 20;
+		}
+
+		value = load_connection(art->cConnections, artList, CONN_DST_EG1_SUSTAINLEVEL) * 2;
 		sustain = (int)((1.0 - to_normalized_percent(value)) * 250.0);
-		value = load_connection(art->cConnections, artList, CONN_DST_PAN);
+		if (sustain < 0)
+		{
+			sustain = 0;
+		}
+		if (sustain > 255)
+		{
+			sustain = 250;
+		}
+
+		value = load_connection(art->cConnections, artList, CONN_DST_PAN) / 2;
 		sample->panning = (int)((0.5 + to_normalized_percent(value)) * 127.0);
+		if (sample->panning < 0)
+		{
+			sample->panning = 0;
+		}
+		if (sample->panning > 128)
+		{
+			sample->panning = 127;
+		}
 
-	/*
-	printf("%d, Rate=%d LV=%d HV=%d Low=%d Hi=%d Root=%d Pan=%d Attack=%f Hold=%f Sustain=%d Decay=%f Release=%f\n", index, sample->sample_rate, rgn->header->RangeVelocity.usLow, rgn->header->RangeVelocity.usHigh, sample->low_freq, sample->high_freq, sample->root_freq, sample->panning, attack, hold, sustain, decay, release);
-	*/
+		//ctl->cmsg(CMSG_INFO, VERB_NORMAL, 
+		//	"%d, Rate=%d LV=%d HV=%d Low=%d Hi=%d Root=%d Pan=%d Attack=%f Hold=%f Sustain=%d Decay=%f Release=%f\n", index, sample->sample_rate, rgn->header->RangeVelocity.usLow, rgn->header->RangeVelocity.usHigh, sample->low_freq, sample->high_freq, sample->root_freq, sample->panning, attack, hold, sustain, decay, release);
+		/*
+		printf("%d, Rate=%d LV=%d HV=%d Low=%d Hi=%d Root=%d Pan=%d Attack=%f Hold=%f Sustain=%d Decay=%f Release=%f\n", index, sample->sample_rate, rgn->header->RangeVelocity.usLow, rgn->header->RangeVelocity.usHigh, sample->low_freq, sample->high_freq, sample->root_freq, sample->panning, attack, hold, sustain, decay, release);
+		*/
 
 		sample->envelope_offset[ATTACK] = to_offset(255);
-		sample->envelope_rate[ATTACK] = calc_rate(255, sample->sample_rate, attack);
+		sample->envelope_rate[ATTACK] = calc_rate(song, 255, sample->sample_rate, attack);
 
 		sample->envelope_offset[HOLD] = to_offset(250);
-		sample->envelope_rate[HOLD] = calc_rate(5, sample->sample_rate, hold);
+		sample->envelope_rate[HOLD] = calc_rate(song, 5, sample->sample_rate, hold);
 
 		sample->envelope_offset[DECAY] = to_offset(sustain);
-		sample->envelope_rate[DECAY] = calc_rate(255 - sustain, sample->sample_rate, decay);
+		sample->envelope_rate[DECAY] = calc_rate(song, 255 - sustain, sample->sample_rate, decay);
 
 		sample->envelope_offset[RELEASE] = to_offset(0);
-		sample->envelope_rate[RELEASE] = calc_rate(5 + sustain, sample->sample_rate, release);
+		sample->envelope_rate[RELEASE] = calc_rate(song, 5 + sustain, sample->sample_rate, release);
 
 		sample->envelope_offset[RELEASEB] = to_offset(0);
 		sample->envelope_rate[RELEASEB] = to_offset(1);
@@ -895,42 +1068,52 @@
 	DLS_Instrument *dls_ins;
 
 	if (!song->patches)
+	{
 		return(NULL);
+	}
 
 	if (!drum)
 	{
 		for (i = 0; i < song->patches->cInstruments; ++i)
 		{
 			dls_ins = &song->patches->instruments[i];
+
 			if (!(dls_ins->header->Locale.ulBank & 0x80000000) &&
 				((dls_ins->header->Locale.ulBank >> 8) & 0xFF) == bank &&
 				dls_ins->header->Locale.ulInstrument == instrument)
+			{
 				break;
+			}
 		}
+
 		if (i == song->patches->cInstruments && !bank)
 		{
 			for (i = 0; i < song->patches->cInstruments; ++i)
 			{
 				dls_ins = &song->patches->instruments[i];
+
 				if (!(dls_ins->header->Locale.ulBank & 0x80000000) &&
 					dls_ins->header->Locale.ulInstrument == instrument)
+				{
 					break;
+				}
 			}
 		}
+
 		if (i == song->patches->cInstruments)
 		{
 			ctl->cmsg(CMSG_ERROR, VERB_NORMAL, "Couldn't find melodic instrument %d in bank %d\n", instrument, bank);
 			return(NULL);
 		}
-
 		inst = (Instrument *)safe_malloc(sizeof(*inst));
 		inst->type = INST_DLS;
 		inst->samples = dls_ins->header->cRegions;
 		inst->sample = (Sample *)safe_malloc(inst->samples * sizeof(*inst->sample));
 		memset(inst->sample, 0, inst->samples * sizeof(*inst->sample));
+
 		for (i = 0; i < dls_ins->header->cRegions; ++i)
 		{
-			load_region_dls(song->patches, &inst->sample[i], dls_ins, i);
+			load_region_dls(song, song->patches, &inst->sample[i], dls_ins, i);
 		}
 	}
 	else
@@ -938,27 +1121,35 @@
 		for (i = 0; i < song->patches->cInstruments; ++i)
 		{
 			dls_ins = &song->patches->instruments[i];
+
 			if ((dls_ins->header->Locale.ulBank & 0x80000000) &&
 				dls_ins->header->Locale.ulInstrument == bank)
+			{
 				break;
+			}
 		}
+
 		if (i == song->patches->cInstruments && !bank)
 		{
 			for (i = 0; i < song->patches->cInstruments; ++i)
 			{
 				dls_ins = &song->patches->instruments[i];
+
 				if ((dls_ins->header->Locale.ulBank & 0x80000000) &&
 					dls_ins->header->Locale.ulInstrument == 0)
+				{
 					break;
+				}
 			}
 		}
+
 		if (i == song->patches->cInstruments)
 		{
 			ctl->cmsg(CMSG_ERROR, VERB_NORMAL, "Couldn't find drum instrument %d\n", bank);
 			return(NULL);
 		}
-
 		int drum_reg = -1;
+
 		for (i = 0; i < dls_ins->header->cRegions; i++)
 		{
 			if (dls_ins->regions[i].header->RangeKey.usLow == instrument)
@@ -967,6 +1158,7 @@
 				break;
 			}
 		}
+
 		if (drum_reg == -1)
 		{
 			ctl->cmsg(CMSG_ERROR, VERB_NORMAL, "Couldn't find drum note %d\n", instrument);
@@ -978,7 +1170,7 @@
 		inst->samples = 1;
 		inst->sample = (Sample *)safe_malloc(inst->samples * sizeof(*inst->sample));
 		memset(inst->sample, 0, inst->samples * sizeof(*inst->sample));
-		load_region_dls(song->patches, &inst->sample[0], dls_ins, drum_reg);
+		load_region_dls(song, song->patches, &inst->sample[0], dls_ins, drum_reg);
 	}
 
 	return inst;
diff -Nur orig/source/timidity/instrum_sf2.cpp mod/source/timidity/instrum_sf2.cpp
--- orig/source/timidity/instrum_sf2.cpp	2010-04-21 15:15:39.000000000 +0200
+++ mod/source/timidity/instrum_sf2.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: instrum_sf2.cpp 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
@@ -172,6 +172,7 @@
 	{
 		FreeRIFF(font->Riff);
 	}
+
 	free(font);
 	font = NULL;
 }
@@ -206,11 +207,12 @@
 	for (RIFF_Chunk* chunk = list->child; chunk; chunk = chunk->next)
 	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
+
 		switch(magic)
 		{
-		case FOURCC_ifil:
-			ReadIfil(font, chunk);
-			break;
+			case FOURCC_ifil:
+				ReadIfil(font, chunk);
+				break;
 		}
 	}
 }
@@ -228,12 +230,12 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 2
 	if (chunk->length % 2)
 	{
 		throw ErrBadFile();
 	}
-
 	font->SampleData = (int16*)chunk->data;
 	font->SampleDataSize = chunk->length;
 }
@@ -249,11 +251,12 @@
 	for (RIFF_Chunk* chunk = list->child; chunk; chunk = chunk->next)
 	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
+
 		switch(magic)
 		{
-		case FOURCC_smpl:
-			ReadSmpl(font, chunk);
-			break;
+			case FOURCC_smpl:
+				ReadSmpl(font, chunk);
+				break;
 		}
 	}
 }
@@ -271,20 +274,22 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 38
 	if (chunk->length % 38)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least 1 record and a terminal record
 	if (chunk->length < 2 * 38)
 	{
 		throw ErrBadFile();
 	}
-
 	font->PresetHeaders = (SFPresetHeader*)chunk->data;
 	font->NumPresetHeaders = chunk->length / sizeof(SFPresetHeader);
 	int LastBagIndex = 0;
+
 	for (int i = 0; i < font->NumPresetHeaders; i++)
 	{
 		SFPresetHeader* Hdr = &font->PresetHeaders[i];
@@ -317,21 +322,23 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 4
 	if (chunk->length % 4)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least 1 record and a terminal record
 	if (chunk->length < 2 * 4)
 	{
 		throw ErrBadFile();
 	}
-
 	font->PresetBags = (SFBag*)chunk->data;
 	font->NumPresetBags = chunk->length / sizeof(SFBag);
 	int LastGenIndex = 0;
 	int LastModIndex = 0;
+
 	for (int i = 0; i < font->NumPresetBags; i++)
 	{
 		SFBag* Bag = &font->PresetBags[i];
@@ -361,19 +368,21 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 10
 	if (chunk->length % 10)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least a terminal record
 	if (chunk->length < 10)
 	{
 		throw ErrBadFile();
 	}
-
 	font->PresetModulators = (SFMod*)chunk->data;
 	font->NumPresetModulators = chunk->length / sizeof(SFMod);
+
 	for (int i = 0; i < font->NumPresetModulators; i++)
 	{
 		SFMod* Mod = &font->PresetModulators[i];
@@ -398,29 +407,36 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 4
 	if (chunk->length % 4)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least 1 record and a terminal record
 	if (chunk->length < 2 * 4)
 	{
 		throw ErrBadFile();
 	}
-
 	font->PresetGenerators = (SFGen*)chunk->data;
 	font->NumPresetGenerators = chunk->length / sizeof(SFGen);
+
 	for (int i = 0; i < font->NumPresetGenerators; i++)
 	{
 		SFGen* Gen = &font->PresetGenerators[i];
 		Gen->Oper = LE_SHORT(Gen->Oper);
+
 		if (Gen->Oper != SFGEN_KeyRange && Gen->Oper != SFGEN_VelRange)
+		{
 			Gen->Amount = LE_SHORT(Gen->Amount);
+		}
 
 		//  Map invalid operator values to an unused generator.
 		if (Gen->Oper >= SFGEN_EndOper)
+		{
 			Gen->Oper = SFGEN_Reserved1;
+		}
 	}
 }
 
@@ -437,20 +453,22 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 22
 	if (chunk->length % 22)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least 1 record and a terminal record
 	if (chunk->length < 2 * 22)
 	{
 		throw ErrBadFile();
 	}
-
 	font->InstrumentHeaders = (SFInst*)chunk->data;
 	font->NumInstrumentHeaders = chunk->length / sizeof(SFInst);
 	int LastBagIndex = 0;
+
 	for (int i = 0; i < font->NumInstrumentHeaders; i++)
 	{
 		SFInst* Hdr = &font->InstrumentHeaders[i];
@@ -478,21 +496,23 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 4
 	if (chunk->length % 4)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least 1 record and a terminal record
 	if (chunk->length < 2 * 4)
 	{
 		throw ErrBadFile();
 	}
-
 	font->InstrumentBags = (SFBag*)chunk->data;
 	font->NumInstrumentBags = chunk->length / sizeof(SFBag);
 	int LastGenIndex = 0;
 	int LastModIndex = 0;
+
 	for (int i = 0; i < font->NumInstrumentBags; i++)
 	{
 		SFBag* Bag = &font->InstrumentBags[i];
@@ -522,19 +542,21 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 10
 	if (chunk->length % 10)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least a terminal record
 	if (chunk->length < 10)
 	{
 		throw ErrBadFile();
 	}
-
 	font->InstrumentModulators = (SFMod*)chunk->data;
 	font->NumInstrumentModulators = chunk->length / sizeof(SFMod);
+
 	for (int i = 0; i < font->NumInstrumentModulators; i++)
 	{
 		SFMod* Mod = &font->InstrumentModulators[i];
@@ -559,29 +581,36 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 4
 	if (chunk->length % 4)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least 1 record and a terminal record
 	if (chunk->length < 2 * 4)
 	{
 		throw ErrBadFile();
 	}
-
 	font->InstrumentGenerators = (SFGen*)chunk->data;
 	font->NumInstrumentGenerators = chunk->length / sizeof(SFGen);
+
 	for (int i = 0; i < font->NumInstrumentGenerators; i++)
 	{
 		SFGen* Gen = &font->InstrumentGenerators[i];
 		Gen->Oper = LE_SHORT(Gen->Oper);
+
 		if (Gen->Oper != SFGEN_KeyRange && Gen->Oper != SFGEN_VelRange)
+		{
 			Gen->Amount = LE_SHORT(Gen->Amount);
+		}
 
 		//  Map invalid operator values to an unused generator.
 		if (Gen->Oper >= SFGEN_EndOper)
+		{
 			Gen->Oper = SFGEN_Reserved1;
+		}
 	}
 }
 
@@ -598,19 +627,21 @@
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify length is a multiple of 46
 	if (chunk->length % 46)
 	{
 		throw ErrBadFile();
 	}
+
 	//  Verify that it contains at least 1 record and a terminal record
 	if (chunk->length < 2 * 46)
 	{
 		throw ErrBadFile();
 	}
-
 	font->SampleHeaders = (SFSample*)chunk->data;
 	font->NumSampleHeaders = chunk->length / sizeof(SFSample);
+
 	for (int i = 0; i < font->NumSampleHeaders; i++)
 	{
 		SFSample* Spl = &font->SampleHeaders[i];
@@ -635,35 +666,36 @@
 	for (RIFF_Chunk* chunk = list->child; chunk; chunk = chunk->next)
 	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
+
 		switch(magic)
 		{
-		case FOURCC_phdr:
-			ReadPhdr(font, chunk);
-			break;
-		case FOURCC_pbag:
-			ReadPbag(font, chunk);
-			break;
-		case FOURCC_pmod:
-			ReadPmod(font, chunk);
-			break;
-		case FOURCC_pgen:
-			ReadPgen(font, chunk);
-			break;
-		case FOURCC_inst:
-			ReadInst(font, chunk);
-			break;
-		case FOURCC_ibag:
-			ReadIbag(font, chunk);
-			break;
-		case FOURCC_imod:
-			ReadImod(font, chunk);
-			break;
-		case FOURCC_igen:
-			ReadIgen(font, chunk);
-			break;
-		case FOURCC_shdr:
-			ReadShdr(font, chunk);
-			break;
+			case FOURCC_phdr:
+				ReadPhdr(font, chunk);
+				break;
+			case FOURCC_pbag:
+				ReadPbag(font, chunk);
+				break;
+			case FOURCC_pmod:
+				ReadPmod(font, chunk);
+				break;
+			case FOURCC_pgen:
+				ReadPgen(font, chunk);
+				break;
+			case FOURCC_inst:
+				ReadInst(font, chunk);
+				break;
+			case FOURCC_ibag:
+				ReadIbag(font, chunk);
+				break;
+			case FOURCC_imod:
+				ReadImod(font, chunk);
+				break;
+			case FOURCC_igen:
+				ReadIgen(font, chunk);
+				break;
+			case FOURCC_shdr:
+				ReadShdr(font, chunk);
+				break;
 		}
 	}
 }
@@ -684,17 +716,18 @@
 	for (RIFF_Chunk* chunk = font->Riff->child; chunk; chunk = chunk->next)
 	{
 		uint32 magic = (chunk->magic == FOURCC_LIST) ? chunk->subtype : chunk->magic;
+
 		switch(magic)
 		{
-		case FOURCC_INFO:
-			ReadInfo(font, chunk);
-			break;
-		case FOURCC_sdta:
-			ReadSdta(font, chunk);
-			break;
-		case FOURCC_pdta:
-			ReadPdta(font, chunk);
-			break;
+			case FOURCC_INFO:
+				ReadInfo(font, chunk);
+				break;
+			case FOURCC_sdta:
+				ReadSdta(font, chunk);
+				break;
+			case FOURCC_pdta:
+				ReadPdta(font, chunk);
+				break;
 		}
 	}
 
@@ -756,23 +789,28 @@
 		int end = Spl->End;
 		int startloop = Spl->Startloop;
 		int endloop = Spl->Endloop;
+
 		if (startloop < start)
 		{
 			Spl->SampleType |= SFSAMPLE_Bad;
 		}
+
 		if (endloop < startloop)
 		{
 			Spl->SampleType |= SFSAMPLE_Bad;
 		}
+
 		if (end < endloop)
 		{
 			Spl->SampleType |= SFSAMPLE_Bad;
 		}
+
 		if (end > font->SampleDataSize / 2)
 		{
 			Spl->SampleType |= SFSAMPLE_Bad;
 		}
 	}
+
 	for (int i = 0; i < font->NumSampleHeaders - 1; i++)
 	{
 		for (int j = i + 1; j < font->NumSampleHeaders - 1; j++)
@@ -796,20 +834,22 @@
 Sf2Data* Timidity_LoadSF2(const char* FileName)
 {
 	FILE* f = open_file(FileName, 1, OF_NORMAL);
+
 	if (!f)
 	{
 		return NULL;
 	}
 	RIFF_Chunk* Riff = LoadRIFF(f);
 	close_file(f);
+
 	if (!Riff)
 	{
 		return NULL;
 	}
-
 	Sf2Data* font = (Sf2Data*)safe_malloc(sizeof(Sf2Data));
 	memset(font, 0, sizeof(Sf2Data));
 	font->Riff = Riff;
+
 	try
 	{
 		LoadSf2Data(font);
@@ -819,6 +859,7 @@
 		Timidity_FreeSf2(font);
 		return NULL;
 	}
+
 	return font;
 }
 
@@ -842,6 +883,7 @@
 			return i;
 		}
 	}
+
 	return -1;
 }
 
@@ -873,6 +915,7 @@
 	{
 		return 0.0;
 	}
+
 	return 1000.0 * pow(2.0, (double)(timecent) / 1200.0);
 }
 
@@ -898,7 +941,7 @@
 //
 //==========================================================================
 
-static int32 calc_rate(int diff, int sample_rate, double msec)
+static int32 calc_rate(MidiSong* song, int diff, int sample_rate, double msec)
 {
 	double rate;
 
@@ -906,12 +949,14 @@
 	{
 		msec = 6;
 	}
+
 	if (diff == 0)
 	{
 		diff = 255;
 	}
 	diff <<= (7+15);
-	rate = ((double)diff / CONTROLS_PER_SECOND) * 1000.0 / msec;
+	rate = ((double)diff / OUTPUT_RATE) * song->control_ratio * 1000.0 / msec;
+
 	return (int32)rate;
 }
 
@@ -925,10 +970,6 @@
 
 static double to_normalized_percent(int decipercent)
 {
-	if (decipercent < 0)
-	{
-		return 0;
-	}
 	return ((double)decipercent) / 1000.0;
 }
 
@@ -938,7 +979,7 @@
 //
 //==========================================================================
 
-static Instrument* LoadPreset(Sf2Data* font, int PresetIndex, bool Drum, int DrumNote)
+static Instrument* LoadPreset(MidiSong* song, Sf2Data* font, int PresetIndex, bool Drum, int DrumNote)
 {
 	if (font == NULL)
 	{
@@ -949,32 +990,37 @@
 	{
 		return NULL;
 	}
-
 	int PresetBagFrom = font->PresetHeaders[PresetIndex].BagNdx;
 	int PresetBagTo = font->PresetHeaders[PresetIndex + 1].BagNdx;
-
 	int NumSamples = 0;
+
 	for (int PBagIdx = PresetBagFrom; PBagIdx < PresetBagTo; PBagIdx++)
 	{
 		int PresetGenFrom = font->PresetBags[PBagIdx].GenNdx;
 		int PresetGenTo = font->PresetBags[PBagIdx + 1].GenNdx;
+
 		for (int PGenIdx = PresetGenFrom; PGenIdx < PresetGenTo; PGenIdx++)
 		{
 			SFGen* PresetGen = &(font->PresetGenerators[PGenIdx]);
+
 			if (PresetGen->Oper == SFGEN_Instrument)
 			{
 				int InstrBagFrom = font->InstrumentHeaders[PresetGen->Amount].BagNdx;
 				int InstrBagTo = font->InstrumentHeaders[PresetGen->Amount + 1].BagNdx;
+
 				for (int IBagIdx = InstrBagFrom; IBagIdx < InstrBagTo; IBagIdx++)
 				{
 					int InstrGenFrom = font->InstrumentBags[IBagIdx].GenNdx;
 					int InstrGenTo = font->InstrumentBags[IBagIdx + 1].GenNdx;
+
 					for (int IGenIdx = InstrGenFrom; IGenIdx < InstrGenTo; IGenIdx++)
 					{
 						SFGen* InstrGen = &font->InstrumentGenerators[IGenIdx];
+
 						if (InstrGen->Oper == SFGEN_SampleId)
 						{
 							SFSample* SampleHdr = &font->SampleHeaders[InstrGen->Amount];
+
 							if ((SampleHdr->SampleType & SFSAMPLE_Bad) ||
 								(SampleHdr->SampleType & SFSAMPLE_RomSample))
 							{
@@ -987,11 +1033,11 @@
 			}
 		}
 	}
+
 	if (Drum)
 	{
 		NumSamples = 1;
 	}
-
 	Instrument* ip = (Instrument*)safe_malloc(sizeof(Instrument));
 	ip->type = INST_SF2;
 	ip->samples = NumSamples;
@@ -1003,6 +1049,7 @@
 	bool IsDefaultPresetZone = true;
 
 	int SampleIdx = 0;
+
 	for (int PBagIdx = PresetBagFrom; PBagIdx < PresetBagTo; PBagIdx++)
 	{
 		int presKeyLo = 0;
@@ -1014,9 +1061,11 @@
 
 		int PresetGenFrom = font->PresetBags[PBagIdx].GenNdx;
 		int PresetGenTo = font->PresetBags[PBagIdx + 1].GenNdx;
+
 		for (int PGenIdx = PresetGenFrom; PGenIdx < PresetGenTo; PGenIdx++)
 		{
 			SFGen* PresetGen = &font->PresetGenerators[PGenIdx];
+
 			if (PresetGen->Oper == SFGEN_KeyRange)
 			{
 				presKeyLo = PresetGen->Range.Lo;
@@ -1030,6 +1079,7 @@
 			else if (PresetGen->Oper == SFGEN_Instrument)
 			{
 				int16 InstrDefaultGenData[SFGEN_EndOper];
+
 				for (int i = 0; i < SFGEN_EndOper; i++)
 				{
 					InstrDefaultGenData[i] = GenInfos[i].Default;
@@ -1038,6 +1088,7 @@
 
 				int InstrBagFrom = font->InstrumentHeaders[PresetGen->Amount].BagNdx;
 				int InstrBagTo = font->InstrumentHeaders[PresetGen->Amount + 1].BagNdx;
+
 				for (int IBagIdx = InstrBagFrom; IBagIdx < InstrBagTo; IBagIdx++)
 				{
 					int keyLo = 0;
@@ -1049,6 +1100,7 @@
 
 					int InstrGenFrom = font->InstrumentBags[IBagIdx].GenNdx;
 					int InstrGenTo = font->InstrumentBags[IBagIdx + 1].GenNdx;
+
 					for (int IGenIdx = InstrGenFrom; IGenIdx < InstrGenTo; IGenIdx++)
 					{
 						SFGen* InstrGen = &font->InstrumentGenerators[IGenIdx];
@@ -1069,6 +1121,7 @@
 						else if (InstrGen->Oper == SFGEN_SampleId)
 						{
 							SFSample* SampleHdr = &font->SampleHeaders[InstrGen->Amount];
+
 							if ((SampleHdr->SampleType & SFSAMPLE_Bad) ||
 								(SampleHdr->SampleType & SFSAMPLE_RomSample))
 							{
@@ -1092,6 +1145,7 @@
 								SampleHdr->Endloop;
 
 							int OrigKey;
+
 							if (InstrGenData[SFGEN_OverridingRootKey] >= 0 &&
 								InstrGenData[SFGEN_OverridingRootKey] < 128)
 							{
@@ -1105,7 +1159,6 @@
 							{
 								OrigKey = 60; 
 							}
-
 							AddGenerators(InstrGenData, PresetGenData);
 
 							Sample *sp = &ip->sample[SampleIdx++];
@@ -1136,6 +1189,7 @@
 							sp->data = (int16*)safe_malloc(sp->data_length * 2);
 							int16* Src = font->SampleData + Start;
 							int16* Dst = sp->data;
+
 							for (int i = 0; i < sp->data_length; i++)
 							{
 								*Dst = LE_SHORT(*Src);
@@ -1153,16 +1207,16 @@
 							int sustain = (int)((1.0 - to_normalized_percent(InstrGenData[SFGEN_SustainVolEnv])) * 250.0);
 
 							sp->envelope_offset[ATTACK] = to_offset(255);
-							sp->envelope_rate[ATTACK] = calc_rate(255, sp->sample_rate, attack);
+							sp->envelope_rate[ATTACK] = calc_rate(song, 255, sp->sample_rate, attack);
 
 							sp->envelope_offset[HOLD] = to_offset(250);
-							sp->envelope_rate[HOLD] = calc_rate(5, sp->sample_rate, hold);
+							sp->envelope_rate[HOLD] = calc_rate(song, 5, sp->sample_rate, hold);
 
 							sp->envelope_offset[DECAY] = to_offset(sustain);
-							sp->envelope_rate[DECAY] = calc_rate(255 - sustain, sp->sample_rate, decay);
+							sp->envelope_rate[DECAY] = calc_rate(song, 255 - sustain, sp->sample_rate, decay);
 
 							sp->envelope_offset[RELEASE] = to_offset(0);
-							sp->envelope_rate[RELEASE] = calc_rate(5 + sustain, sp->sample_rate, release);
+							sp->envelope_rate[RELEASE] = calc_rate(song, 5 + sustain, sp->sample_rate, release);
 
 							sp->envelope_offset[RELEASEB] = to_offset(0);
 							sp->envelope_rate[RELEASEB] = to_offset(1);
@@ -1174,7 +1228,6 @@
 							{
 								return ip;
 							}
-
 							IsDefaultInstrZone = false;
 						}
 						else
@@ -1219,8 +1272,8 @@
 	{ 
 		return NULL; 
 	}
-
 	int PresetIndex; 
+
 	if (Drum)
 	{
 		PresetIndex = FindPreset(song->sf2_font, 128, 0);
@@ -1233,11 +1286,13 @@
 			PresetIndex = FindPreset(song->sf2_font, 0, Instr);
 		}
 	}
+
 	if (PresetIndex < 0)
 	{
 		return NULL; 
 	}
-	return LoadPreset(song->sf2_font, PresetIndex, Drum, Instr);
+
+	return LoadPreset(song, song->sf2_font, PresetIndex, Drum, Instr);
 }
 
 }
diff -Nur orig/source/timidity/mix.cpp mod/source/timidity/mix.cpp
--- orig/source/timidity/mix.cpp	2010-03-20 16:14:28.000000000 +0100
+++ mod/source/timidity/mix.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -28,7 +28,6 @@
 
 namespace LibTimidity
 {
-
 /* Returns 1 if envelope runs out */
 int recompute_envelope(MidiSong* song, int v)
 {
@@ -56,27 +55,36 @@
 	song->voice[v].envelope_stage = stage + 1;
 
 	if (song->voice[v].envelope_volume == song->voice[v].sample->envelope_offset[stage])
+	{
 		return recompute_envelope(song, v);
+	}
 	song->voice[v].envelope_target = song->voice[v].sample->envelope_offset[stage];
 	song->voice[v].envelope_increment = song->voice[v].sample->envelope_rate[stage];
+
 	if (song->voice[v].envelope_target < song->voice[v].envelope_volume)
+	{
 		song->voice[v].envelope_increment = -song->voice[v].envelope_increment;
+	}
+
 	return 0;
 }
 
 void apply_envelope_to_amp(MidiSong* song, int v)
 {
-	float lamp = song->voice[v].left_amp, ramp;
-	int32 la, ra;
+	float lamp = song->voice[v].left_amp;
+	int32 la;
+
 	if (song->voice[v].panned == PANNED_MYSTERY)
 	{
-		ramp = song->voice[v].right_amp;
+		float ramp = song->voice[v].right_amp;
+
 		if (song->voice[v].tremolo_phase_increment)
 		{
 			float tv = song->voice[v].tremolo_volume;
 			lamp *= tv;
 			ramp *= tv;
 		}
+
 		if (song->voice[v].sample->modes & MODES_ENVELOPE)
 		{
 			float ev = (float)vol_table[song->voice[v].envelope_volume >> 23];
@@ -85,12 +93,16 @@
 		}
 
 		la = (int32)FSCALE(lamp,AMP_BITS);
-		ra = (int32)FSCALE(ramp,AMP_BITS);
+		int32 ra = (int32)FSCALE(ramp,AMP_BITS);
 
 		if (la > MAX_AMP_VALUE)
+		{
 			la = MAX_AMP_VALUE;
+		}
 		if (ra > MAX_AMP_VALUE)
+		{
 			ra = MAX_AMP_VALUE;
+		}
 
 		song->voice[v].left_mix = la;
 		song->voice[v].right_mix = ra;
@@ -98,15 +110,19 @@
 	else
 	{
 		if (song->voice[v].tremolo_phase_increment)
+		{
 			lamp *= song->voice[v].tremolo_volume;
+		}
 		if (song->voice[v].sample->modes & MODES_ENVELOPE)
+		{
 			lamp *= (float)vol_table[song->voice[v].envelope_volume >> 23];
-
+		}
 		la = (int32)FSCALE(lamp,AMP_BITS);
 
 		if (la > MAX_AMP_VALUE)
+		{
 			la = MAX_AMP_VALUE;
-
+		}
 		song->voice[v].left_mix = la;
 	}
 }
@@ -114,6 +130,7 @@
 static int update_envelope(MidiSong* song, int v)
 {
 	song->voice[v].envelope_volume += song->voice[v].envelope_increment;
+
 	/* Why is there no ^^ operator?? */
 	if (((song->voice[v].envelope_increment < 0) &&
 		(song->voice[v].envelope_volume <= song->voice[v].envelope_target)) ||
@@ -121,9 +138,13 @@
 		(song->voice[v].envelope_volume >= song->voice[v].envelope_target)))
 	{
 		song->voice[v].envelope_volume = song->voice[v].envelope_target;
+
 		if (recompute_envelope(song, v))
+		{
 			return 1;
+		}
 	}
+
 	return 0;
 }
 
@@ -134,10 +155,12 @@
 	if (song->voice[v].tremolo_sweep)
 	{
 		/* Update sweep position */
-
 		song->voice[v].tremolo_sweep_position += song->voice[v].tremolo_sweep;
+
 		if (song->voice[v].tremolo_sweep_position >= (1 << SWEEP_SHIFT))
+		{
 			song->voice[v].tremolo_sweep = 0; /* Swept to max amplitude */
+		}
 		else
 		{
 			/* Need to adjust depth */
@@ -145,11 +168,10 @@
 			depth >>= SWEEP_SHIFT;
 		}
 	}
-
 	song->voice[v].tremolo_phase += song->voice[v].tremolo_phase_increment;
 
 	song->voice[v].tremolo_volume =
-		(float)(1.0 - FSCALENEG((sine(song->voice[v].tremolo_phase >> RATE_SHIFT) + 1.0) *
+		(float)(1.0 - FSCALENEG((sine(song->voice[v].tremolo_phase >> RATE_SHIFT) /*+ 1.0*/) *
 		depth * TREMOLO_AMPLITUDE_TUNING, 17));
 
 	/* I'm not sure about the +1.0 there -- it makes tremoloed voices'
@@ -160,12 +182,16 @@
 static int update_signal(MidiSong* song, int v)
 {
 	if (song->voice[v].envelope_increment && update_envelope(song, v))
+	{
 		return 1;
+	}
 
 	if (song->voice[v].tremolo_phase_increment)
+	{
 		update_tremolo(song, v);
-
+	}
 	apply_envelope_to_amp(song, v);
+
 	return 0;
 }
 
@@ -181,17 +207,21 @@
 	if (!(cc = vp->control_counter))
 	{
 		cc = song->control_ratio;
+
 		if (update_signal(song, v))
+		{
 			return;	/* Envelope ran out */
-
+		}
 		left = vp->left_mix;
 		right = vp->right_mix;
 	}
 
 	while (count)
+	{
 		if (cc < count)
 		{
 			count -= cc;
+
 			while (cc--)
 			{
 				s = *sp++;
@@ -200,14 +230,18 @@
 				lp += 2;
 			}
 			cc = song->control_ratio;
+
 			if (update_signal(song, v))
+			{
 				return;	/* Envelope ran out */
+			}
 			left = vp->left_mix;
 			right = vp->right_mix;
 		}
 		else
 		{
 			vp->control_counter = cc - count;
+
 			while (count--)
 			{
 				s = *sp++;
@@ -215,8 +249,10 @@
 				lp[1] += right * s;
 				lp += 2;
 			}
+
 			return;
 		}
+	}
 }
 
 static void mix_centre_signal(MidiSong* song, sample_t* sp, int32* lp, int v, int count)
@@ -230,12 +266,16 @@
 	if (!(cc = vp->control_counter))
 	{
 		cc = song->control_ratio;
+
 		if (update_signal(song, v))
+		{
 			return;	/* Envelope ran out */
+		}
 		left = vp->left_mix;
 	}
 
 	while (count)
+	{
 		if (cc < count)
 		{
 			count -= cc;
@@ -248,12 +288,15 @@
 			}
 			cc = song->control_ratio;
 			if (update_signal(song, v))
+			{
 				return;	/* Envelope ran out */
+			}
 			left = vp->left_mix;
 		}
 		else
 		{
 			vp->control_counter = cc - count;
+
 			while (count--)
 			{
 				s = *sp++;
@@ -261,8 +304,10 @@
 				lp[1] += left * s;
 				lp += 2;
 			}
+
 			return;
 		}
+	}
 }
 
 static void mix_single_signal(MidiSong* song, sample_t* sp, int32* lp, int v, int count)
@@ -277,14 +322,18 @@
 	{
 		cc = song->control_ratio;
 		if (update_signal(song, v))
+		{
 			return;	/* Envelope ran out */
+		}
 		left = vp->left_mix;
 	}
 
 	while (count)
+	{
 		if (cc < count)
 		{
 			count -= cc;
+
 			while (cc--)
 			{
 				s = *sp++;
@@ -292,21 +341,27 @@
 				lp += 2;
 			}
 			cc = song->control_ratio;
+
 			if (update_signal(song, v))
+			{
 				return;	/* Envelope ran out */
+			}
 			left = vp->left_mix;
 		}
 		else
 		{
 			vp->control_counter = cc - count;
+
 			while (count--)
 			{
 				s = *sp++;
 				lp[0] += left * s;
 				lp += 2;
 			}
+
 			return;
 		}
+	}
 }
 
 static void mix_mystery(MidiSong* song, sample_t* sp, int32* lp, int v, int count)
@@ -357,7 +412,7 @@
 static void ramp_out(MidiSong* song, sample_t* sp, int32* lp, int v, int32 c)
 {
 	/* should be final_volume_t, but uint8 gives trouble. */
-	int32 left, right, li, ri;
+	int32 left, li;
 
 	sample_t s = 0; /* silly warning about uninitialised s */
 
@@ -366,9 +421,9 @@
 	{
 		c = 1;
 	}
-
 	left = song->voice[v].left_mix;
 	li = -(left/c);
+
 	if (!li)
 	{
 		li = -1;
@@ -376,16 +431,23 @@
 
 	if (song->voice[v].panned == PANNED_MYSTERY)
 	{
-		right=song->voice[v].right_mix;
-		ri = -(right / c);
+		int32 right=song->voice[v].right_mix;
+		int32 ri = -(right / c);
+
 		while (c--)
 		{
 			left += li;
+
 			if (left < 0)
+			{
 				left = 0;
+			}
 			right += ri;
+
 			if (right < 0)
+			{
 				right = 0;
+			}
 			s = *sp++;
 			lp[0] += left * s;
 			lp[1] += right * s;
@@ -397,8 +459,11 @@
 		while (c--)
 		{
 			left += li;
+
 			if (left < 0)
+			{
 				return;
+			}
 			s = *sp++;	
 			lp[0] += left * s;
 			lp[1] += left * s;
@@ -410,8 +475,11 @@
 		while (c--)
 		{
 			left += li;
+
 			if (left < 0)
+			{
 				return;
+			}
 			s = *sp++;
 			lp[0] += left * s;
 			lp += 2;
@@ -422,8 +490,11 @@
 		while (c--)
 		{
 			left += li;
+
 			if (left < 0)
+			{
 				return;
+			}
 			s = *sp++;
 			lp[1] += left * s;
 			lp += 2;
@@ -439,10 +510,13 @@
 	Voice* vp = song->voice + v;
 	int32 count = c;
 	sample_t* sp;
+
 	if (vp->status == VOICE_DIE)
 	{
 		if (count >= MAX_DIE_TIME)
+		{
 			count = MAX_DIE_TIME;
+		}
 		sp = resample_voice(song, v, &count);
 		ramp_out(song, sp, buf, v, count);
 		vp->status = VOICE_FREE;
@@ -453,35 +527,50 @@
 		if (vp->panned == PANNED_MYSTERY)
 		{
 			if (vp->envelope_increment || vp->tremolo_phase_increment)
+			{
 				mix_mystery_signal(song, sp, buf, v, count);
+			}
 			else
+			{
 				mix_mystery(song, sp, buf, v, count);
+			}
 		}
 		else if (vp->panned == PANNED_CENTRE)
 		{
 			if (vp->envelope_increment || vp->tremolo_phase_increment)
+			{
 				mix_centre_signal(song, sp, buf, v, count);
+			}
 			else
+			{
 				mix_centre(song, sp, buf, v, count);
+			}
 		}
 		else
 		{
 			/* It's either full left or full right. In either case,
 			every other sample is 0. Just get the offset right: */
-
 			if (vp->envelope_increment || vp->tremolo_phase_increment)
 			{
 				if (vp->panned == PANNED_RIGHT)
+				{
 					mix_single_signal(song, sp, buf + 1, v, count);
+				}
 				else
+				{
 					mix_single_signal(song, sp, buf, v, count);
+				}
 			}
 			else
 			{
 				if (vp->panned == PANNED_RIGHT)
+				{
 					mix_single(song, sp, buf + 1, v, count);
+				}
 				else
+				{
 					mix_single(song, sp, buf, v, count);
+				}
 			}
 		}
 	}
diff -Nur orig/source/timidity/playmidi.cpp mod/source/timidity/playmidi.cpp
--- orig/source/timidity/playmidi.cpp	2010-09-01 20:26:04.000000000 +0200
+++ mod/source/timidity/playmidi.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -37,7 +37,9 @@
 static void reset_voices(MidiSong* song)
 {
 	for (int i = 0; i < MAX_VOICES; i++)
+	{
 		song->voice[i].status = VOICE_FREE;
+	}
 }
 
 /* Process the Reset All Controllers event */
@@ -76,6 +78,7 @@
 	if (s == 1)
 	{
 		song->voice[v].sample = sp;
+
 		return;
 	}
 
@@ -86,6 +89,7 @@
 			sp->low_freq <= f && sp->high_freq >= f)
 		{
 			song->voice[v].sample=sp;
+
 			return;
 		}
 		sp++;
@@ -103,7 +107,9 @@
 	{
 		diff = sp->root_freq - f;
 		if (diff < 0)
+		{
 			diff = -diff;
+		}
 		if (diff < cdiff)
 		{
 			cdiff = diff;
@@ -112,6 +118,7 @@
 		sp++;
 	}
 	song->voice[v].sample = closest;
+
 	return;
 }
 
@@ -123,7 +130,9 @@
 	double a;
 
 	if (!song->voice[v].sample->sample_rate)
+	{
 		return;
+	}
 
 	if (song->voice[v].vibrato_control_ratio)
 	{
@@ -132,31 +141,44 @@
 	
 		int i = VIBRATO_SAMPLE_INCREMENTS;
 		while (i--)
+		{
 			song->voice[v].vibrato_sample_increment[i] = 0;
+		}
 	}
 
 	if (pb == 0x2000 || pb < 0 || pb > 0x3FFF)
+	{
 		song->voice[v].frequency = song->voice[v].orig_frequency;
+	}
 	else
 	{
 		pb -= 0x2000;
+
 		if (!(song->channel[song->voice[v].channel].pitchfactor))
 		{
 			/* Damn. Somebody bent the pitch. */
 			int32 i = pb * song->channel[song->voice[v].channel].pitchsens;
+
 			if (pb < 0)
+			{
 				i = -i;
+			}
 			song->channel[song->voice[v].channel].pitchfactor =
 				(float)(bend_fine[(i >> 5) & 0xFF] * bend_coarse[i >> 13]);
 		}
+
 		if (pb > 0)
+		{
 			song->voice[v].frequency =
 				(int32)(song->channel[song->voice[v].channel].pitchfactor *
 				(double)(song->voice[v].orig_frequency));
+		}
 		else
+		{
 			song->voice[v].frequency =
 				(int32)((double)(song->voice[v].orig_frequency) /
 				song->channel[song->voice[v].channel].pitchfactor);
+		}
 	}
 
 	a = FSCALE(((double)(song->voice[v].sample->sample_rate) *
@@ -165,9 +187,10 @@
 			(double)(OUTPUT_RATE)),
 			FRACTION_BITS);
 
-	if (sign) 
+	if (sign)
+	{
 		a = -a; /* need to preserve the loop direction */
-
+	}
 	song->voice[v].sample_increment = (int32)(a);
 }
 
@@ -203,8 +226,8 @@
 		song->channel[chan].expression); /* 21 bits */
 
 	/* TODO: use fscale */
-
 	float refv = float((double)(tempamp)) * song->voice[v].sample->volume * song->master_volume;
+
 	if (panning > 60 && panning < 68)
 	{
 		song->voice[v].panned=PANNED_CENTRE;
@@ -240,7 +263,9 @@
 		if (!(ip=song->drumset[song->channel[ch].bank]->instrument[this_note]))
 		{
 			if (!(ip=song->drumset[0]->instrument[this_note]))
+			{
 				return; /* No instrument? Then we can't play. */
+			}
 		}
 		if (ip->samples != 1)
 		{
@@ -249,29 +274,39 @@
 		}
 	
 		if (ip->sample->note_to_use) /* Do we have a fixed pitch? */
+		{
 			song->voice[i].orig_frequency=freq_table[(int)(ip->sample->note_to_use)];
+		}
 		else
+		{
 			song->voice[i].orig_frequency=freq_table[this_note & 0x7F];
-      
+		}      
 		/* drums are supposed to have only one sample */
 		song->voice[i].sample = ip->sample;
 	}
 	else
 	{
 		if (song->channel[ch].program == SPECIAL_PROGRAM)
+		{
 			ip = song->default_instrument;
+		}
 		else if (!(ip = song->tonebank[song->channel[ch].bank]->instrument[song->channel[ch].program]))
 		{
 			if (!(ip=song->tonebank[0]->instrument[song->channel[ch].program]))
+			{
 				return; /* No instrument? Then we can't play. */
+			}
 		}
 		if (ip->sample->note_to_use) /* Fixed-pitch instrument? */
+		{
 			song->voice[i].orig_frequency = freq_table[(int)(ip->sample->note_to_use)];
+		}
 		else
+		{
 			song->voice[i].orig_frequency = freq_table[this_note & 0x7F];
+		}
 		select_sample(song, i, ip, e->b);
 	}
-
 	song->voice[i].status = VOICE_ON;
 	song->voice[i].channel = ch;
 	song->voice[i].note = this_note;
@@ -288,18 +323,23 @@
 	song->voice[i].vibrato_sweep_position = 0;
 	song->voice[i].vibrato_control_ratio = song->voice[i].sample->vibrato_control_ratio;
 	song->voice[i].vibrato_control_counter = song->voice[i].vibrato_phase=0;
+
 	for (j = 0; j < VIBRATO_SAMPLE_INCREMENTS; j++)
 	{
 		song->voice[i].vibrato_sample_increment[j] = 0;
 	}
 
 	if (song->channel[ch].panning != NO_PANNING)
+	{
 		song->voice[i].panning = song->channel[ch].panning;
+	}
 	else
+	{
 		song->voice[i].panning = song->voice[i].sample->panning;
-
+	}
 	recompute_freq(song, i);
 	recompute_amp(song, i);
+
 	if (song->voice[i].sample->modes & MODES_ENVELOPE)
 	{
 		/* Ramp up from 0 */
@@ -331,16 +371,21 @@
 	while (i--)
 	{
 		if (song->voice[i].status == VOICE_FREE)
+		{
 			lowest=i; /* Can't get a lower volume than silence */
+		}
 		else if (song->voice[i].channel == e->channel && 
 				(song->voice[i].note == e->a || song->channel[song->voice[i].channel].mono))
+		{
 			kill_note(song, i);
+		}
 	}
 
 	if (lowest != -1)
 	{
 		/* Found a free voice. */
 		start_note(song, e, lowest);
+
 		return;
 	}
 
@@ -353,7 +398,10 @@
 		{
 			v = song->voice[i].left_mix;
 			if ((song->voice[i].panned == PANNED_MYSTERY) && (song->voice[i].right_mix > v))
+			{
 				v = song->voice[i].right_mix;
+			}
+
 			if (v < lv)
 			{
 				lv = v;
@@ -373,7 +421,9 @@
 		start_note(song, e,lowest);
 	}
 	else
+	{
 		song->lost_notes++;
+	}
 }
 
 static void finish_note(MidiSong* song, int i)
@@ -399,7 +449,9 @@
 {
 	const MidiEvent* e = song->current_event;
 	int i = song->voices;
+
 	while (i--)
+	{
 		if (song->voice[i].status == VOICE_ON &&
 			song->voice[i].channel == e->channel &&
 			song->voice[i].note == e->a)
@@ -409,9 +461,12 @@
 				song->voice[i].status = VOICE_SUSTAINED;
 			}
 			else
+			{
 				finish_note(song, i);
+			}
 			return;
 		}
+	}
 }
 
 /* Process the All Notes Off event */
@@ -420,7 +475,9 @@
 	int c = song->current_event->channel;
 	int i = song->voices;
 	ctl->cmsg(CMSG_INFO, VERB_DEBUG, "All notes off on channel %d", c);
+
 	while (i--)
+	{
 		if (song->voice[i].status == VOICE_ON &&
 			song->voice[i].channel == c)
 		{
@@ -429,8 +486,11 @@
 				song->voice[i].status = VOICE_SUSTAINED;
 			}
 			else
+			{
 				finish_note(song, i);
+			}
 		}
+	}
 }
 
 /* Process the All Sounds Off event */
@@ -439,19 +499,23 @@
 	int c = song->current_event->channel;
 	int i = song->voices;
 	while (i--)
+	{
 		if (song->voice[i].channel == c &&
 			song->voice[i].status != VOICE_FREE &&
 			song->voice[i].status != VOICE_DIE)
 		{
 			kill_note(song, i);
 		}
+	}
 }
 
 static void adjust_pressure(MidiSong* song)
 {
 	const MidiEvent* e = song->current_event;
 	int i = song->voices;
+
 	while (i--)
+	{
 		if (song->voice[i].status == VOICE_ON &&
 			song->voice[i].channel == e->channel &&
 			song->voice[i].note == e->a)
@@ -459,47 +523,61 @@
 			song->voice[i].velocity = e->b;
 			recompute_amp(song, i);
 			apply_envelope_to_amp(song, i);
+
 			return;
 		}
+	}
 }
 
 static void drop_sustain(MidiSong* song)
 {
 	int c = song->current_event->channel;
 	int i = song->voices;
+
 	while (i--)
+	{
 		if (song->voice[i].status == VOICE_SUSTAINED && song->voice[i].channel == c)
+		{
 			finish_note(song, i);
+		}
+	}
 }
 
 static void adjust_pitchbend(MidiSong* song)
 {
 	int c = song->current_event->channel;
 	int i = song->voices;
+
 	while (i--)
+	{
 		if (song->voice[i].status != VOICE_FREE && song->voice[i].channel == c)
 		{
 			recompute_freq(song, i);
 		}
+	}
 }
 
 static void adjust_volume(MidiSong* song)
 {
 	int c = song->current_event->channel;
 	int i = song->voices;
+
 	while (i--)
+	{
 		if (song->voice[i].channel == c &&
 			(song->voice[i].status == VOICE_ON || song->voice[i].status == VOICE_SUSTAINED))
 		{
 			recompute_amp(song, i);
 			apply_envelope_to_amp(song, i);
 		}
+	}
 }
 
 static void do_compute_data(MidiSong* song, int32 count)
 {
 	int i;
 	memset(song->common_buffer, 0, count * 8);
+
 	for (i = 0; i < song->voices; i++)
 	{
 		if (song->voice[i].status != VOICE_FREE)
@@ -515,13 +593,19 @@
 {
 	int16* sp = (int16*)(dp);
 	int32 l;
+
 	while (c--)
 	{
 		l = (*lp++) >> (32 - 16 - GUARD_BITS);
+
 		if (l > 32767)
+		{
 			l = 32767;
+		}
 		else if (l < -32768)
+		{
 			l = -32768;
+		}
 		*sp++ = (int16)(l);
 	}
 }
@@ -538,6 +622,7 @@
 		return 0;
 	}
 	end_sample = song->current_sample + samples;
+
 	while (song->current_sample < end_sample)
 	{
 		/* Handle all events that should happen at this time */
@@ -545,108 +630,122 @@
 		{
 			switch (song->current_event->type)
 			{
-			/* Effects affecting a single note */
-			case ME_NOTEON:
-				if (!(song->current_event->b)) /* Velocity 0? */
+				/* Effects affecting a single note */
+				case ME_NOTEON:
+					if (!(song->current_event->b)) /* Velocity 0? */
+					{
+						note_off(song);
+					}
+					else
+					{
+						note_on(song);
+					}
+					break;
+
+				case ME_NOTEOFF:
 					note_off(song);
-				else
-					note_on(song);
-				break;
-
-			case ME_NOTEOFF:
-				note_off(song);
-				break;
-
-			case ME_KEYPRESSURE:
-				adjust_pressure(song);
-				break;
-
-			/* Effects affecting a single channel */
-			case ME_PITCH_SENS:
-				song->channel[song->current_event->channel].pitchsens = song->current_event->a;
-				song->channel[song->current_event->channel].pitchfactor = 0;
-				break;
-
-			case ME_PITCHWHEEL:
-				song->channel[song->current_event->channel].pitchbend =
-					song->current_event->a + song->current_event->b * 128;
-				song->channel[song->current_event->channel].pitchfactor = 0;
-				/* Adjust pitch for notes already playing */
-				adjust_pitchbend(song);
-				break;
-
-			case ME_MAINVOLUME:
-				song->channel[song->current_event->channel].volume = song->current_event->a;
-				adjust_volume(song);
-				break;
-
-			case ME_PAN:
-				song->channel[song->current_event->channel].panning = song->current_event->a;
-				break;
-
-			case ME_EXPRESSION:
-				song->channel[song->current_event->channel].expression = song->current_event->a;
-				adjust_volume(song);
-				break;
+					break;
 
-			case ME_PROGRAM:
-				if (ISDRUMCHANNEL(song, song->current_event->channel))
-				{
-					/* Change drum set */
+				case ME_KEYPRESSURE:
+					adjust_pressure(song);
+					break;
+
+				/* Effects affecting a single channel */
+				case ME_PITCH_SENS:
+					song->channel[song->current_event->channel].pitchsens = song->current_event->a;
+					song->channel[song->current_event->channel].pitchfactor = 0;
+					break;
+
+				case ME_PITCHWHEEL:
+					song->channel[song->current_event->channel].pitchbend =
+						song->current_event->a + song->current_event->b * 128;
+					song->channel[song->current_event->channel].pitchfactor = 0;
+					/* Adjust pitch for notes already playing */
+					adjust_pitchbend(song);
+					break;
+
+				case ME_MAINVOLUME:
+					song->channel[song->current_event->channel].volume = song->current_event->a;
+					adjust_volume(song);
+					break;
+
+				case ME_PAN:
+					song->channel[song->current_event->channel].panning = song->current_event->a;
+					break;
+
+				case ME_EXPRESSION:
+					song->channel[song->current_event->channel].expression = song->current_event->a;
+					adjust_volume(song);
+					break;
+
+				case ME_PROGRAM:
+					if (ISDRUMCHANNEL(song, song->current_event->channel))
+					{
+						/* Change drum set */
+						song->channel[song->current_event->channel].bank = song->current_event->a;
+					}
+					else
+					{
+						song->channel[song->current_event->channel].program = song->current_event->a;
+					}
+					break;
+
+				case ME_SUSTAIN:
+					song->channel[song->current_event->channel].sustain = song->current_event->a;
+					if (!song->current_event->a)
+					{
+						drop_sustain(song);
+					}
+					break;
+
+				case ME_RESET_CONTROLLERS:
+					reset_controllers(song, song->current_event->channel);
+					break;
+
+				case ME_ALL_NOTES_OFF:
+					all_notes_off(song);
+					break;
+
+				case ME_ALL_SOUNDS_OFF:
+					all_sounds_off(song);
+					break;
+
+				case ME_TONE_BANK:
 					song->channel[song->current_event->channel].bank = song->current_event->a;
-				}
-				else
-				{
-					song->channel[song->current_event->channel].program = song->current_event->a;
-				}
-				break;
+					break;
+
+				case ME_EOT:
+					/* Give the last notes a couple of seconds to decay  */
+					ctl->cmsg(CMSG_INFO, VERB_VERBOSE,
+						"Playing time: ~%d seconds", song->current_sample / OUTPUT_RATE + 2);
+					ctl->cmsg(CMSG_INFO, VERB_VERBOSE,
+						"Notes cut: %d", song->cut_notes);
+					ctl->cmsg(CMSG_INFO, VERB_VERBOSE,
+						"Notes lost totally: %d", song->lost_notes);
+					Timidity_Stop(song);
+					song->current_sample = 0;
 
-			case ME_SUSTAIN:
-				song->channel[song->current_event->channel].sustain = song->current_event->a;
-				if (!song->current_event->a)
-					drop_sustain(song);
-				break;
-
-			case ME_RESET_CONTROLLERS:
-				reset_controllers(song, song->current_event->channel);
-				break;
-
-			case ME_ALL_NOTES_OFF:
-				all_notes_off(song);
-				break;
-
-			case ME_ALL_SOUNDS_OFF:
-				all_sounds_off(song);
-				break;
-
-			case ME_TONE_BANK:
-				song->channel[song->current_event->channel].bank = song->current_event->a;
-				break;
-
-			case ME_EOT:
-				/* Give the last notes a couple of seconds to decay  */
-				ctl->cmsg(CMSG_INFO, VERB_VERBOSE,
-					"Playing time: ~%d seconds", song->current_sample / OUTPUT_RATE + 2);
-				ctl->cmsg(CMSG_INFO, VERB_VERBOSE,
-					"Notes cut: %d", song->cut_notes);
-				ctl->cmsg(CMSG_INFO, VERB_VERBOSE,
-					"Notes lost totally: %d", song->lost_notes);
-				Timidity_Stop(song);
-				song->current_sample = 0;
-				return stream_start;
+					return stream_start;
 			}
 			song->current_event++;
 		}
 		if (song->current_event->time > end_sample)
+		{
 			conv_count = end_sample - song->current_sample;
+		}
 		else
+		{
 			conv_count = song->current_event->time - song->current_sample;
+		}
 
 		while (conv_count > 0)
 		{
 			int comp_count = conv_count;
+
 			if (comp_count > song->buffer_size)
+			{
 				comp_count = song->buffer_size;
+			}
 			do_compute_data(song, comp_count);
 			s32tos16((char*)stream + stream_start * sample_size, song->common_buffer,
 				2 * comp_count);
@@ -654,25 +753,36 @@
 			stream_start += comp_count;
 		}
 	}
+
 	return stream_start;
 }
 
 void Timidity_SetVolume(MidiSong* song, int volume)
 {
 	int i;
+
 	if (volume > MAX_AMPLIFICATION)
+	{
 		song->amplification = MAX_AMPLIFICATION;
+	}
 	else if (volume < 0)
+	{
 		song->amplification = 0;
+	}
 	else
+	{
 		song->amplification = volume;
+	}
 	adjust_amplification(song);
+
 	for (i = 0; i < song->voices; i++)
+	{
 		if (song->voice[i].status != VOICE_FREE)
 		{
 			recompute_amp(song, i);
 			apply_envelope_to_amp(song, i);
 		}
+	}
 }
 
 MidiSong *Timidity_LoadSongMem(void* data, int size, DLS_Data* patches, Sf2Data* sf2_font)
@@ -693,6 +803,7 @@
 			memset(song->tonebank[i], 0, sizeof(ToneBank));
 			song->tonebank[i]->tone = master_tonebank[i]->tone;
 		}
+
 		if (master_drumset[i])
 		{
 			song->drumset[i] = (ToneBank*)safe_malloc(sizeof(ToneBank));
@@ -708,13 +819,18 @@
 	song->resample_buffer = (sample_t*)safe_malloc(song->buffer_size * sizeof(sample_t));
 	song->common_buffer = (int32*)safe_malloc(song->buffer_size * 2 * sizeof(int32));
 	song->control_ratio = OUTPUT_RATE / CONTROLS_PER_SECOND;
+
 	if (song->control_ratio < 1)
+	{
 		song->control_ratio = 1;
+	}
 	else if (song->control_ratio > MAX_CONTROL_RATIO)
+	{
 		song->control_ratio = MAX_CONTROL_RATIO;
-
+	}
 	/* Open the file */
 	song->events = read_midi_mem(song, data, size, &events, &song->samples);
+
 	/* Make sure everything is okay */
 	if (!song->events)
 	{
@@ -722,12 +838,12 @@
 		song = NULL;
 		return NULL;
 	}
-
 	song->default_program = DEFAULT_PROGRAM;
 
 	if (*def_instr_name)
+	{
 		set_default_instrument(song, def_instr_name);
-
+	}
 	load_missing_instruments(song);
 
 	return song;
@@ -762,13 +878,13 @@
 			free(song->tonebank[i]);
 			song->tonebank[i] = NULL;
 		}
+
 		if (song->drumset[i])
 		{
 			free(song->drumset[i]);
 			song->drumset[i] = NULL;
 		}
 	}
-
 	free(song->events);
 	song->events = NULL;
 	free(song->resample_buffer);
@@ -786,6 +902,7 @@
 		if (master_tonebank[i])
 		{
 			ToneBankElement *e = master_tonebank[i]->tone;
+
 			if (e != NULL)
 			{
 				for (int j = 0; j < 128; j++)
@@ -802,9 +919,11 @@
 			free(master_tonebank[i]);
 			master_tonebank[i] = NULL;
 		}
+
 		if (master_drumset[i])
 		{
 			ToneBankElement *e = master_drumset[i]->tone;
+
 			if (e != NULL)
 			{
 				for (int j = 0; j < 128; j++)
diff -Nur orig/source/timidity/readmidi.cpp mod/source/timidity/readmidi.cpp
--- orig/source/timidity/readmidi.cpp	2010-05-30 23:46:44.000000000 +0200
+++ mod/source/timidity/readmidi.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -45,17 +45,22 @@
 static int midi_read(MidiSong* song, void* ptr, uint32 size)
 {
 	if (size > song->image_left)
+	{
 		size = song->image_left;
+	}
 	memcpy(ptr, song->midi_image, size);
 	song->midi_image += size;
 	song->image_left -= size;
+
 	return size;
 }
 
 static void midi_skip(MidiSong* song, uint32 size)
 {
 	if (size > song->image_left)
+	{
 		size = song->image_left;
+	}
 	song->midi_image += size;
 	song->image_left -= size;
 }
@@ -65,12 +70,16 @@
 {
 	int32 l = 0;
 	uint8 c;
+
 	for (;;)
 	{
 		midi_read(song, &c, 1);
 		l += (c & 0x7f);
+
 		if (!(c & 0x80))
+		{
 			return l;
+		}
 		l <<= 7;
 	}
 }
@@ -80,21 +89,27 @@
 static int dumpstring(MidiSong* song, int32 len, const char* label)
 {
 	signed char* s = (signed char*)safe_malloc(len + 1);
+
 	if (len != (int32)midi_read(song, s, len))
 	{
 		free(s);
 		s = NULL;
+
 		return -1;
 	}
 	s[len] = '\0';
+
 	while (len--)
 	{
 		if (s[len] < 32)
+		{
 			s[len] = '.';
+		}
 	}
 	ctl->cmsg(CMSG_TEXT, VERB_VERBOSE, "%s%s", label, s);
 	free(s);
 	s = NULL;
+
 	return 0;
 }
 
@@ -127,6 +142,7 @@
 		{
 			ctl->cmsg(CMSG_ERROR, VERB_NORMAL, "%s: read_midi_event: %s",
 				current_filename, strerror(errno));
+
 			return 0;
 		}
 
@@ -151,20 +167,20 @@
 			else
 				switch(type)
 				{
-				case 0x2F: /* End of Track */
-					return MAGIC_EOT;
+					case 0x2F: /* End of Track */
+						return MAGIC_EOT;
 
-				case 0x51: /* Tempo */
-					midi_read(song, &a,1);
-					midi_read(song, &b,1);
-					midi_read(song, &c,1);
-					MIDIEVENT(song->at, ME_TEMPO, c, a, b);
-
-				default:
-					ctl->cmsg(CMSG_INFO, VERB_DEBUG,
-						"(Meta event type 0x%02x, length %ld)", type, len);
-					midi_skip(song, len);
-					break;
+					case 0x51: /* Tempo */
+						midi_read(song, &a,1);
+						midi_read(song, &b,1);
+						midi_read(song, &c,1);
+						MIDIEVENT(song->at, ME_TEMPO, c, a, b);
+
+					default:
+						ctl->cmsg(CMSG_INFO, VERB_DEBUG,
+							"(Meta event type 0x%02x, length %ld)", type, len);
+						midi_skip(song, len);
+						break;
 				}
 		}
 		else
@@ -179,143 +195,148 @@
 			}
 			switch (laststatus)
 			{
-			case 0: /* Note off */
-				midi_read(song, &b, 1);
-				b &= 0x7F;
-				MIDIEVENT(song->at, ME_NOTEOFF, lastchan, a,b);
-
-			case 1: /* Note on */
-				midi_read(song, &b, 1);
-				b &= 0x7F;
-				MIDIEVENT(song->at, ME_NOTEON, lastchan, a, b);
-
-
-			case 2: /* Key Pressure */
-				midi_read(song, &b, 1);
-				b &= 0x7F;
-				MIDIEVENT(song->at, ME_KEYPRESSURE, lastchan, a, b);
-
-			case 3: /* Control change */
-				midi_read(song, &b, 1);
-				b &= 0x7F;
-				{
-					int control = 255;
-					switch(a)
-					{
-					case 7:
-						control = ME_MAINVOLUME;
-						break;
-					case 10:
-						control = ME_PAN;
-						break;
-					case 11:
-						control = ME_EXPRESSION;
-						break;
-					case 64:
-						control = ME_SUSTAIN;
-						break;
-					case 120:
-						control = ME_ALL_SOUNDS_OFF;
-						break;
-					case 121:
-						control = ME_RESET_CONTROLLERS;
-						break;
-					case 123:
-						control = ME_ALL_NOTES_OFF;
-						break;
-
-					/* These should be the SCC-1 tone bank switch
-						commands. I don't know why there are two, or
-						why the latter only allows switching to bank 0.
-						Also, some MIDI files use 0 as some sort of
-						continuous controller. This will cause lots of
-						warnings about undefined tone banks. */
-					case 0:
-						control = ME_TONE_BANK;
-						break;
+				case 0: /* Note off */
+					midi_read(song, &b, 1);
+					b &= 0x7F;
+					MIDIEVENT(song->at, ME_NOTEOFF, lastchan, a,b);
+
+				case 1: /* Note on */
+					midi_read(song, &b, 1);
+					b &= 0x7F;
+					MIDIEVENT(song->at, ME_NOTEON, lastchan, a, b);
+
+
+				case 2: /* Key Pressure */
+					midi_read(song, &b, 1);
+					b &= 0x7F;
+					MIDIEVENT(song->at, ME_KEYPRESSURE, lastchan, a, b);
+
+				case 3: /* Control change */
+					midi_read(song, &b, 1);
+					// Clamp parameters to 127
+					b = MIN(b, 0x7F);
 
-					case 32:
-						if (b!=0)
-							ctl->cmsg(CMSG_INFO, VERB_DEBUG, "(Strange: tone bank change 0x20%02x)\n", b);
-						else
-							control=ME_TONE_BANK;
-						break;
-
-					case 100:
-						nrpn = 0;
-						rpn_msb[lastchan] = b;
-						break;
-					case 101:
-						nrpn = 0;
-						rpn_lsb[lastchan] = b;
-						break;
-					case 99:
-						nrpn = 1;
-						rpn_msb[lastchan] = b;
-						break;
-					case 98:
-						nrpn = 1;
-						rpn_lsb[lastchan] = b;
-						break;
+					b &= 0x7F;
+					{
+						int control = 255;
 
-					case 6:
-						if (nrpn)
+						switch(a)
 						{
-							ctl->cmsg(CMSG_INFO, VERB_DEBUG, 
-								"(Data entry (MSB) for NRPN %02x,%02x: %ld)",
-								rpn_msb[lastchan], rpn_lsb[lastchan],
-								b);
-							break;
+							case 7:
+								control = ME_MAINVOLUME;
+								break;
+							case 10:
+								control = ME_PAN;
+								break;
+							case 11:
+								control = ME_EXPRESSION;
+								break;
+							case 64:
+								control = ME_SUSTAIN;
+								break;
+							case 120:
+								control = ME_ALL_SOUNDS_OFF;
+								break;
+							case 121:
+								control = ME_RESET_CONTROLLERS;
+								break;
+							case 123:
+								control = ME_ALL_NOTES_OFF;
+								break;
+
+							/* These should be the SCC-1 tone bank switch
+								commands. I don't know why there are two, or
+								why the latter only allows switching to bank 0.
+								Also, some MIDI files use 0 as some sort of
+								continuous controller. This will cause lots of
+								warnings about undefined tone banks. */
+							case 0:
+								control = ME_TONE_BANK;
+								break;
+
+							case 32:
+								if (b!=0)
+									ctl->cmsg(CMSG_INFO, VERB_DEBUG, "(Strange: tone bank change 0x20%02x)\n", b);
+								else
+									control=ME_TONE_BANK;
+								break;
+
+							case 100:
+								nrpn = 0;
+								rpn_msb[lastchan] = b;
+								break;
+							case 101:
+								nrpn = 0;
+								rpn_lsb[lastchan] = b;
+								break;
+							case 99:
+								nrpn = 1;
+								rpn_msb[lastchan] = b;
+								break;
+							case 98:
+								nrpn = 1;
+								rpn_lsb[lastchan] = b;
+								break;
+
+							case 6:
+								if (nrpn)
+								{
+									ctl->cmsg(CMSG_INFO, VERB_DEBUG, 
+										"(Data entry (MSB) for NRPN %02x,%02x: %ld)",
+										rpn_msb[lastchan], rpn_lsb[lastchan],
+										b);
+									break;
+								}
+
+								switch ((rpn_msb[lastchan] << 8) | rpn_lsb[lastchan])
+								{
+								case 0x0000: /* Pitch bend sensitivity */
+									control = ME_PITCH_SENS;
+									break;
+
+								case 0x7F7F: /* RPN reset */
+									/* reset pitch bend sensitivity to 2 */
+									MIDIEVENT(song->at, ME_PITCH_SENS, lastchan, 2, 0);
+
+								default:
+									ctl->cmsg(CMSG_INFO, VERB_DEBUG, 
+										"(Data entry (MSB) for RPN %02x,%02x: %ld)",
+										rpn_msb[lastchan], rpn_lsb[lastchan],
+										b);
+									break;
+								}
+								break;
+
+							default:
+								ctl->cmsg(CMSG_INFO, VERB_DEBUG, 
+									"(Control %d: %d)", a, b);
+								break;
 						}
 
-						switch ((rpn_msb[lastchan] << 8) | rpn_lsb[lastchan])
+						if (control != 255)
 						{
-						case 0x0000: /* Pitch bend sensitivity */
-							control = ME_PITCH_SENS;
-							break;
-
-						case 0x7F7F: /* RPN reset */
-							/* reset pitch bend sensitivity to 2 */
-							MIDIEVENT(song->at, ME_PITCH_SENS, lastchan, 2, 0);
-
-						default:
-							ctl->cmsg(CMSG_INFO, VERB_DEBUG, 
-								"(Data entry (MSB) for RPN %02x,%02x: %ld)",
-								rpn_msb[lastchan], rpn_lsb[lastchan],
-								b);
-							break;
+							MIDIEVENT(song->at, control, lastchan, b, 0);
 						}
-						break;
-
-					default:
-						ctl->cmsg(CMSG_INFO, VERB_DEBUG, 
-							"(Control %d: %d)", a, b);
-						break;
-					}
-					if (control != 255)
-					{
-						MIDIEVENT(song->at, control, lastchan, b, 0);
 					}
-				}
-				break;
+					break;
 
-			case 4: /* Program change */
-				a &= 0x7f;
-				MIDIEVENT(song->at, ME_PROGRAM, lastchan, a, 0);
-
-			case 5: /* Channel pressure - NOT IMPLEMENTED */
-				break;
-
-			case 6: /* Pitch wheel */
-				midi_read(song, &b, 1);
-				b &= 0x7F;
-				MIDIEVENT(song->at, ME_PITCHWHEEL, lastchan, a, b);
-
-			default: 
-				ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
-					"*** Can't happen: status 0x%02X, channel 0x%02X",
-					laststatus, lastchan);
-				break;
+				case 4: /* Program change */
+					a &= 0x7F;
+					MIDIEVENT(song->at, ME_PROGRAM, lastchan, a, 0);
+
+				case 5: /* Channel pressure - NOT IMPLEMENTED */
+					break;
+
+				case 6: /* Pitch wheel */
+					midi_read(song, &b, 1);
+					b &= 0x7F;
+					MIDIEVENT(song->at, ME_PITCHWHEEL, lastchan, a, b);
+
+				default: 
+					ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
+						"*** Can't happen: status 0x%02X, channel 0x%02X",
+						laststatus, lastchan);
+					break;
 			}
 		}
 	}
@@ -335,15 +356,20 @@
 	char tmp[4];
 
 	meep = song->evlist;
-	if (append && meep)
+
+	if (append && meep != NULL)
 	{
 		/* find the last event in the list */
 		for (; meep->next; meep=meep->next)
+		{
 			;
+		}
 		song->at = meep->event.time;
 	}
 	else
+	{
 		song->at = 0;
+	}
 
 	/* Check the formalities */
 	if ((midi_read(song, tmp, 4) != 4) || (midi_read(song, &len, 4) != 4))
@@ -364,20 +390,21 @@
 	for (;;)
 	{
 		if (!(new_ev = read_midi_event(song))) /* Some kind of error  */
+		{
 			return -2;
+		}
 
 		if (new_ev == MAGIC_EOT) /* End-of-track Hack. */
 		{
 			return 0;
 		}
-
 		next = meep->next;
-		while (next && (next->event.time < new_ev->event.time))
+
+		while (next != NULL && (next->event.time < new_ev->event.time))
 		{
 			meep = next;
 			next = meep->next;
 		}
-
 		new_ev->next = next;
 		meep->next = new_ev;
 
@@ -391,7 +418,10 @@
 {
 	MidiEventList *meep, *next;
 	if (!(meep = song->evlist))
+	{
 		return;
+	}
+
 	while (meep)
 	{
 		next = meep->next;
@@ -423,7 +453,6 @@
 		current_set[i] = 0;
 		current_program[i] = song->default_program;
 	}
-
 	tempo = 500000;
 	compute_sample_increment(song, tempo, divisions);
 
@@ -447,92 +476,94 @@
 			skip_this_event = 1;
 		}
 		else
+		{
 			switch (meep->event.type)
 			{
-			case ME_PROGRAM:
-
-				if (ISDRUMCHANNEL(song, meep->event.channel))
-				{
-					if (song->drumset[meep->event.a]) /* Is this a defined drumset? */
-						new_value = meep->event.a;
-					else
+				case ME_PROGRAM:
+					if (ISDRUMCHANNEL(song, meep->event.channel))
 					{
-						ctl->cmsg(CMSG_WARNING, VERB_VERBOSE,
-							"Drum set %d is undefined", meep->event.a);
-						new_value = meep->event.a = 0;
+						if (song->drumset[meep->event.a]) /* Is this a defined drumset? */
+							new_value = meep->event.a;
+						else
+						{
+							ctl->cmsg(CMSG_WARNING, VERB_VERBOSE,
+								"Drum set %d is undefined", meep->event.a);
+							new_value = meep->event.a = 0;
+						}
+						if (current_set[meep->event.channel] != new_value)
+							current_set[meep->event.channel] = new_value;
+						else
+							skip_this_event=1;
 					}
-					if (current_set[meep->event.channel] != new_value)
-						current_set[meep->event.channel] = new_value;
-					else
-						skip_this_event=1;
-				}
-				else
-				{
-					new_value = meep->event.a;
-					if ((current_program[meep->event.channel] != SPECIAL_PROGRAM)
-						&& (current_program[meep->event.channel] != new_value))
-						current_program[meep->event.channel] = new_value;
 					else
-						skip_this_event = 1;
-				}
-				break;
+					{
+						new_value = meep->event.a;
+						if ((current_program[meep->event.channel] != SPECIAL_PROGRAM)
+							&& (current_program[meep->event.channel] != new_value))
+							current_program[meep->event.channel] = new_value;
+						else
+							skip_this_event = 1;
+					}
+					break;
 
-			case ME_NOTEON:
-				if (counting_time)
-					counting_time = 1;
-				if (ISDRUMCHANNEL(song, meep->event.channel)) /* percussion channel? */
-				{
-					int dset = current_set[meep->event.channel];
-					int dnote = meep->event.a;
-					/* Mark this instrument to be loaded */
-					if (!(song->drumset[dset]->instrument[dnote]))
+				case ME_NOTEON:
+					if (counting_time)
+						counting_time = 1;
+					if (ISDRUMCHANNEL(song, meep->event.channel)) /* percussion channel? */
 					{
-						song->drumset[dset]->instrument[dnote] = MAGIC_LOAD_INSTRUMENT;
+						int dset = current_set[meep->event.channel];
+						int dnote = meep->event.a;
+						/* Mark this instrument to be loaded */
+						if (!(song->drumset[dset]->instrument[dnote]))
+						{
+							song->drumset[dset]->instrument[dnote] = MAGIC_LOAD_INSTRUMENT;
+						}
 					}
-				}
-				else
-				{
-					int chan = meep->event.channel;
-					int banknum = current_bank[chan];
-					mprog = current_program[chan];
-					if (mprog == SPECIAL_PROGRAM)
-						break;
+					else
+					{
+						int chan = meep->event.channel;
+						int banknum = current_bank[chan];
+						mprog = current_program[chan];
+						if (mprog == SPECIAL_PROGRAM)
+							break;
+
+						/* Mark this instrument to be loaded */
+						if (!(song->tonebank[banknum]->instrument[mprog]))
+						{
+							song->tonebank[banknum]->instrument[mprog] = MAGIC_LOAD_INSTRUMENT;
+						}
+					}
+					break;
 
-					/* Mark this instrument to be loaded */
-					if (!(song->tonebank[banknum]->instrument[mprog]))
+				case ME_TONE_BANK:
+					if (ISDRUMCHANNEL(song, meep->event.channel))
 					{
-						song->tonebank[banknum]->instrument[mprog] = MAGIC_LOAD_INSTRUMENT;
+						skip_this_event = 1;
+						break;
+					}
+					if (song->tonebank[meep->event.a]) /* Is this a defined tone bank? */
+						new_value = meep->event.a;
+					else 
+					{
+						ctl->cmsg(CMSG_WARNING, VERB_VERBOSE,
+							"Tone bank %d is undefined", meep->event.a);
+						new_value = meep->event.a = 0;
 					}
-				}
-				break;
 
-			case ME_TONE_BANK:
-				if (ISDRUMCHANNEL(song, meep->event.channel))
-				{
-					skip_this_event = 1;
+					if (current_bank[meep->event.channel] != new_value)
+						current_bank[meep->event.channel] = new_value;
+					else
+						skip_this_event = 1;
 					break;
 				}
-				if (song->tonebank[meep->event.a]) /* Is this a defined tone bank? */
-					new_value = meep->event.a;
-				else 
-				{
-					ctl->cmsg(CMSG_WARNING, VERB_VERBOSE,
-						"Tone bank %d is undefined", meep->event.a);
-					new_value = meep->event.a = 0;
-				}
-
-				if (current_bank[meep->event.channel] != new_value)
-					current_bank[meep->event.channel] = new_value;
-				else
-					skip_this_event = 1;
-				break;
-			}
+		}
 
 		/* Recompute time in samples*/
 		if ((dt = meep->event.time - at) && !counting_time)
 		{
 			samples_to_do = song->sample_increment * dt;
 			sample_cum += song->sample_correction * dt;
+
 			if (sample_cum & 0xFFFF0000)
 			{
 				samples_to_do += ((sample_cum >> 16) & 0xFFFF);
@@ -541,7 +572,10 @@
 			st += samples_to_do;
 		}
 		else if (counting_time == 1)
+		{
 			counting_time = 0;
+		}
+
 		if (!skip_this_event)
 		{
 			/* Add the event to the list */
@@ -561,6 +595,7 @@
 
 	*eventsp = our_event_count;
 	*samplesp = st;
+
 	return groomed_list;
 }
 
@@ -578,7 +613,6 @@
 	song->evlist=0;
 
 past_riff:
-
 	if ((midi_read(song, tmp,4) != 4) || (midi_read(song, &len,4) != 4))
 	{
 		ctl->cmsg(CMSG_ERROR, VERB_NORMAL, "%s: Not a MIDI file!", current_filename);
@@ -591,12 +625,12 @@
 		midi_read(song, tmp, 12);
 		goto past_riff;
 	}
+
 	if (memcmp(tmp, "MThd", 4) || len < 6)
 	{
 		ctl->cmsg(CMSG_ERROR, VERB_NORMAL, "%s: Not a MIDI file!", current_filename);
 		return 0;
 	}
-
 	midi_read(song, &format, 2);
 	midi_read(song, &tracks, 2);
 	midi_read(song, &divisions_tmp, 2);
@@ -610,7 +644,9 @@
 		divisions = (int32)(-(divisions_tmp / 256)) * (int32)(divisions_tmp & 0xFF);
 	}
 	else
+	{
 		divisions = (int32)(divisions_tmp);
+	}
 
 	if (len > 6)
 	{
@@ -619,6 +655,7 @@
 			current_filename, len);
 		midi_skip(song, len - 6); /* skip the excess */
 	}
+
 	if (format < 0 || format > 2)
 	{
 		ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
@@ -637,32 +674,33 @@
 
 	switch(format)
 	{
-	case 0:
-		if (read_track(song, 0))
-		{
-			free_midi_list(song);
-			return 0;
-		}
-		break;
-
-	case 1:
-		for (i = 0; i < tracks; i++)
+		case 0:
 			if (read_track(song, 0))
 			{
 				free_midi_list(song);
 				return 0;
 			}
-		break;
+			break;
 
-	case 2: /* We simply play the tracks sequentially */
-		for (i = 0; i < tracks; i++)
-			if (read_track(song, 1))
-			{
-				free_midi_list(song);
-				return 0;
-			}
-		break;
+		case 1:
+			for (i = 0; i < tracks; i++)
+				if (read_track(song, 0))
+				{
+					free_midi_list(song);
+					return 0;
+				}
+			break;
+
+		case 2: /* We simply play the tracks sequentially */
+			for (i = 0; i < tracks; i++)
+				if (read_track(song, 1))
+				{
+					free_midi_list(song);
+					return 0;
+				}
+			break;
 	}
+
 	return groom_list(song, divisions, count, sp);
 }
 
diff -Nur orig/source/timidity/resample.cpp mod/source/timidity/resample.cpp
--- orig/source/timidity/resample.cpp	2010-03-24 19:18:22.000000000 +0100
+++ mod/source/timidity/resample.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -40,9 +40,7 @@
 
 static sample_t* rs_plain(MidiSong* song, int v, int32* countptr)
 {
-
 	/* Play sample until end, then free the voice. */
-
 	INTERPVARS;
 	Voice* vp = &song->voice[v];
 	sample_t* dest = song->resample_buffer;
@@ -56,8 +54,9 @@
 	int32 i;
 
 	if (incr < 0)
+	{
 		incr = -incr; /* In case we're coming out of a bidir loop */
-
+	}
 	/* Precalc how many times we should go through the loop.
 		NOTE: Assumes that incr > 0 and that ofs <= le */
 	i = (le - ofs) / incr + 1;
@@ -68,7 +67,9 @@
 		count = 0;
 	}
 	else
+	{
 		count -= i;
+	}
 
 	while (i--) 
 	{
@@ -82,16 +83,14 @@
 		vp->status = VOICE_FREE;
 		*countptr -= count + 1;
 	}
-
 	vp->sample_offset = ofs; /* Update offset */
+
 	return song->resample_buffer;
 }
 
 static sample_t* rs_loop(MidiSong* song, Voice* vp, int32 count)
 {
-
 	/* Play sample until end-of-loop, skip back and continue. */
-
 	INTERPVARS;
 	int32 
 		ofs = vp->sample_offset, 
@@ -106,25 +105,31 @@
 	while (count)
 	{
 		if (ofs >= le)
+		{
 			/* NOTE: Assumes that ll > incr and that incr > 0. */
 			ofs -= ll;
+		}
 		/* Precalc how many times we should go through the loop */
 		i = (le - ofs) / incr + 1;
+
 		if (i > count) 
 		{
 			i = count;
 			count = 0;
 		}
 		else
+		{
 			count -= i;
+		}
+
 		while (i--)
 		{
 			RESAMPLATION;
 			ofs += incr;
 		}
 	}
-
 	vp->sample_offset = ofs; /* Update offset */
+
 	return song->resample_buffer;
 }
 
@@ -143,8 +148,8 @@
 		le2 = le << 1, 
 		ls2 = ls << 1,
 		i;
-	/* Play normally until inside the loop region */
 
+	/* Play normally until inside the loop region */
 	if (ofs <= ls)
 	{
 		/* NOTE: Assumes that incr > 0, which is NOT always the case
@@ -157,7 +162,10 @@
 			count = 0;
 		}
 		else
+		{
 			count -= i;
+		}
+
 		while (i--)
 		{
 			RESAMPLATION;
@@ -166,23 +174,27 @@
 	}
 
 	/* Then do the bidirectional looping */
-
 	while(count)
 	{
 		/* Precalc how many times we should go through the loop */
 		i = ((incr > 0 ? le : ls) - ofs) / incr + 1;
+
 		if (i > count)
 		{
 			i = count;
 			count = 0;
 		}
 		else
+		{
 			count -= i;
+		}
+
 		while (i--)
 		{
 			RESAMPLATION;
 			ofs += incr;
 		}
+
 		if (ofs>=le)
 		{
 			/* fold the overshoot back in */
@@ -195,9 +207,9 @@
 			incr *= -1;
 		}
 	}
-
 	vp->sample_increment = incr;
 	vp->sample_offset = ofs; /* Update offset */
+
 	return song->resample_buffer;
 }
 
@@ -207,11 +219,17 @@
 static int vib_phase_to_inc_ptr(int phase)
 {
 	if (phase < VIBRATO_SAMPLE_INCREMENTS / 2)
+	{
 		return VIBRATO_SAMPLE_INCREMENTS / 2 - 1 - phase;
+	}
 	else if (phase >= 3 * VIBRATO_SAMPLE_INCREMENTS / 2)
+	{
 		return 5 * VIBRATO_SAMPLE_INCREMENTS / 2 - 1 - phase;
+	}
 	else
+	{
 		return phase - VIBRATO_SAMPLE_INCREMENTS / 2;
+	}
 }
 
 static int32 update_vibrato(Voice* vp, int sign)
@@ -221,27 +239,34 @@
 	double a;
 
 	if (vp->vibrato_phase++ >= 2 * VIBRATO_SAMPLE_INCREMENTS - 1)
+	{
 		vp->vibrato_phase = 0;
+	}
 	phase = vib_phase_to_inc_ptr(vp->vibrato_phase);
 
 	if (vp->vibrato_sample_increment[phase])
 	{
 		if (sign)
+		{
 			return -vp->vibrato_sample_increment[phase];
+		}
 		else
+		{
 			return vp->vibrato_sample_increment[phase];
+		}
 	}
-
 	/* Need to compute this sample increment. */
-
 	depth = vp->sample->vibrato_depth << 7;
 
 	if (vp->vibrato_sweep)
 	{
 		/* Need to update sweep */
 		vp->vibrato_sweep_position += vp->vibrato_sweep;
+
 		if (vp->vibrato_sweep_position >= (1<<SWEEP_SHIFT))
+		{
 			vp->vibrato_sweep = 0;
+		}
 		else
 		{
 			/* Adjust depth */
@@ -249,7 +274,6 @@
 			depth >>= SWEEP_SHIFT;
 		}
 	}
-
 	a = FSCALE(((double)(vp->sample->sample_rate) *
 		(double)(vp->frequency)) /
 		((double)(vp->sample->root_freq) *
@@ -266,23 +290,27 @@
 		a /= bend_fine[(pb >> 5) & 0xFF] * bend_coarse[pb >> 13];
 	}
 	else
+	{
 		a *= bend_fine[(pb >> 5) & 0xFF] * bend_coarse[pb >> 13];
+	}
 
 	/* If the sweep's over, we can store the newly computed sample_increment */
 	if (!vp->vibrato_sweep)
+	{
 		vp->vibrato_sample_increment[phase] = (int32)a;
+	}
 
 	if (sign)
+	{
 		a = -a; /* need to preserve the loop direction */
+	}
 
 	return (int32) a;
 }
 
 static sample_t* rs_vib_plain(MidiSong* song, int v, int32* countptr)
 {
-
 	/* Play sample until end, then free the voice. */
-
 	INTERPVARS;
 	Voice* vp = &song->voice[v];
 	sample_t* dest = song->resample_buffer;
@@ -296,9 +324,10 @@
 		cc = vp->vibrato_control_counter;
 
 	/* This has never been tested */
-
 	if (incr < 0)
+	{
 		incr = -incr; /* In case we're coming out of a bidir loop */
+	}
 
 	while (count--)
 	{
@@ -309,6 +338,7 @@
 		}
 		RESAMPLATION;
 		ofs += incr;
+
 		if (ofs >= le)
 		{
 			FINALINTERP;
@@ -317,18 +347,16 @@
 			break;
 		}
 	}
-
 	vp->vibrato_control_counter = cc;
 	vp->sample_increment = incr;
 	vp->sample_offset = ofs; /* Update offset */
+
 	return song->resample_buffer;
 }
 
 static sample_t* rs_vib_loop(MidiSong* song, Voice* vp, int32 count)
 {
-
 	/* Play sample until end-of-loop, skip back and continue. */
-
 	INTERPVARS;
 	int32 
 		ofs=vp->sample_offset, 
@@ -346,25 +374,35 @@
 	{
 		/* Hopefully the loop is longer than an increment */
 		if (ofs >= le)
+		{
 			ofs -= ll;
+		}
 		/* Precalc how many times to go through the loop, taking
 		the vibrato control ratio into account this time. */
 		i = (le - ofs) / incr + 1;
+
 		if (i > count)
+		{
 			i = count;
+		}
+
 		if (i > cc)
 		{
 			i = cc;
 			vibflag = 1;
 		}
 		else
+		{
 			cc -= i;
+		}
 		count -= i;
+
 		while (i--)
 		{
 			RESAMPLATION;
 			ofs += incr;
 		}
+
 		if (vibflag)
 		{
 			cc = vp->vibrato_control_ratio;
@@ -372,10 +410,10 @@
 			vibflag = 0;
 		}
 	}
-
 	vp->vibrato_control_counter = cc;
 	vp->sample_increment = incr;
 	vp->sample_offset = ofs; /* Update offset */
+
 	return song->resample_buffer;
 }
 
@@ -401,21 +439,29 @@
 	while (count && (ofs <= ls))
 	{
 		i = (ls - ofs) / incr + 1;
+
 		if (i > count)
+		{
 			i = count;
+		}
+
 		if (i > cc)
 		{
 			i = cc;
 			vibflag = 1;
 		}
 		else
+		{
 			cc -= i;
+		}
 		count -= i;
+
 		while (i--)
 		{
 			RESAMPLATION;
 			ofs += incr;
 		}
+
 		if (vibflag)
 		{
 			cc = vp->vibrato_control_ratio;
@@ -425,32 +471,40 @@
 	}
 
 	/* Then do the bidirectional looping */
-
 	while (count)
 	{
 		/* Precalc how many times we should go through the loop */
 		i = ((incr > 0 ? le : ls) - ofs) / incr + 1;
+
 		if (i > count)
+		{
 			i = count;
+		}
+
 		if (i > cc)
 		{
 			i = cc;
 			vibflag = 1;
 		}
 		else
+		{
 			cc -= i;
+		}
 		count -= i;
+
 		while (i--)
 		{
 			RESAMPLATION;
 			ofs += incr;
 		}
+
 		if (vibflag)
 		{
 			cc = vp->vibrato_control_ratio;
 			incr = update_vibrato(vp, (incr < 0));
 			vibflag = 0;
 		}
+
 		if (ofs >= le)
 		{
 			/* fold the overshoot back in */
@@ -463,16 +517,15 @@
 			incr *= -1;
 		}
 	}
-
 	vp->vibrato_control_counter = cc;
 	vp->sample_increment = incr;
 	vp->sample_offset = ofs; /* Update offset */
+
 	return song->resample_buffer;
 }
 
 sample_t* resample_voice(MidiSong* song, int v, int32* countptr)
 {
-	int32 ofs;
 	uint8 modes;
 	Voice* vp = &song->voice[v];
 
@@ -480,8 +533,9 @@
 	{
 		/* Pre-resampled data -- just update the offset and check if
 			we're out of data. */
-		ofs = vp->sample_offset >> FRACTION_BITS; /* Kind of silly to use
+		int32 ofs = vp->sample_offset >> FRACTION_BITS; /* Kind of silly to use
 							FRACTION_BITS here... */
+
 		if (*countptr >= (vp->sample->data_length >> FRACTION_BITS) - ofs)
 		{
 			/* Note finished. Free the voice. */
@@ -491,11 +545,12 @@
 			*countptr = (vp->sample->data_length >> FRACTION_BITS) - ofs;
 		}
 		else
+		{
 			vp->sample_offset += *countptr << FRACTION_BITS;
+		}
 
 		return vp->sample->data + ofs;
 	}
-
 	/* Need to resample. Use the proper function. */
 	modes = vp->sample->modes;
 
@@ -506,12 +561,18 @@
 			(vp->status == VOICE_ON || vp->status == VOICE_SUSTAINED)))
 		{
 			if (modes & MODES_PINGPONG)
+			{
 				return rs_vib_bidir(song, vp, *countptr);
+			}
 			else
+			{
 				return rs_vib_loop(song, vp, *countptr);
+			}
 		}
 		else
+		{
 			return rs_vib_plain(song, v, countptr);
+		}
 	}
 	else
 	{
@@ -520,12 +581,18 @@
 			(vp->status == VOICE_ON || vp->status == VOICE_SUSTAINED)))
 		{
 			if (modes & MODES_PINGPONG)
+			{
 				return rs_bidir(song, vp, *countptr);
+			}
 			else
+			{
 				return rs_loop(song, vp, *countptr);
+			}
 		}
 		else
+		{
 			return rs_plain(song, v, countptr);
+		}
 	}
 }
 
@@ -553,7 +620,9 @@
 	ofs = incr = (sp->data_length - (1 << FRACTION_BITS)) / count;
 
 	if (--count)
+	{
 		*dest++ = src[0];
+	}
 
 	/* Since we're pre-processing and this doesn't have to be done in
 		real-time, we go ahead and do the full sliding cubic interpolation. */
@@ -580,7 +649,9 @@
 		RESAMPLATION;
 	}
 	else
+	{
 		*dest++ = src[ofs >> FRACTION_BITS];
+	}
 
 	sp->data_length = newlen;
 	sp->loop_start = (int32)(sp->loop_start / a);
diff -Nur orig/source/timidity/sf2.h mod/source/timidity/sf2.h
--- orig/source/timidity/sf2.h	2010-03-21 21:05:50.000000000 +0100
+++ mod/source/timidity/sf2.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: sf2.h 4180 2010-03-21 20:10:19Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2010 Jānis Legzdiņš
 //**
diff -Nur orig/source/timidity/timidity.cpp mod/source/timidity/timidity.cpp
--- orig/source/timidity/timidity.cpp	2010-04-21 15:15:39.000000000 +0200
+++ mod/source/timidity/timidity.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -25,7 +25,6 @@
 
 namespace LibTimidity
 {
-
 char				def_instr_name[256] = "";
 ToneBank*			master_tonebank[128];
 ToneBank*			master_drumset[128];
@@ -50,23 +49,33 @@
 	}
 
 	if (!(fp = open_file(name, 1, OF_VERBOSE)))
+	{
 		return -1;
+	}
 
 	while (fgets(tmp, sizeof(tmp), fp))
 	{
 		line++;
 		w[words=0] = strtok(tmp, " \t\n\r\240");
 		if (!w[0])
+		{
 			continue;
+		}
 
 		/* Originally the TiMidity++ extensions were prefixed like this */
 		if (strcmp(w[0], "#extension") == 0)
+		{
 			words = -1;
+		}
 		else if (*w[0] == '#')
+		{
 			continue;
+		}
 
-		while (w[words] && *w[words] != '#' && (words < MAXWORDS))
+		while (w[words] != NULL && *w[words] != '#' && (words < MAXWORDS))
+		{
 			w[++words]=strtok(0," \t\n\r\240");
+		}
 
 		/*
 		* TiMidity++ adds a number of extensions to the config file format.
@@ -76,13 +85,11 @@
 		* Unfortunately the documentation for these extensions is often quite
 		* vague, gramatically strange or completely absent.
 		*/
-		if (
-				!strcmp(w[0], "comm")      /* "comm" program second        */
-			|| !strcmp(w[0], "HTTPproxy") /* "HTTPproxy" hostname:port    */
-			|| !strcmp(w[0], "FTPproxy")  /* "FTPproxy" hostname:port     */
-			|| !strcmp(w[0], "mailaddr")  /* "mailaddr" your-mail-address */
-			|| !strcmp(w[0], "opt")       /* "opt" timidity-options       */
-			)
+		if (	!strcmp(w[0], "comm")      /* "comm" program second        */
+			||  !strcmp(w[0], "HTTPproxy") /* "HTTPproxy" hostname:port    */
+			||  !strcmp(w[0], "FTPproxy")  /* "FTPproxy" hostname:port     */
+			||  !strcmp(w[0], "mailaddr")  /* "mailaddr" your-mail-address */
+			||  !strcmp(w[0], "opt")       /* "opt" timidity-options       */)
 		{
 			/*
 			* + "comm" sets some kind of comment -- the documentation is too
@@ -164,9 +171,7 @@
 			*/
 			ctl->cmsg(CMSG_ERROR, VERB_NORMAL,"FIXME: Implement \"map\" in TiMidity config.\n");
 		}
-
-			/* Standard TiMidity config */
-
+		/* Standard TiMidity config */
 		else if (!strcmp(w[0], "dir"))
 		{
 			if (words < 2)
@@ -176,7 +181,9 @@
 				return -2;
 			}
 			for (i = 1; i < words; i++)
+			{
 				add_to_pathlist(w[i]);
+			}
 		}
 		else if (!strcmp(w[0], "source"))
 		{
@@ -215,6 +222,7 @@
 				return -2;
 			}
 			i = atoi(w[1]);
+
 			if (i < 0 || i > 127)
 			{
 				ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
@@ -222,6 +230,7 @@
 					name, line);
 				return -2;
 			}
+
 			if (!master_drumset[i])
 			{
 				master_drumset[i] = (ToneBank*)safe_malloc(sizeof(ToneBank));
@@ -241,6 +250,7 @@
 				return -2;
 			}
 			i = atoi(w[1]);
+
 			if (i < 0 || i > 127)
 			{
 				ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
@@ -248,6 +258,7 @@
 					name, line);
 				return -2;
 			}
+
 			if (!master_tonebank[i])
 			{
 				master_tonebank[i] = (ToneBank*)safe_malloc(sizeof(ToneBank));
@@ -266,6 +277,7 @@
 				return -2;
 			}
 			i = atoi(w[0]);
+
 			if (i < 0 || i > 127)
 			{
 				ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
@@ -273,6 +285,7 @@
 					name, line);
 				return -2;
 			}
+
 			if (!bank)
 			{
 				ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
@@ -281,6 +294,7 @@
 					name, line);
 				return -2;
 			}
+
 			if (bank->tone[i].name)
 			{
 				free(bank->tone[i].name);
@@ -300,9 +314,11 @@
 					return -2;
 				}
 				*cp++ = 0;
+
 				if (!strcmp(w[j], "amp"))
 				{
 					k = atoi(cp);
+
 					if ((k < 0 || k > MAX_AMPLIFICATION) || (*cp < '0' || *cp > '9'))
 					{
 						ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
@@ -315,6 +331,7 @@
 				else if (!strcmp(w[j], "note"))
 				{
 					k = atoi(cp);
+
 					if ((k < 0 || k > 127) || (*cp < '0' || *cp > '9'))
 					{
 						ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
@@ -327,13 +344,22 @@
 				else if (!strcmp(w[j], "pan"))
 				{
 					if (!strcmp(cp, "center"))
+					{
 						k = 64;
+					}
 					else if (!strcmp(cp, "left"))
+					{
 						k = 0;
+					}
 					else if (!strcmp(cp, "right"))
+					{
 						k = 127;
+					}
 					else
+					{
 						k = ((atoi(cp) + 100) * 100) / 157;
+					}
+
 					if ((k < 0 || k > 127) ||
 						(k==0 && *cp!='-' && (*cp < '0' || *cp > '9')))
 					{
@@ -348,9 +374,13 @@
 				else if (!strcmp(w[j], "keep"))
 				{
 					if (!strcmp(cp, "env"))
+					{
 						bank->tone[i].strip_envelope = 0;
+					}
 					else if (!strcmp(cp, "loop"))
+					{
 						bank->tone[i].strip_loop = 0;
+					}
 					else
 					{
 						ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
@@ -361,11 +391,17 @@
 				else if (!strcmp(w[j], "strip"))
 				{
 					if (!strcmp(cp, "env"))
+					{
 						bank->tone[i].strip_envelope = 1;
+					}
 					else if (!strcmp(cp, "loop"))
+					{
 						bank->tone[i].strip_loop = 1;
+					}
 					else if (!strcmp(cp, "tail"))
+					{
 						bank->tone[i].strip_tail = 1;
+					}
 					else
 					{
 						ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
@@ -390,6 +426,7 @@
 		return -2;
 	}
 	close_file(fp);
+
 	return 0;
 }
 
diff -Nur orig/source/timidity/timidity.h mod/source/timidity/timidity.h
--- orig/source/timidity/timidity.h	2010-03-25 20:20:38.000000000 +0100
+++ mod/source/timidity/timidity.h	2022-08-12 08:34:35.000000000 +0200
@@ -27,7 +27,6 @@
 
 namespace LibTimidity
 {
-
 #if (defined(WIN32) || defined(_WIN32)) && !defined(__WIN32__)
 #define __WIN32__
 #endif
@@ -45,9 +44,9 @@
 
 /* Default sampling rate, default polyphony, and maximum polyphony.
    All but the last can be overridden from the command line. */
-#define DEFAULT_VOICES	32
-//#define DEFAULT_VOICES	256
-#define MAX_VOICES		256
+//#define DEFAULT_VOICES	32
+#define DEFAULT_VOICES	300
+#define MAX_VOICES		300
 
 /* 1000 here will give a control ratio of 22:1 with 22 kHz output.
    Higher CONTROLS_PER_SECOND values allow more accurate rendering
@@ -86,7 +85,6 @@
 #undef BIG_ENDIAN
 #define BIG_ENDIAN 1
 #endif
-
 }
 
 /* Byte order, defined in <machine/endian.h> for FreeBSD and DEC OSF/1 */
@@ -123,7 +121,6 @@
 
 namespace LibTimidity
 {
-
 /* Win32 on Intel machines */
 #ifdef __WIN32__
 #  define LITTLE_ENDIAN
@@ -272,6 +269,8 @@
 
 #define sine(x)		(sin((2*PI/1024.0) * (x)))
 
+#define MIN(x, y)		((x) <= (y) ? (x) : (y))
+
 #define OUTPUT_RATE		44100
 
 /* In percent. */
diff -Nur orig/source/ui_actor.cpp mod/source/ui_actor.cpp
--- orig/source/ui_actor.cpp	2008-08-30 21:00:58.000000000 +0200
+++ mod/source/ui_actor.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui_actor.cpp 3751 2008-08-26 14:23:44Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/ui_font.cpp mod/source/ui_font.cpp
--- orig/source/ui_font.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/ui_font.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui_font.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -224,8 +224,14 @@
 	{
 		VFont* Next = F->Next;
 		delete F;
-		F = NULL;
-		F = Next;
+		if (Next)
+		{
+			F = Next;
+		}
+		else
+		{
+			F = NULL;
+		}
 	}
 	Fonts = NULL;
 	TextColours.Clear();
@@ -297,9 +303,9 @@
 				{
 					sc.ExpectString();
 					vuint32 C = M_ParseColour(sc.String);
-					Col.FlatColour.r = (C >> 16) & 0xff;
-					Col.FlatColour.g = (C >> 8) & 0xff;
-					Col.FlatColour.b = C & 0xff;
+					Col.FlatColour.r = (C >> 16) & 255;
+					Col.FlatColour.g = (C >> 8) & 255;
+					Col.FlatColour.b = C & 255;
 					Col.FlatColour.a = 255;
 				}
 				else
@@ -307,17 +313,17 @@
 					//	From colour.
 					sc.ExpectString();
 					vuint32 C = M_ParseColour(sc.String);
-					TDef.From.r = (C >> 16) & 0xff;
-					TDef.From.g = (C >> 8) & 0xff;
-					TDef.From.b = C & 0xff;
+					TDef.From.r = (C >> 16) & 255;
+					TDef.From.g = (C >> 8) & 255;
+					TDef.From.b = C & 255;
 					TDef.From.a = 255;
 
 					//	To colour.
 					sc.ExpectString();
 					C = M_ParseColour(sc.String);
-					TDef.To.r = (C >> 16) & 0xff;
-					TDef.To.g = (C >> 8) & 0xff;
-					TDef.To.b = C & 0xff;
+					TDef.To.r = (C >> 16) & 255;
+					TDef.To.g = (C >> 8) & 255;
+					TDef.To.b = C & 255;
 					TDef.To.a = 255;
 
 					if (sc.CheckNumber())
@@ -1403,7 +1409,10 @@
 			// registered in texture manager.
 			GTextureManager.AddTexture(FChar.Textures[j]);
 		}
-		FChar.BaseTex = FChar.Textures[CR_UNTRANSLATED];
+		if (FChar.Textures[CR_UNTRANSLATED])
+		{
+			FChar.BaseTex = FChar.Textures[CR_UNTRANSLATED];
+		}
 
 		//	Skip character data.
 		int Count = SpaceWidth * FontHeight;
@@ -1558,7 +1567,10 @@
 				// registered in texture manager.
 				GTextureManager.AddTexture(FChar.Textures[j]);
 			}
-			FChar.BaseTex = FChar.Textures[CR_UNTRANSLATED];
+			if (FChar.Textures[CR_UNTRANSLATED])
+			{
+				FChar.BaseTex = FChar.Textures[CR_UNTRANSLATED];
+			}
 
 			//	Skip character data.
 			do
diff -Nur orig/source/ui_font.h mod/source/ui_font.h
--- orig/source/ui_font.h	2009-01-05 13:30:24.000000000 +0100
+++ mod/source/ui_font.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui_font.h 3947 2009-01-05 12:34:08Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/ui.h mod/source/ui.h
--- orig/source/ui.h	2007-11-15 13:21:20.000000000 +0100
+++ mod/source/ui.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui.h 2792 2007-11-15 12:27:35Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/ui_root.cpp mod/source/ui_root.cpp
--- orig/source/ui_root.cpp	2009-02-12 20:00:34.000000000 +0100
+++ mod/source/ui_root.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui_root.cpp 3987 2009-02-12 19:04:09Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -237,7 +237,7 @@
 	float ScaledNewX = MouseX * SizeScaleX;
 	float ScaledNewY = MouseY * SizeScaleY;
 	VWidget* OldFocus = GetWidgetAt(ScaledOldX, ScaledOldY);
-	for (VWidget* W = OldFocus; W; W = W->ParentWidget)
+	for (VWidget* W = OldFocus; W != NULL; W = W->ParentWidget)
 	{
 		if (W->OnMouseMove(
 			(int)((ScaledOldX - W->ClipRect.OriginX) / W->ClipRect.ScaleX),
@@ -249,7 +249,7 @@
 		}
 	}
 	VWidget* NewFocus = GetWidgetAt(ScaledNewX, ScaledNewY);
-	if (OldFocus != NewFocus)
+	if (OldFocus != NULL && OldFocus != NewFocus)
 	{
 		OldFocus->WidgetFlags &= ~(WF_LMouseDown | WF_MMouseDown |
 			WF_RMouseDown);
diff -Nur orig/source/ui_root.h mod/source/ui_root.h
--- orig/source/ui_root.h	2007-11-10 17:28:10.000000000 +0100
+++ mod/source/ui_root.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui_root.h 2783 2007-11-10 16:32:52Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/ui_widget.cpp mod/source/ui_widget.cpp
--- orig/source/ui_widget.cpp	2010-12-14 13:07:21.000000000 +0100
+++ mod/source/ui_widget.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui_widget.cpp 4339 2010-12-14 12:07:27Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/ui_widget.h mod/source/ui_widget.h
--- orig/source/ui_widget.h	2009-11-09 22:08:47.000000000 +0100
+++ mod/source/ui_widget.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ui_widget.h 4084 2009-11-09 22:14:10Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vavoom.rc mod/source/vavoom.rc
--- orig/source/vavoom.rc	2010-03-04 20:22:47.000000000 +0100
+++ mod/source/vavoom.rc	2022-08-12 08:34:35.000000000 +0200
@@ -1,7 +1,7 @@
 // Microsoft Visual C++ generated resource script.
 //
 //#include "resource.h"
-#include "svnrev.h"
+#include "gitrev.h"
 #include "build.h"
 
 #define APSTUDIO_READONLY_SYMBOLS
@@ -9,7 +9,7 @@
 //
 // Generated from the TEXTINCLUDE 2 resource.
 //
-#include "afxres.h"
+//#include "afxres.h"
 
 /////////////////////////////////////////////////////////////////////////////
 #undef APSTUDIO_READONLY_SYMBOLS
@@ -40,7 +40,7 @@
             VALUE "FileDescription", "Vavoom Engine"
             VALUE "FileVersion", RC_FILEVERSION2
             VALUE "InternalName", "Vavoom"
-            VALUE "LegalCopyright", "Copyright © 1993-1996 id Software, 1999-2009 Jānis Legzdiņš."
+            VALUE "LegalCopyright", "Copyright © 1993-1996 id Software, 1999-2017 Jānis Legzdiņš."
             VALUE "LegalTrademarks", "Doom® is a Registered Trademark of id Software, Inc."
             VALUE "OriginalFilename", "vavoom.exe"
             VALUE "ProductName", "Vavoom: The most Advanced Doom source port."
diff -Nur orig/source/vc_class.cpp mod/source/vc_class.cpp
--- orig/source/vc_class.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_class.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_class.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -583,7 +583,7 @@
 {
 	guard(VClass::FindField);
 	VField* F = FindField(Name);
-	if (F && (F->Flags & FIELD_Private) && this != SelfClass)
+	if (F != NULL && (F->Flags & FIELD_Private) && this != SelfClass)
 	{
 		ParseError(l, "Field %s is private", *F->Name);
 	}
@@ -1335,14 +1335,17 @@
 				break;
 			}
 		}
-		if (!Lbl)
+		if (Lbl == NULL)
 		{
 			Lbl = &List->Alloc();
 			Lbl->Name = Names[ni];
 		}
 		List = &Lbl->SubLabels;
 	}
-	Lbl->State = State;
+	if (Lbl != NULL)
+	{
+		Lbl->State = State;
+	}
 	unguard;
 }
 
@@ -1931,6 +1934,7 @@
 VClass* VClass::GetReplacement()
 {
 	guard(VClass::GetReplacement);
+	check(this);
 	if (!Replacement)
 	{
 		return this;
@@ -1941,7 +1945,7 @@
 	VClass* Ret = Temp->GetReplacement();
 	Replacement = Temp;
 	return Ret;
-	unguard;
+	unguardf(("(%s)", ((VClass*)this)->GetName()));
 }
 
 //==========================================================================
diff -Nur orig/source/vc_class.h mod/source/vc_class.h
--- orig/source/vc_class.h	2010-03-12 18:21:52.000000000 +0100
+++ mod/source/vc_class.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_class.h 4154 2010-03-11 20:42:47Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_constant.cpp mod/source/vc_constant.cpp
--- orig/source/vc_constant.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_constant.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_constant.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_constant.h mod/source/vc_constant.h
--- orig/source/vc_constant.h	2008-02-05 23:17:53.000000000 +0100
+++ mod/source/vc_constant.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_constant.h 3129 2008-02-05 22:21:10Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_decorate.cpp mod/source/vc_decorate.cpp
--- orig/source/vc_decorate.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/vc_decorate.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_decorate.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -1724,16 +1724,16 @@
 	//	Find the method. First try with decorate_ prefix, then without.
 	sc->ExpectIdentifier();
 	VMethod* M = Class->FindMethod(va("decorate_%s", *sc->String));
-	if (!M)
+	if (M == NULL)
 	{
 		M = Class->FindMethod(*sc->String);
 	}
-	if (!M)
+	if (M == NULL)
 	{
 		sc->Error(va("Method %s not found in class %s", *sc->String,
 			Class->GetName()));
 	}
-	if (M->ReturnType.Type != TYPE_Void)
+	if (M != NULL && M->ReturnType.Type != TYPE_Void)
 	{
 		sc->Error(va("State action %s doesn't return void", *sc->String));
 	}
@@ -2196,8 +2196,8 @@
 
 		for (size_t i = 1; i < FramesString.Length(); i++)
 		{
-			char FChar = VStr::ToUpper(FramesString[i]);
-			if (FChar < 'A' || FChar > ']')
+			char FSChar = VStr::ToUpper(FramesString[i]);
+			if (FSChar < 'A' || FSChar > ']')
 			{
 				sc->Error("Frames must be A-Z, [, \\ or ]");
 			}
@@ -2207,7 +2207,7 @@
 				sc->GetLoc());
 			States.Append(s2);
 			s2->SpriteName = State->SpriteName;
-			s2->Frame = (State->Frame & VState::FF_FULLBRIGHT) | (FChar - 'A');
+			s2->Frame = (State->Frame & VState::FF_FULLBRIGHT) | (FSChar - 'A');
 			s2->Time = State->Time;
 			s2->Misc1 = State->Misc1;
 			s2->Misc2 = State->Misc2;
@@ -2238,7 +2238,7 @@
 {
 	guard(ParseParentState);
 	TLocation TmpLoc = sc->GetLoc();
-	VState* State;
+	VState* State = NULL;
 	//	If there's a string token on next line, it gets eaten. Is this a bug?
 	if (sc->GetString() && !sc->Crossed)
 	{
@@ -2322,7 +2322,7 @@
 	}
 
 	VClass* DupCheck = VClass::FindClassLowerCase(*NameStr.ToLower());
-	if (DupCheck && DupCheck->MemberType == MEMBER_Class)
+	if (DupCheck != NULL && DupCheck->MemberType == MEMBER_Class)
 	{
 		sc->Message(va("Warning: Redeclared class %s", *NameStr));
 	}
@@ -2353,11 +2353,11 @@
 	if (ParentStr.IsNotEmpty())
 	{
 		ParentClass = VClass::FindClassLowerCase(*ParentStr.ToLower());
-		if (!ParentClass || ParentClass->MemberType != MEMBER_Class)
+		if (ParentClass == NULL || ParentClass->MemberType != MEMBER_Class)
 		{
 			sc->Error(va("Parent class %s not found", *ParentStr));
 		}
-		if (!ParentClass->IsChildOf(ActorClass))
+		if (ParentClass != NULL && !ParentClass->IsChildOf(ActorClass))
 		{
 			sc->Error(va("Parent class %s is not an actor class", *ParentStr));
 		}
@@ -2367,7 +2367,7 @@
 		sc->GetLoc());
 	DecPkg->ParsedClasses.Append(Class);
 
-	if (ParentClass)
+	if (Class)
 	{
 		//	Copy class fixups of the parent class.
 		for (int i = 0; i < ClassFixups.Num(); i++)
@@ -2389,11 +2389,11 @@
 	{
 		sc->ExpectString();
 		ReplaceeClass = VClass::FindClassLowerCase(*sc->String.ToLower());
-		if (!ReplaceeClass || ReplaceeClass->MemberType != MEMBER_Class)
+		if (ReplaceeClass == NULL || ReplaceeClass->MemberType != MEMBER_Class)
 		{
 			sc->Error(va("Replaced class %s not found", *sc->String));
 		}
-		if (!ReplaceeClass->IsChildOf(ActorClass))
+		if (ReplaceeClass != NULL && !ReplaceeClass->IsChildOf(ActorClass))
 		{
 			sc->Error(va("Replaced class %s is not an actor class", *sc->String));
 		}
@@ -2627,7 +2627,7 @@
 						//	Check pain chances array for replacements.
 						TArray<VPainChanceInfo>& PainChances = GetClassPainChances(Class);
 						VPainChanceInfo* PC = NULL;
-						for (int i = 0; i < PainChances.Num(); i++)
+						for (i = 0; i < PainChances.Num(); i++)
 						{
 							if (PainChances[i].DamageType == DamageType)
 							{
@@ -2652,7 +2652,7 @@
 					if (!sc->CheckFloat())
 					{
 						sc->ExpectString();
-						VName DamageType = !sc->String.ICmp("Normal") ? NAME_None :
+						DamageType = !sc->String.ICmp("Normal") ? NAME_None :
 							VName(*sc->String);
 						sc->Expect(",");
 						sc->ExpectFloat();
@@ -2661,7 +2661,7 @@
 					//	Check damage factors array for replacements.
 					TArray<VDamageFactor> DamageFactors = GetClassDamageFactors(Class);
 					VDamageFactor* DF = NULL;
-					for (int i = 0; i < DamageFactors.Num(); i++)
+					for (i = 0; i < DamageFactors.Num(); i++)
 					{
 						if (DamageFactors[i].DamageType == DamageType)
 						{
@@ -2896,13 +2896,13 @@
 					}
 					break;
 				case PROP_ClearFlags:
-					for (int j = 0; j < FlagList.Num(); j++)
+					for (j = 0; j < FlagList.Num(); j++)
 					{
 						if (FlagList[j].Class != ActorClass)
 						{
 							continue;
 						}
-						for (int i = 0; i < FlagList[j].Flags.Num(); i++)
+						for (i = 0; i < FlagList[j].Flags.Num(); i++)
 						{
 							VFlagDef& F = FlagList[j].Flags[i];
 							switch (F.Type)
@@ -2981,7 +2981,7 @@
 					break;
 				}
 				case PROP_Args:
-					for (int i = 0; i < 5; i++)
+					for (i = 0; i < 5; i++)
 					{
 						sc->ExpectNumber();
 						P.Field->SetInt(DefObj, sc->Number, i);
@@ -3034,9 +3034,9 @@
 							vuint32 Col;
 							sc->ExpectString();
 							Col = M_ParseColour(sc->String);
-							r = (Col >> 16) & 0xff;
-							g = (Col >> 8) & 0xff;
-							b = Col & 0xff;
+							r = (Col >> 16) & 255;
+							g = (Col >> 8) & 255;
+							b = Col & 255;
 						}
 						sc->Check(",");
 						sc->ExpectFloat();
@@ -3272,6 +3272,10 @@
 		if (DurColon >= 0)
 		{
 			Duration = atoi(pFrame);
+			if (Duration < 1 || Duration > 65534)
+			{
+				sc->Error ("Rates must be in the range [0,65534]");
+			}
 			pFrame = *Tokens[TokIdx] + DurColon + 1;
 		}
 
@@ -3300,7 +3304,7 @@
 					sc->GetLoc());
 				States.Append(State);
 				State->Frame = *pFrame - 'A';
-				State->Time = Duration >= 0 ? float(Duration) / 35.0 : -1.0;
+				State->Time = float(Duration) / 35.0;
 			}
 			pFrame++;
 		}
@@ -3717,7 +3721,7 @@
 		}
 		else if (sc->Check("Shadow"))
 		{
-			GCon->Logf("Shadow flag is not currently supported");
+			SetClassFieldBool(Class, "bShadow", true);
 		}
 		else if (sc->Check("NoBlood"))
 		{
@@ -3835,14 +3839,14 @@
 		mobjinfo_t& MI = VClass::GMobjInfos.Alloc();
 		MI.Class = Class;
 		MI.DoomEdNum = DoomEdNum;
-		MI.GameFilter = GameFilter;
+		MI.GameFilter = GameFilter ? GameFilter : GAME_Any;
 	}
 	if (SpawnNum > 0)
 	{
 		mobjinfo_t& SI = VClass::GScriptIds.Alloc();
 		SI.Class = Class;
 		SI.DoomEdNum = SpawnNum;
-		SI.GameFilter = GameFilter;
+		SI.GameFilter = GameFilter ? GameFilter : GAME_Any;
 	}
 
 	//	Set up linked list of states.
@@ -3867,7 +3871,7 @@
 	}
 
 	//	Set up links of spawn states.
-	if (SpawnEnd - SpawnStart == 1)
+	if (States.Num() == 1)
 	{
 		States[SpawnStart]->Time = -1.0;
 	}
diff -Nur orig/source/vc_decorate.h mod/source/vc_decorate.h
--- orig/source/vc_decorate.h	2008-08-15 21:57:33.000000000 +0200
+++ mod/source/vc_decorate.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_decorate.h 3740 2008-08-15 19:59:17Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_dehacked.cpp mod/source/vc_dehacked.cpp
--- orig/source/vc_dehacked.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_dehacked.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_dehacked.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -45,7 +45,7 @@
 {
 	int				Which;
 	const char*		Name;
-	int				Mask;
+	vuint32			Mask;
 };
 
 // EXTERNAL FUNCTION PROTOTYPES --------------------------------------------
@@ -1962,12 +1962,12 @@
 		sc->ExpectString();
 		VStr MethodName = sc->String;
 		VClass* Class = VClass::FindClass(*ClassName);
-		if (!Class)
+		if (Class == NULL)
 		{
 			sc->Error("No such class");
 		}
 		VMethod* Method = Class->FindMethod(*MethodName);
-		if (!Method)
+		if (Method == NULL)
 		{
 			sc->Error(va("No such method %s", *MethodName));
 		}
@@ -2070,13 +2070,13 @@
 		{
 			GCon->Logf("Processing dehacked patch %s", GArgs[p]);
 
-			VStream* Strm = FL_OpenSysFileRead(GArgs[p]);
-			if (!Strm)
+			VStream* AStrm = FL_OpenSysFileRead(GArgs[p]);
+			if (!AStrm)
 			{
 				GCon->Logf("No such file");
 				continue;
 			}
-			LoadDehackedFile(Strm);
+			LoadDehackedFile(AStrm);
 		}
 	}
 	if (LumpNum >= 0)
diff -Nur orig/source/vc_dehacked.h mod/source/vc_dehacked.h
--- orig/source/vc_dehacked.h	2008-02-23 21:59:15.000000000 +0100
+++ mod/source/vc_dehacked.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_dehacked.h 3172 2008-02-23 21:02:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_emit_context.cpp mod/source/vc_emit_context.cpp
--- orig/source/vc_emit_context.cpp	2008-09-09 22:50:46.000000000 +0200
+++ mod/source/vc_emit_context.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_emit_context.cpp 3764 2008-09-09 20:52:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -73,13 +73,13 @@
 	SelfClass = (VClass*)CM;
 
 	VMemberBase* PM = Member;
-	while (PM && PM->MemberType != MEMBER_Package)
+	while (PM != NULL && PM->MemberType != MEMBER_Package)
 	{
 		PM = PM->Outer;
 	}
 	Package = (VPackage*)PM;
 
-	if (Member->MemberType == MEMBER_Method)
+	if (Member != NULL && Member->MemberType == MEMBER_Method)
 	{
 		CurrentFunc = (VMethod*)Member;
 		CurrentFunc->Instructions.Clear();
diff -Nur orig/source/vc_emit_context.h mod/source/vc_emit_context.h
--- orig/source/vc_emit_context.h	2008-02-04 20:46:22.000000000 +0100
+++ mod/source/vc_emit_context.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_emit_context.h 3107 2008-02-04 19:49:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_error.cpp mod/source/vc_error.cpp
--- orig/source/vc_error.cpp	2008-09-09 23:55:38.000000000 +0200
+++ mod/source/vc_error.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_error.cpp 3766 2008-09-09 21:57:56Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_error.h mod/source/vc_error.h
--- orig/source/vc_error.h	2008-09-09 23:55:39.000000000 +0200
+++ mod/source/vc_error.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_error.h 3766 2008-09-09 21:57:56Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_array.cpp mod/source/vc_expr_array.cpp
--- orig/source/vc_expr_array.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_expr_array.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_array.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_array.h mod/source/vc_expr_array.h
--- orig/source/vc_expr_array.h	2008-02-09 19:18:10.000000000 +0100
+++ mod/source/vc_expr_array.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_array.h 3135 2008-02-09 18:21:29Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_assign.cpp mod/source/vc_expr_assign.cpp
--- orig/source/vc_expr_assign.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_expr_assign.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_assign.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_assign.h mod/source/vc_expr_assign.h
--- orig/source/vc_expr_assign.h	2008-02-09 19:18:11.000000000 +0100
+++ mod/source/vc_expr_assign.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_assign.h 3135 2008-02-09 18:21:29Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_base.cpp mod/source/vc_expr_base.cpp
--- orig/source/vc_expr_base.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_expr_base.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_base.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_base.h mod/source/vc_expr_base.h
--- orig/source/vc_expr_base.h	2008-03-02 18:07:09.000000000 +0100
+++ mod/source/vc_expr_base.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_base.h 3212 2008-03-02 17:10:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_cast.cpp mod/source/vc_expr_cast.cpp
--- orig/source/vc_expr_cast.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_expr_cast.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_cast.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_cast.h mod/source/vc_expr_cast.h
--- orig/source/vc_expr_cast.h	2008-02-04 21:41:05.000000000 +0100
+++ mod/source/vc_expr_cast.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_cast.h 3108 2008-02-04 20:44:24Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_field.cpp mod/source/vc_expr_field.cpp
--- orig/source/vc_expr_field.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_expr_field.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_field.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_field.h mod/source/vc_expr_field.h
--- orig/source/vc_expr_field.h	2008-02-09 19:18:11.000000000 +0100
+++ mod/source/vc_expr_field.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_field.h 3135 2008-02-09 18:21:29Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_invoke.cpp mod/source/vc_expr_invoke.cpp
--- orig/source/vc_expr_invoke.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/vc_expr_invoke.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_invoke.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -201,7 +201,7 @@
 			return e->Resolve(ec);
 		}
 		VField* field = ec.SelfClass->FindField(Name, Loc, ec.SelfClass);
-		if (field && field->Type.Type == TYPE_Delegate)
+		if (field != NULL && field->Type.Type == TYPE_Delegate)
 		{
 			VExpression* e = new VInvocation(NULL, field->Func, field,
 				false, false, Loc, NumArgs, Args);
@@ -522,16 +522,16 @@
 	bool ArgsOk = true;
 	for (int i = 0; i < NumArgs; i++)
 	{
-		if (Args[i])
+		if (Args[i] != NULL)
 		{
 			Args[i] = Args[i]->Resolve(ec);
-			if (!Args[i])
+			if (Args[i] == NULL)
 			{
 				ArgsOk = false;
 			}
 		}
 	}
-	if (!ArgsOk)
+	if (ArgsOk == false)
 	{
 		delete this;
 		return NULL;
@@ -541,9 +541,13 @@
 
 	Type  = Func->ReturnType;
 	if (Type.Type == TYPE_Byte || Type.Type == TYPE_Bool)
+	{
 		Type = VFieldType(TYPE_Int);
+	}
 	if (Func->Flags & FUNC_Spawner)
+	{
 		Type.Class = Args[0]->Type.Class;
+	}
 	return this;
 	unguard;
 }
@@ -740,7 +744,7 @@
 					if (!Args[i]->Type.Equals(Func->ParamTypes[i]))
 					{
 						//FIXME This should be error.
-						if (!Func->ParamFlags[NumArgs] & FPARM_Optional)
+						if (!(Func->ParamFlags[NumArgs] & FPARM_Optional))
 						{
 							Args[i]->Type.CheckMatch(Args[i]->Loc, Func->ParamTypes[i]);
 							//ParseError(Args[i]->Loc, "Out parameter types must be equal");
@@ -750,7 +754,7 @@
 				}
 				else
 				{
-					if (!Func->ParamFlags[NumArgs] & FPARM_Optional)
+					if (!(Func->ParamFlags[NumArgs] & FPARM_Optional))
 					{
 						Args[i]->Type.CheckMatch(Args[i]->Loc, Func->ParamTypes[i]);
 					}
@@ -815,6 +819,10 @@
 	{
 		max_params = Func->NumParams;
 	}
+	if (NumArgs > max_params)
+	{
+		ParseError(Loc, "Incorrect number of arguments, need %d, got %d.", max_params, NumArgs);
+	}
 
 	for (int i = 0; i < NumArgs; i++)
 	{
diff -Nur orig/source/vc_expr_invoke.h mod/source/vc_expr_invoke.h
--- orig/source/vc_expr_invoke.h	2008-03-21 08:32:23.000000000 +0100
+++ mod/source/vc_expr_invoke.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_invoke.h 3350 2008-03-21 07:35:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_literal.cpp mod/source/vc_expr_literal.cpp
--- orig/source/vc_expr_literal.cpp	2008-09-09 22:50:46.000000000 +0200
+++ mod/source/vc_expr_literal.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_literal.cpp 3764 2008-09-09 20:52:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_literal.h mod/source/vc_expr_literal.h
--- orig/source/vc_expr_literal.h	2008-02-24 23:10:14.000000000 +0100
+++ mod/source/vc_expr_literal.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_literal.h 3185 2008-02-24 22:14:13Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_local.cpp mod/source/vc_expr_local.cpp
--- orig/source/vc_expr_local.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_expr_local.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_local.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -120,7 +120,7 @@
 		}
 
 		e.TypeExpr = e.TypeExpr->ResolveAsType(ec);
-		if (!e.TypeExpr)
+		if (e.TypeExpr == NULL)
 		{
 			continue;
 		}
diff -Nur orig/source/vc_expr_local.h mod/source/vc_expr_local.h
--- orig/source/vc_expr_local.h	2008-02-09 19:18:11.000000000 +0100
+++ mod/source/vc_expr_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_local.h 3135 2008-02-09 18:21:29Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_misc.cpp mod/source/vc_expr_misc.cpp
--- orig/source/vc_expr_misc.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/vc_expr_misc.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_misc.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_misc.h mod/source/vc_expr_misc.h
--- orig/source/vc_expr_misc.h	2008-03-21 08:32:23.000000000 +0100
+++ mod/source/vc_expr_misc.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_misc.h 3350 2008-03-21 07:35:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_type.cpp mod/source/vc_expr_type.cpp
--- orig/source/vc_expr_type.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_expr_type.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_type.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_type.h mod/source/vc_expr_type.h
--- orig/source/vc_expr_type.h	2008-02-04 22:01:59.000000000 +0100
+++ mod/source/vc_expr_type.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_type.h 3109 2008-02-04 21:05:18Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_expr_unary_binary.cpp mod/source/vc_expr_unary_binary.cpp
--- orig/source/vc_expr_unary_binary.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_expr_unary_binary.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_expr_unary_binary.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_field.cpp mod/source/vc_field.cpp
--- orig/source/vc_field.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_field.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_field.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_field.h mod/source/vc_field.h
--- orig/source/vc_field.h	2008-12-25 18:00:27.000000000 +0100
+++ mod/source/vc_field.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_field.h 3897 2008-12-25 17:11:02Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_lexer.cpp mod/source/vc_lexer.cpp
--- orig/source/vc_lexer.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_lexer.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_lexer.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_lexer.h mod/source/vc_lexer.h
--- orig/source/vc_lexer.h	2008-09-09 23:32:26.000000000 +0200
+++ mod/source/vc_lexer.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_lexer.h 3765 2008-09-09 21:34:40Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_local.h mod/source/vc_local.h
--- orig/source/vc_local.h	2008-09-10 00:20:28.000000000 +0200
+++ mod/source/vc_local.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_local.h 3769 2008-09-09 22:22:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_location.cpp mod/source/vc_location.cpp
--- orig/source/vc_location.cpp	2008-02-02 19:40:08.000000000 +0100
+++ mod/source/vc_location.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_location.cpp 3101 2008-02-02 18:43:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_location.h mod/source/vc_location.h
--- orig/source/vc_location.h	2008-02-02 19:40:08.000000000 +0100
+++ mod/source/vc_location.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_location.h 3101 2008-02-02 18:43:32Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_member.cpp mod/source/vc_member.cpp
--- orig/source/vc_member.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_member.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_member.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_member.h mod/source/vc_member.h
--- orig/source/vc_member.h	2008-10-19 23:08:02.000000000 +0200
+++ mod/source/vc_member.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_member.h 3833 2008-10-19 21:10:53Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_method.cpp mod/source/vc_method.cpp
--- orig/source/vc_method.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_method.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_method.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_method.h mod/source/vc_method.h
--- orig/source/vc_method.h	2010-03-02 20:56:39.000000000 +0100
+++ mod/source/vc_method.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_method.h 4132 2010-03-02 19:59:53Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_modifiers.cpp mod/source/vc_modifiers.cpp
--- orig/source/vc_modifiers.cpp	2008-09-10 00:03:46.000000000 +0200
+++ mod/source/vc_modifiers.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_modifiers.cpp 3767 2008-09-09 22:06:04Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_modifiers.h mod/source/vc_modifiers.h
--- orig/source/vc_modifiers.h	2008-09-10 00:16:18.000000000 +0200
+++ mod/source/vc_modifiers.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_modifiers.h 3768 2008-09-09 22:18:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_object.cpp mod/source/vc_object.cpp
--- orig/source/vc_object.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_object.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_object.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -99,7 +99,7 @@
 
 //==========================================================================
 //
-//	VObject::StaticInit
+//	VObject::operator new
 //
 //==========================================================================
 
@@ -115,7 +115,7 @@
 
 //==========================================================================
 //
-//	VObject::StaticInit
+//	VObject::operator new
 //
 //==========================================================================
 
@@ -131,7 +131,7 @@
 
 //==========================================================================
 //
-//	VObject::StaticInit
+//	VObject::operator delete
 //
 //==========================================================================
 
@@ -142,7 +142,7 @@
 
 //==========================================================================
 //
-//	VObject::StaticInit
+//	VObject::operator delete
 //
 //==========================================================================
 
@@ -204,7 +204,7 @@
 
 	//	Find native class.
 	VClass* NativeClass = AClass;
-	while (NativeClass && !(NativeClass->ObjectFlags & CLASSOF_Native))
+	while (NativeClass != NULL && !(NativeClass->ObjectFlags & CLASSOF_Native))
 	{
 		NativeClass = NativeClass->GetSuperClass();
 	}
@@ -477,12 +477,12 @@
 
 IMPLEMENT_FUNCTION(VObject, Error)
 {
-	Host_Error(*PF_FormatString());
+	Host_Error("%s", *PF_FormatString());
 }
 
 IMPLEMENT_FUNCTION(VObject, FatalError)
 {
-	Sys_Error(*PF_FormatString());
+	Sys_Error("%s", *PF_FormatString());
 }
 
 //**************************************************************************
@@ -1115,7 +1115,7 @@
 		{
 			VObject* Check = VObject::GetIndexObject(Index);
 			Index++;
-			if (Check && !(Check->GetFlags() & _OF_DelayedDestroy) &&
+			if (Check != NULL && !(Check->GetFlags() & _OF_DelayedDestroy) &&
 				Check->IsA(BaseClass))
 			{
 				*Out = Check;
@@ -1273,11 +1273,11 @@
 	if (Idx < 0)
 		host_cycles[-Idx]++;
 	else
-		clock(host_cycles[Idx]);
+		clock_cycle(host_cycles[Idx]);
 }
 
 IMPLEMENT_FUNCTION(VObject, Unclock)
 {
 	P_GET_INT(Idx);
-	unclock(host_cycles[Idx]);
+	unclock_cycle(host_cycles[Idx]);
 }
diff -Nur orig/source/vc_object.h mod/source/vc_object.h
--- orig/source/vc_object.h	2010-04-03 16:16:11.000000000 +0200
+++ mod/source/vc_object.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_object.h 4201 2010-04-03 14:20:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -334,6 +334,7 @@
 
 #ifdef CLIENT
 	DECLARE_FUNCTION(P_GetMapName)
+	DECLARE_FUNCTION(P_GetMapIndexByLevelNum)
 	DECLARE_FUNCTION(P_GetMapLumpName)
 	DECLARE_FUNCTION(P_TranslateMap)
 	DECLARE_FUNCTION(P_GetNumEpisodes)
@@ -383,6 +384,7 @@
 	DECLARE_FUNCTION(SetSeqTrans)
 	DECLARE_FUNCTION(GetSeqTrans)
 	DECLARE_FUNCTION(GetSeqSlot)
+	DECLARE_FUNCTION(StopAllSounds)
 
 	DECLARE_FUNCTION(SB_Start)
 	DECLARE_FUNCTION(TerrainType)
diff -Nur orig/source/vc_package.cpp mod/source/vc_package.cpp
--- orig/source/vc_package.cpp	2010-06-04 23:20:22.000000000 +0200
+++ mod/source/vc_package.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_package.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -690,7 +690,7 @@
 
 	//	Print statistics.
 	dprintf("            count   size\n");
-	dprintf("Header     %6d %6ld\n", 1, sizeof(progs));
+	dprintf("Header     %6d %6ld\n", 1, (long int)sizeof(progs));
 	dprintf("Names      %6d %6d\n", Writer.Names.Num(), progs.ofs_strings - progs.ofs_names);
 	dprintf("Strings    %6d %6d\n", StringInfo.Num(), Strings.Num());
 	dprintf("Builtins   %6d\n", NumBuiltins);
@@ -711,8 +711,6 @@
 		Writer << ((int*)&progs)[i];
 	}
 
-	fclose(f);
-
 #ifdef OPCODE_STATS
 	dprintf("\n-----------------------------------------------\n\n");
 	for (i = 0; i < NUM_OPCODES; i++)
@@ -721,6 +719,8 @@
 	}
 	dprintf("%d opcodes\n", NUM_OPCODES);
 #endif
+
+	fclose(f);
 	unguard;
 }
 
diff -Nur orig/source/vc_package.h mod/source/vc_package.h
--- orig/source/vc_package.h	2008-12-17 22:03:00.000000000 +0100
+++ mod/source/vc_package.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_package.h 3894 2008-12-17 21:11:22Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_parser.cpp mod/source/vc_parser.cpp
--- orig/source/vc_parser.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_parser.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_parser.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -1855,8 +1855,8 @@
 
 		for (size_t i = 1; i < VStr::Length(*FramesString); i++)
 		{
-			char FChar = VStr::ToUpper((*FramesString)[i]);
-			if (FChar < 'A' || FChar > ']')
+			char FSChar = VStr::ToUpper((*FramesString)[i]);
+			if (FSChar < 'A' || FSChar > ']')
 			{
 				ParseError(Lex.Location, "Frames must be A-Z, [, \\ or ]");
 			}
@@ -1866,7 +1866,7 @@
 			VState* s2 = new VState(StateName, InClass, TmpLoc);
 			InClass->AddState(s2);
 			s2->SpriteName = s->SpriteName;
-			s2->Frame = (s->Frame & VState::FF_FULLBRIGHT) | (FChar - 'A');
+			s2->Frame = (s->Frame & VState::FF_FULLBRIGHT) | (FSChar - 'A');
 			s2->Time = s->Time;
 			s2->Misc1 = s->Misc1;
 			s2->Misc2 = s->Misc2;
diff -Nur orig/source/vc_parser.h mod/source/vc_parser.h
--- orig/source/vc_parser.h	2008-09-10 00:20:28.000000000 +0200
+++ mod/source/vc_parser.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_parser.h 3769 2008-09-09 22:22:46Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_property.cpp mod/source/vc_property.cpp
--- orig/source/vc_property.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/vc_property.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_property.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_property.h mod/source/vc_property.h
--- orig/source/vc_property.h	2008-12-17 20:58:27.000000000 +0100
+++ mod/source/vc_property.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_property.h 3893 2008-12-17 20:06:48Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_state.cpp mod/source/vc_state.cpp
--- orig/source/vc_state.cpp	2008-09-10 23:26:03.000000000 +0200
+++ mod/source/vc_state.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_state.cpp 3779 2008-09-10 21:28:18Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_state.h mod/source/vc_state.h
--- orig/source/vc_state.h	2008-09-10 23:26:03.000000000 +0200
+++ mod/source/vc_state.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_state.h 3779 2008-09-10 21:28:18Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_statement.cpp mod/source/vc_statement.cpp
--- orig/source/vc_statement.cpp	2010-06-04 23:20:23.000000000 +0200
+++ mod/source/vc_statement.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_statement.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_statement.h mod/source/vc_statement.h
--- orig/source/vc_statement.h	2008-10-12 22:27:12.000000000 +0200
+++ mod/source/vc_statement.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_statement.h 3810 2008-10-12 20:29:47Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_struct.cpp mod/source/vc_struct.cpp
--- orig/source/vc_struct.cpp	2008-09-09 22:50:46.000000000 +0200
+++ mod/source/vc_struct.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_struct.cpp 3764 2008-09-09 20:52:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_struct.h mod/source/vc_struct.h
--- orig/source/vc_struct.h	2008-02-07 21:41:34.000000000 +0100
+++ mod/source/vc_struct.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_struct.h 3133 2008-02-07 20:44:54Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_type.cpp mod/source/vc_type.cpp
--- orig/source/vc_type.cpp	2010-09-01 20:26:05.000000000 +0200
+++ mod/source/vc_type.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_type.cpp 4327 2010-07-24 19:30:53Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/vc_type.h mod/source/vc_type.h
--- orig/source/vc_type.h	2008-02-23 21:59:15.000000000 +0100
+++ mod/source/vc_type.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vc_type.h 3172 2008-02-23 21:02:59Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/video.h mod/source/video.h
--- orig/source/video.h	2006-06-27 21:47:30.000000000 +0200
+++ mod/source/video.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: video.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/wad.cpp mod/source/wad.cpp
--- orig/source/wad.cpp	2010-06-04 23:20:21.000000000 +0200
+++ mod/source/wad.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: wad.cpp 4297 2010-06-03 22:49:00Z firebrand_kh $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/wad.h mod/source/wad.h
--- orig/source/wad.h	2008-11-13 22:44:16.000000000 +0100
+++ mod/source/wad.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: wad.h 3863 2008-11-13 21:47:26Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/winlocal.h mod/source/winlocal.h
--- orig/source/winlocal.h	2006-12-05 18:51:20.000000000 +0100
+++ mod/source/winlocal.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: winlocal.h 1879 2006-12-05 10:36:08Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/zipstream.cpp mod/source/zipstream.cpp
--- orig/source/zipstream.cpp	2009-11-11 23:28:41.000000000 +0100
+++ mod/source/zipstream.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: zipstream.cpp 4101 2009-11-11 22:30:15Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/source/zipstream.h mod/source/zipstream.h
--- orig/source/zipstream.h	2009-11-10 23:39:22.000000000 +0100
+++ mod/source/zipstream.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**      ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**       #    ##    ##    #      ####     ####   ##       ##
 //**
-//**    $Id: zipstream.h 4091 2009-11-10 22:41:03Z dj_jl $
+//**    $Id$
 //**
 //**    Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/acc/parse.c mod/utils/acc/parse.c
--- orig/utils/acc/parse.c	2010-03-08 19:18:04.000000000 +0100
+++ mod/utils/acc/parse.c	2022-08-12 08:34:35.000000000 +0200
@@ -1884,7 +1884,7 @@
 						}
 						else
 						{
-							symbolNode_t *sym = DemandSymbol (tk_String);
+							sym = DemandSymbol (tk_String);
 							PC_AppendCmd (PCD_PUSHNUMBER);
 							switch (sym->type)
 							{
@@ -3873,7 +3873,7 @@
 	// if there were unspecified indices, multiply the offset by their sizes [JB]
 	if(requiredIndices < sym->info.array.ndim - 1)
 	{
-		int i, mult = 1;
+		int mult = 1;
 		for(i = 0; i < sym->info.array.ndim - requiredIndices - 1; ++i)
 		{
 			mult *= sym->info.array.dimensions[sym->info.array.ndim - 2 - i];
@@ -4018,18 +4018,18 @@
 	sym = SY_Find(name);
 	if(sym == NULL)
 	{
-		char name[MAX_IDENTIFIER_LENGTH];
+		char v_name[MAX_IDENTIFIER_LENGTH];
 
-		strcpy (name, tk_String);
+		strcpy (v_name, tk_String);
 		TK_NextToken();
 		if(tk_Token == TK_LPAREN)
 		{ // Looks like a function call
-			sym = SpeculateFunction(name, hasReturn);
+			sym = SpeculateFunction(v_name, hasReturn);
 			TK_Undo();
 		}
 		else
 		{
-			ERR_Exit(ERR_UNKNOWN_IDENTIFIER, YES, name);
+			ERR_Exit(ERR_UNKNOWN_IDENTIFIER, YES, v_name);
 		}
 	}
 	return sym;
diff -Nur orig/utils/acc/pcode.c mod/utils/acc/pcode.c
--- orig/utils/acc/pcode.c	2010-03-08 19:18:04.000000000 +0100
+++ mod/utils/acc/pcode.c	2022-08-12 08:34:35.000000000 +0200
@@ -683,8 +683,6 @@
 	STR_WriteListChunk(STRLIST_PICS, MAKE4CC('P','I','C','S'), NO);
 	if(MapVariablesInit)
 	{
-		int j;
-
 		for(i = 0; i < pa_MapVarCount; ++i)
 		{
 			if(MapVariables[i].initializer != 0)
@@ -799,8 +797,6 @@
 
 	if(NumArrays)
 	{
-		int count;
-
 		// Arrays defined here
 		for(count = 0, i = 0; i < pa_MapVarCount; ++i)
 		{
@@ -825,8 +821,6 @@
 			{
 				if(ArrayInits[i])
 				{
-					int j;
-
 					PC_Append("AINI", 4);
 					PC_AppendInt(ArraySizes[i]*4+4);
 					PC_AppendInt((U_INT)i);
diff -Nur orig/utils/common/cmdlib.cpp mod/utils/common/cmdlib.cpp
--- orig/utils/common/cmdlib.cpp	2010-12-23 20:47:55.000000000 +0100
+++ mod/utils/common/cmdlib.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cmdlib.cpp 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -268,6 +268,7 @@
 
 	if (count != length)
 	{
+		Z_Free(buffer);
 		Error("Couldn't read file \"%s\".", name);
 	}
 
diff -Nur orig/utils/common/cmdlib.h mod/utils/common/cmdlib.h
--- orig/utils/common/cmdlib.h	2010-04-04 10:18:00.000000000 +0200
+++ mod/utils/common/cmdlib.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: cmdlib.h 4215 2010-04-04 08:22:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/fmapdefs.h mod/utils/common/fmapdefs.h
--- orig/utils/common/fmapdefs.h	2006-07-06 19:19:49.000000000 +0200
+++ mod/utils/common/fmapdefs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fmapdefs.h 1599 2006-07-06 17:20:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/fmd2defs.h mod/utils/common/fmd2defs.h
--- orig/utils/common/fmd2defs.h	2006-07-06 19:19:49.000000000 +0200
+++ mod/utils/common/fmd2defs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fmd2defs.h 1599 2006-07-06 17:20:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/ftexdefs.h mod/utils/common/ftexdefs.h
--- orig/utils/common/ftexdefs.h	2006-09-27 01:32:53.000000000 +0200
+++ mod/utils/common/ftexdefs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: ftexdefs.h 1741 2006-09-26 23:26:48Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/fwaddefs.h mod/utils/common/fwaddefs.h
--- orig/utils/common/fwaddefs.h	2006-06-27 21:47:31.000000000 +0200
+++ mod/utils/common/fwaddefs.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fwaddefs.h 1583 2006-06-27 19:05:42Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/imglib.cpp mod/utils/common/imglib.cpp
--- orig/utils/common/imglib.cpp	2010-04-03 18:27:58.000000000 +0200
+++ mod/utils/common/imglib.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: imglib.cpp 4206 2010-04-03 16:32:33Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -234,12 +234,12 @@
 		hdr->img_type == 9 || hdr->img_type == 11)
 	{
 		ImgBPP = 8;
-		ImgData = (vuint8*)Z_Malloc(ImgWidth * ImgHeight);
+		ImgData = new vuint8[ImgWidth * ImgHeight];
 	}
 	else
 	{
 		ImgBPP = 32;
-		ImgData = (vuint8*)Z_Malloc(ImgWidth * ImgHeight * 4);
+		ImgData = new vuint8[ImgWidth * ImgHeight * 4];
 	}
 
 	if (hdr->img_type == 1 && hdr->bpp == 8 && hdr->pal_type == 1)
@@ -568,7 +568,7 @@
 {
 	if (ImgBPP == 8)
 	{
-		rgba_t *NewData = (rgba_t *)Z_Malloc(ImgWidth * ImgHeight * 4);
+		rgba_t *NewData = (rgba_t *)new vuint8[ImgWidth * ImgHeight * 4];
 		for (int i = 0; i < ImgWidth * ImgHeight; i++)
 		{
 			NewData[i].r = ImgPal[ImgData[i]].r;
@@ -576,7 +576,7 @@
 			NewData[i].b = ImgPal[ImgData[i]].b;
 			NewData[i].a = 255;
 		}
-		Z_Free(ImgData);
+		delete[] ImgData;
 		ImgData = (vuint8*)NewData;
 		ImgBPP = 32;
 	}
@@ -592,7 +592,7 @@
 {
 	if (ImgData)
 	{
-		delete ImgData;
+		delete[] ImgData;
 		ImgData = NULL;
 	}
 }
diff -Nur orig/utils/common/imglib.h mod/utils/common/imglib.h
--- orig/utils/common/imglib.h	2006-07-06 19:19:49.000000000 +0200
+++ mod/utils/common/imglib.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: imglib.h 1599 2006-07-06 17:20:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/scrlib.cpp mod/utils/common/scrlib.cpp
--- orig/utils/common/scrlib.cpp	2010-09-01 20:26:06.000000000 +0200
+++ mod/utils/common/scrlib.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: scrlib.cpp 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/scrlib.h mod/utils/common/scrlib.h
--- orig/utils/common/scrlib.h	2006-07-06 19:19:49.000000000 +0200
+++ mod/utils/common/scrlib.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: scrlib.h 1599 2006-07-06 17:20:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/common/wadlib.cpp mod/utils/common/wadlib.cpp
--- orig/utils/common/wadlib.cpp	2010-04-21 15:15:40.000000000 +0200
+++ mod/utils/common/wadlib.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: wadlib.cpp 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -98,7 +98,7 @@
 		lump_p->size = LittleLong(fi_p->size);
 	}
 	
-	delete fileinfo;
+	delete[] fileinfo;
 	fileinfo = NULL;
 }
 
diff -Nur orig/utils/common/wadlib.h mod/utils/common/wadlib.h
--- orig/utils/common/wadlib.h	2006-07-06 19:19:49.000000000 +0200
+++ mod/utils/common/wadlib.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: wadlib.h 1599 2006-07-06 17:20:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/fixmd2/fixmd2.cpp mod/utils/fixmd2/fixmd2.cpp
--- orig/utils/fixmd2/fixmd2.cpp	2006-07-06 19:19:49.000000000 +0200
+++ mod/utils/fixmd2/fixmd2.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: fixmd2.cpp 1599 2006-07-06 17:20:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/glbsp/level.c mod/utils/glbsp/level.c
--- orig/utils/glbsp/level.c	2007-08-10 19:07:07.000000000 +0200
+++ mod/utils/glbsp/level.c	2022-08-12 08:34:35.000000000 +0200
@@ -255,7 +255,7 @@
   PrintDebug("GetVertices: num = %d\n", count);
 # endif
 
-  if (!lump || count == 0)
+  if (lump == NULL || count == 0)
     FatalError("Couldn't find any Vertices");
 
   raw = (raw_vertex_t *) lump->data;
@@ -287,7 +287,7 @@
   if (lump)
     count = lump->length / sizeof(raw_sector_t);
 
-  if (!lump || count == 0)
+  if (lump == NULL || count == 0)
     FatalError("Couldn't find any Sectors");
 
   DisplayTicker();
@@ -420,7 +420,7 @@
   if (lump)
     count = lump->length / sizeof(raw_sidedef_t);
 
-  if (!lump || count == 0)
+  if (lump == NULL || count == 0)
     FatalError("Couldn't find any Sidedefs");
 
   DisplayTicker();
@@ -517,19 +517,19 @@
     line->right = SafeLookupSidedef(UINT16(raw->sidedef1));
     line->left  = SafeLookupSidedef(UINT16(raw->sidedef2));
 
-    if (line->right)
+    if (line->right != NULL)
     {
       line->right->ref_count++;
       line->right->on_special |= (line->type > 0) ? 1 : 0;
     }
 
-    if (line->left)
+    if (line->left != NULL)
     {
       line->left->ref_count++;
       line->left->on_special |= (line->type > 0) ? 1 : 0;
     }
 
-    line->self_ref = (line->left && line->right &&
+    line->self_ref = (line->left != NULL && line->right != NULL &&
         (line->left->sector == line->right->sector));
 
     line->index = i;
@@ -593,7 +593,7 @@
     line->left  = SafeLookupSidedef(UINT16(raw->sidedef2));
 
     // -JL- Added missing sidedef handling that caused all sidedefs to be pruned
-    if (line->right)
+    if (line->right != NULL)
     {
       line->right->ref_count++;
       line->right->on_special |= (line->type > 0) ? 1 : 0;
@@ -605,7 +605,7 @@
       line->left->on_special |= (line->type > 0) ? 1 : 0;
     }
 
-    line->self_ref = (line->left && line->right &&
+    line->self_ref = (line->left != NULL && line->right != NULL &&
         (line->left->sector == line->right->sector));
 
     line->index = i;
@@ -1673,13 +1673,13 @@
 
   lump = FindLevelLump("VERTEXES");
 
-  if (lump && lump->length > 0)
-    Adler32_AddBlock(&crc, lump->data, lump->length);
+  if (lump != NULL && lump->length > 0)
+    Adler32_AddBlock(&crc, (const uint8_g*)lump->data, lump->length);
 
   lump = FindLevelLump("LINEDEFS");
 
-  if (lump && lump->length > 0)
-    Adler32_AddBlock(&crc, lump->data, lump->length);
+  if (lump != NULL && lump->length > 0)
+    Adler32_AddBlock(&crc, (const uint8_g*)lump->data, lump->length);
 
   Adler32_Finish(&crc);
 
diff -Nur orig/utils/glbsp/node.c mod/utils/glbsp/node.c
--- orig/utils/glbsp/node.c	2007-08-10 19:07:07.000000000 +0200
+++ mod/utils/glbsp/node.c	2022-08-12 08:34:35.000000000 +0200
@@ -428,7 +428,7 @@
       }
     }
     
-    if (line->right)
+    if (line->right != NULL)
     {
       right = CreateOneSeg(line, line->start, line->end, line->right, 0);
       AddSegToSuper(block, right);
@@ -436,12 +436,12 @@
     else
       PrintWarn("Linedef #%d has no right sidedef!\n", line->index);
 
-    if (line->left)
+    if (line->left != NULL)
     {
       left = CreateOneSeg(line, line->end, line->start, line->left, 1);
       AddSegToSuper(block, left);
       
-      if (right)
+      if (right != NULL)
       {
         // -AJA- Partner segs.  These always maintain a one-to-one
         //       correspondence, so if one of the gets split, the
@@ -463,7 +463,7 @@
       // handle the 'One-Sided Window' trick
       if (line->window_effect)
       {
-        seg_t *left = NewSeg();
+        left = NewSeg();
 
         left->start   = line->end;
         left->end     = line->start;
diff -Nur orig/utils/glbsp/util.c mod/utils/glbsp/util.c
--- orig/utils/glbsp/util.c	2010-04-21 15:15:40.000000000 +0200
+++ mod/utils/glbsp/util.c	2022-08-12 08:34:35.000000000 +0200
@@ -92,7 +92,7 @@
   char *result;
   int len = (int)strlen(str);
 
-  result = UtilCalloc(len+1);
+  result = (char *)UtilCalloc(len+1);
 
   if (len > 0)
     memcpy(result, str, len);
@@ -115,7 +115,7 @@
   for (len=0; len < size && str[len]; len++)
   { }
 
-  result = UtilCalloc(len+1);
+  result = (char *)UtilCalloc(len+1);
 
   if (len > 0)
     memcpy(result, str, len);
@@ -140,8 +140,8 @@
 
     buf_size *= 2;
 
-    buf = realloc(buf, buf_size);
-    if (!buf)
+    buf = (char *)realloc(buf, buf_size);
+    if (buf == NULL)
       FatalError("Out of memory (formatting string)");
 
     va_start(args, str);
diff -Nur orig/utils/glbsp/wad.c mod/utils/glbsp/wad.c
--- orig/utils/glbsp/wad.c	2007-08-10 19:07:07.000000000 +0200
+++ mod/utils/glbsp/wad.c	2022-08-12 08:34:35.000000000 +0200
@@ -1089,7 +1089,7 @@
   gl_level = wad.current_level->lev_info->buddy;
 
   // check if already exists
-  for (cur=gl_level->lev_info->children; cur; cur=cur->next)
+  for (cur=gl_level->lev_info->children; cur != NULL; cur=cur->next)
   {
     if (strcmp(name, cur->name) == 0)
       break;
diff -Nur orig/utils/glvis/flow.cpp mod/utils/glvis/flow.cpp
--- orig/utils/glvis/flow.cpp	2010-04-21 15:15:40.000000000 +0200
+++ mod/utils/glvis/flow.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: flow.cpp 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -214,7 +214,7 @@
 		FreeWinding(in);
 		return NULL;
 	}
-	if (dists[0] >= -ON_EPSILON && dists[1] >= -ON_EPSILON)
+	else if (dists[0] >= -ON_EPSILON && dists[1] >= -ON_EPSILON)
 	{
 		return in;
 	}
@@ -282,7 +282,7 @@
 	// check all combinations
 	for (i = 0; i < 2; i++)
 	{
-		// fing a vertex of pass that makes a plane that puts all of the
+		// find a vertex of pass that makes a plane that puts all of the
 		// vertexes of pass on the front side and all of the vertexes of
 		// source on the back side
 		for (j = 0; j < 2; j++)
@@ -651,10 +651,22 @@
 	for (i = 0; i < leaf->numportals; i++)
 	{
 		p = leaf->portals[i];
+		if (p == NULL)
+		{
+			continue;
+		}
 		if (p->status != stat_done)
+		{
 			throw GLVisError("portal %d not done", (int)(p - portals));
+		}
 		for (j = 0; j < rowbytes; j++)
+		{
+			if (p->visbits[j] == 0)
+			{
+				continue;
+			}
 			outbuffer[j] |= p->visbits[j];
+		}
 		delete[] p->visbits;
 		p->visbits = NULL;
 	}
diff -Nur orig/utils/glvis/glvis.cpp mod/utils/glvis/glvis.cpp
--- orig/utils/glvis/glvis.cpp	2010-12-23 20:47:55.000000000 +0100
+++ mod/utils/glvis/glvis.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: glvis.cpp 4352 2010-12-20 03:14:10Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -158,7 +158,7 @@
 static void ShowUsage()
 {
 	fprintf(stderr, "\nGLVIS version 1.6, Copyright (c)2000-2006 Janis "
-		"Legzdinsh ("__DATE__" "__TIME__")\n");
+		"Legzdinsh (" __DATE__ " " __TIME__ ")\n");
 	fprintf(stderr, "Usage: glvis [options] file[.wad]\n");
 	fprintf(stderr, "    -s            silent mode\n");
 	fprintf(stderr, "    -f            fast mode\n");
diff -Nur orig/utils/glvis/glvis.h mod/utils/glvis/glvis.h
--- orig/utils/glvis/glvis.h	2010-04-03 18:27:57.000000000 +0200
+++ mod/utils/glvis/glvis.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: glvis.h 4206 2010-04-03 16:32:33Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/glvis/glvisint.h mod/utils/glvis/glvisint.h
--- orig/utils/glvis/glvisint.h	2006-07-30 18:31:52.000000000 +0200
+++ mod/utils/glvis/glvisint.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: glvisint.h 1599 2006-07-06 17:20:16Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/glvis/level.cpp mod/utils/glvis/level.cpp
--- orig/utils/glvis/level.cpp	2010-09-01 20:26:06.000000000 +0200
+++ mod/utils/glvis/level.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: level.cpp 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -62,7 +62,7 @@
 		size = 4;
 	}
 	size = (size + 3) & ~3;
-	void *ptr = malloc(size);
+	void *ptr = Z_Malloc(size);
 	if (!ptr)
 	{
 		throw GLVisError("Couldn't alloc %d bytes", size);
@@ -79,7 +79,7 @@
 
 static void GLVisFree(void *ptr)
 {
-	free(ptr);
+	Z_Free(ptr);
 	ptr = NULL;
 }
 
diff -Nur orig/utils/glvis/vector.h mod/utils/glvis/vector.h
--- orig/utils/glvis/vector.h	2006-09-27 01:32:53.000000000 +0200
+++ mod/utils/glvis/vector.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vector.h 1741 2006-09-26 23:26:48Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/master/main.cpp mod/utils/master/main.cpp
--- orig/utils/master/main.cpp	2010-09-01 20:26:06.000000000 +0200
+++ mod/utils/master/main.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: main.cpp 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -263,7 +263,9 @@
 #ifdef _WIN32
 			Sleep(1);
 #else
-			usleep(1);
+//			usleep(1);
+			static const struct timespec sleepTime = {0, 28500000};
+			nanosleep(&sleepTime, NULL);
 #endif
 		}
 
diff -Nur orig/utils/updaterevision/updaterevision.c mod/utils/updaterevision/updaterevision.c
--- orig/utils/updaterevision/updaterevision.c	2009-09-01 20:04:03.000000000 +0200
+++ mod/utils/updaterevision/updaterevision.c	2022-08-12 08:34:35.000000000 +0200
@@ -1,75 +1,104 @@
 /* updaterevision.c
  *
- * Public domain. This program uses the svnversion command to get the
- * repository revision for a particular directory and writes it into
- * a header file so that it can be used as a project's build number.
+ * Public domain. This program uses git commands command to get
+ * various bits of repository status for a particular directory
+ * and writes it into a header file so that it can be used for a
+ * project's versioning.
  */
 
+#ifdef _WIN32
 #define _CRT_SECURE_NO_DEPRECATE
 
+#include <direct.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <errno.h>
 
+#ifdef _WIN32
+#define popen _popen
+#define pclose _pclose
+#define chdir _chdir
+#endif
+
+// Used to strip newline characters from lines read by fgets.
+void stripnl(char *str)
+{
+	if (*str != '\0')
+	{
+		size_t len = strlen(str);
+		if (str[len - 1] == '\n')
+		{
+			str[len - 1] = '\0';
+		}
+	}
+}
+
 int main(int argc, char **argv)
 {
-	char *name;
-	char currev[64], lastrev[64], run[256], *rev;
-	unsigned long urev;
+	char path[150], command[255], vertag[128], lastlog[128], lasthash[128], *hash = NULL;
 	FILE *stream = NULL;
 	int gotrev = 0, needupdate = 1;
 
-	if (argc != 3)
+	vertag[0] = '\0';
+	lastlog[0] = '\0';
+
+	if (argc != 4)
 	{
-		fprintf (stderr, "Usage: %s <repository directory> <path to svnrev.h>\n", argv[0]);
+		fprintf(stderr, "Usage: %s <path to git executables>, <path to git repository>, <path to gitrev.h>\n", argv[0]);
 		return 1;
 	}
 
-	// Use svnversion to get the revision number. If that fails, pretend it's
-	// revision 0. Note that this requires you have the command-line svn tools installed.
-	sprintf (run, "svnversion -cn %s", argv[1]);
-	if ((name = tempnam(NULL, "svnout")) != NULL &&
-		(stream = freopen(name, "w+b", stdout)) != NULL &&
-		system(run) == 0 &&
-		errno == 0 &&
-		fseek(stream, 0, SEEK_SET) == 0 &&
-		fgets(currev, sizeof currev, stream) == currev &&
-		(isdigit(currev[0]) || (currev[0] == '-' && currev[1] == '1')))
-	{
-		gotrev = 1;
-	}
-	if (stream != NULL)
-	{
-		fclose (stream);
-		remove (name);
-	}
-	if (name != NULL)
-	{
-		free (name);
-	}
+	// Use git describe --tags to get a version string. If we are sitting directly
+	// on a tag, it returns that tag. Otherwise it returns <most recent tag>-<number of
+	// commits since the tag>-<short hash>.
+	// Use git log to get the time of the latest commit in ISO 8601 format and its full hash.
+	sprintf(command, "git --git-dir=%s.git --work-tree=%s describe --all --dirty=-m && git --git-dir=%s.git --work-tree=%s log -1 --format=%%ai*%%H", argv[2], argv[2], argv[2], argv[2]);
+	sprintf(path, "%s", argv[1]);
+
+	//fprintf(stderr, "git --git-dir=%s.git --work-tree=%s describe --tags --dirty=-m && git --git-dir=%s.git --work-tree=%s log -1 --format=%%ai*%%H", argv[2], argv[2], argv[2], argv[2]);
 
-	if (!gotrev)
-	{
-		fprintf (stderr, "Failed to get current revision: %s\n", strerror(errno));
-		strcpy (currev, "0");
-		rev = currev;
-	}
-	else
+	chdir(path);
+	stream = popen(command, "r");
+
+	if (NULL != stream)
 	{
-		rev = strchr (currev, ':');
-		if (rev == NULL)
+		if (fgets(vertag, sizeof vertag, stream) == vertag &&
+			fgets(lastlog, sizeof lastlog, stream) == lastlog)
 		{
-			rev = currev;
+			stripnl(vertag);
+			stripnl(lastlog);
+			gotrev = 1;
 		}
-		else
+
+		pclose(stream);
+	}
+
+	command[0] = 0;
+	path[0] = 0;
+
+	if (gotrev)
+	{
+		hash = strchr(lastlog, '*');
+		if (hash != NULL)
 		{
-			rev += 1;
+			*hash = '\0';
+			hash++;
 		}
 	}
+	if (hash == NULL)
+	{
+		fprintf(stderr, "Failed to get commit info: %s\n", strerror(errno));
+		strcpy(vertag, "<unknown version>");
+		lastlog[0] = '\0';
+		lastlog[1] = '0';
+		lastlog[2] = '\0';
+		hash = lastlog + 1;
+	}
 
-	stream = fopen (argv[2], "r");
+	stream = fopen (argv[3], "r");
 	if (stream != NULL)
 	{
 		if (!gotrev)
@@ -80,13 +109,10 @@
 		// Read the revision that's in this file already. If it's the same as
 		// what we've got, then we don't need to modify it and can avoid rebuilding
 		// dependant files.
-		if (fgets(lastrev, sizeof lastrev, stream) == lastrev)
+		if (fgets(lasthash, sizeof lasthash, stream) == lasthash)
 		{
-			if (lastrev[0] != '\0')
-			{ // Strip trailing \n
-				lastrev[strlen(lastrev) - 1] = '\0';
-			}
-			if (strcmp(rev, lastrev + 3) == 0)
+			stripnl(lasthash);
+			if (strcmp(hash, lasthash + 3) == 0)
 			{
 				needupdate = 0;
 			}
@@ -96,27 +122,27 @@
 
 	if (needupdate)
 	{
-		stream = fopen (argv[2], "w");
+		stream = fopen (argv[3], "w");
 		if (stream == NULL)
 		{
 			return 1;
 		}
-		urev = strtoul(rev, NULL, 10);
-		fprintf (stream,
-"// %s\n"
-"//\n"
-"// This file was automatically generated by the\n"
-"// updaterevision tool. Do not edit by hand.\n"
-"\n"
-"#define SVN_REVISION_STRING \"%s\"\n"
-"#define SVN_REVISION_NUMBER %lu\n",
-			rev, rev, urev);
-		fclose (stream);
-		fprintf (stderr, "%s updated to revision %s.\n", argv[2], rev);
+		fprintf(stream,
+			"// %s\n"
+			"//\n"
+			"// This file was automatically generated by the\n"
+			"// updaterevision tool. Do not edit by hand.\n"
+			"\n"
+			"#define GIT_DESCRIPTION \"%s\"\n"
+			"#define GIT_HASH \"%s\"\n"
+			"#define GIT_TIME \"%s\"\n",
+			hash, vertag, hash, lastlog);
+		fclose(stream);
+		fprintf(stderr, "%s updated to commit %s.\n", argv[3], vertag);
 	}
 	else
 	{
-		fprintf (stderr, "%s is up to date at revision %s.\n", argv[2], rev);
+		fprintf (stderr, "%s is up to date at commit %s.\n", argv[3], vertag);
 	}
 
 	return 0;
diff -Nur orig/utils/updaterevision/updaterevision.vcproj mod/utils/updaterevision/updaterevision.vcproj
--- orig/utils/updaterevision/updaterevision.vcproj	2010-09-01 20:26:05.000000000 +0200
+++ mod/utils/updaterevision/updaterevision.vcproj	2022-08-12 08:34:35.000000000 +0200
@@ -124,7 +124,7 @@
 				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
+				RuntimeLibrary="1"
 				UsePrecompiledHeader="0"
 				WarningLevel="3"
 				Detect64BitPortabilityProblems="true"
@@ -276,12 +276,19 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
-				RuntimeLibrary="2"
+				Optimization="3"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				PreprocessorDefinitions="WIN64;NDEBUG;_CONSOLE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
 				UsePrecompiledHeader="0"
 				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="1"
 			/>
 			<Tool
 				Name="VCManagedResourceCompilerTool"
@@ -295,10 +302,12 @@
 			<Tool
 				Name="VCLinkerTool"
 				LinkIncremental="1"
-				GenerateDebugInformation="true"
+				GenerateDebugInformation="false"
 				SubSystem="1"
 				OptimizeReferences="2"
 				EnableCOMDATFolding="2"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
 				TargetMachine="17"
 			/>
 			<Tool
diff -Nur orig/utils/vcc/vcc.cpp mod/utils/vcc/vcc.cpp
--- orig/utils/vcc/vcc.cpp	2010-04-21 15:15:40.000000000 +0200
+++ mod/utils/vcc/vcc.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vcc.cpp 4219 2010-04-19 22:11:41Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
@@ -122,7 +122,7 @@
 	}
 	catch (VException& e)
 	{
-		FatalError(e.What());
+		FatalError("%s", e.What());
 	}
 	return 0;
 }
@@ -171,7 +171,7 @@
 {
 	//	Print usage.
 	printf("\n");
-	printf("VCC Version 1.%d. Copyright (c)2000-2001 by JL.          ("__DATE__" "__TIME__")\n", PROG_VERSION);
+	printf("VCC Version 1.%d. Copyright (c)2000-2001 by JL.          (" __DATE__ " " __TIME__ ")\n", PROG_VERSION);
 	printf("Usage: vcc [options] source[.c] [object[.dat]]\n");
 	printf("    -d<file>     Output debugging information into specified file\n");
 	printf("    -a<function> Output function's ASM statements into debug file\n");
@@ -385,7 +385,7 @@
 		return NULL;
 	}
 
-	void *ptr = malloc(size);
+	void *ptr = Z_Malloc(size);
 	if (!ptr)
 	{
 		FatalError("Couldn't alloc %d bytes", (int)size);
@@ -404,7 +404,7 @@
 {
 	if (ptr)
 	{
-		free(ptr);
+		Z_Free(ptr);
 		ptr = NULL;
 	}
 }
diff -Nur orig/utils/vcc/vcc.h mod/utils/vcc/vcc.h
--- orig/utils/vcc/vcc.h	2010-04-03 22:09:00.000000000 +0200
+++ mod/utils/vcc/vcc.h	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vcc.h 4212 2010-04-03 20:13:36Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
diff -Nur orig/utils/vlaunch/vlaunch.cpp mod/utils/vlaunch/vlaunch.cpp
--- orig/utils/vlaunch/vlaunch.cpp	2011-01-01 12:51:56.000000000 +0100
+++ mod/utils/vlaunch/vlaunch.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vlaunch.cpp 4365 2011-01-01 11:49:10Z dj_jl $
+//**	$Id$
 //**
 //**	Copyright (C) 2007 Jānis Legzdiņš
 //**
@@ -133,7 +133,7 @@
 
 VMain::VMain()
 : wxFrame(NULL, wxID_ANY, wxT("Vavoom launcher"), wxDefaultPosition, wxDefaultSize,
-	wxDEFAULT_FRAME_STYLE & ~ (wxRESIZE_BORDER | wxRESIZE_BOX | wxMAXIMIZE_BOX))
+	wxDEFAULT_FRAME_STYLE & ~ (wxRESIZE_BORDER | wxMAXIMIZE_BOX))
 {
 	SetIcon(wxICON(vlaunch));
 
@@ -515,15 +515,15 @@
 	// Timidity
 	if (CheckBoxUseTimidity->IsChecked())
 	{
-		CmdLine += wxT(" +s_timidity 1");
+		CmdLine += wxT(" +snd_mid_player 1");
 	}
 	else
 	{
-		CmdLine += wxT(" +s_timidity 0");
+		CmdLine += wxT(" +snd_mid_player 0");
 	}
 
 	if (PatchFiles->GetValue().Length())
-		CmdLine += wxT(" +s_timidity_patches ") + PatchFiles->GetValue();
+		CmdLine += wxT(" +snd_timidity_patches ") + PatchFiles->GetValue();
 
 	// Mouse Sensitivity
 	if (MouseX->GetValue().Length())
diff -Nur orig/utils/vlumpy/ioapi.h mod/utils/vlumpy/ioapi.h
--- orig/utils/vlumpy/ioapi.h	2008-01-06 14:28:47.000000000 +0100
+++ mod/utils/vlumpy/ioapi.h	2022-08-12 08:34:35.000000000 +0200
@@ -31,6 +31,10 @@
 #endif
 #endif
 
+#ifndef OF
+#define OF(x) _Z_OF(x)
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff -Nur orig/utils/vlumpy/vlumpy.cpp mod/utils/vlumpy/vlumpy.cpp
--- orig/utils/vlumpy/vlumpy.cpp	2010-09-01 20:26:06.000000000 +0200
+++ mod/utils/vlumpy/vlumpy.cpp	2022-08-12 08:34:35.000000000 +0200
@@ -7,7 +7,7 @@
 //**	  ###   ##    ##   ###    ##  ##   ##  ##  ##       ##
 //**	   #    ##    ##    #      ####     ####   ##       ##
 //**
-//**	$Id: vlumpy.cpp 4316 2010-07-01 12:36:28Z firebrand_kh $
+//**	$Id$
 //**
 //**	Copyright (C) 1999-2006 Jānis Legzdiņš
 //**
